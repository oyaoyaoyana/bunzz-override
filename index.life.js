var bunzz = (() => {
  global = window;
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __defNormalProp = (obj, key2, value) => key2 in obj ? __defProp(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
  var __spreadValues = (a3, b2) => {
    for (var prop in b2 || (b2 = {}))
      if (__hasOwnProp.call(b2, prop))
        __defNormalProp(a3, prop, b2[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b2)) {
        if (__propIsEnum.call(b2, prop))
          __defNormalProp(a3, prop, b2[prop]);
      }
    return a3;
  };
  var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[Object.keys(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    __markAsModule(target);
    for (var name2 in all)
      __defProp(target, name2, { get: all[name2], enumerable: true });
  };
  var __reExport = (target, module, desc) => {
    if (module && typeof module === "object" || typeof module === "function") {
      for (let key2 of __getOwnPropNames(module))
        if (!__hasOwnProp.call(target, key2) && key2 !== "default")
          __defProp(target, key2, { get: () => module[key2], enumerable: !(desc = __getOwnPropDesc(module, key2)) || desc.enumerable });
    }
    return target;
  };
  var __toModule = (module) => {
    return __reExport(__markAsModule(__defProp(module != null ? __create(__getProtoOf(module)) : {}, "default", module && module.__esModule && "default" in module ? { get: () => module.default, enumerable: true } : { value: module, enumerable: true })), module);
  };
  var __async = (__this, __arguments, generator) => {
    return new Promise((resolve, reject) => {
      var fulfilled = (value) => {
        try {
          step(generator.next(value));
        } catch (e3) {
          reject(e3);
        }
      };
      var rejected = (value) => {
        try {
          step(generator.throw(value));
        } catch (e3) {
          reject(e3);
        }
      };
      var step = (x3) => x3.done ? resolve(x3.value) : Promise.resolve(x3.value).then(fulfilled, rejected);
      step((generator = generator.apply(__this, __arguments)).next());
    });
  };

  // node_modules/luxon/build/cjs-browser/luxon.js
  var require_luxon = __commonJS({
    "node_modules/luxon/build/cjs-browser/luxon.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      function _defineProperties(target, props) {
        for (var i3 = 0; i3 < props.length; i3++) {
          var descriptor = props[i3];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      function _extends() {
        _extends = Object.assign || function(target) {
          for (var i3 = 1; i3 < arguments.length; i3++) {
            var source = arguments[i3];
            for (var key2 in source) {
              if (Object.prototype.hasOwnProperty.call(source, key2)) {
                target[key2] = source[key2];
              }
            }
          }
          return target;
        };
        return _extends.apply(this, arguments);
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _getPrototypeOf(o3) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o4) {
          return o4.__proto__ || Object.getPrototypeOf(o4);
        };
        return _getPrototypeOf(o3);
      }
      function _setPrototypeOf(o3, p3) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o4, p4) {
          o4.__proto__ = p4;
          return o4;
        };
        return _setPrototypeOf(o3, p3);
      }
      function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
          return true;
        } catch (e3) {
          return false;
        }
      }
      function _construct(Parent, args, Class) {
        if (_isNativeReflectConstruct()) {
          _construct = Reflect.construct;
        } else {
          _construct = function _construct2(Parent2, args2, Class2) {
            var a3 = [null];
            a3.push.apply(a3, args2);
            var Constructor = Function.bind.apply(Parent2, a3);
            var instance = new Constructor();
            if (Class2)
              _setPrototypeOf(instance, Class2.prototype);
            return instance;
          };
        }
        return _construct.apply(null, arguments);
      }
      function _isNativeFunction(fn) {
        return Function.toString.call(fn).indexOf("[native code]") !== -1;
      }
      function _wrapNativeSuper(Class) {
        var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
        _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
          if (Class2 === null || !_isNativeFunction(Class2))
            return Class2;
          if (typeof Class2 !== "function") {
            throw new TypeError("Super expression must either be null or a function");
          }
          if (typeof _cache !== "undefined") {
            if (_cache.has(Class2))
              return _cache.get(Class2);
            _cache.set(Class2, Wrapper);
          }
          function Wrapper() {
            return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
          }
          Wrapper.prototype = Object.create(Class2.prototype, {
            constructor: {
              value: Wrapper,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          return _setPrototypeOf(Wrapper, Class2);
        };
        return _wrapNativeSuper(Class);
      }
      function _objectWithoutPropertiesLoose(source, excluded) {
        if (source == null)
          return {};
        var target = {};
        var sourceKeys = Object.keys(source);
        var key2, i3;
        for (i3 = 0; i3 < sourceKeys.length; i3++) {
          key2 = sourceKeys[i3];
          if (excluded.indexOf(key2) >= 0)
            continue;
          target[key2] = source[key2];
        }
        return target;
      }
      function _unsupportedIterableToArray(o3, minLen) {
        if (!o3)
          return;
        if (typeof o3 === "string")
          return _arrayLikeToArray(o3, minLen);
        var n3 = Object.prototype.toString.call(o3).slice(8, -1);
        if (n3 === "Object" && o3.constructor)
          n3 = o3.constructor.name;
        if (n3 === "Map" || n3 === "Set")
          return Array.from(o3);
        if (n3 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3))
          return _arrayLikeToArray(o3, minLen);
      }
      function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length)
          len = arr.length;
        for (var i3 = 0, arr2 = new Array(len); i3 < len; i3++)
          arr2[i3] = arr[i3];
        return arr2;
      }
      function _createForOfIteratorHelperLoose(o3, allowArrayLike) {
        var it = typeof Symbol !== "undefined" && o3[Symbol.iterator] || o3["@@iterator"];
        if (it)
          return (it = it.call(o3)).next.bind(it);
        if (Array.isArray(o3) || (it = _unsupportedIterableToArray(o3)) || allowArrayLike && o3 && typeof o3.length === "number") {
          if (it)
            o3 = it;
          var i3 = 0;
          return function() {
            if (i3 >= o3.length)
              return {
                done: true
              };
            return {
              done: false,
              value: o3[i3++]
            };
          };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var LuxonError = /* @__PURE__ */ function(_Error) {
        _inheritsLoose(LuxonError2, _Error);
        function LuxonError2() {
          return _Error.apply(this, arguments) || this;
        }
        return LuxonError2;
      }(/* @__PURE__ */ _wrapNativeSuper(Error));
      var InvalidDateTimeError = /* @__PURE__ */ function(_LuxonError) {
        _inheritsLoose(InvalidDateTimeError2, _LuxonError);
        function InvalidDateTimeError2(reason) {
          return _LuxonError.call(this, "Invalid DateTime: " + reason.toMessage()) || this;
        }
        return InvalidDateTimeError2;
      }(LuxonError);
      var InvalidIntervalError = /* @__PURE__ */ function(_LuxonError2) {
        _inheritsLoose(InvalidIntervalError2, _LuxonError2);
        function InvalidIntervalError2(reason) {
          return _LuxonError2.call(this, "Invalid Interval: " + reason.toMessage()) || this;
        }
        return InvalidIntervalError2;
      }(LuxonError);
      var InvalidDurationError = /* @__PURE__ */ function(_LuxonError3) {
        _inheritsLoose(InvalidDurationError2, _LuxonError3);
        function InvalidDurationError2(reason) {
          return _LuxonError3.call(this, "Invalid Duration: " + reason.toMessage()) || this;
        }
        return InvalidDurationError2;
      }(LuxonError);
      var ConflictingSpecificationError = /* @__PURE__ */ function(_LuxonError4) {
        _inheritsLoose(ConflictingSpecificationError2, _LuxonError4);
        function ConflictingSpecificationError2() {
          return _LuxonError4.apply(this, arguments) || this;
        }
        return ConflictingSpecificationError2;
      }(LuxonError);
      var InvalidUnitError = /* @__PURE__ */ function(_LuxonError5) {
        _inheritsLoose(InvalidUnitError2, _LuxonError5);
        function InvalidUnitError2(unit) {
          return _LuxonError5.call(this, "Invalid unit " + unit) || this;
        }
        return InvalidUnitError2;
      }(LuxonError);
      var InvalidArgumentError = /* @__PURE__ */ function(_LuxonError6) {
        _inheritsLoose(InvalidArgumentError2, _LuxonError6);
        function InvalidArgumentError2() {
          return _LuxonError6.apply(this, arguments) || this;
        }
        return InvalidArgumentError2;
      }(LuxonError);
      var ZoneIsAbstractError = /* @__PURE__ */ function(_LuxonError7) {
        _inheritsLoose(ZoneIsAbstractError2, _LuxonError7);
        function ZoneIsAbstractError2() {
          return _LuxonError7.call(this, "Zone is an abstract class") || this;
        }
        return ZoneIsAbstractError2;
      }(LuxonError);
      var n2 = "numeric";
      var s3 = "short";
      var l3 = "long";
      var DATE_SHORT = {
        year: n2,
        month: n2,
        day: n2
      };
      var DATE_MED = {
        year: n2,
        month: s3,
        day: n2
      };
      var DATE_MED_WITH_WEEKDAY = {
        year: n2,
        month: s3,
        day: n2,
        weekday: s3
      };
      var DATE_FULL = {
        year: n2,
        month: l3,
        day: n2
      };
      var DATE_HUGE = {
        year: n2,
        month: l3,
        day: n2,
        weekday: l3
      };
      var TIME_SIMPLE = {
        hour: n2,
        minute: n2
      };
      var TIME_WITH_SECONDS = {
        hour: n2,
        minute: n2,
        second: n2
      };
      var TIME_WITH_SHORT_OFFSET = {
        hour: n2,
        minute: n2,
        second: n2,
        timeZoneName: s3
      };
      var TIME_WITH_LONG_OFFSET = {
        hour: n2,
        minute: n2,
        second: n2,
        timeZoneName: l3
      };
      var TIME_24_SIMPLE = {
        hour: n2,
        minute: n2,
        hourCycle: "h23"
      };
      var TIME_24_WITH_SECONDS = {
        hour: n2,
        minute: n2,
        second: n2,
        hourCycle: "h23"
      };
      var TIME_24_WITH_SHORT_OFFSET = {
        hour: n2,
        minute: n2,
        second: n2,
        hourCycle: "h23",
        timeZoneName: s3
      };
      var TIME_24_WITH_LONG_OFFSET = {
        hour: n2,
        minute: n2,
        second: n2,
        hourCycle: "h23",
        timeZoneName: l3
      };
      var DATETIME_SHORT = {
        year: n2,
        month: n2,
        day: n2,
        hour: n2,
        minute: n2
      };
      var DATETIME_SHORT_WITH_SECONDS = {
        year: n2,
        month: n2,
        day: n2,
        hour: n2,
        minute: n2,
        second: n2
      };
      var DATETIME_MED = {
        year: n2,
        month: s3,
        day: n2,
        hour: n2,
        minute: n2
      };
      var DATETIME_MED_WITH_SECONDS = {
        year: n2,
        month: s3,
        day: n2,
        hour: n2,
        minute: n2,
        second: n2
      };
      var DATETIME_MED_WITH_WEEKDAY = {
        year: n2,
        month: s3,
        day: n2,
        weekday: s3,
        hour: n2,
        minute: n2
      };
      var DATETIME_FULL = {
        year: n2,
        month: l3,
        day: n2,
        hour: n2,
        minute: n2,
        timeZoneName: s3
      };
      var DATETIME_FULL_WITH_SECONDS = {
        year: n2,
        month: l3,
        day: n2,
        hour: n2,
        minute: n2,
        second: n2,
        timeZoneName: s3
      };
      var DATETIME_HUGE = {
        year: n2,
        month: l3,
        day: n2,
        weekday: l3,
        hour: n2,
        minute: n2,
        timeZoneName: l3
      };
      var DATETIME_HUGE_WITH_SECONDS = {
        year: n2,
        month: l3,
        day: n2,
        weekday: l3,
        hour: n2,
        minute: n2,
        second: n2,
        timeZoneName: l3
      };
      function isUndefined(o3) {
        return typeof o3 === "undefined";
      }
      function isNumber(o3) {
        return typeof o3 === "number";
      }
      function isInteger(o3) {
        return typeof o3 === "number" && o3 % 1 === 0;
      }
      function isString(o3) {
        return typeof o3 === "string";
      }
      function isDate(o3) {
        return Object.prototype.toString.call(o3) === "[object Date]";
      }
      function hasRelative() {
        try {
          return typeof Intl !== "undefined" && !!Intl.RelativeTimeFormat;
        } catch (e3) {
          return false;
        }
      }
      function maybeArray(thing) {
        return Array.isArray(thing) ? thing : [thing];
      }
      function bestBy(arr, by, compare) {
        if (arr.length === 0) {
          return void 0;
        }
        return arr.reduce(function(best, next) {
          var pair = [by(next), next];
          if (!best) {
            return pair;
          } else if (compare(best[0], pair[0]) === best[0]) {
            return best;
          } else {
            return pair;
          }
        }, null)[1];
      }
      function pick(obj, keys) {
        return keys.reduce(function(a3, k3) {
          a3[k3] = obj[k3];
          return a3;
        }, {});
      }
      function hasOwnProperty(obj, prop) {
        return Object.prototype.hasOwnProperty.call(obj, prop);
      }
      function integerBetween(thing, bottom, top) {
        return isInteger(thing) && thing >= bottom && thing <= top;
      }
      function floorMod(x3, n3) {
        return x3 - n3 * Math.floor(x3 / n3);
      }
      function padStart(input, n3) {
        if (n3 === void 0) {
          n3 = 2;
        }
        var minus = input < 0 ? "-" : "";
        var target = minus ? input * -1 : input;
        var result;
        if (target.toString().length < n3) {
          result = ("0".repeat(n3) + target).slice(-n3);
        } else {
          result = target.toString();
        }
        return "" + minus + result;
      }
      function parseInteger(string) {
        if (isUndefined(string) || string === null || string === "") {
          return void 0;
        } else {
          return parseInt(string, 10);
        }
      }
      function parseMillis(fraction) {
        if (isUndefined(fraction) || fraction === null || fraction === "") {
          return void 0;
        } else {
          var f3 = parseFloat("0." + fraction) * 1e3;
          return Math.floor(f3);
        }
      }
      function roundTo(number, digits, towardZero) {
        if (towardZero === void 0) {
          towardZero = false;
        }
        var factor = Math.pow(10, digits), rounder = towardZero ? Math.trunc : Math.round;
        return rounder(number * factor) / factor;
      }
      function isLeapYear(year) {
        return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
      }
      function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
      }
      function daysInMonth(year, month) {
        var modMonth = floorMod(month - 1, 12) + 1, modYear = year + (month - modMonth) / 12;
        if (modMonth === 2) {
          return isLeapYear(modYear) ? 29 : 28;
        } else {
          return [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][modMonth - 1];
        }
      }
      function objToLocalTS(obj) {
        var d3 = Date.UTC(obj.year, obj.month - 1, obj.day, obj.hour, obj.minute, obj.second, obj.millisecond);
        if (obj.year < 100 && obj.year >= 0) {
          d3 = new Date(d3);
          d3.setUTCFullYear(d3.getUTCFullYear() - 1900);
        }
        return +d3;
      }
      function weeksInWeekYear(weekYear) {
        var p1 = (weekYear + Math.floor(weekYear / 4) - Math.floor(weekYear / 100) + Math.floor(weekYear / 400)) % 7, last = weekYear - 1, p22 = (last + Math.floor(last / 4) - Math.floor(last / 100) + Math.floor(last / 400)) % 7;
        return p1 === 4 || p22 === 3 ? 53 : 52;
      }
      function untruncateYear(year) {
        if (year > 99) {
          return year;
        } else
          return year > 60 ? 1900 + year : 2e3 + year;
      }
      function parseZoneInfo(ts, offsetFormat, locale, timeZone) {
        if (timeZone === void 0) {
          timeZone = null;
        }
        var date = new Date(ts), intlOpts = {
          hourCycle: "h23",
          year: "numeric",
          month: "2-digit",
          day: "2-digit",
          hour: "2-digit",
          minute: "2-digit"
        };
        if (timeZone) {
          intlOpts.timeZone = timeZone;
        }
        var modified = _extends({
          timeZoneName: offsetFormat
        }, intlOpts);
        var parsed = new Intl.DateTimeFormat(locale, modified).formatToParts(date).find(function(m3) {
          return m3.type.toLowerCase() === "timezonename";
        });
        return parsed ? parsed.value : null;
      }
      function signedOffset(offHourStr, offMinuteStr) {
        var offHour = parseInt(offHourStr, 10);
        if (Number.isNaN(offHour)) {
          offHour = 0;
        }
        var offMin = parseInt(offMinuteStr, 10) || 0, offMinSigned = offHour < 0 || Object.is(offHour, -0) ? -offMin : offMin;
        return offHour * 60 + offMinSigned;
      }
      function asNumber(value) {
        var numericValue = Number(value);
        if (typeof value === "boolean" || value === "" || Number.isNaN(numericValue))
          throw new InvalidArgumentError("Invalid unit value " + value);
        return numericValue;
      }
      function normalizeObject(obj, normalizer) {
        var normalized = {};
        for (var u3 in obj) {
          if (hasOwnProperty(obj, u3)) {
            var v3 = obj[u3];
            if (v3 === void 0 || v3 === null)
              continue;
            normalized[normalizer(u3)] = asNumber(v3);
          }
        }
        return normalized;
      }
      function formatOffset(offset2, format) {
        var hours = Math.trunc(Math.abs(offset2 / 60)), minutes = Math.trunc(Math.abs(offset2 % 60)), sign3 = offset2 >= 0 ? "+" : "-";
        switch (format) {
          case "short":
            return "" + sign3 + padStart(hours, 2) + ":" + padStart(minutes, 2);
          case "narrow":
            return "" + sign3 + hours + (minutes > 0 ? ":" + minutes : "");
          case "techie":
            return "" + sign3 + padStart(hours, 2) + padStart(minutes, 2);
          default:
            throw new RangeError("Value format " + format + " is out of range for property format");
        }
      }
      function timeObject(obj) {
        return pick(obj, ["hour", "minute", "second", "millisecond"]);
      }
      var ianaRegex = /[A-Za-z_+-]{1,256}(:?\/[A-Za-z_+-]{1,256}(\/[A-Za-z_+-]{1,256})?)?/;
      var monthsLong = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
      var monthsShort = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
      var monthsNarrow = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];
      function months(length) {
        switch (length) {
          case "narrow":
            return [].concat(monthsNarrow);
          case "short":
            return [].concat(monthsShort);
          case "long":
            return [].concat(monthsLong);
          case "numeric":
            return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
          case "2-digit":
            return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];
          default:
            return null;
        }
      }
      var weekdaysLong = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"];
      var weekdaysShort = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
      var weekdaysNarrow = ["M", "T", "W", "T", "F", "S", "S"];
      function weekdays(length) {
        switch (length) {
          case "narrow":
            return [].concat(weekdaysNarrow);
          case "short":
            return [].concat(weekdaysShort);
          case "long":
            return [].concat(weekdaysLong);
          case "numeric":
            return ["1", "2", "3", "4", "5", "6", "7"];
          default:
            return null;
        }
      }
      var meridiems = ["AM", "PM"];
      var erasLong = ["Before Christ", "Anno Domini"];
      var erasShort = ["BC", "AD"];
      var erasNarrow = ["B", "A"];
      function eras(length) {
        switch (length) {
          case "narrow":
            return [].concat(erasNarrow);
          case "short":
            return [].concat(erasShort);
          case "long":
            return [].concat(erasLong);
          default:
            return null;
        }
      }
      function meridiemForDateTime(dt) {
        return meridiems[dt.hour < 12 ? 0 : 1];
      }
      function weekdayForDateTime(dt, length) {
        return weekdays(length)[dt.weekday - 1];
      }
      function monthForDateTime(dt, length) {
        return months(length)[dt.month - 1];
      }
      function eraForDateTime(dt, length) {
        return eras(length)[dt.year < 0 ? 0 : 1];
      }
      function formatRelativeTime(unit, count, numeric, narrow) {
        if (numeric === void 0) {
          numeric = "always";
        }
        if (narrow === void 0) {
          narrow = false;
        }
        var units = {
          years: ["year", "yr."],
          quarters: ["quarter", "qtr."],
          months: ["month", "mo."],
          weeks: ["week", "wk."],
          days: ["day", "day", "days"],
          hours: ["hour", "hr."],
          minutes: ["minute", "min."],
          seconds: ["second", "sec."]
        };
        var lastable = ["hours", "minutes", "seconds"].indexOf(unit) === -1;
        if (numeric === "auto" && lastable) {
          var isDay = unit === "days";
          switch (count) {
            case 1:
              return isDay ? "tomorrow" : "next " + units[unit][0];
            case -1:
              return isDay ? "yesterday" : "last " + units[unit][0];
            case 0:
              return isDay ? "today" : "this " + units[unit][0];
          }
        }
        var isInPast = Object.is(count, -0) || count < 0, fmtValue = Math.abs(count), singular = fmtValue === 1, lilUnits = units[unit], fmtUnit = narrow ? singular ? lilUnits[1] : lilUnits[2] || lilUnits[1] : singular ? units[unit][0] : unit;
        return isInPast ? fmtValue + " " + fmtUnit + " ago" : "in " + fmtValue + " " + fmtUnit;
      }
      function stringifyTokens(splits, tokenToString) {
        var s4 = "";
        for (var _iterator = _createForOfIteratorHelperLoose(splits), _step; !(_step = _iterator()).done; ) {
          var token = _step.value;
          if (token.literal) {
            s4 += token.val;
          } else {
            s4 += tokenToString(token.val);
          }
        }
        return s4;
      }
      var _macroTokenToFormatOpts = {
        D: DATE_SHORT,
        DD: DATE_MED,
        DDD: DATE_FULL,
        DDDD: DATE_HUGE,
        t: TIME_SIMPLE,
        tt: TIME_WITH_SECONDS,
        ttt: TIME_WITH_SHORT_OFFSET,
        tttt: TIME_WITH_LONG_OFFSET,
        T: TIME_24_SIMPLE,
        TT: TIME_24_WITH_SECONDS,
        TTT: TIME_24_WITH_SHORT_OFFSET,
        TTTT: TIME_24_WITH_LONG_OFFSET,
        f: DATETIME_SHORT,
        ff: DATETIME_MED,
        fff: DATETIME_FULL,
        ffff: DATETIME_HUGE,
        F: DATETIME_SHORT_WITH_SECONDS,
        FF: DATETIME_MED_WITH_SECONDS,
        FFF: DATETIME_FULL_WITH_SECONDS,
        FFFF: DATETIME_HUGE_WITH_SECONDS
      };
      var Formatter2 = /* @__PURE__ */ function() {
        Formatter3.create = function create(locale, opts) {
          if (opts === void 0) {
            opts = {};
          }
          return new Formatter3(locale, opts);
        };
        Formatter3.parseFormat = function parseFormat(fmt) {
          var current = null, currentFull = "", bracketed = false;
          var splits = [];
          for (var i3 = 0; i3 < fmt.length; i3++) {
            var c3 = fmt.charAt(i3);
            if (c3 === "'") {
              if (currentFull.length > 0) {
                splits.push({
                  literal: bracketed,
                  val: currentFull
                });
              }
              current = null;
              currentFull = "";
              bracketed = !bracketed;
            } else if (bracketed) {
              currentFull += c3;
            } else if (c3 === current) {
              currentFull += c3;
            } else {
              if (currentFull.length > 0) {
                splits.push({
                  literal: false,
                  val: currentFull
                });
              }
              currentFull = c3;
              current = c3;
            }
          }
          if (currentFull.length > 0) {
            splits.push({
              literal: bracketed,
              val: currentFull
            });
          }
          return splits;
        };
        Formatter3.macroTokenToFormatOpts = function macroTokenToFormatOpts(token) {
          return _macroTokenToFormatOpts[token];
        };
        function Formatter3(locale, formatOpts) {
          this.opts = formatOpts;
          this.loc = locale;
          this.systemLoc = null;
        }
        var _proto = Formatter3.prototype;
        _proto.formatWithSystemDefault = function formatWithSystemDefault(dt, opts) {
          if (this.systemLoc === null) {
            this.systemLoc = this.loc.redefaultToSystem();
          }
          var df = this.systemLoc.dtFormatter(dt, _extends({}, this.opts, opts));
          return df.format();
        };
        _proto.formatDateTime = function formatDateTime(dt, opts) {
          if (opts === void 0) {
            opts = {};
          }
          var df = this.loc.dtFormatter(dt, _extends({}, this.opts, opts));
          return df.format();
        };
        _proto.formatDateTimeParts = function formatDateTimeParts(dt, opts) {
          if (opts === void 0) {
            opts = {};
          }
          var df = this.loc.dtFormatter(dt, _extends({}, this.opts, opts));
          return df.formatToParts();
        };
        _proto.resolvedOptions = function resolvedOptions(dt, opts) {
          if (opts === void 0) {
            opts = {};
          }
          var df = this.loc.dtFormatter(dt, _extends({}, this.opts, opts));
          return df.resolvedOptions();
        };
        _proto.num = function num(n3, p3) {
          if (p3 === void 0) {
            p3 = 0;
          }
          if (this.opts.forceSimple) {
            return padStart(n3, p3);
          }
          var opts = _extends({}, this.opts);
          if (p3 > 0) {
            opts.padTo = p3;
          }
          return this.loc.numberFormatter(opts).format(n3);
        };
        _proto.formatDateTimeFromString = function formatDateTimeFromString(dt, fmt) {
          var _this = this;
          var knownEnglish = this.loc.listingMode() === "en", useDateTimeFormatter = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory", string = function string2(opts, extract) {
            return _this.loc.extract(dt, opts, extract);
          }, formatOffset2 = function formatOffset3(opts) {
            if (dt.isOffsetFixed && dt.offset === 0 && opts.allowZ) {
              return "Z";
            }
            return dt.isValid ? dt.zone.formatOffset(dt.ts, opts.format) : "";
          }, meridiem = function meridiem2() {
            return knownEnglish ? meridiemForDateTime(dt) : string({
              hour: "numeric",
              hourCycle: "h12"
            }, "dayperiod");
          }, month = function month2(length, standalone) {
            return knownEnglish ? monthForDateTime(dt, length) : string(standalone ? {
              month: length
            } : {
              month: length,
              day: "numeric"
            }, "month");
          }, weekday = function weekday2(length, standalone) {
            return knownEnglish ? weekdayForDateTime(dt, length) : string(standalone ? {
              weekday: length
            } : {
              weekday: length,
              month: "long",
              day: "numeric"
            }, "weekday");
          }, maybeMacro = function maybeMacro2(token) {
            var formatOpts = Formatter3.macroTokenToFormatOpts(token);
            if (formatOpts) {
              return _this.formatWithSystemDefault(dt, formatOpts);
            } else {
              return token;
            }
          }, era = function era2(length) {
            return knownEnglish ? eraForDateTime(dt, length) : string({
              era: length
            }, "era");
          }, tokenToString = function tokenToString2(token) {
            switch (token) {
              case "S":
                return _this.num(dt.millisecond);
              case "u":
              case "SSS":
                return _this.num(dt.millisecond, 3);
              case "s":
                return _this.num(dt.second);
              case "ss":
                return _this.num(dt.second, 2);
              case "m":
                return _this.num(dt.minute);
              case "mm":
                return _this.num(dt.minute, 2);
              case "h":
                return _this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12);
              case "hh":
                return _this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12, 2);
              case "H":
                return _this.num(dt.hour);
              case "HH":
                return _this.num(dt.hour, 2);
              case "Z":
                return formatOffset2({
                  format: "narrow",
                  allowZ: _this.opts.allowZ
                });
              case "ZZ":
                return formatOffset2({
                  format: "short",
                  allowZ: _this.opts.allowZ
                });
              case "ZZZ":
                return formatOffset2({
                  format: "techie",
                  allowZ: _this.opts.allowZ
                });
              case "ZZZZ":
                return dt.zone.offsetName(dt.ts, {
                  format: "short",
                  locale: _this.loc.locale
                });
              case "ZZZZZ":
                return dt.zone.offsetName(dt.ts, {
                  format: "long",
                  locale: _this.loc.locale
                });
              case "z":
                return dt.zoneName;
              case "a":
                return meridiem();
              case "d":
                return useDateTimeFormatter ? string({
                  day: "numeric"
                }, "day") : _this.num(dt.day);
              case "dd":
                return useDateTimeFormatter ? string({
                  day: "2-digit"
                }, "day") : _this.num(dt.day, 2);
              case "c":
                return _this.num(dt.weekday);
              case "ccc":
                return weekday("short", true);
              case "cccc":
                return weekday("long", true);
              case "ccccc":
                return weekday("narrow", true);
              case "E":
                return _this.num(dt.weekday);
              case "EEE":
                return weekday("short", false);
              case "EEEE":
                return weekday("long", false);
              case "EEEEE":
                return weekday("narrow", false);
              case "L":
                return useDateTimeFormatter ? string({
                  month: "numeric",
                  day: "numeric"
                }, "month") : _this.num(dt.month);
              case "LL":
                return useDateTimeFormatter ? string({
                  month: "2-digit",
                  day: "numeric"
                }, "month") : _this.num(dt.month, 2);
              case "LLL":
                return month("short", true);
              case "LLLL":
                return month("long", true);
              case "LLLLL":
                return month("narrow", true);
              case "M":
                return useDateTimeFormatter ? string({
                  month: "numeric"
                }, "month") : _this.num(dt.month);
              case "MM":
                return useDateTimeFormatter ? string({
                  month: "2-digit"
                }, "month") : _this.num(dt.month, 2);
              case "MMM":
                return month("short", false);
              case "MMMM":
                return month("long", false);
              case "MMMMM":
                return month("narrow", false);
              case "y":
                return useDateTimeFormatter ? string({
                  year: "numeric"
                }, "year") : _this.num(dt.year);
              case "yy":
                return useDateTimeFormatter ? string({
                  year: "2-digit"
                }, "year") : _this.num(dt.year.toString().slice(-2), 2);
              case "yyyy":
                return useDateTimeFormatter ? string({
                  year: "numeric"
                }, "year") : _this.num(dt.year, 4);
              case "yyyyyy":
                return useDateTimeFormatter ? string({
                  year: "numeric"
                }, "year") : _this.num(dt.year, 6);
              case "G":
                return era("short");
              case "GG":
                return era("long");
              case "GGGGG":
                return era("narrow");
              case "kk":
                return _this.num(dt.weekYear.toString().slice(-2), 2);
              case "kkkk":
                return _this.num(dt.weekYear, 4);
              case "W":
                return _this.num(dt.weekNumber);
              case "WW":
                return _this.num(dt.weekNumber, 2);
              case "o":
                return _this.num(dt.ordinal);
              case "ooo":
                return _this.num(dt.ordinal, 3);
              case "q":
                return _this.num(dt.quarter);
              case "qq":
                return _this.num(dt.quarter, 2);
              case "X":
                return _this.num(Math.floor(dt.ts / 1e3));
              case "x":
                return _this.num(dt.ts);
              default:
                return maybeMacro(token);
            }
          };
          return stringifyTokens(Formatter3.parseFormat(fmt), tokenToString);
        };
        _proto.formatDurationFromString = function formatDurationFromString(dur, fmt) {
          var _this2 = this;
          var tokenToField = function tokenToField2(token) {
            switch (token[0]) {
              case "S":
                return "millisecond";
              case "s":
                return "second";
              case "m":
                return "minute";
              case "h":
                return "hour";
              case "d":
                return "day";
              case "M":
                return "month";
              case "y":
                return "year";
              default:
                return null;
            }
          }, tokenToString = function tokenToString2(lildur) {
            return function(token) {
              var mapped = tokenToField(token);
              if (mapped) {
                return _this2.num(lildur.get(mapped), token.length);
              } else {
                return token;
              }
            };
          }, tokens = Formatter3.parseFormat(fmt), realTokens = tokens.reduce(function(found, _ref) {
            var literal = _ref.literal, val = _ref.val;
            return literal ? found : found.concat(val);
          }, []), collapsed = dur.shiftTo.apply(dur, realTokens.map(tokenToField).filter(function(t3) {
            return t3;
          }));
          return stringifyTokens(tokens, tokenToString(collapsed));
        };
        return Formatter3;
      }();
      var Invalid = /* @__PURE__ */ function() {
        function Invalid2(reason, explanation) {
          this.reason = reason;
          this.explanation = explanation;
        }
        var _proto = Invalid2.prototype;
        _proto.toMessage = function toMessage() {
          if (this.explanation) {
            return this.reason + ": " + this.explanation;
          } else {
            return this.reason;
          }
        };
        return Invalid2;
      }();
      var Zone = /* @__PURE__ */ function() {
        function Zone2() {
        }
        var _proto = Zone2.prototype;
        _proto.offsetName = function offsetName(ts, opts) {
          throw new ZoneIsAbstractError();
        };
        _proto.formatOffset = function formatOffset2(ts, format) {
          throw new ZoneIsAbstractError();
        };
        _proto.offset = function offset2(ts) {
          throw new ZoneIsAbstractError();
        };
        _proto.equals = function equals(otherZone) {
          throw new ZoneIsAbstractError();
        };
        _createClass(Zone2, [{
          key: "type",
          get: function get() {
            throw new ZoneIsAbstractError();
          }
        }, {
          key: "name",
          get: function get() {
            throw new ZoneIsAbstractError();
          }
        }, {
          key: "isUniversal",
          get: function get() {
            throw new ZoneIsAbstractError();
          }
        }, {
          key: "isValid",
          get: function get() {
            throw new ZoneIsAbstractError();
          }
        }]);
        return Zone2;
      }();
      var singleton$1 = null;
      var SystemZone = /* @__PURE__ */ function(_Zone) {
        _inheritsLoose(SystemZone2, _Zone);
        function SystemZone2() {
          return _Zone.apply(this, arguments) || this;
        }
        var _proto = SystemZone2.prototype;
        _proto.offsetName = function offsetName(ts, _ref) {
          var format = _ref.format, locale = _ref.locale;
          return parseZoneInfo(ts, format, locale);
        };
        _proto.formatOffset = function formatOffset$1(ts, format) {
          return formatOffset(this.offset(ts), format);
        };
        _proto.offset = function offset2(ts) {
          return -new Date(ts).getTimezoneOffset();
        };
        _proto.equals = function equals(otherZone) {
          return otherZone.type === "system";
        };
        _createClass(SystemZone2, [{
          key: "type",
          get: function get() {
            return "system";
          }
        }, {
          key: "name",
          get: function get() {
            return new Intl.DateTimeFormat().resolvedOptions().timeZone;
          }
        }, {
          key: "isUniversal",
          get: function get() {
            return false;
          }
        }, {
          key: "isValid",
          get: function get() {
            return true;
          }
        }], [{
          key: "instance",
          get: function get() {
            if (singleton$1 === null) {
              singleton$1 = new SystemZone2();
            }
            return singleton$1;
          }
        }]);
        return SystemZone2;
      }(Zone);
      var matchingRegex = RegExp("^" + ianaRegex.source + "$");
      var dtfCache = {};
      function makeDTF(zone) {
        if (!dtfCache[zone]) {
          dtfCache[zone] = new Intl.DateTimeFormat("en-US", {
            hourCycle: "h23",
            timeZone: zone,
            year: "numeric",
            month: "2-digit",
            day: "2-digit",
            hour: "2-digit",
            minute: "2-digit",
            second: "2-digit"
          });
        }
        return dtfCache[zone];
      }
      var typeToPos = {
        year: 0,
        month: 1,
        day: 2,
        hour: 3,
        minute: 4,
        second: 5
      };
      function hackyOffset(dtf, date) {
        var formatted = dtf.format(date).replace(/\u200E/g, ""), parsed = /(\d+)\/(\d+)\/(\d+),? (\d+):(\d+):(\d+)/.exec(formatted), fMonth = parsed[1], fDay = parsed[2], fYear = parsed[3], fHour = parsed[4], fMinute = parsed[5], fSecond = parsed[6];
        return [fYear, fMonth, fDay, fHour, fMinute, fSecond];
      }
      function partsOffset(dtf, date) {
        var formatted = dtf.formatToParts(date), filled = [];
        for (var i3 = 0; i3 < formatted.length; i3++) {
          var _formatted$i = formatted[i3], type = _formatted$i.type, value = _formatted$i.value, pos = typeToPos[type];
          if (!isUndefined(pos)) {
            filled[pos] = parseInt(value, 10);
          }
        }
        return filled;
      }
      var ianaZoneCache = {};
      var IANAZone = /* @__PURE__ */ function(_Zone) {
        _inheritsLoose(IANAZone2, _Zone);
        IANAZone2.create = function create(name2) {
          if (!ianaZoneCache[name2]) {
            ianaZoneCache[name2] = new IANAZone2(name2);
          }
          return ianaZoneCache[name2];
        };
        IANAZone2.resetCache = function resetCache() {
          ianaZoneCache = {};
          dtfCache = {};
        };
        IANAZone2.isValidSpecifier = function isValidSpecifier(s4) {
          return !!(s4 && s4.match(matchingRegex));
        };
        IANAZone2.isValidZone = function isValidZone(zone) {
          try {
            new Intl.DateTimeFormat("en-US", {
              timeZone: zone
            }).format();
            return true;
          } catch (e3) {
            return false;
          }
        };
        IANAZone2.parseGMTOffset = function parseGMTOffset(specifier) {
          if (specifier) {
            var match2 = specifier.match(/^Etc\/GMT(0|[+-]\d{1,2})$/i);
            if (match2) {
              return -60 * parseInt(match2[1]);
            }
          }
          return null;
        };
        function IANAZone2(name2) {
          var _this;
          _this = _Zone.call(this) || this;
          _this.zoneName = name2;
          _this.valid = IANAZone2.isValidZone(name2);
          return _this;
        }
        var _proto = IANAZone2.prototype;
        _proto.offsetName = function offsetName(ts, _ref) {
          var format = _ref.format, locale = _ref.locale;
          return parseZoneInfo(ts, format, locale, this.name);
        };
        _proto.formatOffset = function formatOffset$1(ts, format) {
          return formatOffset(this.offset(ts), format);
        };
        _proto.offset = function offset2(ts) {
          var date = new Date(ts);
          if (isNaN(date))
            return NaN;
          var dtf = makeDTF(this.name), _ref2 = dtf.formatToParts ? partsOffset(dtf, date) : hackyOffset(dtf, date), year = _ref2[0], month = _ref2[1], day = _ref2[2], hour = _ref2[3], minute = _ref2[4], second = _ref2[5];
          var asUTC = objToLocalTS({
            year,
            month,
            day,
            hour,
            minute,
            second,
            millisecond: 0
          });
          var asTS = +date;
          var over = asTS % 1e3;
          asTS -= over >= 0 ? over : 1e3 + over;
          return (asUTC - asTS) / (60 * 1e3);
        };
        _proto.equals = function equals(otherZone) {
          return otherZone.type === "iana" && otherZone.name === this.name;
        };
        _createClass(IANAZone2, [{
          key: "type",
          get: function get() {
            return "iana";
          }
        }, {
          key: "name",
          get: function get() {
            return this.zoneName;
          }
        }, {
          key: "isUniversal",
          get: function get() {
            return false;
          }
        }, {
          key: "isValid",
          get: function get() {
            return this.valid;
          }
        }]);
        return IANAZone2;
      }(Zone);
      var singleton = null;
      var FixedOffsetZone = /* @__PURE__ */ function(_Zone) {
        _inheritsLoose(FixedOffsetZone2, _Zone);
        FixedOffsetZone2.instance = function instance(offset2) {
          return offset2 === 0 ? FixedOffsetZone2.utcInstance : new FixedOffsetZone2(offset2);
        };
        FixedOffsetZone2.parseSpecifier = function parseSpecifier(s4) {
          if (s4) {
            var r3 = s4.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);
            if (r3) {
              return new FixedOffsetZone2(signedOffset(r3[1], r3[2]));
            }
          }
          return null;
        };
        function FixedOffsetZone2(offset2) {
          var _this;
          _this = _Zone.call(this) || this;
          _this.fixed = offset2;
          return _this;
        }
        var _proto = FixedOffsetZone2.prototype;
        _proto.offsetName = function offsetName() {
          return this.name;
        };
        _proto.formatOffset = function formatOffset$1(ts, format) {
          return formatOffset(this.fixed, format);
        };
        _proto.offset = function offset2() {
          return this.fixed;
        };
        _proto.equals = function equals(otherZone) {
          return otherZone.type === "fixed" && otherZone.fixed === this.fixed;
        };
        _createClass(FixedOffsetZone2, [{
          key: "type",
          get: function get() {
            return "fixed";
          }
        }, {
          key: "name",
          get: function get() {
            return this.fixed === 0 ? "UTC" : "UTC" + formatOffset(this.fixed, "narrow");
          }
        }, {
          key: "isUniversal",
          get: function get() {
            return true;
          }
        }, {
          key: "isValid",
          get: function get() {
            return true;
          }
        }], [{
          key: "utcInstance",
          get: function get() {
            if (singleton === null) {
              singleton = new FixedOffsetZone2(0);
            }
            return singleton;
          }
        }]);
        return FixedOffsetZone2;
      }(Zone);
      var InvalidZone = /* @__PURE__ */ function(_Zone) {
        _inheritsLoose(InvalidZone2, _Zone);
        function InvalidZone2(zoneName) {
          var _this;
          _this = _Zone.call(this) || this;
          _this.zoneName = zoneName;
          return _this;
        }
        var _proto = InvalidZone2.prototype;
        _proto.offsetName = function offsetName() {
          return null;
        };
        _proto.formatOffset = function formatOffset2() {
          return "";
        };
        _proto.offset = function offset2() {
          return NaN;
        };
        _proto.equals = function equals() {
          return false;
        };
        _createClass(InvalidZone2, [{
          key: "type",
          get: function get() {
            return "invalid";
          }
        }, {
          key: "name",
          get: function get() {
            return this.zoneName;
          }
        }, {
          key: "isUniversal",
          get: function get() {
            return false;
          }
        }, {
          key: "isValid",
          get: function get() {
            return false;
          }
        }]);
        return InvalidZone2;
      }(Zone);
      function normalizeZone(input, defaultZone2) {
        var offset2;
        if (isUndefined(input) || input === null) {
          return defaultZone2;
        } else if (input instanceof Zone) {
          return input;
        } else if (isString(input)) {
          var lowered = input.toLowerCase();
          if (lowered === "local" || lowered === "system")
            return defaultZone2;
          else if (lowered === "utc" || lowered === "gmt")
            return FixedOffsetZone.utcInstance;
          else if ((offset2 = IANAZone.parseGMTOffset(input)) != null) {
            return FixedOffsetZone.instance(offset2);
          } else if (IANAZone.isValidSpecifier(lowered))
            return IANAZone.create(input);
          else
            return FixedOffsetZone.parseSpecifier(lowered) || new InvalidZone(input);
        } else if (isNumber(input)) {
          return FixedOffsetZone.instance(input);
        } else if (typeof input === "object" && input.offset && typeof input.offset === "number") {
          return input;
        } else {
          return new InvalidZone(input);
        }
      }
      var now2 = function now3() {
        return Date.now();
      };
      var defaultZone = "system";
      var defaultLocale = null;
      var defaultNumberingSystem = null;
      var defaultOutputCalendar = null;
      var throwOnInvalid;
      var Settings = /* @__PURE__ */ function() {
        function Settings2() {
        }
        Settings2.resetCaches = function resetCaches() {
          Locale.resetCache();
          IANAZone.resetCache();
        };
        _createClass(Settings2, null, [{
          key: "now",
          get: function get() {
            return now2;
          },
          set: function set(n3) {
            now2 = n3;
          }
        }, {
          key: "defaultZone",
          get: function get() {
            return normalizeZone(defaultZone, SystemZone.instance);
          },
          set: function set(zone) {
            defaultZone = zone;
          }
        }, {
          key: "defaultLocale",
          get: function get() {
            return defaultLocale;
          },
          set: function set(locale) {
            defaultLocale = locale;
          }
        }, {
          key: "defaultNumberingSystem",
          get: function get() {
            return defaultNumberingSystem;
          },
          set: function set(numberingSystem) {
            defaultNumberingSystem = numberingSystem;
          }
        }, {
          key: "defaultOutputCalendar",
          get: function get() {
            return defaultOutputCalendar;
          },
          set: function set(outputCalendar) {
            defaultOutputCalendar = outputCalendar;
          }
        }, {
          key: "throwOnInvalid",
          get: function get() {
            return throwOnInvalid;
          },
          set: function set(t3) {
            throwOnInvalid = t3;
          }
        }]);
        return Settings2;
      }();
      var _excluded = ["base"];
      var intlDTCache = {};
      function getCachedDTF(locString, opts) {
        if (opts === void 0) {
          opts = {};
        }
        var key2 = JSON.stringify([locString, opts]);
        var dtf = intlDTCache[key2];
        if (!dtf) {
          dtf = new Intl.DateTimeFormat(locString, opts);
          intlDTCache[key2] = dtf;
        }
        return dtf;
      }
      var intlNumCache = {};
      function getCachedINF(locString, opts) {
        if (opts === void 0) {
          opts = {};
        }
        var key2 = JSON.stringify([locString, opts]);
        var inf = intlNumCache[key2];
        if (!inf) {
          inf = new Intl.NumberFormat(locString, opts);
          intlNumCache[key2] = inf;
        }
        return inf;
      }
      var intlRelCache = {};
      function getCachedRTF(locString, opts) {
        if (opts === void 0) {
          opts = {};
        }
        var _opts = opts;
        _opts.base;
        var cacheKeyOpts = _objectWithoutPropertiesLoose(_opts, _excluded);
        var key2 = JSON.stringify([locString, cacheKeyOpts]);
        var inf = intlRelCache[key2];
        if (!inf) {
          inf = new Intl.RelativeTimeFormat(locString, opts);
          intlRelCache[key2] = inf;
        }
        return inf;
      }
      var sysLocaleCache = null;
      function systemLocale() {
        if (sysLocaleCache) {
          return sysLocaleCache;
        } else {
          sysLocaleCache = "en-US";
          return sysLocaleCache;
        }
      }
      function parseLocaleString(localeStr) {
        var uIndex = localeStr.indexOf("-u-");
        if (uIndex === -1) {
          return [localeStr];
        } else {
          var options;
          var smaller = localeStr.substring(0, uIndex);
          try {
            options = getCachedDTF(localeStr).resolvedOptions();
          } catch (e3) {
            options = getCachedDTF(smaller).resolvedOptions();
          }
          var _options = options, numberingSystem = _options.numberingSystem, calendar = _options.calendar;
          return [smaller, numberingSystem, calendar];
        }
      }
      function intlConfigString(localeStr, numberingSystem, outputCalendar) {
        if (outputCalendar || numberingSystem) {
          localeStr += "-u";
          if (outputCalendar) {
            localeStr += "-ca-" + outputCalendar;
          }
          if (numberingSystem) {
            localeStr += "-nu-" + numberingSystem;
          }
          return localeStr;
        } else {
          return localeStr;
        }
      }
      function mapMonths(f3) {
        var ms = [];
        for (var i3 = 1; i3 <= 12; i3++) {
          var dt = DateTime2.utc(2016, i3, 1);
          ms.push(f3(dt));
        }
        return ms;
      }
      function mapWeekdays(f3) {
        var ms = [];
        for (var i3 = 1; i3 <= 7; i3++) {
          var dt = DateTime2.utc(2016, 11, 13 + i3);
          ms.push(f3(dt));
        }
        return ms;
      }
      function listStuff(loc, length, defaultOK, englishFn, intlFn) {
        var mode = loc.listingMode(defaultOK);
        if (mode === "error") {
          return null;
        } else if (mode === "en") {
          return englishFn(length);
        } else {
          return intlFn(length);
        }
      }
      function supportsFastNumbers(loc) {
        if (loc.numberingSystem && loc.numberingSystem !== "latn") {
          return false;
        } else {
          return loc.numberingSystem === "latn" || !loc.locale || loc.locale.startsWith("en") || new Intl.DateTimeFormat(loc.intl).resolvedOptions().numberingSystem === "latn";
        }
      }
      var PolyNumberFormatter = /* @__PURE__ */ function() {
        function PolyNumberFormatter2(intl, forceSimple, opts) {
          this.padTo = opts.padTo || 0;
          this.floor = opts.floor || false;
          if (!forceSimple) {
            var intlOpts = {
              useGrouping: false
            };
            if (opts.padTo > 0)
              intlOpts.minimumIntegerDigits = opts.padTo;
            this.inf = getCachedINF(intl, intlOpts);
          }
        }
        var _proto = PolyNumberFormatter2.prototype;
        _proto.format = function format(i3) {
          if (this.inf) {
            var fixed = this.floor ? Math.floor(i3) : i3;
            return this.inf.format(fixed);
          } else {
            var _fixed = this.floor ? Math.floor(i3) : roundTo(i3, 3);
            return padStart(_fixed, this.padTo);
          }
        };
        return PolyNumberFormatter2;
      }();
      var PolyDateFormatter = /* @__PURE__ */ function() {
        function PolyDateFormatter2(dt, intl, opts) {
          this.opts = opts;
          var z3;
          if (dt.zone.isUniversal) {
            var gmtOffset = -1 * (dt.offset / 60);
            var offsetZ = gmtOffset >= 0 ? "Etc/GMT+" + gmtOffset : "Etc/GMT" + gmtOffset;
            var isOffsetZoneSupported = IANAZone.isValidZone(offsetZ);
            if (dt.offset !== 0 && isOffsetZoneSupported) {
              z3 = offsetZ;
              this.dt = dt;
            } else {
              z3 = "UTC";
              if (opts.timeZoneName) {
                this.dt = dt;
              } else {
                this.dt = dt.offset === 0 ? dt : DateTime2.fromMillis(dt.ts + dt.offset * 60 * 1e3);
              }
            }
          } else if (dt.zone.type === "system") {
            this.dt = dt;
          } else {
            this.dt = dt;
            z3 = dt.zone.name;
          }
          var intlOpts = _extends({}, this.opts);
          if (z3) {
            intlOpts.timeZone = z3;
          }
          this.dtf = getCachedDTF(intl, intlOpts);
        }
        var _proto2 = PolyDateFormatter2.prototype;
        _proto2.format = function format() {
          return this.dtf.format(this.dt.toJSDate());
        };
        _proto2.formatToParts = function formatToParts() {
          return this.dtf.formatToParts(this.dt.toJSDate());
        };
        _proto2.resolvedOptions = function resolvedOptions() {
          return this.dtf.resolvedOptions();
        };
        return PolyDateFormatter2;
      }();
      var PolyRelFormatter = /* @__PURE__ */ function() {
        function PolyRelFormatter2(intl, isEnglish, opts) {
          this.opts = _extends({
            style: "long"
          }, opts);
          if (!isEnglish && hasRelative()) {
            this.rtf = getCachedRTF(intl, opts);
          }
        }
        var _proto3 = PolyRelFormatter2.prototype;
        _proto3.format = function format(count, unit) {
          if (this.rtf) {
            return this.rtf.format(count, unit);
          } else {
            return formatRelativeTime(unit, count, this.opts.numeric, this.opts.style !== "long");
          }
        };
        _proto3.formatToParts = function formatToParts(count, unit) {
          if (this.rtf) {
            return this.rtf.formatToParts(count, unit);
          } else {
            return [];
          }
        };
        return PolyRelFormatter2;
      }();
      var Locale = /* @__PURE__ */ function() {
        Locale2.fromOpts = function fromOpts(opts) {
          return Locale2.create(opts.locale, opts.numberingSystem, opts.outputCalendar, opts.defaultToEN);
        };
        Locale2.create = function create(locale, numberingSystem, outputCalendar, defaultToEN) {
          if (defaultToEN === void 0) {
            defaultToEN = false;
          }
          var specifiedLocale = locale || Settings.defaultLocale, localeR = specifiedLocale || (defaultToEN ? "en-US" : systemLocale()), numberingSystemR = numberingSystem || Settings.defaultNumberingSystem, outputCalendarR = outputCalendar || Settings.defaultOutputCalendar;
          return new Locale2(localeR, numberingSystemR, outputCalendarR, specifiedLocale);
        };
        Locale2.resetCache = function resetCache() {
          sysLocaleCache = null;
          intlDTCache = {};
          intlNumCache = {};
          intlRelCache = {};
        };
        Locale2.fromObject = function fromObject(_temp) {
          var _ref = _temp === void 0 ? {} : _temp, locale = _ref.locale, numberingSystem = _ref.numberingSystem, outputCalendar = _ref.outputCalendar;
          return Locale2.create(locale, numberingSystem, outputCalendar);
        };
        function Locale2(locale, numbering, outputCalendar, specifiedLocale) {
          var _parseLocaleString = parseLocaleString(locale), parsedLocale = _parseLocaleString[0], parsedNumberingSystem = _parseLocaleString[1], parsedOutputCalendar = _parseLocaleString[2];
          this.locale = parsedLocale;
          this.numberingSystem = numbering || parsedNumberingSystem || null;
          this.outputCalendar = outputCalendar || parsedOutputCalendar || null;
          this.intl = intlConfigString(this.locale, this.numberingSystem, this.outputCalendar);
          this.weekdaysCache = {
            format: {},
            standalone: {}
          };
          this.monthsCache = {
            format: {},
            standalone: {}
          };
          this.meridiemCache = null;
          this.eraCache = {};
          this.specifiedLocale = specifiedLocale;
          this.fastNumbersCached = null;
        }
        var _proto4 = Locale2.prototype;
        _proto4.listingMode = function listingMode(defaultOK) {
          var isActuallyEn = this.isEnglish();
          var hasNoWeirdness = (this.numberingSystem === null || this.numberingSystem === "latn") && (this.outputCalendar === null || this.outputCalendar === "gregory");
          return isActuallyEn && hasNoWeirdness ? "en" : "intl";
        };
        _proto4.clone = function clone2(alts) {
          if (!alts || Object.getOwnPropertyNames(alts).length === 0) {
            return this;
          } else {
            return Locale2.create(alts.locale || this.specifiedLocale, alts.numberingSystem || this.numberingSystem, alts.outputCalendar || this.outputCalendar, alts.defaultToEN || false);
          }
        };
        _proto4.redefaultToEN = function redefaultToEN(alts) {
          if (alts === void 0) {
            alts = {};
          }
          return this.clone(_extends({}, alts, {
            defaultToEN: true
          }));
        };
        _proto4.redefaultToSystem = function redefaultToSystem(alts) {
          if (alts === void 0) {
            alts = {};
          }
          return this.clone(_extends({}, alts, {
            defaultToEN: false
          }));
        };
        _proto4.months = function months$1(length, format, defaultOK) {
          var _this = this;
          if (format === void 0) {
            format = false;
          }
          if (defaultOK === void 0) {
            defaultOK = true;
          }
          return listStuff(this, length, defaultOK, months, function() {
            var intl = format ? {
              month: length,
              day: "numeric"
            } : {
              month: length
            }, formatStr = format ? "format" : "standalone";
            if (!_this.monthsCache[formatStr][length]) {
              _this.monthsCache[formatStr][length] = mapMonths(function(dt) {
                return _this.extract(dt, intl, "month");
              });
            }
            return _this.monthsCache[formatStr][length];
          });
        };
        _proto4.weekdays = function weekdays$1(length, format, defaultOK) {
          var _this2 = this;
          if (format === void 0) {
            format = false;
          }
          if (defaultOK === void 0) {
            defaultOK = true;
          }
          return listStuff(this, length, defaultOK, weekdays, function() {
            var intl = format ? {
              weekday: length,
              year: "numeric",
              month: "long",
              day: "numeric"
            } : {
              weekday: length
            }, formatStr = format ? "format" : "standalone";
            if (!_this2.weekdaysCache[formatStr][length]) {
              _this2.weekdaysCache[formatStr][length] = mapWeekdays(function(dt) {
                return _this2.extract(dt, intl, "weekday");
              });
            }
            return _this2.weekdaysCache[formatStr][length];
          });
        };
        _proto4.meridiems = function meridiems$1(defaultOK) {
          var _this3 = this;
          if (defaultOK === void 0) {
            defaultOK = true;
          }
          return listStuff(this, void 0, defaultOK, function() {
            return meridiems;
          }, function() {
            if (!_this3.meridiemCache) {
              var intl = {
                hour: "numeric",
                hourCycle: "h12"
              };
              _this3.meridiemCache = [DateTime2.utc(2016, 11, 13, 9), DateTime2.utc(2016, 11, 13, 19)].map(function(dt) {
                return _this3.extract(dt, intl, "dayperiod");
              });
            }
            return _this3.meridiemCache;
          });
        };
        _proto4.eras = function eras$1(length, defaultOK) {
          var _this4 = this;
          if (defaultOK === void 0) {
            defaultOK = true;
          }
          return listStuff(this, length, defaultOK, eras, function() {
            var intl = {
              era: length
            };
            if (!_this4.eraCache[length]) {
              _this4.eraCache[length] = [DateTime2.utc(-40, 1, 1), DateTime2.utc(2017, 1, 1)].map(function(dt) {
                return _this4.extract(dt, intl, "era");
              });
            }
            return _this4.eraCache[length];
          });
        };
        _proto4.extract = function extract(dt, intlOpts, field) {
          var df = this.dtFormatter(dt, intlOpts), results = df.formatToParts(), matching = results.find(function(m3) {
            return m3.type.toLowerCase() === field;
          });
          return matching ? matching.value : null;
        };
        _proto4.numberFormatter = function numberFormatter(opts) {
          if (opts === void 0) {
            opts = {};
          }
          return new PolyNumberFormatter(this.intl, opts.forceSimple || this.fastNumbers, opts);
        };
        _proto4.dtFormatter = function dtFormatter(dt, intlOpts) {
          if (intlOpts === void 0) {
            intlOpts = {};
          }
          return new PolyDateFormatter(dt, this.intl, intlOpts);
        };
        _proto4.relFormatter = function relFormatter(opts) {
          if (opts === void 0) {
            opts = {};
          }
          return new PolyRelFormatter(this.intl, this.isEnglish(), opts);
        };
        _proto4.isEnglish = function isEnglish() {
          return this.locale === "en" || this.locale.toLowerCase() === "en-us" || new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us");
        };
        _proto4.equals = function equals(other) {
          return this.locale === other.locale && this.numberingSystem === other.numberingSystem && this.outputCalendar === other.outputCalendar;
        };
        _createClass(Locale2, [{
          key: "fastNumbers",
          get: function get() {
            if (this.fastNumbersCached == null) {
              this.fastNumbersCached = supportsFastNumbers(this);
            }
            return this.fastNumbersCached;
          }
        }]);
        return Locale2;
      }();
      function combineRegexes() {
        for (var _len = arguments.length, regexes = new Array(_len), _key = 0; _key < _len; _key++) {
          regexes[_key] = arguments[_key];
        }
        var full = regexes.reduce(function(f3, r3) {
          return f3 + r3.source;
        }, "");
        return RegExp("^" + full + "$");
      }
      function combineExtractors() {
        for (var _len2 = arguments.length, extractors = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          extractors[_key2] = arguments[_key2];
        }
        return function(m3) {
          return extractors.reduce(function(_ref, ex) {
            var mergedVals = _ref[0], mergedZone = _ref[1], cursor = _ref[2];
            var _ex = ex(m3, cursor), val = _ex[0], zone = _ex[1], next = _ex[2];
            return [_extends({}, mergedVals, val), mergedZone || zone, next];
          }, [{}, null, 1]).slice(0, 2);
        };
      }
      function parse3(s4) {
        if (s4 == null) {
          return [null, null];
        }
        for (var _len3 = arguments.length, patterns = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
          patterns[_key3 - 1] = arguments[_key3];
        }
        for (var _i = 0, _patterns = patterns; _i < _patterns.length; _i++) {
          var _patterns$_i = _patterns[_i], regex = _patterns$_i[0], extractor = _patterns$_i[1];
          var m3 = regex.exec(s4);
          if (m3) {
            return extractor(m3);
          }
        }
        return [null, null];
      }
      function simpleParse() {
        for (var _len4 = arguments.length, keys = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          keys[_key4] = arguments[_key4];
        }
        return function(match2, cursor) {
          var ret = {};
          var i3;
          for (i3 = 0; i3 < keys.length; i3++) {
            ret[keys[i3]] = parseInteger(match2[cursor + i3]);
          }
          return [ret, null, cursor + i3];
        };
      }
      var offsetRegex = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/;
      var isoTimeBaseRegex = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/;
      var isoTimeRegex = RegExp("" + isoTimeBaseRegex.source + offsetRegex.source + "?");
      var isoTimeExtensionRegex = RegExp("(?:T" + isoTimeRegex.source + ")?");
      var isoYmdRegex = /([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/;
      var isoWeekRegex = /(\d{4})-?W(\d\d)(?:-?(\d))?/;
      var isoOrdinalRegex = /(\d{4})-?(\d{3})/;
      var extractISOWeekData = simpleParse("weekYear", "weekNumber", "weekDay");
      var extractISOOrdinalData = simpleParse("year", "ordinal");
      var sqlYmdRegex = /(\d{4})-(\d\d)-(\d\d)/;
      var sqlTimeRegex = RegExp(isoTimeBaseRegex.source + " ?(?:" + offsetRegex.source + "|(" + ianaRegex.source + "))?");
      var sqlTimeExtensionRegex = RegExp("(?: " + sqlTimeRegex.source + ")?");
      function int(match2, pos, fallback) {
        var m3 = match2[pos];
        return isUndefined(m3) ? fallback : parseInteger(m3);
      }
      function extractISOYmd(match2, cursor) {
        var item = {
          year: int(match2, cursor),
          month: int(match2, cursor + 1, 1),
          day: int(match2, cursor + 2, 1)
        };
        return [item, null, cursor + 3];
      }
      function extractISOTime(match2, cursor) {
        var item = {
          hours: int(match2, cursor, 0),
          minutes: int(match2, cursor + 1, 0),
          seconds: int(match2, cursor + 2, 0),
          milliseconds: parseMillis(match2[cursor + 3])
        };
        return [item, null, cursor + 4];
      }
      function extractISOOffset(match2, cursor) {
        var local = !match2[cursor] && !match2[cursor + 1], fullOffset = signedOffset(match2[cursor + 1], match2[cursor + 2]), zone = local ? null : FixedOffsetZone.instance(fullOffset);
        return [{}, zone, cursor + 3];
      }
      function extractIANAZone(match2, cursor) {
        var zone = match2[cursor] ? IANAZone.create(match2[cursor]) : null;
        return [{}, zone, cursor + 1];
      }
      var isoTimeOnly = RegExp("^T?" + isoTimeBaseRegex.source + "$");
      var isoDuration = /^-?P(?:(?:(-?\d{1,9})Y)?(?:(-?\d{1,9})M)?(?:(-?\d{1,9})W)?(?:(-?\d{1,9})D)?(?:T(?:(-?\d{1,9})H)?(?:(-?\d{1,9})M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,9}))?S)?)?)$/;
      function extractISODuration(match2) {
        var s4 = match2[0], yearStr = match2[1], monthStr = match2[2], weekStr = match2[3], dayStr = match2[4], hourStr = match2[5], minuteStr = match2[6], secondStr = match2[7], millisecondsStr = match2[8];
        var hasNegativePrefix = s4[0] === "-";
        var negativeSeconds = secondStr && secondStr[0] === "-";
        var maybeNegate = function maybeNegate2(num, force) {
          if (force === void 0) {
            force = false;
          }
          return num !== void 0 && (force || num && hasNegativePrefix) ? -num : num;
        };
        return [{
          years: maybeNegate(parseInteger(yearStr)),
          months: maybeNegate(parseInteger(monthStr)),
          weeks: maybeNegate(parseInteger(weekStr)),
          days: maybeNegate(parseInteger(dayStr)),
          hours: maybeNegate(parseInteger(hourStr)),
          minutes: maybeNegate(parseInteger(minuteStr)),
          seconds: maybeNegate(parseInteger(secondStr), secondStr === "-0"),
          milliseconds: maybeNegate(parseMillis(millisecondsStr), negativeSeconds)
        }];
      }
      var obsOffsets = {
        GMT: 0,
        EDT: -4 * 60,
        EST: -5 * 60,
        CDT: -5 * 60,
        CST: -6 * 60,
        MDT: -6 * 60,
        MST: -7 * 60,
        PDT: -7 * 60,
        PST: -8 * 60
      };
      function fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
        var result = {
          year: yearStr.length === 2 ? untruncateYear(parseInteger(yearStr)) : parseInteger(yearStr),
          month: monthsShort.indexOf(monthStr) + 1,
          day: parseInteger(dayStr),
          hour: parseInteger(hourStr),
          minute: parseInteger(minuteStr)
        };
        if (secondStr)
          result.second = parseInteger(secondStr);
        if (weekdayStr) {
          result.weekday = weekdayStr.length > 3 ? weekdaysLong.indexOf(weekdayStr) + 1 : weekdaysShort.indexOf(weekdayStr) + 1;
        }
        return result;
      }
      var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;
      function extractRFC2822(match2) {
        var weekdayStr = match2[1], dayStr = match2[2], monthStr = match2[3], yearStr = match2[4], hourStr = match2[5], minuteStr = match2[6], secondStr = match2[7], obsOffset = match2[8], milOffset = match2[9], offHourStr = match2[10], offMinuteStr = match2[11], result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
        var offset2;
        if (obsOffset) {
          offset2 = obsOffsets[obsOffset];
        } else if (milOffset) {
          offset2 = 0;
        } else {
          offset2 = signedOffset(offHourStr, offMinuteStr);
        }
        return [result, new FixedOffsetZone(offset2)];
      }
      function preprocessRFC2822(s4) {
        return s4.replace(/\([^)]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim();
      }
      var rfc1123 = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/;
      var rfc850 = /^(Monday|Tuesday|Wedsday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/;
      var ascii = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;
      function extractRFC1123Or850(match2) {
        var weekdayStr = match2[1], dayStr = match2[2], monthStr = match2[3], yearStr = match2[4], hourStr = match2[5], minuteStr = match2[6], secondStr = match2[7], result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
        return [result, FixedOffsetZone.utcInstance];
      }
      function extractASCII(match2) {
        var weekdayStr = match2[1], monthStr = match2[2], dayStr = match2[3], hourStr = match2[4], minuteStr = match2[5], secondStr = match2[6], yearStr = match2[7], result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
        return [result, FixedOffsetZone.utcInstance];
      }
      var isoYmdWithTimeExtensionRegex = combineRegexes(isoYmdRegex, isoTimeExtensionRegex);
      var isoWeekWithTimeExtensionRegex = combineRegexes(isoWeekRegex, isoTimeExtensionRegex);
      var isoOrdinalWithTimeExtensionRegex = combineRegexes(isoOrdinalRegex, isoTimeExtensionRegex);
      var isoTimeCombinedRegex = combineRegexes(isoTimeRegex);
      var extractISOYmdTimeAndOffset = combineExtractors(extractISOYmd, extractISOTime, extractISOOffset);
      var extractISOWeekTimeAndOffset = combineExtractors(extractISOWeekData, extractISOTime, extractISOOffset);
      var extractISOOrdinalDateAndTime = combineExtractors(extractISOOrdinalData, extractISOTime, extractISOOffset);
      var extractISOTimeAndOffset = combineExtractors(extractISOTime, extractISOOffset);
      function parseISODate(s4) {
        return parse3(s4, [isoYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset], [isoWeekWithTimeExtensionRegex, extractISOWeekTimeAndOffset], [isoOrdinalWithTimeExtensionRegex, extractISOOrdinalDateAndTime], [isoTimeCombinedRegex, extractISOTimeAndOffset]);
      }
      function parseRFC2822Date(s4) {
        return parse3(preprocessRFC2822(s4), [rfc2822, extractRFC2822]);
      }
      function parseHTTPDate(s4) {
        return parse3(s4, [rfc1123, extractRFC1123Or850], [rfc850, extractRFC1123Or850], [ascii, extractASCII]);
      }
      function parseISODuration(s4) {
        return parse3(s4, [isoDuration, extractISODuration]);
      }
      var extractISOTimeOnly = combineExtractors(extractISOTime);
      function parseISOTimeOnly(s4) {
        return parse3(s4, [isoTimeOnly, extractISOTimeOnly]);
      }
      var sqlYmdWithTimeExtensionRegex = combineRegexes(sqlYmdRegex, sqlTimeExtensionRegex);
      var sqlTimeCombinedRegex = combineRegexes(sqlTimeRegex);
      var extractISOYmdTimeOffsetAndIANAZone = combineExtractors(extractISOYmd, extractISOTime, extractISOOffset, extractIANAZone);
      var extractISOTimeOffsetAndIANAZone = combineExtractors(extractISOTime, extractISOOffset, extractIANAZone);
      function parseSQL(s4) {
        return parse3(s4, [sqlYmdWithTimeExtensionRegex, extractISOYmdTimeOffsetAndIANAZone], [sqlTimeCombinedRegex, extractISOTimeOffsetAndIANAZone]);
      }
      var INVALID$2 = "Invalid Duration";
      var lowOrderMatrix = {
        weeks: {
          days: 7,
          hours: 7 * 24,
          minutes: 7 * 24 * 60,
          seconds: 7 * 24 * 60 * 60,
          milliseconds: 7 * 24 * 60 * 60 * 1e3
        },
        days: {
          hours: 24,
          minutes: 24 * 60,
          seconds: 24 * 60 * 60,
          milliseconds: 24 * 60 * 60 * 1e3
        },
        hours: {
          minutes: 60,
          seconds: 60 * 60,
          milliseconds: 60 * 60 * 1e3
        },
        minutes: {
          seconds: 60,
          milliseconds: 60 * 1e3
        },
        seconds: {
          milliseconds: 1e3
        }
      };
      var casualMatrix = _extends({
        years: {
          quarters: 4,
          months: 12,
          weeks: 52,
          days: 365,
          hours: 365 * 24,
          minutes: 365 * 24 * 60,
          seconds: 365 * 24 * 60 * 60,
          milliseconds: 365 * 24 * 60 * 60 * 1e3
        },
        quarters: {
          months: 3,
          weeks: 13,
          days: 91,
          hours: 91 * 24,
          minutes: 91 * 24 * 60,
          seconds: 91 * 24 * 60 * 60,
          milliseconds: 91 * 24 * 60 * 60 * 1e3
        },
        months: {
          weeks: 4,
          days: 30,
          hours: 30 * 24,
          minutes: 30 * 24 * 60,
          seconds: 30 * 24 * 60 * 60,
          milliseconds: 30 * 24 * 60 * 60 * 1e3
        }
      }, lowOrderMatrix);
      var daysInYearAccurate = 146097 / 400;
      var daysInMonthAccurate = 146097 / 4800;
      var accurateMatrix = _extends({
        years: {
          quarters: 4,
          months: 12,
          weeks: daysInYearAccurate / 7,
          days: daysInYearAccurate,
          hours: daysInYearAccurate * 24,
          minutes: daysInYearAccurate * 24 * 60,
          seconds: daysInYearAccurate * 24 * 60 * 60,
          milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1e3
        },
        quarters: {
          months: 3,
          weeks: daysInYearAccurate / 28,
          days: daysInYearAccurate / 4,
          hours: daysInYearAccurate * 24 / 4,
          minutes: daysInYearAccurate * 24 * 60 / 4,
          seconds: daysInYearAccurate * 24 * 60 * 60 / 4,
          milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1e3 / 4
        },
        months: {
          weeks: daysInMonthAccurate / 7,
          days: daysInMonthAccurate,
          hours: daysInMonthAccurate * 24,
          minutes: daysInMonthAccurate * 24 * 60,
          seconds: daysInMonthAccurate * 24 * 60 * 60,
          milliseconds: daysInMonthAccurate * 24 * 60 * 60 * 1e3
        }
      }, lowOrderMatrix);
      var orderedUnits$1 = ["years", "quarters", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds"];
      var reverseUnits = orderedUnits$1.slice(0).reverse();
      function clone$1(dur, alts, clear) {
        if (clear === void 0) {
          clear = false;
        }
        var conf = {
          values: clear ? alts.values : _extends({}, dur.values, alts.values || {}),
          loc: dur.loc.clone(alts.loc),
          conversionAccuracy: alts.conversionAccuracy || dur.conversionAccuracy
        };
        return new Duration(conf);
      }
      function antiTrunc(n3) {
        return n3 < 0 ? Math.floor(n3) : Math.ceil(n3);
      }
      function convert(matrix, fromMap, fromUnit, toMap, toUnit) {
        var conv = matrix[toUnit][fromUnit], raw = fromMap[fromUnit] / conv, sameSign = Math.sign(raw) === Math.sign(toMap[toUnit]), added = !sameSign && toMap[toUnit] !== 0 && Math.abs(raw) <= 1 ? antiTrunc(raw) : Math.trunc(raw);
        toMap[toUnit] += added;
        fromMap[fromUnit] -= added * conv;
      }
      function normalizeValues(matrix, vals) {
        reverseUnits.reduce(function(previous, current) {
          if (!isUndefined(vals[current])) {
            if (previous) {
              convert(matrix, vals, previous, vals, current);
            }
            return current;
          } else {
            return previous;
          }
        }, null);
      }
      var Duration = /* @__PURE__ */ function() {
        function Duration2(config) {
          var accurate = config.conversionAccuracy === "longterm" || false;
          this.values = config.values;
          this.loc = config.loc || Locale.create();
          this.conversionAccuracy = accurate ? "longterm" : "casual";
          this.invalid = config.invalid || null;
          this.matrix = accurate ? accurateMatrix : casualMatrix;
          this.isLuxonDuration = true;
        }
        Duration2.fromMillis = function fromMillis(count, opts) {
          return Duration2.fromObject({
            milliseconds: count
          }, opts);
        };
        Duration2.fromObject = function fromObject(obj, opts) {
          if (opts === void 0) {
            opts = {};
          }
          if (obj == null || typeof obj !== "object") {
            throw new InvalidArgumentError("Duration.fromObject: argument expected to be an object, got " + (obj === null ? "null" : typeof obj));
          }
          return new Duration2({
            values: normalizeObject(obj, Duration2.normalizeUnit),
            loc: Locale.fromObject(opts),
            conversionAccuracy: opts.conversionAccuracy
          });
        };
        Duration2.fromISO = function fromISO(text, opts) {
          var _parseISODuration = parseISODuration(text), parsed = _parseISODuration[0];
          if (parsed) {
            return Duration2.fromObject(parsed, opts);
          } else {
            return Duration2.invalid("unparsable", 'the input "' + text + `" can't be parsed as ISO 8601`);
          }
        };
        Duration2.fromISOTime = function fromISOTime(text, opts) {
          var _parseISOTimeOnly = parseISOTimeOnly(text), parsed = _parseISOTimeOnly[0];
          if (parsed) {
            return Duration2.fromObject(parsed, opts);
          } else {
            return Duration2.invalid("unparsable", 'the input "' + text + `" can't be parsed as ISO 8601`);
          }
        };
        Duration2.invalid = function invalid(reason, explanation) {
          if (explanation === void 0) {
            explanation = null;
          }
          if (!reason) {
            throw new InvalidArgumentError("need to specify a reason the Duration is invalid");
          }
          var invalid2 = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
          if (Settings.throwOnInvalid) {
            throw new InvalidDurationError(invalid2);
          } else {
            return new Duration2({
              invalid: invalid2
            });
          }
        };
        Duration2.normalizeUnit = function normalizeUnit2(unit) {
          var normalized = {
            year: "years",
            years: "years",
            quarter: "quarters",
            quarters: "quarters",
            month: "months",
            months: "months",
            week: "weeks",
            weeks: "weeks",
            day: "days",
            days: "days",
            hour: "hours",
            hours: "hours",
            minute: "minutes",
            minutes: "minutes",
            second: "seconds",
            seconds: "seconds",
            millisecond: "milliseconds",
            milliseconds: "milliseconds"
          }[unit ? unit.toLowerCase() : unit];
          if (!normalized)
            throw new InvalidUnitError(unit);
          return normalized;
        };
        Duration2.isDuration = function isDuration(o3) {
          return o3 && o3.isLuxonDuration || false;
        };
        var _proto = Duration2.prototype;
        _proto.toFormat = function toFormat(fmt, opts) {
          if (opts === void 0) {
            opts = {};
          }
          var fmtOpts = _extends({}, opts, {
            floor: opts.round !== false && opts.floor !== false
          });
          return this.isValid ? Formatter2.create(this.loc, fmtOpts).formatDurationFromString(this, fmt) : INVALID$2;
        };
        _proto.toObject = function toObject() {
          if (!this.isValid)
            return {};
          return _extends({}, this.values);
        };
        _proto.toISO = function toISO() {
          if (!this.isValid)
            return null;
          var s4 = "P";
          if (this.years !== 0)
            s4 += this.years + "Y";
          if (this.months !== 0 || this.quarters !== 0)
            s4 += this.months + this.quarters * 3 + "M";
          if (this.weeks !== 0)
            s4 += this.weeks + "W";
          if (this.days !== 0)
            s4 += this.days + "D";
          if (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0)
            s4 += "T";
          if (this.hours !== 0)
            s4 += this.hours + "H";
          if (this.minutes !== 0)
            s4 += this.minutes + "M";
          if (this.seconds !== 0 || this.milliseconds !== 0)
            s4 += roundTo(this.seconds + this.milliseconds / 1e3, 3) + "S";
          if (s4 === "P")
            s4 += "T0S";
          return s4;
        };
        _proto.toISOTime = function toISOTime(opts) {
          if (opts === void 0) {
            opts = {};
          }
          if (!this.isValid)
            return null;
          var millis = this.toMillis();
          if (millis < 0 || millis >= 864e5)
            return null;
          opts = _extends({
            suppressMilliseconds: false,
            suppressSeconds: false,
            includePrefix: false,
            format: "extended"
          }, opts);
          var value = this.shiftTo("hours", "minutes", "seconds", "milliseconds");
          var fmt = opts.format === "basic" ? "hhmm" : "hh:mm";
          if (!opts.suppressSeconds || value.seconds !== 0 || value.milliseconds !== 0) {
            fmt += opts.format === "basic" ? "ss" : ":ss";
            if (!opts.suppressMilliseconds || value.milliseconds !== 0) {
              fmt += ".SSS";
            }
          }
          var str = value.toFormat(fmt);
          if (opts.includePrefix) {
            str = "T" + str;
          }
          return str;
        };
        _proto.toJSON = function toJSON2() {
          return this.toISO();
        };
        _proto.toString = function toString() {
          return this.toISO();
        };
        _proto.toMillis = function toMillis() {
          return this.as("milliseconds");
        };
        _proto.valueOf = function valueOf() {
          return this.toMillis();
        };
        _proto.plus = function plus(duration) {
          if (!this.isValid)
            return this;
          var dur = friendlyDuration(duration), result = {};
          for (var _iterator = _createForOfIteratorHelperLoose(orderedUnits$1), _step; !(_step = _iterator()).done; ) {
            var k3 = _step.value;
            if (hasOwnProperty(dur.values, k3) || hasOwnProperty(this.values, k3)) {
              result[k3] = dur.get(k3) + this.get(k3);
            }
          }
          return clone$1(this, {
            values: result
          }, true);
        };
        _proto.minus = function minus(duration) {
          if (!this.isValid)
            return this;
          var dur = friendlyDuration(duration);
          return this.plus(dur.negate());
        };
        _proto.mapUnits = function mapUnits(fn) {
          if (!this.isValid)
            return this;
          var result = {};
          for (var _i = 0, _Object$keys = Object.keys(this.values); _i < _Object$keys.length; _i++) {
            var k3 = _Object$keys[_i];
            result[k3] = asNumber(fn(this.values[k3], k3));
          }
          return clone$1(this, {
            values: result
          }, true);
        };
        _proto.get = function get(unit) {
          return this[Duration2.normalizeUnit(unit)];
        };
        _proto.set = function set(values) {
          if (!this.isValid)
            return this;
          var mixed = _extends({}, this.values, normalizeObject(values, Duration2.normalizeUnit));
          return clone$1(this, {
            values: mixed
          });
        };
        _proto.reconfigure = function reconfigure(_temp) {
          var _ref = _temp === void 0 ? {} : _temp, locale = _ref.locale, numberingSystem = _ref.numberingSystem, conversionAccuracy = _ref.conversionAccuracy;
          var loc = this.loc.clone({
            locale,
            numberingSystem
          }), opts = {
            loc
          };
          if (conversionAccuracy) {
            opts.conversionAccuracy = conversionAccuracy;
          }
          return clone$1(this, opts);
        };
        _proto.as = function as(unit) {
          return this.isValid ? this.shiftTo(unit).get(unit) : NaN;
        };
        _proto.normalize = function normalize() {
          if (!this.isValid)
            return this;
          var vals = this.toObject();
          normalizeValues(this.matrix, vals);
          return clone$1(this, {
            values: vals
          }, true);
        };
        _proto.shiftTo = function shiftTo() {
          for (var _len = arguments.length, units = new Array(_len), _key = 0; _key < _len; _key++) {
            units[_key] = arguments[_key];
          }
          if (!this.isValid)
            return this;
          if (units.length === 0) {
            return this;
          }
          units = units.map(function(u3) {
            return Duration2.normalizeUnit(u3);
          });
          var built = {}, accumulated = {}, vals = this.toObject();
          var lastUnit;
          for (var _iterator2 = _createForOfIteratorHelperLoose(orderedUnits$1), _step2; !(_step2 = _iterator2()).done; ) {
            var k3 = _step2.value;
            if (units.indexOf(k3) >= 0) {
              lastUnit = k3;
              var own = 0;
              for (var ak in accumulated) {
                own += this.matrix[ak][k3] * accumulated[ak];
                accumulated[ak] = 0;
              }
              if (isNumber(vals[k3])) {
                own += vals[k3];
              }
              var i3 = Math.trunc(own);
              built[k3] = i3;
              accumulated[k3] = own - i3;
              for (var down in vals) {
                if (orderedUnits$1.indexOf(down) > orderedUnits$1.indexOf(k3)) {
                  convert(this.matrix, vals, down, built, k3);
                }
              }
            } else if (isNumber(vals[k3])) {
              accumulated[k3] = vals[k3];
            }
          }
          for (var key2 in accumulated) {
            if (accumulated[key2] !== 0) {
              built[lastUnit] += key2 === lastUnit ? accumulated[key2] : accumulated[key2] / this.matrix[lastUnit][key2];
            }
          }
          return clone$1(this, {
            values: built
          }, true).normalize();
        };
        _proto.negate = function negate() {
          if (!this.isValid)
            return this;
          var negated = {};
          for (var _i2 = 0, _Object$keys2 = Object.keys(this.values); _i2 < _Object$keys2.length; _i2++) {
            var k3 = _Object$keys2[_i2];
            negated[k3] = -this.values[k3];
          }
          return clone$1(this, {
            values: negated
          }, true);
        };
        _proto.equals = function equals(other) {
          if (!this.isValid || !other.isValid) {
            return false;
          }
          if (!this.loc.equals(other.loc)) {
            return false;
          }
          function eq4(v1, v22) {
            if (v1 === void 0 || v1 === 0)
              return v22 === void 0 || v22 === 0;
            return v1 === v22;
          }
          for (var _iterator3 = _createForOfIteratorHelperLoose(orderedUnits$1), _step3; !(_step3 = _iterator3()).done; ) {
            var u3 = _step3.value;
            if (!eq4(this.values[u3], other.values[u3])) {
              return false;
            }
          }
          return true;
        };
        _createClass(Duration2, [{
          key: "locale",
          get: function get() {
            return this.isValid ? this.loc.locale : null;
          }
        }, {
          key: "numberingSystem",
          get: function get() {
            return this.isValid ? this.loc.numberingSystem : null;
          }
        }, {
          key: "years",
          get: function get() {
            return this.isValid ? this.values.years || 0 : NaN;
          }
        }, {
          key: "quarters",
          get: function get() {
            return this.isValid ? this.values.quarters || 0 : NaN;
          }
        }, {
          key: "months",
          get: function get() {
            return this.isValid ? this.values.months || 0 : NaN;
          }
        }, {
          key: "weeks",
          get: function get() {
            return this.isValid ? this.values.weeks || 0 : NaN;
          }
        }, {
          key: "days",
          get: function get() {
            return this.isValid ? this.values.days || 0 : NaN;
          }
        }, {
          key: "hours",
          get: function get() {
            return this.isValid ? this.values.hours || 0 : NaN;
          }
        }, {
          key: "minutes",
          get: function get() {
            return this.isValid ? this.values.minutes || 0 : NaN;
          }
        }, {
          key: "seconds",
          get: function get() {
            return this.isValid ? this.values.seconds || 0 : NaN;
          }
        }, {
          key: "milliseconds",
          get: function get() {
            return this.isValid ? this.values.milliseconds || 0 : NaN;
          }
        }, {
          key: "isValid",
          get: function get() {
            return this.invalid === null;
          }
        }, {
          key: "invalidReason",
          get: function get() {
            return this.invalid ? this.invalid.reason : null;
          }
        }, {
          key: "invalidExplanation",
          get: function get() {
            return this.invalid ? this.invalid.explanation : null;
          }
        }]);
        return Duration2;
      }();
      function friendlyDuration(durationish) {
        if (isNumber(durationish)) {
          return Duration.fromMillis(durationish);
        } else if (Duration.isDuration(durationish)) {
          return durationish;
        } else if (typeof durationish === "object") {
          return Duration.fromObject(durationish);
        } else {
          throw new InvalidArgumentError("Unknown duration argument " + durationish + " of type " + typeof durationish);
        }
      }
      var INVALID$1 = "Invalid Interval";
      function validateStartEnd(start, end) {
        if (!start || !start.isValid) {
          return Interval.invalid("missing or invalid start");
        } else if (!end || !end.isValid) {
          return Interval.invalid("missing or invalid end");
        } else if (end < start) {
          return Interval.invalid("end before start", "The end of an interval must be after its start, but you had start=" + start.toISO() + " and end=" + end.toISO());
        } else {
          return null;
        }
      }
      var Interval = /* @__PURE__ */ function() {
        function Interval2(config) {
          this.s = config.start;
          this.e = config.end;
          this.invalid = config.invalid || null;
          this.isLuxonInterval = true;
        }
        Interval2.invalid = function invalid(reason, explanation) {
          if (explanation === void 0) {
            explanation = null;
          }
          if (!reason) {
            throw new InvalidArgumentError("need to specify a reason the Interval is invalid");
          }
          var invalid2 = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
          if (Settings.throwOnInvalid) {
            throw new InvalidIntervalError(invalid2);
          } else {
            return new Interval2({
              invalid: invalid2
            });
          }
        };
        Interval2.fromDateTimes = function fromDateTimes(start, end) {
          var builtStart = friendlyDateTime(start), builtEnd = friendlyDateTime(end);
          var validateError = validateStartEnd(builtStart, builtEnd);
          if (validateError == null) {
            return new Interval2({
              start: builtStart,
              end: builtEnd
            });
          } else {
            return validateError;
          }
        };
        Interval2.after = function after(start, duration) {
          var dur = friendlyDuration(duration), dt = friendlyDateTime(start);
          return Interval2.fromDateTimes(dt, dt.plus(dur));
        };
        Interval2.before = function before(end, duration) {
          var dur = friendlyDuration(duration), dt = friendlyDateTime(end);
          return Interval2.fromDateTimes(dt.minus(dur), dt);
        };
        Interval2.fromISO = function fromISO(text, opts) {
          var _split = (text || "").split("/", 2), s4 = _split[0], e3 = _split[1];
          if (s4 && e3) {
            var start, startIsValid;
            try {
              start = DateTime2.fromISO(s4, opts);
              startIsValid = start.isValid;
            } catch (e4) {
              startIsValid = false;
            }
            var end, endIsValid;
            try {
              end = DateTime2.fromISO(e3, opts);
              endIsValid = end.isValid;
            } catch (e4) {
              endIsValid = false;
            }
            if (startIsValid && endIsValid) {
              return Interval2.fromDateTimes(start, end);
            }
            if (startIsValid) {
              var dur = Duration.fromISO(e3, opts);
              if (dur.isValid) {
                return Interval2.after(start, dur);
              }
            } else if (endIsValid) {
              var _dur = Duration.fromISO(s4, opts);
              if (_dur.isValid) {
                return Interval2.before(end, _dur);
              }
            }
          }
          return Interval2.invalid("unparsable", 'the input "' + text + `" can't be parsed as ISO 8601`);
        };
        Interval2.isInterval = function isInterval(o3) {
          return o3 && o3.isLuxonInterval || false;
        };
        var _proto = Interval2.prototype;
        _proto.length = function length(unit) {
          if (unit === void 0) {
            unit = "milliseconds";
          }
          return this.isValid ? this.toDuration.apply(this, [unit]).get(unit) : NaN;
        };
        _proto.count = function count(unit) {
          if (unit === void 0) {
            unit = "milliseconds";
          }
          if (!this.isValid)
            return NaN;
          var start = this.start.startOf(unit), end = this.end.startOf(unit);
          return Math.floor(end.diff(start, unit).get(unit)) + 1;
        };
        _proto.hasSame = function hasSame(unit) {
          return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, unit) : false;
        };
        _proto.isEmpty = function isEmpty() {
          return this.s.valueOf() === this.e.valueOf();
        };
        _proto.isAfter = function isAfter(dateTime) {
          if (!this.isValid)
            return false;
          return this.s > dateTime;
        };
        _proto.isBefore = function isBefore(dateTime) {
          if (!this.isValid)
            return false;
          return this.e <= dateTime;
        };
        _proto.contains = function contains(dateTime) {
          if (!this.isValid)
            return false;
          return this.s <= dateTime && this.e > dateTime;
        };
        _proto.set = function set(_temp) {
          var _ref = _temp === void 0 ? {} : _temp, start = _ref.start, end = _ref.end;
          if (!this.isValid)
            return this;
          return Interval2.fromDateTimes(start || this.s, end || this.e);
        };
        _proto.splitAt = function splitAt() {
          var _this = this;
          if (!this.isValid)
            return [];
          for (var _len = arguments.length, dateTimes = new Array(_len), _key = 0; _key < _len; _key++) {
            dateTimes[_key] = arguments[_key];
          }
          var sorted = dateTimes.map(friendlyDateTime).filter(function(d3) {
            return _this.contains(d3);
          }).sort(), results = [];
          var s4 = this.s, i3 = 0;
          while (s4 < this.e) {
            var added = sorted[i3] || this.e, next = +added > +this.e ? this.e : added;
            results.push(Interval2.fromDateTimes(s4, next));
            s4 = next;
            i3 += 1;
          }
          return results;
        };
        _proto.splitBy = function splitBy(duration) {
          var dur = friendlyDuration(duration);
          if (!this.isValid || !dur.isValid || dur.as("milliseconds") === 0) {
            return [];
          }
          var s4 = this.s, idx = 1, next;
          var results = [];
          while (s4 < this.e) {
            var added = this.start.plus(dur.mapUnits(function(x3) {
              return x3 * idx;
            }));
            next = +added > +this.e ? this.e : added;
            results.push(Interval2.fromDateTimes(s4, next));
            s4 = next;
            idx += 1;
          }
          return results;
        };
        _proto.divideEqually = function divideEqually(numberOfParts) {
          if (!this.isValid)
            return [];
          return this.splitBy(this.length() / numberOfParts).slice(0, numberOfParts);
        };
        _proto.overlaps = function overlaps(other) {
          return this.e > other.s && this.s < other.e;
        };
        _proto.abutsStart = function abutsStart(other) {
          if (!this.isValid)
            return false;
          return +this.e === +other.s;
        };
        _proto.abutsEnd = function abutsEnd(other) {
          if (!this.isValid)
            return false;
          return +other.e === +this.s;
        };
        _proto.engulfs = function engulfs(other) {
          if (!this.isValid)
            return false;
          return this.s <= other.s && this.e >= other.e;
        };
        _proto.equals = function equals(other) {
          if (!this.isValid || !other.isValid) {
            return false;
          }
          return this.s.equals(other.s) && this.e.equals(other.e);
        };
        _proto.intersection = function intersection(other) {
          if (!this.isValid)
            return this;
          var s4 = this.s > other.s ? this.s : other.s, e3 = this.e < other.e ? this.e : other.e;
          if (s4 >= e3) {
            return null;
          } else {
            return Interval2.fromDateTimes(s4, e3);
          }
        };
        _proto.union = function union(other) {
          if (!this.isValid)
            return this;
          var s4 = this.s < other.s ? this.s : other.s, e3 = this.e > other.e ? this.e : other.e;
          return Interval2.fromDateTimes(s4, e3);
        };
        Interval2.merge = function merge(intervals) {
          var _intervals$sort$reduc = intervals.sort(function(a3, b2) {
            return a3.s - b2.s;
          }).reduce(function(_ref2, item) {
            var sofar = _ref2[0], current = _ref2[1];
            if (!current) {
              return [sofar, item];
            } else if (current.overlaps(item) || current.abutsStart(item)) {
              return [sofar, current.union(item)];
            } else {
              return [sofar.concat([current]), item];
            }
          }, [[], null]), found = _intervals$sort$reduc[0], final = _intervals$sort$reduc[1];
          if (final) {
            found.push(final);
          }
          return found;
        };
        Interval2.xor = function xor(intervals) {
          var _Array$prototype;
          var start = null, currentCount = 0;
          var results = [], ends = intervals.map(function(i4) {
            return [{
              time: i4.s,
              type: "s"
            }, {
              time: i4.e,
              type: "e"
            }];
          }), flattened = (_Array$prototype = Array.prototype).concat.apply(_Array$prototype, ends), arr = flattened.sort(function(a3, b2) {
            return a3.time - b2.time;
          });
          for (var _iterator = _createForOfIteratorHelperLoose(arr), _step; !(_step = _iterator()).done; ) {
            var i3 = _step.value;
            currentCount += i3.type === "s" ? 1 : -1;
            if (currentCount === 1) {
              start = i3.time;
            } else {
              if (start && +start !== +i3.time) {
                results.push(Interval2.fromDateTimes(start, i3.time));
              }
              start = null;
            }
          }
          return Interval2.merge(results);
        };
        _proto.difference = function difference() {
          var _this2 = this;
          for (var _len2 = arguments.length, intervals = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            intervals[_key2] = arguments[_key2];
          }
          return Interval2.xor([this].concat(intervals)).map(function(i3) {
            return _this2.intersection(i3);
          }).filter(function(i3) {
            return i3 && !i3.isEmpty();
          });
        };
        _proto.toString = function toString() {
          if (!this.isValid)
            return INVALID$1;
          return "[" + this.s.toISO() + " \u2013 " + this.e.toISO() + ")";
        };
        _proto.toISO = function toISO(opts) {
          if (!this.isValid)
            return INVALID$1;
          return this.s.toISO(opts) + "/" + this.e.toISO(opts);
        };
        _proto.toISODate = function toISODate() {
          if (!this.isValid)
            return INVALID$1;
          return this.s.toISODate() + "/" + this.e.toISODate();
        };
        _proto.toISOTime = function toISOTime(opts) {
          if (!this.isValid)
            return INVALID$1;
          return this.s.toISOTime(opts) + "/" + this.e.toISOTime(opts);
        };
        _proto.toFormat = function toFormat(dateFormat, _temp2) {
          var _ref3 = _temp2 === void 0 ? {} : _temp2, _ref3$separator = _ref3.separator, separator = _ref3$separator === void 0 ? " \u2013 " : _ref3$separator;
          if (!this.isValid)
            return INVALID$1;
          return "" + this.s.toFormat(dateFormat) + separator + this.e.toFormat(dateFormat);
        };
        _proto.toDuration = function toDuration(unit, opts) {
          if (!this.isValid) {
            return Duration.invalid(this.invalidReason);
          }
          return this.e.diff(this.s, unit, opts);
        };
        _proto.mapEndpoints = function mapEndpoints(mapFn) {
          return Interval2.fromDateTimes(mapFn(this.s), mapFn(this.e));
        };
        _createClass(Interval2, [{
          key: "start",
          get: function get() {
            return this.isValid ? this.s : null;
          }
        }, {
          key: "end",
          get: function get() {
            return this.isValid ? this.e : null;
          }
        }, {
          key: "isValid",
          get: function get() {
            return this.invalidReason === null;
          }
        }, {
          key: "invalidReason",
          get: function get() {
            return this.invalid ? this.invalid.reason : null;
          }
        }, {
          key: "invalidExplanation",
          get: function get() {
            return this.invalid ? this.invalid.explanation : null;
          }
        }]);
        return Interval2;
      }();
      var Info = /* @__PURE__ */ function() {
        function Info2() {
        }
        Info2.hasDST = function hasDST(zone) {
          if (zone === void 0) {
            zone = Settings.defaultZone;
          }
          var proto = DateTime2.now().setZone(zone).set({
            month: 12
          });
          return !zone.isUniversal && proto.offset !== proto.set({
            month: 6
          }).offset;
        };
        Info2.isValidIANAZone = function isValidIANAZone(zone) {
          return IANAZone.isValidSpecifier(zone) && IANAZone.isValidZone(zone);
        };
        Info2.normalizeZone = function normalizeZone$1(input) {
          return normalizeZone(input, Settings.defaultZone);
        };
        Info2.months = function months2(length, _temp) {
          if (length === void 0) {
            length = "long";
          }
          var _ref = _temp === void 0 ? {} : _temp, _ref$locale = _ref.locale, locale = _ref$locale === void 0 ? null : _ref$locale, _ref$numberingSystem = _ref.numberingSystem, numberingSystem = _ref$numberingSystem === void 0 ? null : _ref$numberingSystem, _ref$locObj = _ref.locObj, locObj = _ref$locObj === void 0 ? null : _ref$locObj, _ref$outputCalendar = _ref.outputCalendar, outputCalendar = _ref$outputCalendar === void 0 ? "gregory" : _ref$outputCalendar;
          return (locObj || Locale.create(locale, numberingSystem, outputCalendar)).months(length);
        };
        Info2.monthsFormat = function monthsFormat(length, _temp2) {
          if (length === void 0) {
            length = "long";
          }
          var _ref2 = _temp2 === void 0 ? {} : _temp2, _ref2$locale = _ref2.locale, locale = _ref2$locale === void 0 ? null : _ref2$locale, _ref2$numberingSystem = _ref2.numberingSystem, numberingSystem = _ref2$numberingSystem === void 0 ? null : _ref2$numberingSystem, _ref2$locObj = _ref2.locObj, locObj = _ref2$locObj === void 0 ? null : _ref2$locObj, _ref2$outputCalendar = _ref2.outputCalendar, outputCalendar = _ref2$outputCalendar === void 0 ? "gregory" : _ref2$outputCalendar;
          return (locObj || Locale.create(locale, numberingSystem, outputCalendar)).months(length, true);
        };
        Info2.weekdays = function weekdays2(length, _temp3) {
          if (length === void 0) {
            length = "long";
          }
          var _ref3 = _temp3 === void 0 ? {} : _temp3, _ref3$locale = _ref3.locale, locale = _ref3$locale === void 0 ? null : _ref3$locale, _ref3$numberingSystem = _ref3.numberingSystem, numberingSystem = _ref3$numberingSystem === void 0 ? null : _ref3$numberingSystem, _ref3$locObj = _ref3.locObj, locObj = _ref3$locObj === void 0 ? null : _ref3$locObj;
          return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(length);
        };
        Info2.weekdaysFormat = function weekdaysFormat(length, _temp4) {
          if (length === void 0) {
            length = "long";
          }
          var _ref4 = _temp4 === void 0 ? {} : _temp4, _ref4$locale = _ref4.locale, locale = _ref4$locale === void 0 ? null : _ref4$locale, _ref4$numberingSystem = _ref4.numberingSystem, numberingSystem = _ref4$numberingSystem === void 0 ? null : _ref4$numberingSystem, _ref4$locObj = _ref4.locObj, locObj = _ref4$locObj === void 0 ? null : _ref4$locObj;
          return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(length, true);
        };
        Info2.meridiems = function meridiems2(_temp5) {
          var _ref5 = _temp5 === void 0 ? {} : _temp5, _ref5$locale = _ref5.locale, locale = _ref5$locale === void 0 ? null : _ref5$locale;
          return Locale.create(locale).meridiems();
        };
        Info2.eras = function eras2(length, _temp6) {
          if (length === void 0) {
            length = "short";
          }
          var _ref6 = _temp6 === void 0 ? {} : _temp6, _ref6$locale = _ref6.locale, locale = _ref6$locale === void 0 ? null : _ref6$locale;
          return Locale.create(locale, null, "gregory").eras(length);
        };
        Info2.features = function features() {
          return {
            relative: hasRelative()
          };
        };
        return Info2;
      }();
      function dayDiff(earlier, later) {
        var utcDayStart = function utcDayStart2(dt) {
          return dt.toUTC(0, {
            keepLocalTime: true
          }).startOf("day").valueOf();
        }, ms = utcDayStart(later) - utcDayStart(earlier);
        return Math.floor(Duration.fromMillis(ms).as("days"));
      }
      function highOrderDiffs(cursor, later, units) {
        var differs = [["years", function(a3, b2) {
          return b2.year - a3.year;
        }], ["quarters", function(a3, b2) {
          return b2.quarter - a3.quarter;
        }], ["months", function(a3, b2) {
          return b2.month - a3.month + (b2.year - a3.year) * 12;
        }], ["weeks", function(a3, b2) {
          var days = dayDiff(a3, b2);
          return (days - days % 7) / 7;
        }], ["days", dayDiff]];
        var results = {};
        var lowestOrder, highWater;
        for (var _i = 0, _differs = differs; _i < _differs.length; _i++) {
          var _differs$_i = _differs[_i], unit = _differs$_i[0], differ = _differs$_i[1];
          if (units.indexOf(unit) >= 0) {
            var _cursor$plus;
            lowestOrder = unit;
            var delta = differ(cursor, later);
            highWater = cursor.plus((_cursor$plus = {}, _cursor$plus[unit] = delta, _cursor$plus));
            if (highWater > later) {
              var _cursor$plus2;
              cursor = cursor.plus((_cursor$plus2 = {}, _cursor$plus2[unit] = delta - 1, _cursor$plus2));
              delta -= 1;
            } else {
              cursor = highWater;
            }
            results[unit] = delta;
          }
        }
        return [cursor, results, highWater, lowestOrder];
      }
      function _diff(earlier, later, units, opts) {
        var _highOrderDiffs = highOrderDiffs(earlier, later, units), cursor = _highOrderDiffs[0], results = _highOrderDiffs[1], highWater = _highOrderDiffs[2], lowestOrder = _highOrderDiffs[3];
        var remainingMillis = later - cursor;
        var lowerOrderUnits = units.filter(function(u3) {
          return ["hours", "minutes", "seconds", "milliseconds"].indexOf(u3) >= 0;
        });
        if (lowerOrderUnits.length === 0) {
          if (highWater < later) {
            var _cursor$plus3;
            highWater = cursor.plus((_cursor$plus3 = {}, _cursor$plus3[lowestOrder] = 1, _cursor$plus3));
          }
          if (highWater !== cursor) {
            results[lowestOrder] = (results[lowestOrder] || 0) + remainingMillis / (highWater - cursor);
          }
        }
        var duration = Duration.fromObject(results, opts);
        if (lowerOrderUnits.length > 0) {
          var _Duration$fromMillis;
          return (_Duration$fromMillis = Duration.fromMillis(remainingMillis, opts)).shiftTo.apply(_Duration$fromMillis, lowerOrderUnits).plus(duration);
        } else {
          return duration;
        }
      }
      var numberingSystems = {
        arab: "[\u0660-\u0669]",
        arabext: "[\u06F0-\u06F9]",
        bali: "[\u1B50-\u1B59]",
        beng: "[\u09E6-\u09EF]",
        deva: "[\u0966-\u096F]",
        fullwide: "[\uFF10-\uFF19]",
        gujr: "[\u0AE6-\u0AEF]",
        hanidec: "[\u3007|\u4E00|\u4E8C|\u4E09|\u56DB|\u4E94|\u516D|\u4E03|\u516B|\u4E5D]",
        khmr: "[\u17E0-\u17E9]",
        knda: "[\u0CE6-\u0CEF]",
        laoo: "[\u0ED0-\u0ED9]",
        limb: "[\u1946-\u194F]",
        mlym: "[\u0D66-\u0D6F]",
        mong: "[\u1810-\u1819]",
        mymr: "[\u1040-\u1049]",
        orya: "[\u0B66-\u0B6F]",
        tamldec: "[\u0BE6-\u0BEF]",
        telu: "[\u0C66-\u0C6F]",
        thai: "[\u0E50-\u0E59]",
        tibt: "[\u0F20-\u0F29]",
        latn: "\\d"
      };
      var numberingSystemsUTF16 = {
        arab: [1632, 1641],
        arabext: [1776, 1785],
        bali: [6992, 7001],
        beng: [2534, 2543],
        deva: [2406, 2415],
        fullwide: [65296, 65303],
        gujr: [2790, 2799],
        khmr: [6112, 6121],
        knda: [3302, 3311],
        laoo: [3792, 3801],
        limb: [6470, 6479],
        mlym: [3430, 3439],
        mong: [6160, 6169],
        mymr: [4160, 4169],
        orya: [2918, 2927],
        tamldec: [3046, 3055],
        telu: [3174, 3183],
        thai: [3664, 3673],
        tibt: [3872, 3881]
      };
      var hanidecChars = numberingSystems.hanidec.replace(/[\[|\]]/g, "").split("");
      function parseDigits(str) {
        var value = parseInt(str, 10);
        if (isNaN(value)) {
          value = "";
          for (var i3 = 0; i3 < str.length; i3++) {
            var code = str.charCodeAt(i3);
            if (str[i3].search(numberingSystems.hanidec) !== -1) {
              value += hanidecChars.indexOf(str[i3]);
            } else {
              for (var key2 in numberingSystemsUTF16) {
                var _numberingSystemsUTF = numberingSystemsUTF16[key2], min = _numberingSystemsUTF[0], max = _numberingSystemsUTF[1];
                if (code >= min && code <= max) {
                  value += code - min;
                }
              }
            }
          }
          return parseInt(value, 10);
        } else {
          return value;
        }
      }
      function digitRegex(_ref, append) {
        var numberingSystem = _ref.numberingSystem;
        if (append === void 0) {
          append = "";
        }
        return new RegExp("" + numberingSystems[numberingSystem || "latn"] + append);
      }
      var MISSING_FTP = "missing Intl.DateTimeFormat.formatToParts support";
      function intUnit(regex, post) {
        if (post === void 0) {
          post = function post2(i3) {
            return i3;
          };
        }
        return {
          regex,
          deser: function deser(_ref) {
            var s4 = _ref[0];
            return post(parseDigits(s4));
          }
        };
      }
      var NBSP = String.fromCharCode(160);
      var spaceOrNBSP = "( |" + NBSP + ")";
      var spaceOrNBSPRegExp = new RegExp(spaceOrNBSP, "g");
      function fixListRegex(s4) {
        return s4.replace(/\./g, "\\.?").replace(spaceOrNBSPRegExp, spaceOrNBSP);
      }
      function stripInsensitivities(s4) {
        return s4.replace(/\./g, "").replace(spaceOrNBSPRegExp, " ").toLowerCase();
      }
      function oneOf(strings, startIndex) {
        if (strings === null) {
          return null;
        } else {
          return {
            regex: RegExp(strings.map(fixListRegex).join("|")),
            deser: function deser(_ref2) {
              var s4 = _ref2[0];
              return strings.findIndex(function(i3) {
                return stripInsensitivities(s4) === stripInsensitivities(i3);
              }) + startIndex;
            }
          };
        }
      }
      function offset(regex, groups) {
        return {
          regex,
          deser: function deser(_ref3) {
            var h3 = _ref3[1], m3 = _ref3[2];
            return signedOffset(h3, m3);
          },
          groups
        };
      }
      function simple(regex) {
        return {
          regex,
          deser: function deser(_ref4) {
            var s4 = _ref4[0];
            return s4;
          }
        };
      }
      function escapeToken(value) {
        return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
      }
      function unitForToken(token, loc) {
        var one = digitRegex(loc), two = digitRegex(loc, "{2}"), three = digitRegex(loc, "{3}"), four = digitRegex(loc, "{4}"), six = digitRegex(loc, "{6}"), oneOrTwo = digitRegex(loc, "{1,2}"), oneToThree = digitRegex(loc, "{1,3}"), oneToSix = digitRegex(loc, "{1,6}"), oneToNine = digitRegex(loc, "{1,9}"), twoToFour = digitRegex(loc, "{2,4}"), fourToSix = digitRegex(loc, "{4,6}"), literal = function literal2(t3) {
          return {
            regex: RegExp(escapeToken(t3.val)),
            deser: function deser(_ref5) {
              var s4 = _ref5[0];
              return s4;
            },
            literal: true
          };
        }, unitate = function unitate2(t3) {
          if (token.literal) {
            return literal(t3);
          }
          switch (t3.val) {
            case "G":
              return oneOf(loc.eras("short", false), 0);
            case "GG":
              return oneOf(loc.eras("long", false), 0);
            case "y":
              return intUnit(oneToSix);
            case "yy":
              return intUnit(twoToFour, untruncateYear);
            case "yyyy":
              return intUnit(four);
            case "yyyyy":
              return intUnit(fourToSix);
            case "yyyyyy":
              return intUnit(six);
            case "M":
              return intUnit(oneOrTwo);
            case "MM":
              return intUnit(two);
            case "MMM":
              return oneOf(loc.months("short", true, false), 1);
            case "MMMM":
              return oneOf(loc.months("long", true, false), 1);
            case "L":
              return intUnit(oneOrTwo);
            case "LL":
              return intUnit(two);
            case "LLL":
              return oneOf(loc.months("short", false, false), 1);
            case "LLLL":
              return oneOf(loc.months("long", false, false), 1);
            case "d":
              return intUnit(oneOrTwo);
            case "dd":
              return intUnit(two);
            case "o":
              return intUnit(oneToThree);
            case "ooo":
              return intUnit(three);
            case "HH":
              return intUnit(two);
            case "H":
              return intUnit(oneOrTwo);
            case "hh":
              return intUnit(two);
            case "h":
              return intUnit(oneOrTwo);
            case "mm":
              return intUnit(two);
            case "m":
              return intUnit(oneOrTwo);
            case "q":
              return intUnit(oneOrTwo);
            case "qq":
              return intUnit(two);
            case "s":
              return intUnit(oneOrTwo);
            case "ss":
              return intUnit(two);
            case "S":
              return intUnit(oneToThree);
            case "SSS":
              return intUnit(three);
            case "u":
              return simple(oneToNine);
            case "a":
              return oneOf(loc.meridiems(), 0);
            case "kkkk":
              return intUnit(four);
            case "kk":
              return intUnit(twoToFour, untruncateYear);
            case "W":
              return intUnit(oneOrTwo);
            case "WW":
              return intUnit(two);
            case "E":
            case "c":
              return intUnit(one);
            case "EEE":
              return oneOf(loc.weekdays("short", false, false), 1);
            case "EEEE":
              return oneOf(loc.weekdays("long", false, false), 1);
            case "ccc":
              return oneOf(loc.weekdays("short", true, false), 1);
            case "cccc":
              return oneOf(loc.weekdays("long", true, false), 1);
            case "Z":
            case "ZZ":
              return offset(new RegExp("([+-]" + oneOrTwo.source + ")(?::(" + two.source + "))?"), 2);
            case "ZZZ":
              return offset(new RegExp("([+-]" + oneOrTwo.source + ")(" + two.source + ")?"), 2);
            case "z":
              return simple(/[a-z_+-/]{1,256}?/i);
            default:
              return literal(t3);
          }
        };
        var unit = unitate(token) || {
          invalidReason: MISSING_FTP
        };
        unit.token = token;
        return unit;
      }
      var partTypeStyleToTokenVal = {
        year: {
          "2-digit": "yy",
          numeric: "yyyyy"
        },
        month: {
          numeric: "M",
          "2-digit": "MM",
          short: "MMM",
          long: "MMMM"
        },
        day: {
          numeric: "d",
          "2-digit": "dd"
        },
        weekday: {
          short: "EEE",
          long: "EEEE"
        },
        dayperiod: "a",
        dayPeriod: "a",
        hour: {
          numeric: "h",
          "2-digit": "hh"
        },
        minute: {
          numeric: "m",
          "2-digit": "mm"
        },
        second: {
          numeric: "s",
          "2-digit": "ss"
        }
      };
      function tokenForPart(part, locale, formatOpts) {
        var type = part.type, value = part.value;
        if (type === "literal") {
          return {
            literal: true,
            val: value
          };
        }
        var style2 = formatOpts[type];
        var val = partTypeStyleToTokenVal[type];
        if (typeof val === "object") {
          val = val[style2];
        }
        if (val) {
          return {
            literal: false,
            val
          };
        }
        return void 0;
      }
      function buildRegex(units) {
        var re = units.map(function(u3) {
          return u3.regex;
        }).reduce(function(f3, r3) {
          return f3 + "(" + r3.source + ")";
        }, "");
        return ["^" + re + "$", units];
      }
      function match(input, regex, handlers) {
        var matches = input.match(regex);
        if (matches) {
          var all = {};
          var matchIndex = 1;
          for (var i3 in handlers) {
            if (hasOwnProperty(handlers, i3)) {
              var h3 = handlers[i3], groups = h3.groups ? h3.groups + 1 : 1;
              if (!h3.literal && h3.token) {
                all[h3.token.val[0]] = h3.deser(matches.slice(matchIndex, matchIndex + groups));
              }
              matchIndex += groups;
            }
          }
          return [matches, all];
        } else {
          return [matches, {}];
        }
      }
      function dateTimeFromMatches(matches) {
        var toField = function toField2(token) {
          switch (token) {
            case "S":
              return "millisecond";
            case "s":
              return "second";
            case "m":
              return "minute";
            case "h":
            case "H":
              return "hour";
            case "d":
              return "day";
            case "o":
              return "ordinal";
            case "L":
            case "M":
              return "month";
            case "y":
              return "year";
            case "E":
            case "c":
              return "weekday";
            case "W":
              return "weekNumber";
            case "k":
              return "weekYear";
            case "q":
              return "quarter";
            default:
              return null;
          }
        };
        var zone;
        if (!isUndefined(matches.Z)) {
          zone = new FixedOffsetZone(matches.Z);
        } else if (!isUndefined(matches.z)) {
          zone = IANAZone.create(matches.z);
        } else {
          zone = null;
        }
        if (!isUndefined(matches.q)) {
          matches.M = (matches.q - 1) * 3 + 1;
        }
        if (!isUndefined(matches.h)) {
          if (matches.h < 12 && matches.a === 1) {
            matches.h += 12;
          } else if (matches.h === 12 && matches.a === 0) {
            matches.h = 0;
          }
        }
        if (matches.G === 0 && matches.y) {
          matches.y = -matches.y;
        }
        if (!isUndefined(matches.u)) {
          matches.S = parseMillis(matches.u);
        }
        var vals = Object.keys(matches).reduce(function(r3, k3) {
          var f3 = toField(k3);
          if (f3) {
            r3[f3] = matches[k3];
          }
          return r3;
        }, {});
        return [vals, zone];
      }
      var dummyDateTimeCache = null;
      function getDummyDateTime() {
        if (!dummyDateTimeCache) {
          dummyDateTimeCache = DateTime2.fromMillis(1555555555555);
        }
        return dummyDateTimeCache;
      }
      function maybeExpandMacroToken(token, locale) {
        if (token.literal) {
          return token;
        }
        var formatOpts = Formatter2.macroTokenToFormatOpts(token.val);
        if (!formatOpts) {
          return token;
        }
        var formatter = Formatter2.create(locale, formatOpts);
        var parts = formatter.formatDateTimeParts(getDummyDateTime());
        var tokens = parts.map(function(p3) {
          return tokenForPart(p3, locale, formatOpts);
        });
        if (tokens.includes(void 0)) {
          return token;
        }
        return tokens;
      }
      function expandMacroTokens(tokens, locale) {
        var _Array$prototype;
        return (_Array$prototype = Array.prototype).concat.apply(_Array$prototype, tokens.map(function(t3) {
          return maybeExpandMacroToken(t3, locale);
        }));
      }
      function explainFromTokens(locale, input, format) {
        var tokens = expandMacroTokens(Formatter2.parseFormat(format), locale), units = tokens.map(function(t3) {
          return unitForToken(t3, locale);
        }), disqualifyingUnit = units.find(function(t3) {
          return t3.invalidReason;
        });
        if (disqualifyingUnit) {
          return {
            input,
            tokens,
            invalidReason: disqualifyingUnit.invalidReason
          };
        } else {
          var _buildRegex = buildRegex(units), regexString = _buildRegex[0], handlers = _buildRegex[1], regex = RegExp(regexString, "i"), _match = match(input, regex, handlers), rawMatches = _match[0], matches = _match[1], _ref6 = matches ? dateTimeFromMatches(matches) : [null, null], result = _ref6[0], zone = _ref6[1];
          if (hasOwnProperty(matches, "a") && hasOwnProperty(matches, "H")) {
            throw new ConflictingSpecificationError("Can't include meridiem when specifying 24-hour format");
          }
          return {
            input,
            tokens,
            regex,
            rawMatches,
            matches,
            result,
            zone
          };
        }
      }
      function parseFromTokens(locale, input, format) {
        var _explainFromTokens = explainFromTokens(locale, input, format), result = _explainFromTokens.result, zone = _explainFromTokens.zone, invalidReason = _explainFromTokens.invalidReason;
        return [result, zone, invalidReason];
      }
      var nonLeapLadder = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
      var leapLadder = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
      function unitOutOfRange(unit, value) {
        return new Invalid("unit out of range", "you specified " + value + " (of type " + typeof value + ") as a " + unit + ", which is invalid");
      }
      function dayOfWeek(year, month, day) {
        var js = new Date(Date.UTC(year, month - 1, day)).getUTCDay();
        return js === 0 ? 7 : js;
      }
      function computeOrdinal(year, month, day) {
        return day + (isLeapYear(year) ? leapLadder : nonLeapLadder)[month - 1];
      }
      function uncomputeOrdinal(year, ordinal) {
        var table = isLeapYear(year) ? leapLadder : nonLeapLadder, month0 = table.findIndex(function(i3) {
          return i3 < ordinal;
        }), day = ordinal - table[month0];
        return {
          month: month0 + 1,
          day
        };
      }
      function gregorianToWeek(gregObj) {
        var year = gregObj.year, month = gregObj.month, day = gregObj.day, ordinal = computeOrdinal(year, month, day), weekday = dayOfWeek(year, month, day);
        var weekNumber = Math.floor((ordinal - weekday + 10) / 7), weekYear;
        if (weekNumber < 1) {
          weekYear = year - 1;
          weekNumber = weeksInWeekYear(weekYear);
        } else if (weekNumber > weeksInWeekYear(year)) {
          weekYear = year + 1;
          weekNumber = 1;
        } else {
          weekYear = year;
        }
        return _extends({
          weekYear,
          weekNumber,
          weekday
        }, timeObject(gregObj));
      }
      function weekToGregorian(weekData) {
        var weekYear = weekData.weekYear, weekNumber = weekData.weekNumber, weekday = weekData.weekday, weekdayOfJan4 = dayOfWeek(weekYear, 1, 4), yearInDays = daysInYear(weekYear);
        var ordinal = weekNumber * 7 + weekday - weekdayOfJan4 - 3, year;
        if (ordinal < 1) {
          year = weekYear - 1;
          ordinal += daysInYear(year);
        } else if (ordinal > yearInDays) {
          year = weekYear + 1;
          ordinal -= daysInYear(weekYear);
        } else {
          year = weekYear;
        }
        var _uncomputeOrdinal = uncomputeOrdinal(year, ordinal), month = _uncomputeOrdinal.month, day = _uncomputeOrdinal.day;
        return _extends({
          year,
          month,
          day
        }, timeObject(weekData));
      }
      function gregorianToOrdinal(gregData) {
        var year = gregData.year, month = gregData.month, day = gregData.day;
        var ordinal = computeOrdinal(year, month, day);
        return _extends({
          year,
          ordinal
        }, timeObject(gregData));
      }
      function ordinalToGregorian(ordinalData) {
        var year = ordinalData.year, ordinal = ordinalData.ordinal;
        var _uncomputeOrdinal2 = uncomputeOrdinal(year, ordinal), month = _uncomputeOrdinal2.month, day = _uncomputeOrdinal2.day;
        return _extends({
          year,
          month,
          day
        }, timeObject(ordinalData));
      }
      function hasInvalidWeekData(obj) {
        var validYear = isInteger(obj.weekYear), validWeek = integerBetween(obj.weekNumber, 1, weeksInWeekYear(obj.weekYear)), validWeekday = integerBetween(obj.weekday, 1, 7);
        if (!validYear) {
          return unitOutOfRange("weekYear", obj.weekYear);
        } else if (!validWeek) {
          return unitOutOfRange("week", obj.week);
        } else if (!validWeekday) {
          return unitOutOfRange("weekday", obj.weekday);
        } else
          return false;
      }
      function hasInvalidOrdinalData(obj) {
        var validYear = isInteger(obj.year), validOrdinal = integerBetween(obj.ordinal, 1, daysInYear(obj.year));
        if (!validYear) {
          return unitOutOfRange("year", obj.year);
        } else if (!validOrdinal) {
          return unitOutOfRange("ordinal", obj.ordinal);
        } else
          return false;
      }
      function hasInvalidGregorianData(obj) {
        var validYear = isInteger(obj.year), validMonth = integerBetween(obj.month, 1, 12), validDay = integerBetween(obj.day, 1, daysInMonth(obj.year, obj.month));
        if (!validYear) {
          return unitOutOfRange("year", obj.year);
        } else if (!validMonth) {
          return unitOutOfRange("month", obj.month);
        } else if (!validDay) {
          return unitOutOfRange("day", obj.day);
        } else
          return false;
      }
      function hasInvalidTimeData(obj) {
        var hour = obj.hour, minute = obj.minute, second = obj.second, millisecond = obj.millisecond;
        var validHour = integerBetween(hour, 0, 23) || hour === 24 && minute === 0 && second === 0 && millisecond === 0, validMinute = integerBetween(minute, 0, 59), validSecond = integerBetween(second, 0, 59), validMillisecond = integerBetween(millisecond, 0, 999);
        if (!validHour) {
          return unitOutOfRange("hour", hour);
        } else if (!validMinute) {
          return unitOutOfRange("minute", minute);
        } else if (!validSecond) {
          return unitOutOfRange("second", second);
        } else if (!validMillisecond) {
          return unitOutOfRange("millisecond", millisecond);
        } else
          return false;
      }
      var INVALID = "Invalid DateTime";
      var MAX_DATE = 864e13;
      function unsupportedZone(zone) {
        return new Invalid("unsupported zone", 'the zone "' + zone.name + '" is not supported');
      }
      function possiblyCachedWeekData(dt) {
        if (dt.weekData === null) {
          dt.weekData = gregorianToWeek(dt.c);
        }
        return dt.weekData;
      }
      function clone(inst, alts) {
        var current = {
          ts: inst.ts,
          zone: inst.zone,
          c: inst.c,
          o: inst.o,
          loc: inst.loc,
          invalid: inst.invalid
        };
        return new DateTime2(_extends({}, current, alts, {
          old: current
        }));
      }
      function fixOffset(localTS, o3, tz) {
        var utcGuess = localTS - o3 * 60 * 1e3;
        var o22 = tz.offset(utcGuess);
        if (o3 === o22) {
          return [utcGuess, o3];
        }
        utcGuess -= (o22 - o3) * 60 * 1e3;
        var o32 = tz.offset(utcGuess);
        if (o22 === o32) {
          return [utcGuess, o22];
        }
        return [localTS - Math.min(o22, o32) * 60 * 1e3, Math.max(o22, o32)];
      }
      function tsToObj(ts, offset2) {
        ts += offset2 * 60 * 1e3;
        var d3 = new Date(ts);
        return {
          year: d3.getUTCFullYear(),
          month: d3.getUTCMonth() + 1,
          day: d3.getUTCDate(),
          hour: d3.getUTCHours(),
          minute: d3.getUTCMinutes(),
          second: d3.getUTCSeconds(),
          millisecond: d3.getUTCMilliseconds()
        };
      }
      function objToTS(obj, offset2, zone) {
        return fixOffset(objToLocalTS(obj), offset2, zone);
      }
      function adjustTime(inst, dur) {
        var oPre = inst.o, year = inst.c.year + Math.trunc(dur.years), month = inst.c.month + Math.trunc(dur.months) + Math.trunc(dur.quarters) * 3, c3 = _extends({}, inst.c, {
          year,
          month,
          day: Math.min(inst.c.day, daysInMonth(year, month)) + Math.trunc(dur.days) + Math.trunc(dur.weeks) * 7
        }), millisToAdd = Duration.fromObject({
          years: dur.years - Math.trunc(dur.years),
          quarters: dur.quarters - Math.trunc(dur.quarters),
          months: dur.months - Math.trunc(dur.months),
          weeks: dur.weeks - Math.trunc(dur.weeks),
          days: dur.days - Math.trunc(dur.days),
          hours: dur.hours,
          minutes: dur.minutes,
          seconds: dur.seconds,
          milliseconds: dur.milliseconds
        }).as("milliseconds"), localTS = objToLocalTS(c3);
        var _fixOffset = fixOffset(localTS, oPre, inst.zone), ts = _fixOffset[0], o3 = _fixOffset[1];
        if (millisToAdd !== 0) {
          ts += millisToAdd;
          o3 = inst.zone.offset(ts);
        }
        return {
          ts,
          o: o3
        };
      }
      function parseDataToDateTime(parsed, parsedZone, opts, format, text) {
        var setZone = opts.setZone, zone = opts.zone;
        if (parsed && Object.keys(parsed).length !== 0) {
          var interpretationZone = parsedZone || zone, inst = DateTime2.fromObject(parsed, _extends({}, opts, {
            zone: interpretationZone,
            setZone: void 0
          }));
          return setZone ? inst : inst.setZone(zone);
        } else {
          return DateTime2.invalid(new Invalid("unparsable", 'the input "' + text + `" can't be parsed as ` + format));
        }
      }
      function toTechFormat(dt, format, allowZ) {
        if (allowZ === void 0) {
          allowZ = true;
        }
        return dt.isValid ? Formatter2.create(Locale.create("en-US"), {
          allowZ,
          forceSimple: true
        }).formatDateTimeFromString(dt, format) : null;
      }
      function toTechTimeFormat(dt, _ref) {
        var _ref$suppressSeconds = _ref.suppressSeconds, suppressSeconds = _ref$suppressSeconds === void 0 ? false : _ref$suppressSeconds, _ref$suppressMillisec = _ref.suppressMilliseconds, suppressMilliseconds = _ref$suppressMillisec === void 0 ? false : _ref$suppressMillisec, includeOffset = _ref.includeOffset, _ref$includePrefix = _ref.includePrefix, includePrefix = _ref$includePrefix === void 0 ? false : _ref$includePrefix, _ref$includeZone = _ref.includeZone, includeZone = _ref$includeZone === void 0 ? false : _ref$includeZone, _ref$spaceZone = _ref.spaceZone, spaceZone = _ref$spaceZone === void 0 ? false : _ref$spaceZone, _ref$format = _ref.format, format = _ref$format === void 0 ? "extended" : _ref$format;
        var fmt = format === "basic" ? "HHmm" : "HH:mm";
        if (!suppressSeconds || dt.second !== 0 || dt.millisecond !== 0) {
          fmt += format === "basic" ? "ss" : ":ss";
          if (!suppressMilliseconds || dt.millisecond !== 0) {
            fmt += ".SSS";
          }
        }
        if ((includeZone || includeOffset) && spaceZone) {
          fmt += " ";
        }
        if (includeZone) {
          fmt += "z";
        } else if (includeOffset) {
          fmt += format === "basic" ? "ZZZ" : "ZZ";
        }
        var str = toTechFormat(dt, fmt);
        if (includePrefix) {
          str = "T" + str;
        }
        return str;
      }
      var defaultUnitValues = {
        month: 1,
        day: 1,
        hour: 0,
        minute: 0,
        second: 0,
        millisecond: 0
      };
      var defaultWeekUnitValues = {
        weekNumber: 1,
        weekday: 1,
        hour: 0,
        minute: 0,
        second: 0,
        millisecond: 0
      };
      var defaultOrdinalUnitValues = {
        ordinal: 1,
        hour: 0,
        minute: 0,
        second: 0,
        millisecond: 0
      };
      var orderedUnits = ["year", "month", "day", "hour", "minute", "second", "millisecond"];
      var orderedWeekUnits = ["weekYear", "weekNumber", "weekday", "hour", "minute", "second", "millisecond"];
      var orderedOrdinalUnits = ["year", "ordinal", "hour", "minute", "second", "millisecond"];
      function normalizeUnit(unit) {
        var normalized = {
          year: "year",
          years: "year",
          month: "month",
          months: "month",
          day: "day",
          days: "day",
          hour: "hour",
          hours: "hour",
          minute: "minute",
          minutes: "minute",
          quarter: "quarter",
          quarters: "quarter",
          second: "second",
          seconds: "second",
          millisecond: "millisecond",
          milliseconds: "millisecond",
          weekday: "weekday",
          weekdays: "weekday",
          weeknumber: "weekNumber",
          weeksnumber: "weekNumber",
          weeknumbers: "weekNumber",
          weekyear: "weekYear",
          weekyears: "weekYear",
          ordinal: "ordinal"
        }[unit.toLowerCase()];
        if (!normalized)
          throw new InvalidUnitError(unit);
        return normalized;
      }
      function quickDT(obj, opts) {
        var zone = normalizeZone(opts.zone, Settings.defaultZone), loc = Locale.fromObject(opts), tsNow = Settings.now();
        var ts, o3;
        if (!isUndefined(obj.year)) {
          for (var _iterator = _createForOfIteratorHelperLoose(orderedUnits), _step; !(_step = _iterator()).done; ) {
            var u3 = _step.value;
            if (isUndefined(obj[u3])) {
              obj[u3] = defaultUnitValues[u3];
            }
          }
          var invalid = hasInvalidGregorianData(obj) || hasInvalidTimeData(obj);
          if (invalid) {
            return DateTime2.invalid(invalid);
          }
          var offsetProvis = zone.offset(tsNow);
          var _objToTS = objToTS(obj, offsetProvis, zone);
          ts = _objToTS[0];
          o3 = _objToTS[1];
        } else {
          ts = tsNow;
        }
        return new DateTime2({
          ts,
          zone,
          loc,
          o: o3
        });
      }
      function diffRelative(start, end, opts) {
        var round = isUndefined(opts.round) ? true : opts.round, format = function format2(c3, unit2) {
          c3 = roundTo(c3, round || opts.calendary ? 0 : 2, true);
          var formatter = end.loc.clone(opts).relFormatter(opts);
          return formatter.format(c3, unit2);
        }, differ = function differ2(unit2) {
          if (opts.calendary) {
            if (!end.hasSame(start, unit2)) {
              return end.startOf(unit2).diff(start.startOf(unit2), unit2).get(unit2);
            } else
              return 0;
          } else {
            return end.diff(start, unit2).get(unit2);
          }
        };
        if (opts.unit) {
          return format(differ(opts.unit), opts.unit);
        }
        for (var _iterator2 = _createForOfIteratorHelperLoose(opts.units), _step2; !(_step2 = _iterator2()).done; ) {
          var unit = _step2.value;
          var count = differ(unit);
          if (Math.abs(count) >= 1) {
            return format(count, unit);
          }
        }
        return format(start > end ? -0 : 0, opts.units[opts.units.length - 1]);
      }
      function lastOpts(argList) {
        var opts = {}, args;
        if (argList.length > 0 && typeof argList[argList.length - 1] === "object") {
          opts = argList[argList.length - 1];
          args = Array.from(argList).slice(0, argList.length - 1);
        } else {
          args = Array.from(argList);
        }
        return [opts, args];
      }
      var DateTime2 = /* @__PURE__ */ function() {
        function DateTime3(config) {
          var zone = config.zone || Settings.defaultZone;
          var invalid = config.invalid || (Number.isNaN(config.ts) ? new Invalid("invalid input") : null) || (!zone.isValid ? unsupportedZone(zone) : null);
          this.ts = isUndefined(config.ts) ? Settings.now() : config.ts;
          var c3 = null, o3 = null;
          if (!invalid) {
            var unchanged = config.old && config.old.ts === this.ts && config.old.zone.equals(zone);
            if (unchanged) {
              var _ref2 = [config.old.c, config.old.o];
              c3 = _ref2[0];
              o3 = _ref2[1];
            } else {
              var ot = zone.offset(this.ts);
              c3 = tsToObj(this.ts, ot);
              invalid = Number.isNaN(c3.year) ? new Invalid("invalid input") : null;
              c3 = invalid ? null : c3;
              o3 = invalid ? null : ot;
            }
          }
          this._zone = zone;
          this.loc = config.loc || Locale.create();
          this.invalid = invalid;
          this.weekData = null;
          this.c = c3;
          this.o = o3;
          this.isLuxonDateTime = true;
        }
        DateTime3.now = function now3() {
          return new DateTime3({});
        };
        DateTime3.local = function local() {
          var _lastOpts = lastOpts(arguments), opts = _lastOpts[0], args = _lastOpts[1], year = args[0], month = args[1], day = args[2], hour = args[3], minute = args[4], second = args[5], millisecond = args[6];
          return quickDT({
            year,
            month,
            day,
            hour,
            minute,
            second,
            millisecond
          }, opts);
        };
        DateTime3.utc = function utc() {
          var _lastOpts2 = lastOpts(arguments), opts = _lastOpts2[0], args = _lastOpts2[1], year = args[0], month = args[1], day = args[2], hour = args[3], minute = args[4], second = args[5], millisecond = args[6];
          opts.zone = FixedOffsetZone.utcInstance;
          return quickDT({
            year,
            month,
            day,
            hour,
            minute,
            second,
            millisecond
          }, opts);
        };
        DateTime3.fromJSDate = function fromJSDate(date, options) {
          if (options === void 0) {
            options = {};
          }
          var ts = isDate(date) ? date.valueOf() : NaN;
          if (Number.isNaN(ts)) {
            return DateTime3.invalid("invalid input");
          }
          var zoneToUse = normalizeZone(options.zone, Settings.defaultZone);
          if (!zoneToUse.isValid) {
            return DateTime3.invalid(unsupportedZone(zoneToUse));
          }
          return new DateTime3({
            ts,
            zone: zoneToUse,
            loc: Locale.fromObject(options)
          });
        };
        DateTime3.fromMillis = function fromMillis(milliseconds, options) {
          if (options === void 0) {
            options = {};
          }
          if (!isNumber(milliseconds)) {
            throw new InvalidArgumentError("fromMillis requires a numerical input, but received a " + typeof milliseconds + " with value " + milliseconds);
          } else if (milliseconds < -MAX_DATE || milliseconds > MAX_DATE) {
            return DateTime3.invalid("Timestamp out of range");
          } else {
            return new DateTime3({
              ts: milliseconds,
              zone: normalizeZone(options.zone, Settings.defaultZone),
              loc: Locale.fromObject(options)
            });
          }
        };
        DateTime3.fromSeconds = function fromSeconds(seconds, options) {
          if (options === void 0) {
            options = {};
          }
          if (!isNumber(seconds)) {
            throw new InvalidArgumentError("fromSeconds requires a numerical input");
          } else {
            return new DateTime3({
              ts: seconds * 1e3,
              zone: normalizeZone(options.zone, Settings.defaultZone),
              loc: Locale.fromObject(options)
            });
          }
        };
        DateTime3.fromObject = function fromObject(obj, opts) {
          if (opts === void 0) {
            opts = {};
          }
          obj = obj || {};
          var zoneToUse = normalizeZone(opts.zone, Settings.defaultZone);
          if (!zoneToUse.isValid) {
            return DateTime3.invalid(unsupportedZone(zoneToUse));
          }
          var tsNow = Settings.now(), offsetProvis = zoneToUse.offset(tsNow), normalized = normalizeObject(obj, normalizeUnit), containsOrdinal = !isUndefined(normalized.ordinal), containsGregorYear = !isUndefined(normalized.year), containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber, loc = Locale.fromObject(opts);
          if ((containsGregor || containsOrdinal) && definiteWeekDef) {
            throw new ConflictingSpecificationError("Can't mix weekYear/weekNumber units with year/month/day or ordinals");
          }
          if (containsGregorMD && containsOrdinal) {
            throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
          }
          var useWeekData = definiteWeekDef || normalized.weekday && !containsGregor;
          var units, defaultValues, objNow = tsToObj(tsNow, offsetProvis);
          if (useWeekData) {
            units = orderedWeekUnits;
            defaultValues = defaultWeekUnitValues;
            objNow = gregorianToWeek(objNow);
          } else if (containsOrdinal) {
            units = orderedOrdinalUnits;
            defaultValues = defaultOrdinalUnitValues;
            objNow = gregorianToOrdinal(objNow);
          } else {
            units = orderedUnits;
            defaultValues = defaultUnitValues;
          }
          var foundFirst = false;
          for (var _iterator3 = _createForOfIteratorHelperLoose(units), _step3; !(_step3 = _iterator3()).done; ) {
            var u3 = _step3.value;
            var v3 = normalized[u3];
            if (!isUndefined(v3)) {
              foundFirst = true;
            } else if (foundFirst) {
              normalized[u3] = defaultValues[u3];
            } else {
              normalized[u3] = objNow[u3];
            }
          }
          var higherOrderInvalid = useWeekData ? hasInvalidWeekData(normalized) : containsOrdinal ? hasInvalidOrdinalData(normalized) : hasInvalidGregorianData(normalized), invalid = higherOrderInvalid || hasInvalidTimeData(normalized);
          if (invalid) {
            return DateTime3.invalid(invalid);
          }
          var gregorian = useWeekData ? weekToGregorian(normalized) : containsOrdinal ? ordinalToGregorian(normalized) : normalized, _objToTS2 = objToTS(gregorian, offsetProvis, zoneToUse), tsFinal = _objToTS2[0], offsetFinal = _objToTS2[1], inst = new DateTime3({
            ts: tsFinal,
            zone: zoneToUse,
            o: offsetFinal,
            loc
          });
          if (normalized.weekday && containsGregor && obj.weekday !== inst.weekday) {
            return DateTime3.invalid("mismatched weekday", "you can't specify both a weekday of " + normalized.weekday + " and a date of " + inst.toISO());
          }
          return inst;
        };
        DateTime3.fromISO = function fromISO(text, opts) {
          if (opts === void 0) {
            opts = {};
          }
          var _parseISODate = parseISODate(text), vals = _parseISODate[0], parsedZone = _parseISODate[1];
          return parseDataToDateTime(vals, parsedZone, opts, "ISO 8601", text);
        };
        DateTime3.fromRFC2822 = function fromRFC2822(text, opts) {
          if (opts === void 0) {
            opts = {};
          }
          var _parseRFC2822Date = parseRFC2822Date(text), vals = _parseRFC2822Date[0], parsedZone = _parseRFC2822Date[1];
          return parseDataToDateTime(vals, parsedZone, opts, "RFC 2822", text);
        };
        DateTime3.fromHTTP = function fromHTTP(text, opts) {
          if (opts === void 0) {
            opts = {};
          }
          var _parseHTTPDate = parseHTTPDate(text), vals = _parseHTTPDate[0], parsedZone = _parseHTTPDate[1];
          return parseDataToDateTime(vals, parsedZone, opts, "HTTP", opts);
        };
        DateTime3.fromFormat = function fromFormat(text, fmt, opts) {
          if (opts === void 0) {
            opts = {};
          }
          if (isUndefined(text) || isUndefined(fmt)) {
            throw new InvalidArgumentError("fromFormat requires an input string and a format");
          }
          var _opts = opts, _opts$locale = _opts.locale, locale = _opts$locale === void 0 ? null : _opts$locale, _opts$numberingSystem = _opts.numberingSystem, numberingSystem = _opts$numberingSystem === void 0 ? null : _opts$numberingSystem, localeToUse = Locale.fromOpts({
            locale,
            numberingSystem,
            defaultToEN: true
          }), _parseFromTokens = parseFromTokens(localeToUse, text, fmt), vals = _parseFromTokens[0], parsedZone = _parseFromTokens[1], invalid = _parseFromTokens[2];
          if (invalid) {
            return DateTime3.invalid(invalid);
          } else {
            return parseDataToDateTime(vals, parsedZone, opts, "format " + fmt, text);
          }
        };
        DateTime3.fromString = function fromString(text, fmt, opts) {
          if (opts === void 0) {
            opts = {};
          }
          return DateTime3.fromFormat(text, fmt, opts);
        };
        DateTime3.fromSQL = function fromSQL(text, opts) {
          if (opts === void 0) {
            opts = {};
          }
          var _parseSQL = parseSQL(text), vals = _parseSQL[0], parsedZone = _parseSQL[1];
          return parseDataToDateTime(vals, parsedZone, opts, "SQL", text);
        };
        DateTime3.invalid = function invalid(reason, explanation) {
          if (explanation === void 0) {
            explanation = null;
          }
          if (!reason) {
            throw new InvalidArgumentError("need to specify a reason the DateTime is invalid");
          }
          var invalid2 = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
          if (Settings.throwOnInvalid) {
            throw new InvalidDateTimeError(invalid2);
          } else {
            return new DateTime3({
              invalid: invalid2
            });
          }
        };
        DateTime3.isDateTime = function isDateTime(o3) {
          return o3 && o3.isLuxonDateTime || false;
        };
        var _proto = DateTime3.prototype;
        _proto.get = function get(unit) {
          return this[unit];
        };
        _proto.resolvedLocaleOptions = function resolvedLocaleOptions(opts) {
          if (opts === void 0) {
            opts = {};
          }
          var _Formatter$create$res = Formatter2.create(this.loc.clone(opts), opts).resolvedOptions(this), locale = _Formatter$create$res.locale, numberingSystem = _Formatter$create$res.numberingSystem, calendar = _Formatter$create$res.calendar;
          return {
            locale,
            numberingSystem,
            outputCalendar: calendar
          };
        };
        _proto.toUTC = function toUTC(offset2, opts) {
          if (offset2 === void 0) {
            offset2 = 0;
          }
          if (opts === void 0) {
            opts = {};
          }
          return this.setZone(FixedOffsetZone.instance(offset2), opts);
        };
        _proto.toLocal = function toLocal() {
          return this.setZone(Settings.defaultZone);
        };
        _proto.setZone = function setZone(zone, _temp) {
          var _ref3 = _temp === void 0 ? {} : _temp, _ref3$keepLocalTime = _ref3.keepLocalTime, keepLocalTime = _ref3$keepLocalTime === void 0 ? false : _ref3$keepLocalTime, _ref3$keepCalendarTim = _ref3.keepCalendarTime, keepCalendarTime = _ref3$keepCalendarTim === void 0 ? false : _ref3$keepCalendarTim;
          zone = normalizeZone(zone, Settings.defaultZone);
          if (zone.equals(this.zone)) {
            return this;
          } else if (!zone.isValid) {
            return DateTime3.invalid(unsupportedZone(zone));
          } else {
            var newTS = this.ts;
            if (keepLocalTime || keepCalendarTime) {
              var offsetGuess = zone.offset(this.ts);
              var asObj = this.toObject();
              var _objToTS3 = objToTS(asObj, offsetGuess, zone);
              newTS = _objToTS3[0];
            }
            return clone(this, {
              ts: newTS,
              zone
            });
          }
        };
        _proto.reconfigure = function reconfigure(_temp2) {
          var _ref4 = _temp2 === void 0 ? {} : _temp2, locale = _ref4.locale, numberingSystem = _ref4.numberingSystem, outputCalendar = _ref4.outputCalendar;
          var loc = this.loc.clone({
            locale,
            numberingSystem,
            outputCalendar
          });
          return clone(this, {
            loc
          });
        };
        _proto.setLocale = function setLocale(locale) {
          return this.reconfigure({
            locale
          });
        };
        _proto.set = function set(values) {
          if (!this.isValid)
            return this;
          var normalized = normalizeObject(values, normalizeUnit), settingWeekStuff = !isUndefined(normalized.weekYear) || !isUndefined(normalized.weekNumber) || !isUndefined(normalized.weekday), containsOrdinal = !isUndefined(normalized.ordinal), containsGregorYear = !isUndefined(normalized.year), containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber;
          if ((containsGregor || containsOrdinal) && definiteWeekDef) {
            throw new ConflictingSpecificationError("Can't mix weekYear/weekNumber units with year/month/day or ordinals");
          }
          if (containsGregorMD && containsOrdinal) {
            throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
          }
          var mixed;
          if (settingWeekStuff) {
            mixed = weekToGregorian(_extends({}, gregorianToWeek(this.c), normalized));
          } else if (!isUndefined(normalized.ordinal)) {
            mixed = ordinalToGregorian(_extends({}, gregorianToOrdinal(this.c), normalized));
          } else {
            mixed = _extends({}, this.toObject(), normalized);
            if (isUndefined(normalized.day)) {
              mixed.day = Math.min(daysInMonth(mixed.year, mixed.month), mixed.day);
            }
          }
          var _objToTS4 = objToTS(mixed, this.o, this.zone), ts = _objToTS4[0], o3 = _objToTS4[1];
          return clone(this, {
            ts,
            o: o3
          });
        };
        _proto.plus = function plus(duration) {
          if (!this.isValid)
            return this;
          var dur = friendlyDuration(duration);
          return clone(this, adjustTime(this, dur));
        };
        _proto.minus = function minus(duration) {
          if (!this.isValid)
            return this;
          var dur = friendlyDuration(duration).negate();
          return clone(this, adjustTime(this, dur));
        };
        _proto.startOf = function startOf(unit) {
          if (!this.isValid)
            return this;
          var o3 = {}, normalizedUnit = Duration.normalizeUnit(unit);
          switch (normalizedUnit) {
            case "years":
              o3.month = 1;
            case "quarters":
            case "months":
              o3.day = 1;
            case "weeks":
            case "days":
              o3.hour = 0;
            case "hours":
              o3.minute = 0;
            case "minutes":
              o3.second = 0;
            case "seconds":
              o3.millisecond = 0;
              break;
          }
          if (normalizedUnit === "weeks") {
            o3.weekday = 1;
          }
          if (normalizedUnit === "quarters") {
            var q3 = Math.ceil(this.month / 3);
            o3.month = (q3 - 1) * 3 + 1;
          }
          return this.set(o3);
        };
        _proto.endOf = function endOf(unit) {
          var _this$plus;
          return this.isValid ? this.plus((_this$plus = {}, _this$plus[unit] = 1, _this$plus)).startOf(unit).minus(1) : this;
        };
        _proto.toFormat = function toFormat(fmt, opts) {
          if (opts === void 0) {
            opts = {};
          }
          return this.isValid ? Formatter2.create(this.loc.redefaultToEN(opts)).formatDateTimeFromString(this, fmt) : INVALID;
        };
        _proto.toLocaleString = function toLocaleString(formatOpts, opts) {
          if (formatOpts === void 0) {
            formatOpts = DATE_SHORT;
          }
          if (opts === void 0) {
            opts = {};
          }
          return this.isValid ? Formatter2.create(this.loc.clone(opts), formatOpts).formatDateTime(this) : INVALID;
        };
        _proto.toLocaleParts = function toLocaleParts(opts) {
          if (opts === void 0) {
            opts = {};
          }
          return this.isValid ? Formatter2.create(this.loc.clone(opts), opts).formatDateTimeParts(this) : [];
        };
        _proto.toISO = function toISO(opts) {
          if (opts === void 0) {
            opts = {};
          }
          if (!this.isValid) {
            return null;
          }
          return this.toISODate(opts) + "T" + this.toISOTime(opts);
        };
        _proto.toISODate = function toISODate(_temp3) {
          var _ref5 = _temp3 === void 0 ? {} : _temp3, _ref5$format = _ref5.format, format = _ref5$format === void 0 ? "extended" : _ref5$format;
          var fmt = format === "basic" ? "yyyyMMdd" : "yyyy-MM-dd";
          if (this.year > 9999) {
            fmt = "+" + fmt;
          }
          return toTechFormat(this, fmt);
        };
        _proto.toISOWeekDate = function toISOWeekDate() {
          return toTechFormat(this, "kkkk-'W'WW-c");
        };
        _proto.toISOTime = function toISOTime(_temp4) {
          var _ref6 = _temp4 === void 0 ? {} : _temp4, _ref6$suppressMillise = _ref6.suppressMilliseconds, suppressMilliseconds = _ref6$suppressMillise === void 0 ? false : _ref6$suppressMillise, _ref6$suppressSeconds = _ref6.suppressSeconds, suppressSeconds = _ref6$suppressSeconds === void 0 ? false : _ref6$suppressSeconds, _ref6$includeOffset = _ref6.includeOffset, includeOffset = _ref6$includeOffset === void 0 ? true : _ref6$includeOffset, _ref6$includePrefix = _ref6.includePrefix, includePrefix = _ref6$includePrefix === void 0 ? false : _ref6$includePrefix, _ref6$format = _ref6.format, format = _ref6$format === void 0 ? "extended" : _ref6$format;
          return toTechTimeFormat(this, {
            suppressSeconds,
            suppressMilliseconds,
            includeOffset,
            includePrefix,
            format
          });
        };
        _proto.toRFC2822 = function toRFC2822() {
          return toTechFormat(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", false);
        };
        _proto.toHTTP = function toHTTP() {
          return toTechFormat(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'");
        };
        _proto.toSQLDate = function toSQLDate() {
          return toTechFormat(this, "yyyy-MM-dd");
        };
        _proto.toSQLTime = function toSQLTime(_temp5) {
          var _ref7 = _temp5 === void 0 ? {} : _temp5, _ref7$includeOffset = _ref7.includeOffset, includeOffset = _ref7$includeOffset === void 0 ? true : _ref7$includeOffset, _ref7$includeZone = _ref7.includeZone, includeZone = _ref7$includeZone === void 0 ? false : _ref7$includeZone;
          return toTechTimeFormat(this, {
            includeOffset,
            includeZone,
            spaceZone: true
          });
        };
        _proto.toSQL = function toSQL(opts) {
          if (opts === void 0) {
            opts = {};
          }
          if (!this.isValid) {
            return null;
          }
          return this.toSQLDate() + " " + this.toSQLTime(opts);
        };
        _proto.toString = function toString() {
          return this.isValid ? this.toISO() : INVALID;
        };
        _proto.valueOf = function valueOf() {
          return this.toMillis();
        };
        _proto.toMillis = function toMillis() {
          return this.isValid ? this.ts : NaN;
        };
        _proto.toSeconds = function toSeconds() {
          return this.isValid ? this.ts / 1e3 : NaN;
        };
        _proto.toJSON = function toJSON2() {
          return this.toISO();
        };
        _proto.toBSON = function toBSON() {
          return this.toJSDate();
        };
        _proto.toObject = function toObject(opts) {
          if (opts === void 0) {
            opts = {};
          }
          if (!this.isValid)
            return {};
          var base2 = _extends({}, this.c);
          if (opts.includeConfig) {
            base2.outputCalendar = this.outputCalendar;
            base2.numberingSystem = this.loc.numberingSystem;
            base2.locale = this.loc.locale;
          }
          return base2;
        };
        _proto.toJSDate = function toJSDate() {
          return new Date(this.isValid ? this.ts : NaN);
        };
        _proto.diff = function diff(otherDateTime, unit, opts) {
          if (unit === void 0) {
            unit = "milliseconds";
          }
          if (opts === void 0) {
            opts = {};
          }
          if (!this.isValid || !otherDateTime.isValid) {
            return Duration.invalid("created by diffing an invalid DateTime");
          }
          var durOpts = _extends({
            locale: this.locale,
            numberingSystem: this.numberingSystem
          }, opts);
          var units = maybeArray(unit).map(Duration.normalizeUnit), otherIsLater = otherDateTime.valueOf() > this.valueOf(), earlier = otherIsLater ? this : otherDateTime, later = otherIsLater ? otherDateTime : this, diffed = _diff(earlier, later, units, durOpts);
          return otherIsLater ? diffed.negate() : diffed;
        };
        _proto.diffNow = function diffNow(unit, opts) {
          if (unit === void 0) {
            unit = "milliseconds";
          }
          if (opts === void 0) {
            opts = {};
          }
          return this.diff(DateTime3.now(), unit, opts);
        };
        _proto.until = function until(otherDateTime) {
          return this.isValid ? Interval.fromDateTimes(this, otherDateTime) : this;
        };
        _proto.hasSame = function hasSame(otherDateTime, unit) {
          if (!this.isValid)
            return false;
          var inputMs = otherDateTime.valueOf();
          var otherZoneDateTime = this.setZone(otherDateTime.zone, {
            keepLocalTime: true
          });
          return otherZoneDateTime.startOf(unit) <= inputMs && inputMs <= otherZoneDateTime.endOf(unit);
        };
        _proto.equals = function equals(other) {
          return this.isValid && other.isValid && this.valueOf() === other.valueOf() && this.zone.equals(other.zone) && this.loc.equals(other.loc);
        };
        _proto.toRelative = function toRelative(options) {
          if (options === void 0) {
            options = {};
          }
          if (!this.isValid)
            return null;
          var base2 = options.base || DateTime3.fromObject({}, {
            zone: this.zone
          }), padding2 = options.padding ? this < base2 ? -options.padding : options.padding : 0;
          var units = ["years", "months", "days", "hours", "minutes", "seconds"];
          var unit = options.unit;
          if (Array.isArray(options.unit)) {
            units = options.unit;
            unit = void 0;
          }
          return diffRelative(base2, this.plus(padding2), _extends({}, options, {
            numeric: "always",
            units,
            unit
          }));
        };
        _proto.toRelativeCalendar = function toRelativeCalendar(options) {
          if (options === void 0) {
            options = {};
          }
          if (!this.isValid)
            return null;
          return diffRelative(options.base || DateTime3.fromObject({}, {
            zone: this.zone
          }), this, _extends({}, options, {
            numeric: "auto",
            units: ["years", "months", "days"],
            calendary: true
          }));
        };
        DateTime3.min = function min() {
          for (var _len = arguments.length, dateTimes = new Array(_len), _key = 0; _key < _len; _key++) {
            dateTimes[_key] = arguments[_key];
          }
          if (!dateTimes.every(DateTime3.isDateTime)) {
            throw new InvalidArgumentError("min requires all arguments be DateTimes");
          }
          return bestBy(dateTimes, function(i3) {
            return i3.valueOf();
          }, Math.min);
        };
        DateTime3.max = function max() {
          for (var _len2 = arguments.length, dateTimes = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            dateTimes[_key2] = arguments[_key2];
          }
          if (!dateTimes.every(DateTime3.isDateTime)) {
            throw new InvalidArgumentError("max requires all arguments be DateTimes");
          }
          return bestBy(dateTimes, function(i3) {
            return i3.valueOf();
          }, Math.max);
        };
        DateTime3.fromFormatExplain = function fromFormatExplain(text, fmt, options) {
          if (options === void 0) {
            options = {};
          }
          var _options = options, _options$locale = _options.locale, locale = _options$locale === void 0 ? null : _options$locale, _options$numberingSys = _options.numberingSystem, numberingSystem = _options$numberingSys === void 0 ? null : _options$numberingSys, localeToUse = Locale.fromOpts({
            locale,
            numberingSystem,
            defaultToEN: true
          });
          return explainFromTokens(localeToUse, text, fmt);
        };
        DateTime3.fromStringExplain = function fromStringExplain(text, fmt, options) {
          if (options === void 0) {
            options = {};
          }
          return DateTime3.fromFormatExplain(text, fmt, options);
        };
        _createClass(DateTime3, [{
          key: "isValid",
          get: function get() {
            return this.invalid === null;
          }
        }, {
          key: "invalidReason",
          get: function get() {
            return this.invalid ? this.invalid.reason : null;
          }
        }, {
          key: "invalidExplanation",
          get: function get() {
            return this.invalid ? this.invalid.explanation : null;
          }
        }, {
          key: "locale",
          get: function get() {
            return this.isValid ? this.loc.locale : null;
          }
        }, {
          key: "numberingSystem",
          get: function get() {
            return this.isValid ? this.loc.numberingSystem : null;
          }
        }, {
          key: "outputCalendar",
          get: function get() {
            return this.isValid ? this.loc.outputCalendar : null;
          }
        }, {
          key: "zone",
          get: function get() {
            return this._zone;
          }
        }, {
          key: "zoneName",
          get: function get() {
            return this.isValid ? this.zone.name : null;
          }
        }, {
          key: "year",
          get: function get() {
            return this.isValid ? this.c.year : NaN;
          }
        }, {
          key: "quarter",
          get: function get() {
            return this.isValid ? Math.ceil(this.c.month / 3) : NaN;
          }
        }, {
          key: "month",
          get: function get() {
            return this.isValid ? this.c.month : NaN;
          }
        }, {
          key: "day",
          get: function get() {
            return this.isValid ? this.c.day : NaN;
          }
        }, {
          key: "hour",
          get: function get() {
            return this.isValid ? this.c.hour : NaN;
          }
        }, {
          key: "minute",
          get: function get() {
            return this.isValid ? this.c.minute : NaN;
          }
        }, {
          key: "second",
          get: function get() {
            return this.isValid ? this.c.second : NaN;
          }
        }, {
          key: "millisecond",
          get: function get() {
            return this.isValid ? this.c.millisecond : NaN;
          }
        }, {
          key: "weekYear",
          get: function get() {
            return this.isValid ? possiblyCachedWeekData(this).weekYear : NaN;
          }
        }, {
          key: "weekNumber",
          get: function get() {
            return this.isValid ? possiblyCachedWeekData(this).weekNumber : NaN;
          }
        }, {
          key: "weekday",
          get: function get() {
            return this.isValid ? possiblyCachedWeekData(this).weekday : NaN;
          }
        }, {
          key: "ordinal",
          get: function get() {
            return this.isValid ? gregorianToOrdinal(this.c).ordinal : NaN;
          }
        }, {
          key: "monthShort",
          get: function get() {
            return this.isValid ? Info.months("short", {
              locObj: this.loc
            })[this.month - 1] : null;
          }
        }, {
          key: "monthLong",
          get: function get() {
            return this.isValid ? Info.months("long", {
              locObj: this.loc
            })[this.month - 1] : null;
          }
        }, {
          key: "weekdayShort",
          get: function get() {
            return this.isValid ? Info.weekdays("short", {
              locObj: this.loc
            })[this.weekday - 1] : null;
          }
        }, {
          key: "weekdayLong",
          get: function get() {
            return this.isValid ? Info.weekdays("long", {
              locObj: this.loc
            })[this.weekday - 1] : null;
          }
        }, {
          key: "offset",
          get: function get() {
            return this.isValid ? +this.o : NaN;
          }
        }, {
          key: "offsetNameShort",
          get: function get() {
            if (this.isValid) {
              return this.zone.offsetName(this.ts, {
                format: "short",
                locale: this.locale
              });
            } else {
              return null;
            }
          }
        }, {
          key: "offsetNameLong",
          get: function get() {
            if (this.isValid) {
              return this.zone.offsetName(this.ts, {
                format: "long",
                locale: this.locale
              });
            } else {
              return null;
            }
          }
        }, {
          key: "isOffsetFixed",
          get: function get() {
            return this.isValid ? this.zone.isUniversal : null;
          }
        }, {
          key: "isInDST",
          get: function get() {
            if (this.isOffsetFixed) {
              return false;
            } else {
              return this.offset > this.set({
                month: 1
              }).offset || this.offset > this.set({
                month: 5
              }).offset;
            }
          }
        }, {
          key: "isInLeapYear",
          get: function get() {
            return isLeapYear(this.year);
          }
        }, {
          key: "daysInMonth",
          get: function get() {
            return daysInMonth(this.year, this.month);
          }
        }, {
          key: "daysInYear",
          get: function get() {
            return this.isValid ? daysInYear(this.year) : NaN;
          }
        }, {
          key: "weeksInWeekYear",
          get: function get() {
            return this.isValid ? weeksInWeekYear(this.weekYear) : NaN;
          }
        }], [{
          key: "DATE_SHORT",
          get: function get() {
            return DATE_SHORT;
          }
        }, {
          key: "DATE_MED",
          get: function get() {
            return DATE_MED;
          }
        }, {
          key: "DATE_MED_WITH_WEEKDAY",
          get: function get() {
            return DATE_MED_WITH_WEEKDAY;
          }
        }, {
          key: "DATE_FULL",
          get: function get() {
            return DATE_FULL;
          }
        }, {
          key: "DATE_HUGE",
          get: function get() {
            return DATE_HUGE;
          }
        }, {
          key: "TIME_SIMPLE",
          get: function get() {
            return TIME_SIMPLE;
          }
        }, {
          key: "TIME_WITH_SECONDS",
          get: function get() {
            return TIME_WITH_SECONDS;
          }
        }, {
          key: "TIME_WITH_SHORT_OFFSET",
          get: function get() {
            return TIME_WITH_SHORT_OFFSET;
          }
        }, {
          key: "TIME_WITH_LONG_OFFSET",
          get: function get() {
            return TIME_WITH_LONG_OFFSET;
          }
        }, {
          key: "TIME_24_SIMPLE",
          get: function get() {
            return TIME_24_SIMPLE;
          }
        }, {
          key: "TIME_24_WITH_SECONDS",
          get: function get() {
            return TIME_24_WITH_SECONDS;
          }
        }, {
          key: "TIME_24_WITH_SHORT_OFFSET",
          get: function get() {
            return TIME_24_WITH_SHORT_OFFSET;
          }
        }, {
          key: "TIME_24_WITH_LONG_OFFSET",
          get: function get() {
            return TIME_24_WITH_LONG_OFFSET;
          }
        }, {
          key: "DATETIME_SHORT",
          get: function get() {
            return DATETIME_SHORT;
          }
        }, {
          key: "DATETIME_SHORT_WITH_SECONDS",
          get: function get() {
            return DATETIME_SHORT_WITH_SECONDS;
          }
        }, {
          key: "DATETIME_MED",
          get: function get() {
            return DATETIME_MED;
          }
        }, {
          key: "DATETIME_MED_WITH_SECONDS",
          get: function get() {
            return DATETIME_MED_WITH_SECONDS;
          }
        }, {
          key: "DATETIME_MED_WITH_WEEKDAY",
          get: function get() {
            return DATETIME_MED_WITH_WEEKDAY;
          }
        }, {
          key: "DATETIME_FULL",
          get: function get() {
            return DATETIME_FULL;
          }
        }, {
          key: "DATETIME_FULL_WITH_SECONDS",
          get: function get() {
            return DATETIME_FULL_WITH_SECONDS;
          }
        }, {
          key: "DATETIME_HUGE",
          get: function get() {
            return DATETIME_HUGE;
          }
        }, {
          key: "DATETIME_HUGE_WITH_SECONDS",
          get: function get() {
            return DATETIME_HUGE_WITH_SECONDS;
          }
        }]);
        return DateTime3;
      }();
      function friendlyDateTime(dateTimeish) {
        if (DateTime2.isDateTime(dateTimeish)) {
          return dateTimeish;
        } else if (dateTimeish && dateTimeish.valueOf && isNumber(dateTimeish.valueOf())) {
          return DateTime2.fromJSDate(dateTimeish);
        } else if (dateTimeish && typeof dateTimeish === "object") {
          return DateTime2.fromObject(dateTimeish);
        } else {
          throw new InvalidArgumentError("Unknown datetime argument: " + dateTimeish + ", of type " + typeof dateTimeish);
        }
      }
      var VERSION = "2.0.1";
      exports.DateTime = DateTime2;
      exports.Duration = Duration;
      exports.FixedOffsetZone = FixedOffsetZone;
      exports.IANAZone = IANAZone;
      exports.Info = Info;
      exports.Interval = Interval;
      exports.InvalidZone = InvalidZone;
      exports.Settings = Settings;
      exports.SystemZone = SystemZone;
      exports.VERSION = VERSION;
      exports.Zone = Zone;
    }
  });

  // (disabled):node_modules/buffer/index.js
  var require_buffer = __commonJS({
    "(disabled):node_modules/buffer/index.js"() {
    }
  });

  // node_modules/bn.js/lib/bn.js
  var require_bn = __commonJS({
    "node_modules/bn.js/lib/bn.js"(exports, module) {
      (function(module2, exports2) {
        "use strict";
        function assert3(val, msg) {
          if (!val)
            throw new Error(msg || "Assertion failed");
        }
        function inherits(ctor, superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
        function BN4(number, base2, endian) {
          if (BN4.isBN(number)) {
            return number;
          }
          this.negative = 0;
          this.words = null;
          this.length = 0;
          this.red = null;
          if (number !== null) {
            if (base2 === "le" || base2 === "be") {
              endian = base2;
              base2 = 10;
            }
            this._init(number || 0, base2 || 10, endian || "be");
          }
        }
        if (typeof module2 === "object") {
          module2.exports = BN4;
        } else {
          exports2.BN = BN4;
        }
        BN4.BN = BN4;
        BN4.wordSize = 26;
        var Buffer2;
        try {
          if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
            Buffer2 = window.Buffer;
          } else {
            Buffer2 = require_buffer().Buffer;
          }
        } catch (e3) {
        }
        BN4.isBN = function isBN(num) {
          if (num instanceof BN4) {
            return true;
          }
          return num !== null && typeof num === "object" && num.constructor.wordSize === BN4.wordSize && Array.isArray(num.words);
        };
        BN4.max = function max(left, right) {
          if (left.cmp(right) > 0)
            return left;
          return right;
        };
        BN4.min = function min(left, right) {
          if (left.cmp(right) < 0)
            return left;
          return right;
        };
        BN4.prototype._init = function init2(number, base2, endian) {
          if (typeof number === "number") {
            return this._initNumber(number, base2, endian);
          }
          if (typeof number === "object") {
            return this._initArray(number, base2, endian);
          }
          if (base2 === "hex") {
            base2 = 16;
          }
          assert3(base2 === (base2 | 0) && base2 >= 2 && base2 <= 36);
          number = number.toString().replace(/\s+/g, "");
          var start = 0;
          if (number[0] === "-") {
            start++;
            this.negative = 1;
          }
          if (start < number.length) {
            if (base2 === 16) {
              this._parseHex(number, start, endian);
            } else {
              this._parseBase(number, base2, start);
              if (endian === "le") {
                this._initArray(this.toArray(), base2, endian);
              }
            }
          }
        };
        BN4.prototype._initNumber = function _initNumber(number, base2, endian) {
          if (number < 0) {
            this.negative = 1;
            number = -number;
          }
          if (number < 67108864) {
            this.words = [number & 67108863];
            this.length = 1;
          } else if (number < 4503599627370496) {
            this.words = [
              number & 67108863,
              number / 67108864 & 67108863
            ];
            this.length = 2;
          } else {
            assert3(number < 9007199254740992);
            this.words = [
              number & 67108863,
              number / 67108864 & 67108863,
              1
            ];
            this.length = 3;
          }
          if (endian !== "le")
            return;
          this._initArray(this.toArray(), base2, endian);
        };
        BN4.prototype._initArray = function _initArray(number, base2, endian) {
          assert3(typeof number.length === "number");
          if (number.length <= 0) {
            this.words = [0];
            this.length = 1;
            return this;
          }
          this.length = Math.ceil(number.length / 3);
          this.words = new Array(this.length);
          for (var i3 = 0; i3 < this.length; i3++) {
            this.words[i3] = 0;
          }
          var j3, w4;
          var off = 0;
          if (endian === "be") {
            for (i3 = number.length - 1, j3 = 0; i3 >= 0; i3 -= 3) {
              w4 = number[i3] | number[i3 - 1] << 8 | number[i3 - 2] << 16;
              this.words[j3] |= w4 << off & 67108863;
              this.words[j3 + 1] = w4 >>> 26 - off & 67108863;
              off += 24;
              if (off >= 26) {
                off -= 26;
                j3++;
              }
            }
          } else if (endian === "le") {
            for (i3 = 0, j3 = 0; i3 < number.length; i3 += 3) {
              w4 = number[i3] | number[i3 + 1] << 8 | number[i3 + 2] << 16;
              this.words[j3] |= w4 << off & 67108863;
              this.words[j3 + 1] = w4 >>> 26 - off & 67108863;
              off += 24;
              if (off >= 26) {
                off -= 26;
                j3++;
              }
            }
          }
          return this.strip();
        };
        function parseHex4Bits(string, index) {
          var c3 = string.charCodeAt(index);
          if (c3 >= 65 && c3 <= 70) {
            return c3 - 55;
          } else if (c3 >= 97 && c3 <= 102) {
            return c3 - 87;
          } else {
            return c3 - 48 & 15;
          }
        }
        function parseHexByte(string, lowerBound, index) {
          var r3 = parseHex4Bits(string, index);
          if (index - 1 >= lowerBound) {
            r3 |= parseHex4Bits(string, index - 1) << 4;
          }
          return r3;
        }
        BN4.prototype._parseHex = function _parseHex(number, start, endian) {
          this.length = Math.ceil((number.length - start) / 6);
          this.words = new Array(this.length);
          for (var i3 = 0; i3 < this.length; i3++) {
            this.words[i3] = 0;
          }
          var off = 0;
          var j3 = 0;
          var w4;
          if (endian === "be") {
            for (i3 = number.length - 1; i3 >= start; i3 -= 2) {
              w4 = parseHexByte(number, start, i3) << off;
              this.words[j3] |= w4 & 67108863;
              if (off >= 18) {
                off -= 18;
                j3 += 1;
                this.words[j3] |= w4 >>> 26;
              } else {
                off += 8;
              }
            }
          } else {
            var parseLength = number.length - start;
            for (i3 = parseLength % 2 === 0 ? start + 1 : start; i3 < number.length; i3 += 2) {
              w4 = parseHexByte(number, start, i3) << off;
              this.words[j3] |= w4 & 67108863;
              if (off >= 18) {
                off -= 18;
                j3 += 1;
                this.words[j3] |= w4 >>> 26;
              } else {
                off += 8;
              }
            }
          }
          this.strip();
        };
        function parseBase(str, start, end, mul3) {
          var r3 = 0;
          var len = Math.min(str.length, end);
          for (var i3 = start; i3 < len; i3++) {
            var c3 = str.charCodeAt(i3) - 48;
            r3 *= mul3;
            if (c3 >= 49) {
              r3 += c3 - 49 + 10;
            } else if (c3 >= 17) {
              r3 += c3 - 17 + 10;
            } else {
              r3 += c3;
            }
          }
          return r3;
        }
        BN4.prototype._parseBase = function _parseBase(number, base2, start) {
          this.words = [0];
          this.length = 1;
          for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base2) {
            limbLen++;
          }
          limbLen--;
          limbPow = limbPow / base2 | 0;
          var total = number.length - start;
          var mod = total % limbLen;
          var end = Math.min(total, total - mod) + start;
          var word = 0;
          for (var i3 = start; i3 < end; i3 += limbLen) {
            word = parseBase(number, i3, i3 + limbLen, base2);
            this.imuln(limbPow);
            if (this.words[0] + word < 67108864) {
              this.words[0] += word;
            } else {
              this._iaddn(word);
            }
          }
          if (mod !== 0) {
            var pow = 1;
            word = parseBase(number, i3, number.length, base2);
            for (i3 = 0; i3 < mod; i3++) {
              pow *= base2;
            }
            this.imuln(pow);
            if (this.words[0] + word < 67108864) {
              this.words[0] += word;
            } else {
              this._iaddn(word);
            }
          }
          this.strip();
        };
        BN4.prototype.copy = function copy(dest) {
          dest.words = new Array(this.length);
          for (var i3 = 0; i3 < this.length; i3++) {
            dest.words[i3] = this.words[i3];
          }
          dest.length = this.length;
          dest.negative = this.negative;
          dest.red = this.red;
        };
        BN4.prototype.clone = function clone() {
          var r3 = new BN4(null);
          this.copy(r3);
          return r3;
        };
        BN4.prototype._expand = function _expand(size) {
          while (this.length < size) {
            this.words[this.length++] = 0;
          }
          return this;
        };
        BN4.prototype.strip = function strip() {
          while (this.length > 1 && this.words[this.length - 1] === 0) {
            this.length--;
          }
          return this._normSign();
        };
        BN4.prototype._normSign = function _normSign() {
          if (this.length === 1 && this.words[0] === 0) {
            this.negative = 0;
          }
          return this;
        };
        BN4.prototype.inspect = function inspect4() {
          return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
        };
        var zeros2 = [
          "",
          "0",
          "00",
          "000",
          "0000",
          "00000",
          "000000",
          "0000000",
          "00000000",
          "000000000",
          "0000000000",
          "00000000000",
          "000000000000",
          "0000000000000",
          "00000000000000",
          "000000000000000",
          "0000000000000000",
          "00000000000000000",
          "000000000000000000",
          "0000000000000000000",
          "00000000000000000000",
          "000000000000000000000",
          "0000000000000000000000",
          "00000000000000000000000",
          "000000000000000000000000",
          "0000000000000000000000000"
        ];
        var groupSizes = [
          0,
          0,
          25,
          16,
          12,
          11,
          10,
          9,
          8,
          8,
          7,
          7,
          7,
          7,
          6,
          6,
          6,
          6,
          6,
          6,
          6,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5
        ];
        var groupBases = [
          0,
          0,
          33554432,
          43046721,
          16777216,
          48828125,
          60466176,
          40353607,
          16777216,
          43046721,
          1e7,
          19487171,
          35831808,
          62748517,
          7529536,
          11390625,
          16777216,
          24137569,
          34012224,
          47045881,
          64e6,
          4084101,
          5153632,
          6436343,
          7962624,
          9765625,
          11881376,
          14348907,
          17210368,
          20511149,
          243e5,
          28629151,
          33554432,
          39135393,
          45435424,
          52521875,
          60466176
        ];
        BN4.prototype.toString = function toString(base2, padding2) {
          base2 = base2 || 10;
          padding2 = padding2 | 0 || 1;
          var out;
          if (base2 === 16 || base2 === "hex") {
            out = "";
            var off = 0;
            var carry = 0;
            for (var i3 = 0; i3 < this.length; i3++) {
              var w4 = this.words[i3];
              var word = ((w4 << off | carry) & 16777215).toString(16);
              carry = w4 >>> 24 - off & 16777215;
              if (carry !== 0 || i3 !== this.length - 1) {
                out = zeros2[6 - word.length] + word + out;
              } else {
                out = word + out;
              }
              off += 2;
              if (off >= 26) {
                off -= 26;
                i3--;
              }
            }
            if (carry !== 0) {
              out = carry.toString(16) + out;
            }
            while (out.length % padding2 !== 0) {
              out = "0" + out;
            }
            if (this.negative !== 0) {
              out = "-" + out;
            }
            return out;
          }
          if (base2 === (base2 | 0) && base2 >= 2 && base2 <= 36) {
            var groupSize = groupSizes[base2];
            var groupBase = groupBases[base2];
            out = "";
            var c3 = this.clone();
            c3.negative = 0;
            while (!c3.isZero()) {
              var r3 = c3.modn(groupBase).toString(base2);
              c3 = c3.idivn(groupBase);
              if (!c3.isZero()) {
                out = zeros2[groupSize - r3.length] + r3 + out;
              } else {
                out = r3 + out;
              }
            }
            if (this.isZero()) {
              out = "0" + out;
            }
            while (out.length % padding2 !== 0) {
              out = "0" + out;
            }
            if (this.negative !== 0) {
              out = "-" + out;
            }
            return out;
          }
          assert3(false, "Base should be between 2 and 36");
        };
        BN4.prototype.toNumber = function toNumber() {
          var ret = this.words[0];
          if (this.length === 2) {
            ret += this.words[1] * 67108864;
          } else if (this.length === 3 && this.words[2] === 1) {
            ret += 4503599627370496 + this.words[1] * 67108864;
          } else if (this.length > 2) {
            assert3(false, "Number can only safely store up to 53 bits");
          }
          return this.negative !== 0 ? -ret : ret;
        };
        BN4.prototype.toJSON = function toJSON2() {
          return this.toString(16);
        };
        BN4.prototype.toBuffer = function toBuffer(endian, length) {
          assert3(typeof Buffer2 !== "undefined");
          return this.toArrayLike(Buffer2, endian, length);
        };
        BN4.prototype.toArray = function toArray(endian, length) {
          return this.toArrayLike(Array, endian, length);
        };
        BN4.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
          var byteLength = this.byteLength();
          var reqLength = length || Math.max(1, byteLength);
          assert3(byteLength <= reqLength, "byte array longer than desired length");
          assert3(reqLength > 0, "Requested array length <= 0");
          this.strip();
          var littleEndian = endian === "le";
          var res = new ArrayType(reqLength);
          var b2, i3;
          var q3 = this.clone();
          if (!littleEndian) {
            for (i3 = 0; i3 < reqLength - byteLength; i3++) {
              res[i3] = 0;
            }
            for (i3 = 0; !q3.isZero(); i3++) {
              b2 = q3.andln(255);
              q3.iushrn(8);
              res[reqLength - i3 - 1] = b2;
            }
          } else {
            for (i3 = 0; !q3.isZero(); i3++) {
              b2 = q3.andln(255);
              q3.iushrn(8);
              res[i3] = b2;
            }
            for (; i3 < reqLength; i3++) {
              res[i3] = 0;
            }
          }
          return res;
        };
        if (Math.clz32) {
          BN4.prototype._countBits = function _countBits(w4) {
            return 32 - Math.clz32(w4);
          };
        } else {
          BN4.prototype._countBits = function _countBits(w4) {
            var t3 = w4;
            var r3 = 0;
            if (t3 >= 4096) {
              r3 += 13;
              t3 >>>= 13;
            }
            if (t3 >= 64) {
              r3 += 7;
              t3 >>>= 7;
            }
            if (t3 >= 8) {
              r3 += 4;
              t3 >>>= 4;
            }
            if (t3 >= 2) {
              r3 += 2;
              t3 >>>= 2;
            }
            return r3 + t3;
          };
        }
        BN4.prototype._zeroBits = function _zeroBits(w4) {
          if (w4 === 0)
            return 26;
          var t3 = w4;
          var r3 = 0;
          if ((t3 & 8191) === 0) {
            r3 += 13;
            t3 >>>= 13;
          }
          if ((t3 & 127) === 0) {
            r3 += 7;
            t3 >>>= 7;
          }
          if ((t3 & 15) === 0) {
            r3 += 4;
            t3 >>>= 4;
          }
          if ((t3 & 3) === 0) {
            r3 += 2;
            t3 >>>= 2;
          }
          if ((t3 & 1) === 0) {
            r3++;
          }
          return r3;
        };
        BN4.prototype.bitLength = function bitLength() {
          var w4 = this.words[this.length - 1];
          var hi = this._countBits(w4);
          return (this.length - 1) * 26 + hi;
        };
        function toBitArray(num) {
          var w4 = new Array(num.bitLength());
          for (var bit = 0; bit < w4.length; bit++) {
            var off = bit / 26 | 0;
            var wbit = bit % 26;
            w4[bit] = (num.words[off] & 1 << wbit) >>> wbit;
          }
          return w4;
        }
        BN4.prototype.zeroBits = function zeroBits() {
          if (this.isZero())
            return 0;
          var r3 = 0;
          for (var i3 = 0; i3 < this.length; i3++) {
            var b2 = this._zeroBits(this.words[i3]);
            r3 += b2;
            if (b2 !== 26)
              break;
          }
          return r3;
        };
        BN4.prototype.byteLength = function byteLength() {
          return Math.ceil(this.bitLength() / 8);
        };
        BN4.prototype.toTwos = function toTwos(width) {
          if (this.negative !== 0) {
            return this.abs().inotn(width).iaddn(1);
          }
          return this.clone();
        };
        BN4.prototype.fromTwos = function fromTwos(width) {
          if (this.testn(width - 1)) {
            return this.notn(width).iaddn(1).ineg();
          }
          return this.clone();
        };
        BN4.prototype.isNeg = function isNeg() {
          return this.negative !== 0;
        };
        BN4.prototype.neg = function neg3() {
          return this.clone().ineg();
        };
        BN4.prototype.ineg = function ineg() {
          if (!this.isZero()) {
            this.negative ^= 1;
          }
          return this;
        };
        BN4.prototype.iuor = function iuor(num) {
          while (this.length < num.length) {
            this.words[this.length++] = 0;
          }
          for (var i3 = 0; i3 < num.length; i3++) {
            this.words[i3] = this.words[i3] | num.words[i3];
          }
          return this.strip();
        };
        BN4.prototype.ior = function ior(num) {
          assert3((this.negative | num.negative) === 0);
          return this.iuor(num);
        };
        BN4.prototype.or = function or(num) {
          if (this.length > num.length)
            return this.clone().ior(num);
          return num.clone().ior(this);
        };
        BN4.prototype.uor = function uor(num) {
          if (this.length > num.length)
            return this.clone().iuor(num);
          return num.clone().iuor(this);
        };
        BN4.prototype.iuand = function iuand(num) {
          var b2;
          if (this.length > num.length) {
            b2 = num;
          } else {
            b2 = this;
          }
          for (var i3 = 0; i3 < b2.length; i3++) {
            this.words[i3] = this.words[i3] & num.words[i3];
          }
          this.length = b2.length;
          return this.strip();
        };
        BN4.prototype.iand = function iand(num) {
          assert3((this.negative | num.negative) === 0);
          return this.iuand(num);
        };
        BN4.prototype.and = function and(num) {
          if (this.length > num.length)
            return this.clone().iand(num);
          return num.clone().iand(this);
        };
        BN4.prototype.uand = function uand(num) {
          if (this.length > num.length)
            return this.clone().iuand(num);
          return num.clone().iuand(this);
        };
        BN4.prototype.iuxor = function iuxor(num) {
          var a3;
          var b2;
          if (this.length > num.length) {
            a3 = this;
            b2 = num;
          } else {
            a3 = num;
            b2 = this;
          }
          for (var i3 = 0; i3 < b2.length; i3++) {
            this.words[i3] = a3.words[i3] ^ b2.words[i3];
          }
          if (this !== a3) {
            for (; i3 < a3.length; i3++) {
              this.words[i3] = a3.words[i3];
            }
          }
          this.length = a3.length;
          return this.strip();
        };
        BN4.prototype.ixor = function ixor(num) {
          assert3((this.negative | num.negative) === 0);
          return this.iuxor(num);
        };
        BN4.prototype.xor = function xor(num) {
          if (this.length > num.length)
            return this.clone().ixor(num);
          return num.clone().ixor(this);
        };
        BN4.prototype.uxor = function uxor(num) {
          if (this.length > num.length)
            return this.clone().iuxor(num);
          return num.clone().iuxor(this);
        };
        BN4.prototype.inotn = function inotn(width) {
          assert3(typeof width === "number" && width >= 0);
          var bytesNeeded = Math.ceil(width / 26) | 0;
          var bitsLeft = width % 26;
          this._expand(bytesNeeded);
          if (bitsLeft > 0) {
            bytesNeeded--;
          }
          for (var i3 = 0; i3 < bytesNeeded; i3++) {
            this.words[i3] = ~this.words[i3] & 67108863;
          }
          if (bitsLeft > 0) {
            this.words[i3] = ~this.words[i3] & 67108863 >> 26 - bitsLeft;
          }
          return this.strip();
        };
        BN4.prototype.notn = function notn(width) {
          return this.clone().inotn(width);
        };
        BN4.prototype.setn = function setn(bit, val) {
          assert3(typeof bit === "number" && bit >= 0);
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          this._expand(off + 1);
          if (val) {
            this.words[off] = this.words[off] | 1 << wbit;
          } else {
            this.words[off] = this.words[off] & ~(1 << wbit);
          }
          return this.strip();
        };
        BN4.prototype.iadd = function iadd(num) {
          var r3;
          if (this.negative !== 0 && num.negative === 0) {
            this.negative = 0;
            r3 = this.isub(num);
            this.negative ^= 1;
            return this._normSign();
          } else if (this.negative === 0 && num.negative !== 0) {
            num.negative = 0;
            r3 = this.isub(num);
            num.negative = 1;
            return r3._normSign();
          }
          var a3, b2;
          if (this.length > num.length) {
            a3 = this;
            b2 = num;
          } else {
            a3 = num;
            b2 = this;
          }
          var carry = 0;
          for (var i3 = 0; i3 < b2.length; i3++) {
            r3 = (a3.words[i3] | 0) + (b2.words[i3] | 0) + carry;
            this.words[i3] = r3 & 67108863;
            carry = r3 >>> 26;
          }
          for (; carry !== 0 && i3 < a3.length; i3++) {
            r3 = (a3.words[i3] | 0) + carry;
            this.words[i3] = r3 & 67108863;
            carry = r3 >>> 26;
          }
          this.length = a3.length;
          if (carry !== 0) {
            this.words[this.length] = carry;
            this.length++;
          } else if (a3 !== this) {
            for (; i3 < a3.length; i3++) {
              this.words[i3] = a3.words[i3];
            }
          }
          return this;
        };
        BN4.prototype.add = function add3(num) {
          var res;
          if (num.negative !== 0 && this.negative === 0) {
            num.negative = 0;
            res = this.sub(num);
            num.negative ^= 1;
            return res;
          } else if (num.negative === 0 && this.negative !== 0) {
            this.negative = 0;
            res = num.sub(this);
            this.negative = 1;
            return res;
          }
          if (this.length > num.length)
            return this.clone().iadd(num);
          return num.clone().iadd(this);
        };
        BN4.prototype.isub = function isub(num) {
          if (num.negative !== 0) {
            num.negative = 0;
            var r3 = this.iadd(num);
            num.negative = 1;
            return r3._normSign();
          } else if (this.negative !== 0) {
            this.negative = 0;
            this.iadd(num);
            this.negative = 1;
            return this._normSign();
          }
          var cmp = this.cmp(num);
          if (cmp === 0) {
            this.negative = 0;
            this.length = 1;
            this.words[0] = 0;
            return this;
          }
          var a3, b2;
          if (cmp > 0) {
            a3 = this;
            b2 = num;
          } else {
            a3 = num;
            b2 = this;
          }
          var carry = 0;
          for (var i3 = 0; i3 < b2.length; i3++) {
            r3 = (a3.words[i3] | 0) - (b2.words[i3] | 0) + carry;
            carry = r3 >> 26;
            this.words[i3] = r3 & 67108863;
          }
          for (; carry !== 0 && i3 < a3.length; i3++) {
            r3 = (a3.words[i3] | 0) + carry;
            carry = r3 >> 26;
            this.words[i3] = r3 & 67108863;
          }
          if (carry === 0 && i3 < a3.length && a3 !== this) {
            for (; i3 < a3.length; i3++) {
              this.words[i3] = a3.words[i3];
            }
          }
          this.length = Math.max(this.length, i3);
          if (a3 !== this) {
            this.negative = 1;
          }
          return this.strip();
        };
        BN4.prototype.sub = function sub(num) {
          return this.clone().isub(num);
        };
        function smallMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative;
          var len = self2.length + num.length | 0;
          out.length = len;
          len = len - 1 | 0;
          var a3 = self2.words[0] | 0;
          var b2 = num.words[0] | 0;
          var r3 = a3 * b2;
          var lo = r3 & 67108863;
          var carry = r3 / 67108864 | 0;
          out.words[0] = lo;
          for (var k3 = 1; k3 < len; k3++) {
            var ncarry = carry >>> 26;
            var rword = carry & 67108863;
            var maxJ = Math.min(k3, num.length - 1);
            for (var j3 = Math.max(0, k3 - self2.length + 1); j3 <= maxJ; j3++) {
              var i3 = k3 - j3 | 0;
              a3 = self2.words[i3] | 0;
              b2 = num.words[j3] | 0;
              r3 = a3 * b2 + rword;
              ncarry += r3 / 67108864 | 0;
              rword = r3 & 67108863;
            }
            out.words[k3] = rword | 0;
            carry = ncarry | 0;
          }
          if (carry !== 0) {
            out.words[k3] = carry | 0;
          } else {
            out.length--;
          }
          return out.strip();
        }
        var comb10MulTo = function comb10MulTo2(self2, num, out) {
          var a3 = self2.words;
          var b2 = num.words;
          var o3 = out.words;
          var c3 = 0;
          var lo;
          var mid;
          var hi;
          var a0 = a3[0] | 0;
          var al0 = a0 & 8191;
          var ah0 = a0 >>> 13;
          var a1 = a3[1] | 0;
          var al1 = a1 & 8191;
          var ah1 = a1 >>> 13;
          var a22 = a3[2] | 0;
          var al2 = a22 & 8191;
          var ah2 = a22 >>> 13;
          var a32 = a3[3] | 0;
          var al3 = a32 & 8191;
          var ah3 = a32 >>> 13;
          var a4 = a3[4] | 0;
          var al4 = a4 & 8191;
          var ah4 = a4 >>> 13;
          var a5 = a3[5] | 0;
          var al5 = a5 & 8191;
          var ah5 = a5 >>> 13;
          var a6 = a3[6] | 0;
          var al6 = a6 & 8191;
          var ah6 = a6 >>> 13;
          var a7 = a3[7] | 0;
          var al7 = a7 & 8191;
          var ah7 = a7 >>> 13;
          var a8 = a3[8] | 0;
          var al8 = a8 & 8191;
          var ah8 = a8 >>> 13;
          var a9 = a3[9] | 0;
          var al9 = a9 & 8191;
          var ah9 = a9 >>> 13;
          var b0 = b2[0] | 0;
          var bl0 = b0 & 8191;
          var bh0 = b0 >>> 13;
          var b1 = b2[1] | 0;
          var bl1 = b1 & 8191;
          var bh1 = b1 >>> 13;
          var b22 = b2[2] | 0;
          var bl2 = b22 & 8191;
          var bh2 = b22 >>> 13;
          var b3 = b2[3] | 0;
          var bl3 = b3 & 8191;
          var bh3 = b3 >>> 13;
          var b4 = b2[4] | 0;
          var bl4 = b4 & 8191;
          var bh4 = b4 >>> 13;
          var b5 = b2[5] | 0;
          var bl5 = b5 & 8191;
          var bh5 = b5 >>> 13;
          var b6 = b2[6] | 0;
          var bl6 = b6 & 8191;
          var bh6 = b6 >>> 13;
          var b7 = b2[7] | 0;
          var bl7 = b7 & 8191;
          var bh7 = b7 >>> 13;
          var b8 = b2[8] | 0;
          var bl8 = b8 & 8191;
          var bh8 = b8 >>> 13;
          var b9 = b2[9] | 0;
          var bl9 = b9 & 8191;
          var bh9 = b9 >>> 13;
          out.negative = self2.negative ^ num.negative;
          out.length = 19;
          lo = Math.imul(al0, bl0);
          mid = Math.imul(al0, bh0);
          mid = mid + Math.imul(ah0, bl0) | 0;
          hi = Math.imul(ah0, bh0);
          var w0 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
          c3 = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
          w0 &= 67108863;
          lo = Math.imul(al1, bl0);
          mid = Math.imul(al1, bh0);
          mid = mid + Math.imul(ah1, bl0) | 0;
          hi = Math.imul(ah1, bh0);
          lo = lo + Math.imul(al0, bl1) | 0;
          mid = mid + Math.imul(al0, bh1) | 0;
          mid = mid + Math.imul(ah0, bl1) | 0;
          hi = hi + Math.imul(ah0, bh1) | 0;
          var w1 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
          c3 = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
          w1 &= 67108863;
          lo = Math.imul(al2, bl0);
          mid = Math.imul(al2, bh0);
          mid = mid + Math.imul(ah2, bl0) | 0;
          hi = Math.imul(ah2, bh0);
          lo = lo + Math.imul(al1, bl1) | 0;
          mid = mid + Math.imul(al1, bh1) | 0;
          mid = mid + Math.imul(ah1, bl1) | 0;
          hi = hi + Math.imul(ah1, bh1) | 0;
          lo = lo + Math.imul(al0, bl2) | 0;
          mid = mid + Math.imul(al0, bh2) | 0;
          mid = mid + Math.imul(ah0, bl2) | 0;
          hi = hi + Math.imul(ah0, bh2) | 0;
          var w22 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
          c3 = (hi + (mid >>> 13) | 0) + (w22 >>> 26) | 0;
          w22 &= 67108863;
          lo = Math.imul(al3, bl0);
          mid = Math.imul(al3, bh0);
          mid = mid + Math.imul(ah3, bl0) | 0;
          hi = Math.imul(ah3, bh0);
          lo = lo + Math.imul(al2, bl1) | 0;
          mid = mid + Math.imul(al2, bh1) | 0;
          mid = mid + Math.imul(ah2, bl1) | 0;
          hi = hi + Math.imul(ah2, bh1) | 0;
          lo = lo + Math.imul(al1, bl2) | 0;
          mid = mid + Math.imul(al1, bh2) | 0;
          mid = mid + Math.imul(ah1, bl2) | 0;
          hi = hi + Math.imul(ah1, bh2) | 0;
          lo = lo + Math.imul(al0, bl3) | 0;
          mid = mid + Math.imul(al0, bh3) | 0;
          mid = mid + Math.imul(ah0, bl3) | 0;
          hi = hi + Math.imul(ah0, bh3) | 0;
          var w32 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
          c3 = (hi + (mid >>> 13) | 0) + (w32 >>> 26) | 0;
          w32 &= 67108863;
          lo = Math.imul(al4, bl0);
          mid = Math.imul(al4, bh0);
          mid = mid + Math.imul(ah4, bl0) | 0;
          hi = Math.imul(ah4, bh0);
          lo = lo + Math.imul(al3, bl1) | 0;
          mid = mid + Math.imul(al3, bh1) | 0;
          mid = mid + Math.imul(ah3, bl1) | 0;
          hi = hi + Math.imul(ah3, bh1) | 0;
          lo = lo + Math.imul(al2, bl2) | 0;
          mid = mid + Math.imul(al2, bh2) | 0;
          mid = mid + Math.imul(ah2, bl2) | 0;
          hi = hi + Math.imul(ah2, bh2) | 0;
          lo = lo + Math.imul(al1, bl3) | 0;
          mid = mid + Math.imul(al1, bh3) | 0;
          mid = mid + Math.imul(ah1, bl3) | 0;
          hi = hi + Math.imul(ah1, bh3) | 0;
          lo = lo + Math.imul(al0, bl4) | 0;
          mid = mid + Math.imul(al0, bh4) | 0;
          mid = mid + Math.imul(ah0, bl4) | 0;
          hi = hi + Math.imul(ah0, bh4) | 0;
          var w4 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
          c3 = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
          w4 &= 67108863;
          lo = Math.imul(al5, bl0);
          mid = Math.imul(al5, bh0);
          mid = mid + Math.imul(ah5, bl0) | 0;
          hi = Math.imul(ah5, bh0);
          lo = lo + Math.imul(al4, bl1) | 0;
          mid = mid + Math.imul(al4, bh1) | 0;
          mid = mid + Math.imul(ah4, bl1) | 0;
          hi = hi + Math.imul(ah4, bh1) | 0;
          lo = lo + Math.imul(al3, bl2) | 0;
          mid = mid + Math.imul(al3, bh2) | 0;
          mid = mid + Math.imul(ah3, bl2) | 0;
          hi = hi + Math.imul(ah3, bh2) | 0;
          lo = lo + Math.imul(al2, bl3) | 0;
          mid = mid + Math.imul(al2, bh3) | 0;
          mid = mid + Math.imul(ah2, bl3) | 0;
          hi = hi + Math.imul(ah2, bh3) | 0;
          lo = lo + Math.imul(al1, bl4) | 0;
          mid = mid + Math.imul(al1, bh4) | 0;
          mid = mid + Math.imul(ah1, bl4) | 0;
          hi = hi + Math.imul(ah1, bh4) | 0;
          lo = lo + Math.imul(al0, bl5) | 0;
          mid = mid + Math.imul(al0, bh5) | 0;
          mid = mid + Math.imul(ah0, bl5) | 0;
          hi = hi + Math.imul(ah0, bh5) | 0;
          var w5 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
          c3 = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
          w5 &= 67108863;
          lo = Math.imul(al6, bl0);
          mid = Math.imul(al6, bh0);
          mid = mid + Math.imul(ah6, bl0) | 0;
          hi = Math.imul(ah6, bh0);
          lo = lo + Math.imul(al5, bl1) | 0;
          mid = mid + Math.imul(al5, bh1) | 0;
          mid = mid + Math.imul(ah5, bl1) | 0;
          hi = hi + Math.imul(ah5, bh1) | 0;
          lo = lo + Math.imul(al4, bl2) | 0;
          mid = mid + Math.imul(al4, bh2) | 0;
          mid = mid + Math.imul(ah4, bl2) | 0;
          hi = hi + Math.imul(ah4, bh2) | 0;
          lo = lo + Math.imul(al3, bl3) | 0;
          mid = mid + Math.imul(al3, bh3) | 0;
          mid = mid + Math.imul(ah3, bl3) | 0;
          hi = hi + Math.imul(ah3, bh3) | 0;
          lo = lo + Math.imul(al2, bl4) | 0;
          mid = mid + Math.imul(al2, bh4) | 0;
          mid = mid + Math.imul(ah2, bl4) | 0;
          hi = hi + Math.imul(ah2, bh4) | 0;
          lo = lo + Math.imul(al1, bl5) | 0;
          mid = mid + Math.imul(al1, bh5) | 0;
          mid = mid + Math.imul(ah1, bl5) | 0;
          hi = hi + Math.imul(ah1, bh5) | 0;
          lo = lo + Math.imul(al0, bl6) | 0;
          mid = mid + Math.imul(al0, bh6) | 0;
          mid = mid + Math.imul(ah0, bl6) | 0;
          hi = hi + Math.imul(ah0, bh6) | 0;
          var w6 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
          c3 = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
          w6 &= 67108863;
          lo = Math.imul(al7, bl0);
          mid = Math.imul(al7, bh0);
          mid = mid + Math.imul(ah7, bl0) | 0;
          hi = Math.imul(ah7, bh0);
          lo = lo + Math.imul(al6, bl1) | 0;
          mid = mid + Math.imul(al6, bh1) | 0;
          mid = mid + Math.imul(ah6, bl1) | 0;
          hi = hi + Math.imul(ah6, bh1) | 0;
          lo = lo + Math.imul(al5, bl2) | 0;
          mid = mid + Math.imul(al5, bh2) | 0;
          mid = mid + Math.imul(ah5, bl2) | 0;
          hi = hi + Math.imul(ah5, bh2) | 0;
          lo = lo + Math.imul(al4, bl3) | 0;
          mid = mid + Math.imul(al4, bh3) | 0;
          mid = mid + Math.imul(ah4, bl3) | 0;
          hi = hi + Math.imul(ah4, bh3) | 0;
          lo = lo + Math.imul(al3, bl4) | 0;
          mid = mid + Math.imul(al3, bh4) | 0;
          mid = mid + Math.imul(ah3, bl4) | 0;
          hi = hi + Math.imul(ah3, bh4) | 0;
          lo = lo + Math.imul(al2, bl5) | 0;
          mid = mid + Math.imul(al2, bh5) | 0;
          mid = mid + Math.imul(ah2, bl5) | 0;
          hi = hi + Math.imul(ah2, bh5) | 0;
          lo = lo + Math.imul(al1, bl6) | 0;
          mid = mid + Math.imul(al1, bh6) | 0;
          mid = mid + Math.imul(ah1, bl6) | 0;
          hi = hi + Math.imul(ah1, bh6) | 0;
          lo = lo + Math.imul(al0, bl7) | 0;
          mid = mid + Math.imul(al0, bh7) | 0;
          mid = mid + Math.imul(ah0, bl7) | 0;
          hi = hi + Math.imul(ah0, bh7) | 0;
          var w7 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
          c3 = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
          w7 &= 67108863;
          lo = Math.imul(al8, bl0);
          mid = Math.imul(al8, bh0);
          mid = mid + Math.imul(ah8, bl0) | 0;
          hi = Math.imul(ah8, bh0);
          lo = lo + Math.imul(al7, bl1) | 0;
          mid = mid + Math.imul(al7, bh1) | 0;
          mid = mid + Math.imul(ah7, bl1) | 0;
          hi = hi + Math.imul(ah7, bh1) | 0;
          lo = lo + Math.imul(al6, bl2) | 0;
          mid = mid + Math.imul(al6, bh2) | 0;
          mid = mid + Math.imul(ah6, bl2) | 0;
          hi = hi + Math.imul(ah6, bh2) | 0;
          lo = lo + Math.imul(al5, bl3) | 0;
          mid = mid + Math.imul(al5, bh3) | 0;
          mid = mid + Math.imul(ah5, bl3) | 0;
          hi = hi + Math.imul(ah5, bh3) | 0;
          lo = lo + Math.imul(al4, bl4) | 0;
          mid = mid + Math.imul(al4, bh4) | 0;
          mid = mid + Math.imul(ah4, bl4) | 0;
          hi = hi + Math.imul(ah4, bh4) | 0;
          lo = lo + Math.imul(al3, bl5) | 0;
          mid = mid + Math.imul(al3, bh5) | 0;
          mid = mid + Math.imul(ah3, bl5) | 0;
          hi = hi + Math.imul(ah3, bh5) | 0;
          lo = lo + Math.imul(al2, bl6) | 0;
          mid = mid + Math.imul(al2, bh6) | 0;
          mid = mid + Math.imul(ah2, bl6) | 0;
          hi = hi + Math.imul(ah2, bh6) | 0;
          lo = lo + Math.imul(al1, bl7) | 0;
          mid = mid + Math.imul(al1, bh7) | 0;
          mid = mid + Math.imul(ah1, bl7) | 0;
          hi = hi + Math.imul(ah1, bh7) | 0;
          lo = lo + Math.imul(al0, bl8) | 0;
          mid = mid + Math.imul(al0, bh8) | 0;
          mid = mid + Math.imul(ah0, bl8) | 0;
          hi = hi + Math.imul(ah0, bh8) | 0;
          var w8 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
          c3 = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
          w8 &= 67108863;
          lo = Math.imul(al9, bl0);
          mid = Math.imul(al9, bh0);
          mid = mid + Math.imul(ah9, bl0) | 0;
          hi = Math.imul(ah9, bh0);
          lo = lo + Math.imul(al8, bl1) | 0;
          mid = mid + Math.imul(al8, bh1) | 0;
          mid = mid + Math.imul(ah8, bl1) | 0;
          hi = hi + Math.imul(ah8, bh1) | 0;
          lo = lo + Math.imul(al7, bl2) | 0;
          mid = mid + Math.imul(al7, bh2) | 0;
          mid = mid + Math.imul(ah7, bl2) | 0;
          hi = hi + Math.imul(ah7, bh2) | 0;
          lo = lo + Math.imul(al6, bl3) | 0;
          mid = mid + Math.imul(al6, bh3) | 0;
          mid = mid + Math.imul(ah6, bl3) | 0;
          hi = hi + Math.imul(ah6, bh3) | 0;
          lo = lo + Math.imul(al5, bl4) | 0;
          mid = mid + Math.imul(al5, bh4) | 0;
          mid = mid + Math.imul(ah5, bl4) | 0;
          hi = hi + Math.imul(ah5, bh4) | 0;
          lo = lo + Math.imul(al4, bl5) | 0;
          mid = mid + Math.imul(al4, bh5) | 0;
          mid = mid + Math.imul(ah4, bl5) | 0;
          hi = hi + Math.imul(ah4, bh5) | 0;
          lo = lo + Math.imul(al3, bl6) | 0;
          mid = mid + Math.imul(al3, bh6) | 0;
          mid = mid + Math.imul(ah3, bl6) | 0;
          hi = hi + Math.imul(ah3, bh6) | 0;
          lo = lo + Math.imul(al2, bl7) | 0;
          mid = mid + Math.imul(al2, bh7) | 0;
          mid = mid + Math.imul(ah2, bl7) | 0;
          hi = hi + Math.imul(ah2, bh7) | 0;
          lo = lo + Math.imul(al1, bl8) | 0;
          mid = mid + Math.imul(al1, bh8) | 0;
          mid = mid + Math.imul(ah1, bl8) | 0;
          hi = hi + Math.imul(ah1, bh8) | 0;
          lo = lo + Math.imul(al0, bl9) | 0;
          mid = mid + Math.imul(al0, bh9) | 0;
          mid = mid + Math.imul(ah0, bl9) | 0;
          hi = hi + Math.imul(ah0, bh9) | 0;
          var w9 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
          c3 = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
          w9 &= 67108863;
          lo = Math.imul(al9, bl1);
          mid = Math.imul(al9, bh1);
          mid = mid + Math.imul(ah9, bl1) | 0;
          hi = Math.imul(ah9, bh1);
          lo = lo + Math.imul(al8, bl2) | 0;
          mid = mid + Math.imul(al8, bh2) | 0;
          mid = mid + Math.imul(ah8, bl2) | 0;
          hi = hi + Math.imul(ah8, bh2) | 0;
          lo = lo + Math.imul(al7, bl3) | 0;
          mid = mid + Math.imul(al7, bh3) | 0;
          mid = mid + Math.imul(ah7, bl3) | 0;
          hi = hi + Math.imul(ah7, bh3) | 0;
          lo = lo + Math.imul(al6, bl4) | 0;
          mid = mid + Math.imul(al6, bh4) | 0;
          mid = mid + Math.imul(ah6, bl4) | 0;
          hi = hi + Math.imul(ah6, bh4) | 0;
          lo = lo + Math.imul(al5, bl5) | 0;
          mid = mid + Math.imul(al5, bh5) | 0;
          mid = mid + Math.imul(ah5, bl5) | 0;
          hi = hi + Math.imul(ah5, bh5) | 0;
          lo = lo + Math.imul(al4, bl6) | 0;
          mid = mid + Math.imul(al4, bh6) | 0;
          mid = mid + Math.imul(ah4, bl6) | 0;
          hi = hi + Math.imul(ah4, bh6) | 0;
          lo = lo + Math.imul(al3, bl7) | 0;
          mid = mid + Math.imul(al3, bh7) | 0;
          mid = mid + Math.imul(ah3, bl7) | 0;
          hi = hi + Math.imul(ah3, bh7) | 0;
          lo = lo + Math.imul(al2, bl8) | 0;
          mid = mid + Math.imul(al2, bh8) | 0;
          mid = mid + Math.imul(ah2, bl8) | 0;
          hi = hi + Math.imul(ah2, bh8) | 0;
          lo = lo + Math.imul(al1, bl9) | 0;
          mid = mid + Math.imul(al1, bh9) | 0;
          mid = mid + Math.imul(ah1, bl9) | 0;
          hi = hi + Math.imul(ah1, bh9) | 0;
          var w10 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
          c3 = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
          w10 &= 67108863;
          lo = Math.imul(al9, bl2);
          mid = Math.imul(al9, bh2);
          mid = mid + Math.imul(ah9, bl2) | 0;
          hi = Math.imul(ah9, bh2);
          lo = lo + Math.imul(al8, bl3) | 0;
          mid = mid + Math.imul(al8, bh3) | 0;
          mid = mid + Math.imul(ah8, bl3) | 0;
          hi = hi + Math.imul(ah8, bh3) | 0;
          lo = lo + Math.imul(al7, bl4) | 0;
          mid = mid + Math.imul(al7, bh4) | 0;
          mid = mid + Math.imul(ah7, bl4) | 0;
          hi = hi + Math.imul(ah7, bh4) | 0;
          lo = lo + Math.imul(al6, bl5) | 0;
          mid = mid + Math.imul(al6, bh5) | 0;
          mid = mid + Math.imul(ah6, bl5) | 0;
          hi = hi + Math.imul(ah6, bh5) | 0;
          lo = lo + Math.imul(al5, bl6) | 0;
          mid = mid + Math.imul(al5, bh6) | 0;
          mid = mid + Math.imul(ah5, bl6) | 0;
          hi = hi + Math.imul(ah5, bh6) | 0;
          lo = lo + Math.imul(al4, bl7) | 0;
          mid = mid + Math.imul(al4, bh7) | 0;
          mid = mid + Math.imul(ah4, bl7) | 0;
          hi = hi + Math.imul(ah4, bh7) | 0;
          lo = lo + Math.imul(al3, bl8) | 0;
          mid = mid + Math.imul(al3, bh8) | 0;
          mid = mid + Math.imul(ah3, bl8) | 0;
          hi = hi + Math.imul(ah3, bh8) | 0;
          lo = lo + Math.imul(al2, bl9) | 0;
          mid = mid + Math.imul(al2, bh9) | 0;
          mid = mid + Math.imul(ah2, bl9) | 0;
          hi = hi + Math.imul(ah2, bh9) | 0;
          var w11 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
          c3 = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
          w11 &= 67108863;
          lo = Math.imul(al9, bl3);
          mid = Math.imul(al9, bh3);
          mid = mid + Math.imul(ah9, bl3) | 0;
          hi = Math.imul(ah9, bh3);
          lo = lo + Math.imul(al8, bl4) | 0;
          mid = mid + Math.imul(al8, bh4) | 0;
          mid = mid + Math.imul(ah8, bl4) | 0;
          hi = hi + Math.imul(ah8, bh4) | 0;
          lo = lo + Math.imul(al7, bl5) | 0;
          mid = mid + Math.imul(al7, bh5) | 0;
          mid = mid + Math.imul(ah7, bl5) | 0;
          hi = hi + Math.imul(ah7, bh5) | 0;
          lo = lo + Math.imul(al6, bl6) | 0;
          mid = mid + Math.imul(al6, bh6) | 0;
          mid = mid + Math.imul(ah6, bl6) | 0;
          hi = hi + Math.imul(ah6, bh6) | 0;
          lo = lo + Math.imul(al5, bl7) | 0;
          mid = mid + Math.imul(al5, bh7) | 0;
          mid = mid + Math.imul(ah5, bl7) | 0;
          hi = hi + Math.imul(ah5, bh7) | 0;
          lo = lo + Math.imul(al4, bl8) | 0;
          mid = mid + Math.imul(al4, bh8) | 0;
          mid = mid + Math.imul(ah4, bl8) | 0;
          hi = hi + Math.imul(ah4, bh8) | 0;
          lo = lo + Math.imul(al3, bl9) | 0;
          mid = mid + Math.imul(al3, bh9) | 0;
          mid = mid + Math.imul(ah3, bl9) | 0;
          hi = hi + Math.imul(ah3, bh9) | 0;
          var w12 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
          c3 = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
          w12 &= 67108863;
          lo = Math.imul(al9, bl4);
          mid = Math.imul(al9, bh4);
          mid = mid + Math.imul(ah9, bl4) | 0;
          hi = Math.imul(ah9, bh4);
          lo = lo + Math.imul(al8, bl5) | 0;
          mid = mid + Math.imul(al8, bh5) | 0;
          mid = mid + Math.imul(ah8, bl5) | 0;
          hi = hi + Math.imul(ah8, bh5) | 0;
          lo = lo + Math.imul(al7, bl6) | 0;
          mid = mid + Math.imul(al7, bh6) | 0;
          mid = mid + Math.imul(ah7, bl6) | 0;
          hi = hi + Math.imul(ah7, bh6) | 0;
          lo = lo + Math.imul(al6, bl7) | 0;
          mid = mid + Math.imul(al6, bh7) | 0;
          mid = mid + Math.imul(ah6, bl7) | 0;
          hi = hi + Math.imul(ah6, bh7) | 0;
          lo = lo + Math.imul(al5, bl8) | 0;
          mid = mid + Math.imul(al5, bh8) | 0;
          mid = mid + Math.imul(ah5, bl8) | 0;
          hi = hi + Math.imul(ah5, bh8) | 0;
          lo = lo + Math.imul(al4, bl9) | 0;
          mid = mid + Math.imul(al4, bh9) | 0;
          mid = mid + Math.imul(ah4, bl9) | 0;
          hi = hi + Math.imul(ah4, bh9) | 0;
          var w13 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
          c3 = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
          w13 &= 67108863;
          lo = Math.imul(al9, bl5);
          mid = Math.imul(al9, bh5);
          mid = mid + Math.imul(ah9, bl5) | 0;
          hi = Math.imul(ah9, bh5);
          lo = lo + Math.imul(al8, bl6) | 0;
          mid = mid + Math.imul(al8, bh6) | 0;
          mid = mid + Math.imul(ah8, bl6) | 0;
          hi = hi + Math.imul(ah8, bh6) | 0;
          lo = lo + Math.imul(al7, bl7) | 0;
          mid = mid + Math.imul(al7, bh7) | 0;
          mid = mid + Math.imul(ah7, bl7) | 0;
          hi = hi + Math.imul(ah7, bh7) | 0;
          lo = lo + Math.imul(al6, bl8) | 0;
          mid = mid + Math.imul(al6, bh8) | 0;
          mid = mid + Math.imul(ah6, bl8) | 0;
          hi = hi + Math.imul(ah6, bh8) | 0;
          lo = lo + Math.imul(al5, bl9) | 0;
          mid = mid + Math.imul(al5, bh9) | 0;
          mid = mid + Math.imul(ah5, bl9) | 0;
          hi = hi + Math.imul(ah5, bh9) | 0;
          var w14 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
          c3 = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
          w14 &= 67108863;
          lo = Math.imul(al9, bl6);
          mid = Math.imul(al9, bh6);
          mid = mid + Math.imul(ah9, bl6) | 0;
          hi = Math.imul(ah9, bh6);
          lo = lo + Math.imul(al8, bl7) | 0;
          mid = mid + Math.imul(al8, bh7) | 0;
          mid = mid + Math.imul(ah8, bl7) | 0;
          hi = hi + Math.imul(ah8, bh7) | 0;
          lo = lo + Math.imul(al7, bl8) | 0;
          mid = mid + Math.imul(al7, bh8) | 0;
          mid = mid + Math.imul(ah7, bl8) | 0;
          hi = hi + Math.imul(ah7, bh8) | 0;
          lo = lo + Math.imul(al6, bl9) | 0;
          mid = mid + Math.imul(al6, bh9) | 0;
          mid = mid + Math.imul(ah6, bl9) | 0;
          hi = hi + Math.imul(ah6, bh9) | 0;
          var w15 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
          c3 = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
          w15 &= 67108863;
          lo = Math.imul(al9, bl7);
          mid = Math.imul(al9, bh7);
          mid = mid + Math.imul(ah9, bl7) | 0;
          hi = Math.imul(ah9, bh7);
          lo = lo + Math.imul(al8, bl8) | 0;
          mid = mid + Math.imul(al8, bh8) | 0;
          mid = mid + Math.imul(ah8, bl8) | 0;
          hi = hi + Math.imul(ah8, bh8) | 0;
          lo = lo + Math.imul(al7, bl9) | 0;
          mid = mid + Math.imul(al7, bh9) | 0;
          mid = mid + Math.imul(ah7, bl9) | 0;
          hi = hi + Math.imul(ah7, bh9) | 0;
          var w16 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
          c3 = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
          w16 &= 67108863;
          lo = Math.imul(al9, bl8);
          mid = Math.imul(al9, bh8);
          mid = mid + Math.imul(ah9, bl8) | 0;
          hi = Math.imul(ah9, bh8);
          lo = lo + Math.imul(al8, bl9) | 0;
          mid = mid + Math.imul(al8, bh9) | 0;
          mid = mid + Math.imul(ah8, bl9) | 0;
          hi = hi + Math.imul(ah8, bh9) | 0;
          var w17 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
          c3 = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
          w17 &= 67108863;
          lo = Math.imul(al9, bl9);
          mid = Math.imul(al9, bh9);
          mid = mid + Math.imul(ah9, bl9) | 0;
          hi = Math.imul(ah9, bh9);
          var w18 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
          c3 = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
          w18 &= 67108863;
          o3[0] = w0;
          o3[1] = w1;
          o3[2] = w22;
          o3[3] = w32;
          o3[4] = w4;
          o3[5] = w5;
          o3[6] = w6;
          o3[7] = w7;
          o3[8] = w8;
          o3[9] = w9;
          o3[10] = w10;
          o3[11] = w11;
          o3[12] = w12;
          o3[13] = w13;
          o3[14] = w14;
          o3[15] = w15;
          o3[16] = w16;
          o3[17] = w17;
          o3[18] = w18;
          if (c3 !== 0) {
            o3[19] = c3;
            out.length++;
          }
          return out;
        };
        if (!Math.imul) {
          comb10MulTo = smallMulTo;
        }
        function bigMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative;
          out.length = self2.length + num.length;
          var carry = 0;
          var hncarry = 0;
          for (var k3 = 0; k3 < out.length - 1; k3++) {
            var ncarry = hncarry;
            hncarry = 0;
            var rword = carry & 67108863;
            var maxJ = Math.min(k3, num.length - 1);
            for (var j3 = Math.max(0, k3 - self2.length + 1); j3 <= maxJ; j3++) {
              var i3 = k3 - j3;
              var a3 = self2.words[i3] | 0;
              var b2 = num.words[j3] | 0;
              var r3 = a3 * b2;
              var lo = r3 & 67108863;
              ncarry = ncarry + (r3 / 67108864 | 0) | 0;
              lo = lo + rword | 0;
              rword = lo & 67108863;
              ncarry = ncarry + (lo >>> 26) | 0;
              hncarry += ncarry >>> 26;
              ncarry &= 67108863;
            }
            out.words[k3] = rword;
            carry = ncarry;
            ncarry = hncarry;
          }
          if (carry !== 0) {
            out.words[k3] = carry;
          } else {
            out.length--;
          }
          return out.strip();
        }
        function jumboMulTo(self2, num, out) {
          var fftm = new FFTM();
          return fftm.mulp(self2, num, out);
        }
        BN4.prototype.mulTo = function mulTo(num, out) {
          var res;
          var len = this.length + num.length;
          if (this.length === 10 && num.length === 10) {
            res = comb10MulTo(this, num, out);
          } else if (len < 63) {
            res = smallMulTo(this, num, out);
          } else if (len < 1024) {
            res = bigMulTo(this, num, out);
          } else {
            res = jumboMulTo(this, num, out);
          }
          return res;
        };
        function FFTM(x3, y3) {
          this.x = x3;
          this.y = y3;
        }
        FFTM.prototype.makeRBT = function makeRBT(N4) {
          var t3 = new Array(N4);
          var l3 = BN4.prototype._countBits(N4) - 1;
          for (var i3 = 0; i3 < N4; i3++) {
            t3[i3] = this.revBin(i3, l3, N4);
          }
          return t3;
        };
        FFTM.prototype.revBin = function revBin(x3, l3, N4) {
          if (x3 === 0 || x3 === N4 - 1)
            return x3;
          var rb = 0;
          for (var i3 = 0; i3 < l3; i3++) {
            rb |= (x3 & 1) << l3 - i3 - 1;
            x3 >>= 1;
          }
          return rb;
        };
        FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N4) {
          for (var i3 = 0; i3 < N4; i3++) {
            rtws[i3] = rws[rbt[i3]];
            itws[i3] = iws[rbt[i3]];
          }
        };
        FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N4, rbt) {
          this.permute(rbt, rws, iws, rtws, itws, N4);
          for (var s3 = 1; s3 < N4; s3 <<= 1) {
            var l3 = s3 << 1;
            var rtwdf = Math.cos(2 * Math.PI / l3);
            var itwdf = Math.sin(2 * Math.PI / l3);
            for (var p3 = 0; p3 < N4; p3 += l3) {
              var rtwdf_ = rtwdf;
              var itwdf_ = itwdf;
              for (var j3 = 0; j3 < s3; j3++) {
                var re = rtws[p3 + j3];
                var ie = itws[p3 + j3];
                var ro = rtws[p3 + j3 + s3];
                var io = itws[p3 + j3 + s3];
                var rx = rtwdf_ * ro - itwdf_ * io;
                io = rtwdf_ * io + itwdf_ * ro;
                ro = rx;
                rtws[p3 + j3] = re + ro;
                itws[p3 + j3] = ie + io;
                rtws[p3 + j3 + s3] = re - ro;
                itws[p3 + j3 + s3] = ie - io;
                if (j3 !== l3) {
                  rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                  itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                  rtwdf_ = rx;
                }
              }
            }
          }
        };
        FFTM.prototype.guessLen13b = function guessLen13b(n2, m3) {
          var N4 = Math.max(m3, n2) | 1;
          var odd = N4 & 1;
          var i3 = 0;
          for (N4 = N4 / 2 | 0; N4; N4 = N4 >>> 1) {
            i3++;
          }
          return 1 << i3 + 1 + odd;
        };
        FFTM.prototype.conjugate = function conjugate(rws, iws, N4) {
          if (N4 <= 1)
            return;
          for (var i3 = 0; i3 < N4 / 2; i3++) {
            var t3 = rws[i3];
            rws[i3] = rws[N4 - i3 - 1];
            rws[N4 - i3 - 1] = t3;
            t3 = iws[i3];
            iws[i3] = -iws[N4 - i3 - 1];
            iws[N4 - i3 - 1] = -t3;
          }
        };
        FFTM.prototype.normalize13b = function normalize13b(ws, N4) {
          var carry = 0;
          for (var i3 = 0; i3 < N4 / 2; i3++) {
            var w4 = Math.round(ws[2 * i3 + 1] / N4) * 8192 + Math.round(ws[2 * i3] / N4) + carry;
            ws[i3] = w4 & 67108863;
            if (w4 < 67108864) {
              carry = 0;
            } else {
              carry = w4 / 67108864 | 0;
            }
          }
          return ws;
        };
        FFTM.prototype.convert13b = function convert13b(ws, len, rws, N4) {
          var carry = 0;
          for (var i3 = 0; i3 < len; i3++) {
            carry = carry + (ws[i3] | 0);
            rws[2 * i3] = carry & 8191;
            carry = carry >>> 13;
            rws[2 * i3 + 1] = carry & 8191;
            carry = carry >>> 13;
          }
          for (i3 = 2 * len; i3 < N4; ++i3) {
            rws[i3] = 0;
          }
          assert3(carry === 0);
          assert3((carry & ~8191) === 0);
        };
        FFTM.prototype.stub = function stub(N4) {
          var ph = new Array(N4);
          for (var i3 = 0; i3 < N4; i3++) {
            ph[i3] = 0;
          }
          return ph;
        };
        FFTM.prototype.mulp = function mulp(x3, y3, out) {
          var N4 = 2 * this.guessLen13b(x3.length, y3.length);
          var rbt = this.makeRBT(N4);
          var _4 = this.stub(N4);
          var rws = new Array(N4);
          var rwst = new Array(N4);
          var iwst = new Array(N4);
          var nrws = new Array(N4);
          var nrwst = new Array(N4);
          var niwst = new Array(N4);
          var rmws = out.words;
          rmws.length = N4;
          this.convert13b(x3.words, x3.length, rws, N4);
          this.convert13b(y3.words, y3.length, nrws, N4);
          this.transform(rws, _4, rwst, iwst, N4, rbt);
          this.transform(nrws, _4, nrwst, niwst, N4, rbt);
          for (var i3 = 0; i3 < N4; i3++) {
            var rx = rwst[i3] * nrwst[i3] - iwst[i3] * niwst[i3];
            iwst[i3] = rwst[i3] * niwst[i3] + iwst[i3] * nrwst[i3];
            rwst[i3] = rx;
          }
          this.conjugate(rwst, iwst, N4);
          this.transform(rwst, iwst, rmws, _4, N4, rbt);
          this.conjugate(rmws, _4, N4);
          this.normalize13b(rmws, N4);
          out.negative = x3.negative ^ y3.negative;
          out.length = x3.length + y3.length;
          return out.strip();
        };
        BN4.prototype.mul = function mul3(num) {
          var out = new BN4(null);
          out.words = new Array(this.length + num.length);
          return this.mulTo(num, out);
        };
        BN4.prototype.mulf = function mulf(num) {
          var out = new BN4(null);
          out.words = new Array(this.length + num.length);
          return jumboMulTo(this, num, out);
        };
        BN4.prototype.imul = function imul(num) {
          return this.clone().mulTo(num, this);
        };
        BN4.prototype.imuln = function imuln(num) {
          assert3(typeof num === "number");
          assert3(num < 67108864);
          var carry = 0;
          for (var i3 = 0; i3 < this.length; i3++) {
            var w4 = (this.words[i3] | 0) * num;
            var lo = (w4 & 67108863) + (carry & 67108863);
            carry >>= 26;
            carry += w4 / 67108864 | 0;
            carry += lo >>> 26;
            this.words[i3] = lo & 67108863;
          }
          if (carry !== 0) {
            this.words[i3] = carry;
            this.length++;
          }
          return this;
        };
        BN4.prototype.muln = function muln(num) {
          return this.clone().imuln(num);
        };
        BN4.prototype.sqr = function sqr() {
          return this.mul(this);
        };
        BN4.prototype.isqr = function isqr() {
          return this.imul(this.clone());
        };
        BN4.prototype.pow = function pow(num) {
          var w4 = toBitArray(num);
          if (w4.length === 0)
            return new BN4(1);
          var res = this;
          for (var i3 = 0; i3 < w4.length; i3++, res = res.sqr()) {
            if (w4[i3] !== 0)
              break;
          }
          if (++i3 < w4.length) {
            for (var q3 = res.sqr(); i3 < w4.length; i3++, q3 = q3.sqr()) {
              if (w4[i3] === 0)
                continue;
              res = res.mul(q3);
            }
          }
          return res;
        };
        BN4.prototype.iushln = function iushln(bits) {
          assert3(typeof bits === "number" && bits >= 0);
          var r3 = bits % 26;
          var s3 = (bits - r3) / 26;
          var carryMask = 67108863 >>> 26 - r3 << 26 - r3;
          var i3;
          if (r3 !== 0) {
            var carry = 0;
            for (i3 = 0; i3 < this.length; i3++) {
              var newCarry = this.words[i3] & carryMask;
              var c3 = (this.words[i3] | 0) - newCarry << r3;
              this.words[i3] = c3 | carry;
              carry = newCarry >>> 26 - r3;
            }
            if (carry) {
              this.words[i3] = carry;
              this.length++;
            }
          }
          if (s3 !== 0) {
            for (i3 = this.length - 1; i3 >= 0; i3--) {
              this.words[i3 + s3] = this.words[i3];
            }
            for (i3 = 0; i3 < s3; i3++) {
              this.words[i3] = 0;
            }
            this.length += s3;
          }
          return this.strip();
        };
        BN4.prototype.ishln = function ishln(bits) {
          assert3(this.negative === 0);
          return this.iushln(bits);
        };
        BN4.prototype.iushrn = function iushrn(bits, hint, extended) {
          assert3(typeof bits === "number" && bits >= 0);
          var h3;
          if (hint) {
            h3 = (hint - hint % 26) / 26;
          } else {
            h3 = 0;
          }
          var r3 = bits % 26;
          var s3 = Math.min((bits - r3) / 26, this.length);
          var mask = 67108863 ^ 67108863 >>> r3 << r3;
          var maskedWords = extended;
          h3 -= s3;
          h3 = Math.max(0, h3);
          if (maskedWords) {
            for (var i3 = 0; i3 < s3; i3++) {
              maskedWords.words[i3] = this.words[i3];
            }
            maskedWords.length = s3;
          }
          if (s3 === 0) {
          } else if (this.length > s3) {
            this.length -= s3;
            for (i3 = 0; i3 < this.length; i3++) {
              this.words[i3] = this.words[i3 + s3];
            }
          } else {
            this.words[0] = 0;
            this.length = 1;
          }
          var carry = 0;
          for (i3 = this.length - 1; i3 >= 0 && (carry !== 0 || i3 >= h3); i3--) {
            var word = this.words[i3] | 0;
            this.words[i3] = carry << 26 - r3 | word >>> r3;
            carry = word & mask;
          }
          if (maskedWords && carry !== 0) {
            maskedWords.words[maskedWords.length++] = carry;
          }
          if (this.length === 0) {
            this.words[0] = 0;
            this.length = 1;
          }
          return this.strip();
        };
        BN4.prototype.ishrn = function ishrn(bits, hint, extended) {
          assert3(this.negative === 0);
          return this.iushrn(bits, hint, extended);
        };
        BN4.prototype.shln = function shln(bits) {
          return this.clone().ishln(bits);
        };
        BN4.prototype.ushln = function ushln(bits) {
          return this.clone().iushln(bits);
        };
        BN4.prototype.shrn = function shrn(bits) {
          return this.clone().ishrn(bits);
        };
        BN4.prototype.ushrn = function ushrn(bits) {
          return this.clone().iushrn(bits);
        };
        BN4.prototype.testn = function testn(bit) {
          assert3(typeof bit === "number" && bit >= 0);
          var r3 = bit % 26;
          var s3 = (bit - r3) / 26;
          var q3 = 1 << r3;
          if (this.length <= s3)
            return false;
          var w4 = this.words[s3];
          return !!(w4 & q3);
        };
        BN4.prototype.imaskn = function imaskn(bits) {
          assert3(typeof bits === "number" && bits >= 0);
          var r3 = bits % 26;
          var s3 = (bits - r3) / 26;
          assert3(this.negative === 0, "imaskn works only with positive numbers");
          if (this.length <= s3) {
            return this;
          }
          if (r3 !== 0) {
            s3++;
          }
          this.length = Math.min(s3, this.length);
          if (r3 !== 0) {
            var mask = 67108863 ^ 67108863 >>> r3 << r3;
            this.words[this.length - 1] &= mask;
          }
          return this.strip();
        };
        BN4.prototype.maskn = function maskn(bits) {
          return this.clone().imaskn(bits);
        };
        BN4.prototype.iaddn = function iaddn(num) {
          assert3(typeof num === "number");
          assert3(num < 67108864);
          if (num < 0)
            return this.isubn(-num);
          if (this.negative !== 0) {
            if (this.length === 1 && (this.words[0] | 0) < num) {
              this.words[0] = num - (this.words[0] | 0);
              this.negative = 0;
              return this;
            }
            this.negative = 0;
            this.isubn(num);
            this.negative = 1;
            return this;
          }
          return this._iaddn(num);
        };
        BN4.prototype._iaddn = function _iaddn(num) {
          this.words[0] += num;
          for (var i3 = 0; i3 < this.length && this.words[i3] >= 67108864; i3++) {
            this.words[i3] -= 67108864;
            if (i3 === this.length - 1) {
              this.words[i3 + 1] = 1;
            } else {
              this.words[i3 + 1]++;
            }
          }
          this.length = Math.max(this.length, i3 + 1);
          return this;
        };
        BN4.prototype.isubn = function isubn(num) {
          assert3(typeof num === "number");
          assert3(num < 67108864);
          if (num < 0)
            return this.iaddn(-num);
          if (this.negative !== 0) {
            this.negative = 0;
            this.iaddn(num);
            this.negative = 1;
            return this;
          }
          this.words[0] -= num;
          if (this.length === 1 && this.words[0] < 0) {
            this.words[0] = -this.words[0];
            this.negative = 1;
          } else {
            for (var i3 = 0; i3 < this.length && this.words[i3] < 0; i3++) {
              this.words[i3] += 67108864;
              this.words[i3 + 1] -= 1;
            }
          }
          return this.strip();
        };
        BN4.prototype.addn = function addn(num) {
          return this.clone().iaddn(num);
        };
        BN4.prototype.subn = function subn(num) {
          return this.clone().isubn(num);
        };
        BN4.prototype.iabs = function iabs() {
          this.negative = 0;
          return this;
        };
        BN4.prototype.abs = function abs() {
          return this.clone().iabs();
        };
        BN4.prototype._ishlnsubmul = function _ishlnsubmul(num, mul3, shift) {
          var len = num.length + shift;
          var i3;
          this._expand(len);
          var w4;
          var carry = 0;
          for (i3 = 0; i3 < num.length; i3++) {
            w4 = (this.words[i3 + shift] | 0) + carry;
            var right = (num.words[i3] | 0) * mul3;
            w4 -= right & 67108863;
            carry = (w4 >> 26) - (right / 67108864 | 0);
            this.words[i3 + shift] = w4 & 67108863;
          }
          for (; i3 < this.length - shift; i3++) {
            w4 = (this.words[i3 + shift] | 0) + carry;
            carry = w4 >> 26;
            this.words[i3 + shift] = w4 & 67108863;
          }
          if (carry === 0)
            return this.strip();
          assert3(carry === -1);
          carry = 0;
          for (i3 = 0; i3 < this.length; i3++) {
            w4 = -(this.words[i3] | 0) + carry;
            carry = w4 >> 26;
            this.words[i3] = w4 & 67108863;
          }
          this.negative = 1;
          return this.strip();
        };
        BN4.prototype._wordDiv = function _wordDiv(num, mode) {
          var shift = this.length - num.length;
          var a3 = this.clone();
          var b2 = num;
          var bhi = b2.words[b2.length - 1] | 0;
          var bhiBits = this._countBits(bhi);
          shift = 26 - bhiBits;
          if (shift !== 0) {
            b2 = b2.ushln(shift);
            a3.iushln(shift);
            bhi = b2.words[b2.length - 1] | 0;
          }
          var m3 = a3.length - b2.length;
          var q3;
          if (mode !== "mod") {
            q3 = new BN4(null);
            q3.length = m3 + 1;
            q3.words = new Array(q3.length);
            for (var i3 = 0; i3 < q3.length; i3++) {
              q3.words[i3] = 0;
            }
          }
          var diff = a3.clone()._ishlnsubmul(b2, 1, m3);
          if (diff.negative === 0) {
            a3 = diff;
            if (q3) {
              q3.words[m3] = 1;
            }
          }
          for (var j3 = m3 - 1; j3 >= 0; j3--) {
            var qj = (a3.words[b2.length + j3] | 0) * 67108864 + (a3.words[b2.length + j3 - 1] | 0);
            qj = Math.min(qj / bhi | 0, 67108863);
            a3._ishlnsubmul(b2, qj, j3);
            while (a3.negative !== 0) {
              qj--;
              a3.negative = 0;
              a3._ishlnsubmul(b2, 1, j3);
              if (!a3.isZero()) {
                a3.negative ^= 1;
              }
            }
            if (q3) {
              q3.words[j3] = qj;
            }
          }
          if (q3) {
            q3.strip();
          }
          a3.strip();
          if (mode !== "div" && shift !== 0) {
            a3.iushrn(shift);
          }
          return {
            div: q3 || null,
            mod: a3
          };
        };
        BN4.prototype.divmod = function divmod(num, mode, positive) {
          assert3(!num.isZero());
          if (this.isZero()) {
            return {
              div: new BN4(0),
              mod: new BN4(0)
            };
          }
          var div, mod, res;
          if (this.negative !== 0 && num.negative === 0) {
            res = this.neg().divmod(num, mode);
            if (mode !== "mod") {
              div = res.div.neg();
            }
            if (mode !== "div") {
              mod = res.mod.neg();
              if (positive && mod.negative !== 0) {
                mod.iadd(num);
              }
            }
            return {
              div,
              mod
            };
          }
          if (this.negative === 0 && num.negative !== 0) {
            res = this.divmod(num.neg(), mode);
            if (mode !== "mod") {
              div = res.div.neg();
            }
            return {
              div,
              mod: res.mod
            };
          }
          if ((this.negative & num.negative) !== 0) {
            res = this.neg().divmod(num.neg(), mode);
            if (mode !== "div") {
              mod = res.mod.neg();
              if (positive && mod.negative !== 0) {
                mod.isub(num);
              }
            }
            return {
              div: res.div,
              mod
            };
          }
          if (num.length > this.length || this.cmp(num) < 0) {
            return {
              div: new BN4(0),
              mod: this
            };
          }
          if (num.length === 1) {
            if (mode === "div") {
              return {
                div: this.divn(num.words[0]),
                mod: null
              };
            }
            if (mode === "mod") {
              return {
                div: null,
                mod: new BN4(this.modn(num.words[0]))
              };
            }
            return {
              div: this.divn(num.words[0]),
              mod: new BN4(this.modn(num.words[0]))
            };
          }
          return this._wordDiv(num, mode);
        };
        BN4.prototype.div = function div(num) {
          return this.divmod(num, "div", false).div;
        };
        BN4.prototype.mod = function mod(num) {
          return this.divmod(num, "mod", false).mod;
        };
        BN4.prototype.umod = function umod(num) {
          return this.divmod(num, "mod", true).mod;
        };
        BN4.prototype.divRound = function divRound(num) {
          var dm = this.divmod(num);
          if (dm.mod.isZero())
            return dm.div;
          var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
          var half = num.ushrn(1);
          var r22 = num.andln(1);
          var cmp = mod.cmp(half);
          if (cmp < 0 || r22 === 1 && cmp === 0)
            return dm.div;
          return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
        };
        BN4.prototype.modn = function modn(num) {
          assert3(num <= 67108863);
          var p3 = (1 << 26) % num;
          var acc = 0;
          for (var i3 = this.length - 1; i3 >= 0; i3--) {
            acc = (p3 * acc + (this.words[i3] | 0)) % num;
          }
          return acc;
        };
        BN4.prototype.idivn = function idivn(num) {
          assert3(num <= 67108863);
          var carry = 0;
          for (var i3 = this.length - 1; i3 >= 0; i3--) {
            var w4 = (this.words[i3] | 0) + carry * 67108864;
            this.words[i3] = w4 / num | 0;
            carry = w4 % num;
          }
          return this.strip();
        };
        BN4.prototype.divn = function divn(num) {
          return this.clone().idivn(num);
        };
        BN4.prototype.egcd = function egcd(p3) {
          assert3(p3.negative === 0);
          assert3(!p3.isZero());
          var x3 = this;
          var y3 = p3.clone();
          if (x3.negative !== 0) {
            x3 = x3.umod(p3);
          } else {
            x3 = x3.clone();
          }
          var A4 = new BN4(1);
          var B2 = new BN4(0);
          var C3 = new BN4(0);
          var D3 = new BN4(1);
          var g3 = 0;
          while (x3.isEven() && y3.isEven()) {
            x3.iushrn(1);
            y3.iushrn(1);
            ++g3;
          }
          var yp = y3.clone();
          var xp = x3.clone();
          while (!x3.isZero()) {
            for (var i3 = 0, im = 1; (x3.words[0] & im) === 0 && i3 < 26; ++i3, im <<= 1)
              ;
            if (i3 > 0) {
              x3.iushrn(i3);
              while (i3-- > 0) {
                if (A4.isOdd() || B2.isOdd()) {
                  A4.iadd(yp);
                  B2.isub(xp);
                }
                A4.iushrn(1);
                B2.iushrn(1);
              }
            }
            for (var j3 = 0, jm = 1; (y3.words[0] & jm) === 0 && j3 < 26; ++j3, jm <<= 1)
              ;
            if (j3 > 0) {
              y3.iushrn(j3);
              while (j3-- > 0) {
                if (C3.isOdd() || D3.isOdd()) {
                  C3.iadd(yp);
                  D3.isub(xp);
                }
                C3.iushrn(1);
                D3.iushrn(1);
              }
            }
            if (x3.cmp(y3) >= 0) {
              x3.isub(y3);
              A4.isub(C3);
              B2.isub(D3);
            } else {
              y3.isub(x3);
              C3.isub(A4);
              D3.isub(B2);
            }
          }
          return {
            a: C3,
            b: D3,
            gcd: y3.iushln(g3)
          };
        };
        BN4.prototype._invmp = function _invmp(p3) {
          assert3(p3.negative === 0);
          assert3(!p3.isZero());
          var a3 = this;
          var b2 = p3.clone();
          if (a3.negative !== 0) {
            a3 = a3.umod(p3);
          } else {
            a3 = a3.clone();
          }
          var x1 = new BN4(1);
          var x22 = new BN4(0);
          var delta = b2.clone();
          while (a3.cmpn(1) > 0 && b2.cmpn(1) > 0) {
            for (var i3 = 0, im = 1; (a3.words[0] & im) === 0 && i3 < 26; ++i3, im <<= 1)
              ;
            if (i3 > 0) {
              a3.iushrn(i3);
              while (i3-- > 0) {
                if (x1.isOdd()) {
                  x1.iadd(delta);
                }
                x1.iushrn(1);
              }
            }
            for (var j3 = 0, jm = 1; (b2.words[0] & jm) === 0 && j3 < 26; ++j3, jm <<= 1)
              ;
            if (j3 > 0) {
              b2.iushrn(j3);
              while (j3-- > 0) {
                if (x22.isOdd()) {
                  x22.iadd(delta);
                }
                x22.iushrn(1);
              }
            }
            if (a3.cmp(b2) >= 0) {
              a3.isub(b2);
              x1.isub(x22);
            } else {
              b2.isub(a3);
              x22.isub(x1);
            }
          }
          var res;
          if (a3.cmpn(1) === 0) {
            res = x1;
          } else {
            res = x22;
          }
          if (res.cmpn(0) < 0) {
            res.iadd(p3);
          }
          return res;
        };
        BN4.prototype.gcd = function gcd(num) {
          if (this.isZero())
            return num.abs();
          if (num.isZero())
            return this.abs();
          var a3 = this.clone();
          var b2 = num.clone();
          a3.negative = 0;
          b2.negative = 0;
          for (var shift = 0; a3.isEven() && b2.isEven(); shift++) {
            a3.iushrn(1);
            b2.iushrn(1);
          }
          do {
            while (a3.isEven()) {
              a3.iushrn(1);
            }
            while (b2.isEven()) {
              b2.iushrn(1);
            }
            var r3 = a3.cmp(b2);
            if (r3 < 0) {
              var t3 = a3;
              a3 = b2;
              b2 = t3;
            } else if (r3 === 0 || b2.cmpn(1) === 0) {
              break;
            }
            a3.isub(b2);
          } while (true);
          return b2.iushln(shift);
        };
        BN4.prototype.invm = function invm(num) {
          return this.egcd(num).a.umod(num);
        };
        BN4.prototype.isEven = function isEven() {
          return (this.words[0] & 1) === 0;
        };
        BN4.prototype.isOdd = function isOdd() {
          return (this.words[0] & 1) === 1;
        };
        BN4.prototype.andln = function andln(num) {
          return this.words[0] & num;
        };
        BN4.prototype.bincn = function bincn(bit) {
          assert3(typeof bit === "number");
          var r3 = bit % 26;
          var s3 = (bit - r3) / 26;
          var q3 = 1 << r3;
          if (this.length <= s3) {
            this._expand(s3 + 1);
            this.words[s3] |= q3;
            return this;
          }
          var carry = q3;
          for (var i3 = s3; carry !== 0 && i3 < this.length; i3++) {
            var w4 = this.words[i3] | 0;
            w4 += carry;
            carry = w4 >>> 26;
            w4 &= 67108863;
            this.words[i3] = w4;
          }
          if (carry !== 0) {
            this.words[i3] = carry;
            this.length++;
          }
          return this;
        };
        BN4.prototype.isZero = function isZero() {
          return this.length === 1 && this.words[0] === 0;
        };
        BN4.prototype.cmpn = function cmpn(num) {
          var negative = num < 0;
          if (this.negative !== 0 && !negative)
            return -1;
          if (this.negative === 0 && negative)
            return 1;
          this.strip();
          var res;
          if (this.length > 1) {
            res = 1;
          } else {
            if (negative) {
              num = -num;
            }
            assert3(num <= 67108863, "Number is too big");
            var w4 = this.words[0] | 0;
            res = w4 === num ? 0 : w4 < num ? -1 : 1;
          }
          if (this.negative !== 0)
            return -res | 0;
          return res;
        };
        BN4.prototype.cmp = function cmp(num) {
          if (this.negative !== 0 && num.negative === 0)
            return -1;
          if (this.negative === 0 && num.negative !== 0)
            return 1;
          var res = this.ucmp(num);
          if (this.negative !== 0)
            return -res | 0;
          return res;
        };
        BN4.prototype.ucmp = function ucmp(num) {
          if (this.length > num.length)
            return 1;
          if (this.length < num.length)
            return -1;
          var res = 0;
          for (var i3 = this.length - 1; i3 >= 0; i3--) {
            var a3 = this.words[i3] | 0;
            var b2 = num.words[i3] | 0;
            if (a3 === b2)
              continue;
            if (a3 < b2) {
              res = -1;
            } else if (a3 > b2) {
              res = 1;
            }
            break;
          }
          return res;
        };
        BN4.prototype.gtn = function gtn(num) {
          return this.cmpn(num) === 1;
        };
        BN4.prototype.gt = function gt(num) {
          return this.cmp(num) === 1;
        };
        BN4.prototype.gten = function gten(num) {
          return this.cmpn(num) >= 0;
        };
        BN4.prototype.gte = function gte(num) {
          return this.cmp(num) >= 0;
        };
        BN4.prototype.ltn = function ltn(num) {
          return this.cmpn(num) === -1;
        };
        BN4.prototype.lt = function lt(num) {
          return this.cmp(num) === -1;
        };
        BN4.prototype.lten = function lten(num) {
          return this.cmpn(num) <= 0;
        };
        BN4.prototype.lte = function lte(num) {
          return this.cmp(num) <= 0;
        };
        BN4.prototype.eqn = function eqn(num) {
          return this.cmpn(num) === 0;
        };
        BN4.prototype.eq = function eq4(num) {
          return this.cmp(num) === 0;
        };
        BN4.red = function red(num) {
          return new Red(num);
        };
        BN4.prototype.toRed = function toRed(ctx) {
          assert3(!this.red, "Already a number in reduction context");
          assert3(this.negative === 0, "red works only with positives");
          return ctx.convertTo(this)._forceRed(ctx);
        };
        BN4.prototype.fromRed = function fromRed() {
          assert3(this.red, "fromRed works only with numbers in reduction context");
          return this.red.convertFrom(this);
        };
        BN4.prototype._forceRed = function _forceRed(ctx) {
          this.red = ctx;
          return this;
        };
        BN4.prototype.forceRed = function forceRed(ctx) {
          assert3(!this.red, "Already a number in reduction context");
          return this._forceRed(ctx);
        };
        BN4.prototype.redAdd = function redAdd(num) {
          assert3(this.red, "redAdd works only with red numbers");
          return this.red.add(this, num);
        };
        BN4.prototype.redIAdd = function redIAdd(num) {
          assert3(this.red, "redIAdd works only with red numbers");
          return this.red.iadd(this, num);
        };
        BN4.prototype.redSub = function redSub(num) {
          assert3(this.red, "redSub works only with red numbers");
          return this.red.sub(this, num);
        };
        BN4.prototype.redISub = function redISub(num) {
          assert3(this.red, "redISub works only with red numbers");
          return this.red.isub(this, num);
        };
        BN4.prototype.redShl = function redShl(num) {
          assert3(this.red, "redShl works only with red numbers");
          return this.red.shl(this, num);
        };
        BN4.prototype.redMul = function redMul(num) {
          assert3(this.red, "redMul works only with red numbers");
          this.red._verify2(this, num);
          return this.red.mul(this, num);
        };
        BN4.prototype.redIMul = function redIMul(num) {
          assert3(this.red, "redMul works only with red numbers");
          this.red._verify2(this, num);
          return this.red.imul(this, num);
        };
        BN4.prototype.redSqr = function redSqr() {
          assert3(this.red, "redSqr works only with red numbers");
          this.red._verify1(this);
          return this.red.sqr(this);
        };
        BN4.prototype.redISqr = function redISqr() {
          assert3(this.red, "redISqr works only with red numbers");
          this.red._verify1(this);
          return this.red.isqr(this);
        };
        BN4.prototype.redSqrt = function redSqrt() {
          assert3(this.red, "redSqrt works only with red numbers");
          this.red._verify1(this);
          return this.red.sqrt(this);
        };
        BN4.prototype.redInvm = function redInvm() {
          assert3(this.red, "redInvm works only with red numbers");
          this.red._verify1(this);
          return this.red.invm(this);
        };
        BN4.prototype.redNeg = function redNeg() {
          assert3(this.red, "redNeg works only with red numbers");
          this.red._verify1(this);
          return this.red.neg(this);
        };
        BN4.prototype.redPow = function redPow(num) {
          assert3(this.red && !num.red, "redPow(normalNum)");
          this.red._verify1(this);
          return this.red.pow(this, num);
        };
        var primes = {
          k256: null,
          p224: null,
          p192: null,
          p25519: null
        };
        function MPrime(name2, p3) {
          this.name = name2;
          this.p = new BN4(p3, 16);
          this.n = this.p.bitLength();
          this.k = new BN4(1).iushln(this.n).isub(this.p);
          this.tmp = this._tmp();
        }
        MPrime.prototype._tmp = function _tmp() {
          var tmp = new BN4(null);
          tmp.words = new Array(Math.ceil(this.n / 13));
          return tmp;
        };
        MPrime.prototype.ireduce = function ireduce(num) {
          var r3 = num;
          var rlen;
          do {
            this.split(r3, this.tmp);
            r3 = this.imulK(r3);
            r3 = r3.iadd(this.tmp);
            rlen = r3.bitLength();
          } while (rlen > this.n);
          var cmp = rlen < this.n ? -1 : r3.ucmp(this.p);
          if (cmp === 0) {
            r3.words[0] = 0;
            r3.length = 1;
          } else if (cmp > 0) {
            r3.isub(this.p);
          } else {
            if (r3.strip !== void 0) {
              r3.strip();
            } else {
              r3._strip();
            }
          }
          return r3;
        };
        MPrime.prototype.split = function split(input, out) {
          input.iushrn(this.n, 0, out);
        };
        MPrime.prototype.imulK = function imulK(num) {
          return num.imul(this.k);
        };
        function K256() {
          MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
        }
        inherits(K256, MPrime);
        K256.prototype.split = function split(input, output) {
          var mask = 4194303;
          var outLen = Math.min(input.length, 9);
          for (var i3 = 0; i3 < outLen; i3++) {
            output.words[i3] = input.words[i3];
          }
          output.length = outLen;
          if (input.length <= 9) {
            input.words[0] = 0;
            input.length = 1;
            return;
          }
          var prev = input.words[9];
          output.words[output.length++] = prev & mask;
          for (i3 = 10; i3 < input.length; i3++) {
            var next = input.words[i3] | 0;
            input.words[i3 - 10] = (next & mask) << 4 | prev >>> 22;
            prev = next;
          }
          prev >>>= 22;
          input.words[i3 - 10] = prev;
          if (prev === 0 && input.length > 10) {
            input.length -= 10;
          } else {
            input.length -= 9;
          }
        };
        K256.prototype.imulK = function imulK(num) {
          num.words[num.length] = 0;
          num.words[num.length + 1] = 0;
          num.length += 2;
          var lo = 0;
          for (var i3 = 0; i3 < num.length; i3++) {
            var w4 = num.words[i3] | 0;
            lo += w4 * 977;
            num.words[i3] = lo & 67108863;
            lo = w4 * 64 + (lo / 67108864 | 0);
          }
          if (num.words[num.length - 1] === 0) {
            num.length--;
            if (num.words[num.length - 1] === 0) {
              num.length--;
            }
          }
          return num;
        };
        function P224() {
          MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
        }
        inherits(P224, MPrime);
        function P192() {
          MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
        }
        inherits(P192, MPrime);
        function P25519() {
          MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
        }
        inherits(P25519, MPrime);
        P25519.prototype.imulK = function imulK(num) {
          var carry = 0;
          for (var i3 = 0; i3 < num.length; i3++) {
            var hi = (num.words[i3] | 0) * 19 + carry;
            var lo = hi & 67108863;
            hi >>>= 26;
            num.words[i3] = lo;
            carry = hi;
          }
          if (carry !== 0) {
            num.words[num.length++] = carry;
          }
          return num;
        };
        BN4._prime = function prime(name2) {
          if (primes[name2])
            return primes[name2];
          var prime2;
          if (name2 === "k256") {
            prime2 = new K256();
          } else if (name2 === "p224") {
            prime2 = new P224();
          } else if (name2 === "p192") {
            prime2 = new P192();
          } else if (name2 === "p25519") {
            prime2 = new P25519();
          } else {
            throw new Error("Unknown prime " + name2);
          }
          primes[name2] = prime2;
          return prime2;
        };
        function Red(m3) {
          if (typeof m3 === "string") {
            var prime = BN4._prime(m3);
            this.m = prime.p;
            this.prime = prime;
          } else {
            assert3(m3.gtn(1), "modulus must be greater than 1");
            this.m = m3;
            this.prime = null;
          }
        }
        Red.prototype._verify1 = function _verify1(a3) {
          assert3(a3.negative === 0, "red works only with positives");
          assert3(a3.red, "red works only with red numbers");
        };
        Red.prototype._verify2 = function _verify2(a3, b2) {
          assert3((a3.negative | b2.negative) === 0, "red works only with positives");
          assert3(a3.red && a3.red === b2.red, "red works only with red numbers");
        };
        Red.prototype.imod = function imod(a3) {
          if (this.prime)
            return this.prime.ireduce(a3)._forceRed(this);
          return a3.umod(this.m)._forceRed(this);
        };
        Red.prototype.neg = function neg3(a3) {
          if (a3.isZero()) {
            return a3.clone();
          }
          return this.m.sub(a3)._forceRed(this);
        };
        Red.prototype.add = function add3(a3, b2) {
          this._verify2(a3, b2);
          var res = a3.add(b2);
          if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
          }
          return res._forceRed(this);
        };
        Red.prototype.iadd = function iadd(a3, b2) {
          this._verify2(a3, b2);
          var res = a3.iadd(b2);
          if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
          }
          return res;
        };
        Red.prototype.sub = function sub(a3, b2) {
          this._verify2(a3, b2);
          var res = a3.sub(b2);
          if (res.cmpn(0) < 0) {
            res.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Red.prototype.isub = function isub(a3, b2) {
          this._verify2(a3, b2);
          var res = a3.isub(b2);
          if (res.cmpn(0) < 0) {
            res.iadd(this.m);
          }
          return res;
        };
        Red.prototype.shl = function shl(a3, num) {
          this._verify1(a3);
          return this.imod(a3.ushln(num));
        };
        Red.prototype.imul = function imul(a3, b2) {
          this._verify2(a3, b2);
          return this.imod(a3.imul(b2));
        };
        Red.prototype.mul = function mul3(a3, b2) {
          this._verify2(a3, b2);
          return this.imod(a3.mul(b2));
        };
        Red.prototype.isqr = function isqr(a3) {
          return this.imul(a3, a3.clone());
        };
        Red.prototype.sqr = function sqr(a3) {
          return this.mul(a3, a3);
        };
        Red.prototype.sqrt = function sqrt(a3) {
          if (a3.isZero())
            return a3.clone();
          var mod3 = this.m.andln(3);
          assert3(mod3 % 2 === 1);
          if (mod3 === 3) {
            var pow = this.m.add(new BN4(1)).iushrn(2);
            return this.pow(a3, pow);
          }
          var q3 = this.m.subn(1);
          var s3 = 0;
          while (!q3.isZero() && q3.andln(1) === 0) {
            s3++;
            q3.iushrn(1);
          }
          assert3(!q3.isZero());
          var one = new BN4(1).toRed(this);
          var nOne = one.redNeg();
          var lpow = this.m.subn(1).iushrn(1);
          var z3 = this.m.bitLength();
          z3 = new BN4(2 * z3 * z3).toRed(this);
          while (this.pow(z3, lpow).cmp(nOne) !== 0) {
            z3.redIAdd(nOne);
          }
          var c3 = this.pow(z3, q3);
          var r3 = this.pow(a3, q3.addn(1).iushrn(1));
          var t3 = this.pow(a3, q3);
          var m3 = s3;
          while (t3.cmp(one) !== 0) {
            var tmp = t3;
            for (var i3 = 0; tmp.cmp(one) !== 0; i3++) {
              tmp = tmp.redSqr();
            }
            assert3(i3 < m3);
            var b2 = this.pow(c3, new BN4(1).iushln(m3 - i3 - 1));
            r3 = r3.redMul(b2);
            c3 = b2.redSqr();
            t3 = t3.redMul(c3);
            m3 = i3;
          }
          return r3;
        };
        Red.prototype.invm = function invm(a3) {
          var inv = a3._invmp(this.m);
          if (inv.negative !== 0) {
            inv.negative = 0;
            return this.imod(inv).redNeg();
          } else {
            return this.imod(inv);
          }
        };
        Red.prototype.pow = function pow(a3, num) {
          if (num.isZero())
            return new BN4(1).toRed(this);
          if (num.cmpn(1) === 0)
            return a3.clone();
          var windowSize = 4;
          var wnd = new Array(1 << windowSize);
          wnd[0] = new BN4(1).toRed(this);
          wnd[1] = a3;
          for (var i3 = 2; i3 < wnd.length; i3++) {
            wnd[i3] = this.mul(wnd[i3 - 1], a3);
          }
          var res = wnd[0];
          var current = 0;
          var currentLen = 0;
          var start = num.bitLength() % 26;
          if (start === 0) {
            start = 26;
          }
          for (i3 = num.length - 1; i3 >= 0; i3--) {
            var word = num.words[i3];
            for (var j3 = start - 1; j3 >= 0; j3--) {
              var bit = word >> j3 & 1;
              if (res !== wnd[0]) {
                res = this.sqr(res);
              }
              if (bit === 0 && current === 0) {
                currentLen = 0;
                continue;
              }
              current <<= 1;
              current |= bit;
              currentLen++;
              if (currentLen !== windowSize && (i3 !== 0 || j3 !== 0))
                continue;
              res = this.mul(res, wnd[current]);
              currentLen = 0;
              current = 0;
            }
            start = 26;
          }
          return res;
        };
        Red.prototype.convertTo = function convertTo(num) {
          var r3 = num.umod(this.m);
          return r3 === num ? r3.clone() : r3;
        };
        Red.prototype.convertFrom = function convertFrom(num) {
          var res = num.clone();
          res.red = null;
          return res;
        };
        BN4.mont = function mont(num) {
          return new Mont(num);
        };
        function Mont(m3) {
          Red.call(this, m3);
          this.shift = this.m.bitLength();
          if (this.shift % 26 !== 0) {
            this.shift += 26 - this.shift % 26;
          }
          this.r = new BN4(1).iushln(this.shift);
          this.r2 = this.imod(this.r.sqr());
          this.rinv = this.r._invmp(this.m);
          this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
          this.minv = this.minv.umod(this.r);
          this.minv = this.r.sub(this.minv);
        }
        inherits(Mont, Red);
        Mont.prototype.convertTo = function convertTo(num) {
          return this.imod(num.ushln(this.shift));
        };
        Mont.prototype.convertFrom = function convertFrom(num) {
          var r3 = this.imod(num.mul(this.rinv));
          r3.red = null;
          return r3;
        };
        Mont.prototype.imul = function imul(a3, b2) {
          if (a3.isZero() || b2.isZero()) {
            a3.words[0] = 0;
            a3.length = 1;
            return a3;
          }
          var t3 = a3.imul(b2);
          var c3 = t3.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
          var u3 = t3.isub(c3).iushrn(this.shift);
          var res = u3;
          if (u3.cmp(this.m) >= 0) {
            res = u3.isub(this.m);
          } else if (u3.cmpn(0) < 0) {
            res = u3.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Mont.prototype.mul = function mul3(a3, b2) {
          if (a3.isZero() || b2.isZero())
            return new BN4(0)._forceRed(this);
          var t3 = a3.mul(b2);
          var c3 = t3.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
          var u3 = t3.isub(c3).iushrn(this.shift);
          var res = u3;
          if (u3.cmp(this.m) >= 0) {
            res = u3.isub(this.m);
          } else if (u3.cmpn(0) < 0) {
            res = u3.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Mont.prototype.invm = function invm(a3) {
          var res = this.imod(a3._invmp(this.m).mul(this.r2));
          return res._forceRed(this);
        };
      })(typeof module === "undefined" || module, exports);
    }
  });

  // node_modules/js-sha3/src/sha3.js
  var require_sha3 = __commonJS({
    "node_modules/js-sha3/src/sha3.js"(exports, module) {
      (function() {
        "use strict";
        var root = typeof window === "object" ? window : {};
        var NODE_JS = !root.JS_SHA3_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
        if (NODE_JS) {
          root = global;
        }
        var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && typeof module === "object" && module.exports;
        var HEX_CHARS = "0123456789abcdef".split("");
        var SHAKE_PADDING = [31, 7936, 2031616, 520093696];
        var KECCAK_PADDING = [1, 256, 65536, 16777216];
        var PADDING2 = [6, 1536, 393216, 100663296];
        var SHIFT = [0, 8, 16, 24];
        var RC = [
          1,
          0,
          32898,
          0,
          32906,
          2147483648,
          2147516416,
          2147483648,
          32907,
          0,
          2147483649,
          0,
          2147516545,
          2147483648,
          32777,
          2147483648,
          138,
          0,
          136,
          0,
          2147516425,
          0,
          2147483658,
          0,
          2147516555,
          0,
          139,
          2147483648,
          32905,
          2147483648,
          32771,
          2147483648,
          32770,
          2147483648,
          128,
          2147483648,
          32778,
          0,
          2147483658,
          2147483648,
          2147516545,
          2147483648,
          32896,
          2147483648,
          2147483649,
          0,
          2147516424,
          2147483648
        ];
        var BITS = [224, 256, 384, 512];
        var SHAKE_BITS = [128, 256];
        var OUTPUT_TYPES = ["hex", "buffer", "arrayBuffer", "array"];
        var createOutputMethod = function(bits2, padding2, outputType) {
          return function(message) {
            return new Keccak(bits2, padding2, bits2).update(message)[outputType]();
          };
        };
        var createShakeOutputMethod = function(bits2, padding2, outputType) {
          return function(message, outputBits) {
            return new Keccak(bits2, padding2, outputBits).update(message)[outputType]();
          };
        };
        var createMethod = function(bits2, padding2) {
          var method = createOutputMethod(bits2, padding2, "hex");
          method.create = function() {
            return new Keccak(bits2, padding2, bits2);
          };
          method.update = function(message) {
            return method.create().update(message);
          };
          for (var i4 = 0; i4 < OUTPUT_TYPES.length; ++i4) {
            var type = OUTPUT_TYPES[i4];
            method[type] = createOutputMethod(bits2, padding2, type);
          }
          return method;
        };
        var createShakeMethod = function(bits2, padding2) {
          var method = createShakeOutputMethod(bits2, padding2, "hex");
          method.create = function(outputBits) {
            return new Keccak(bits2, padding2, outputBits);
          };
          method.update = function(message, outputBits) {
            return method.create(outputBits).update(message);
          };
          for (var i4 = 0; i4 < OUTPUT_TYPES.length; ++i4) {
            var type = OUTPUT_TYPES[i4];
            method[type] = createShakeOutputMethod(bits2, padding2, type);
          }
          return method;
        };
        var algorithms = [
          { name: "keccak", padding: KECCAK_PADDING, bits: BITS, createMethod },
          { name: "sha3", padding: PADDING2, bits: BITS, createMethod },
          { name: "shake", padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod }
        ];
        var methods = {}, methodNames = [];
        for (var i3 = 0; i3 < algorithms.length; ++i3) {
          var algorithm = algorithms[i3];
          var bits = algorithm.bits;
          for (var j3 = 0; j3 < bits.length; ++j3) {
            var methodName = algorithm.name + "_" + bits[j3];
            methodNames.push(methodName);
            methods[methodName] = algorithm.createMethod(bits[j3], algorithm.padding);
          }
        }
        function Keccak(bits2, padding2, outputBits) {
          this.blocks = [];
          this.s = [];
          this.padding = padding2;
          this.outputBits = outputBits;
          this.reset = true;
          this.block = 0;
          this.start = 0;
          this.blockCount = 1600 - (bits2 << 1) >> 5;
          this.byteCount = this.blockCount << 2;
          this.outputBlocks = outputBits >> 5;
          this.extraBytes = (outputBits & 31) >> 3;
          for (var i4 = 0; i4 < 50; ++i4) {
            this.s[i4] = 0;
          }
        }
        Keccak.prototype.update = function(message) {
          var notString = typeof message !== "string";
          if (notString && message.constructor === ArrayBuffer) {
            message = new Uint8Array(message);
          }
          var length = message.length, blocks = this.blocks, byteCount = this.byteCount, blockCount = this.blockCount, index = 0, s3 = this.s, i4, code;
          while (index < length) {
            if (this.reset) {
              this.reset = false;
              blocks[0] = this.block;
              for (i4 = 1; i4 < blockCount + 1; ++i4) {
                blocks[i4] = 0;
              }
            }
            if (notString) {
              for (i4 = this.start; index < length && i4 < byteCount; ++index) {
                blocks[i4 >> 2] |= message[index] << SHIFT[i4++ & 3];
              }
            } else {
              for (i4 = this.start; index < length && i4 < byteCount; ++index) {
                code = message.charCodeAt(index);
                if (code < 128) {
                  blocks[i4 >> 2] |= code << SHIFT[i4++ & 3];
                } else if (code < 2048) {
                  blocks[i4 >> 2] |= (192 | code >> 6) << SHIFT[i4++ & 3];
                  blocks[i4 >> 2] |= (128 | code & 63) << SHIFT[i4++ & 3];
                } else if (code < 55296 || code >= 57344) {
                  blocks[i4 >> 2] |= (224 | code >> 12) << SHIFT[i4++ & 3];
                  blocks[i4 >> 2] |= (128 | code >> 6 & 63) << SHIFT[i4++ & 3];
                  blocks[i4 >> 2] |= (128 | code & 63) << SHIFT[i4++ & 3];
                } else {
                  code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
                  blocks[i4 >> 2] |= (240 | code >> 18) << SHIFT[i4++ & 3];
                  blocks[i4 >> 2] |= (128 | code >> 12 & 63) << SHIFT[i4++ & 3];
                  blocks[i4 >> 2] |= (128 | code >> 6 & 63) << SHIFT[i4++ & 3];
                  blocks[i4 >> 2] |= (128 | code & 63) << SHIFT[i4++ & 3];
                }
              }
            }
            this.lastByteIndex = i4;
            if (i4 >= byteCount) {
              this.start = i4 - byteCount;
              this.block = blocks[blockCount];
              for (i4 = 0; i4 < blockCount; ++i4) {
                s3[i4] ^= blocks[i4];
              }
              f3(s3);
              this.reset = true;
            } else {
              this.start = i4;
            }
          }
          return this;
        };
        Keccak.prototype.finalize = function() {
          var blocks = this.blocks, i4 = this.lastByteIndex, blockCount = this.blockCount, s3 = this.s;
          blocks[i4 >> 2] |= this.padding[i4 & 3];
          if (this.lastByteIndex === this.byteCount) {
            blocks[0] = blocks[blockCount];
            for (i4 = 1; i4 < blockCount + 1; ++i4) {
              blocks[i4] = 0;
            }
          }
          blocks[blockCount - 1] |= 2147483648;
          for (i4 = 0; i4 < blockCount; ++i4) {
            s3[i4] ^= blocks[i4];
          }
          f3(s3);
        };
        Keccak.prototype.toString = Keccak.prototype.hex = function() {
          this.finalize();
          var blockCount = this.blockCount, s3 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i4 = 0, j4 = 0;
          var hex2 = "", block;
          while (j4 < outputBlocks) {
            for (i4 = 0; i4 < blockCount && j4 < outputBlocks; ++i4, ++j4) {
              block = s3[i4];
              hex2 += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15] + HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15] + HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15] + HEX_CHARS[block >> 28 & 15] + HEX_CHARS[block >> 24 & 15];
            }
            if (j4 % blockCount === 0) {
              f3(s3);
              i4 = 0;
            }
          }
          if (extraBytes) {
            block = s3[i4];
            if (extraBytes > 0) {
              hex2 += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15];
            }
            if (extraBytes > 1) {
              hex2 += HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15];
            }
            if (extraBytes > 2) {
              hex2 += HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15];
            }
          }
          return hex2;
        };
        Keccak.prototype.arrayBuffer = function() {
          this.finalize();
          var blockCount = this.blockCount, s3 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i4 = 0, j4 = 0;
          var bytes = this.outputBits >> 3;
          var buffer;
          if (extraBytes) {
            buffer = new ArrayBuffer(outputBlocks + 1 << 2);
          } else {
            buffer = new ArrayBuffer(bytes);
          }
          var array = new Uint32Array(buffer);
          while (j4 < outputBlocks) {
            for (i4 = 0; i4 < blockCount && j4 < outputBlocks; ++i4, ++j4) {
              array[j4] = s3[i4];
            }
            if (j4 % blockCount === 0) {
              f3(s3);
            }
          }
          if (extraBytes) {
            array[i4] = s3[i4];
            buffer = buffer.slice(0, bytes);
          }
          return buffer;
        };
        Keccak.prototype.buffer = Keccak.prototype.arrayBuffer;
        Keccak.prototype.digest = Keccak.prototype.array = function() {
          this.finalize();
          var blockCount = this.blockCount, s3 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i4 = 0, j4 = 0;
          var array = [], offset, block;
          while (j4 < outputBlocks) {
            for (i4 = 0; i4 < blockCount && j4 < outputBlocks; ++i4, ++j4) {
              offset = j4 << 2;
              block = s3[i4];
              array[offset] = block & 255;
              array[offset + 1] = block >> 8 & 255;
              array[offset + 2] = block >> 16 & 255;
              array[offset + 3] = block >> 24 & 255;
            }
            if (j4 % blockCount === 0) {
              f3(s3);
            }
          }
          if (extraBytes) {
            offset = j4 << 2;
            block = s3[i4];
            if (extraBytes > 0) {
              array[offset] = block & 255;
            }
            if (extraBytes > 1) {
              array[offset + 1] = block >> 8 & 255;
            }
            if (extraBytes > 2) {
              array[offset + 2] = block >> 16 & 255;
            }
          }
          return array;
        };
        var f3 = function(s3) {
          var h3, l3, n2, c0, c1, c22, c3, c4, c5, c6, c7, c8, c9, b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33, b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
          for (n2 = 0; n2 < 48; n2 += 2) {
            c0 = s3[0] ^ s3[10] ^ s3[20] ^ s3[30] ^ s3[40];
            c1 = s3[1] ^ s3[11] ^ s3[21] ^ s3[31] ^ s3[41];
            c22 = s3[2] ^ s3[12] ^ s3[22] ^ s3[32] ^ s3[42];
            c3 = s3[3] ^ s3[13] ^ s3[23] ^ s3[33] ^ s3[43];
            c4 = s3[4] ^ s3[14] ^ s3[24] ^ s3[34] ^ s3[44];
            c5 = s3[5] ^ s3[15] ^ s3[25] ^ s3[35] ^ s3[45];
            c6 = s3[6] ^ s3[16] ^ s3[26] ^ s3[36] ^ s3[46];
            c7 = s3[7] ^ s3[17] ^ s3[27] ^ s3[37] ^ s3[47];
            c8 = s3[8] ^ s3[18] ^ s3[28] ^ s3[38] ^ s3[48];
            c9 = s3[9] ^ s3[19] ^ s3[29] ^ s3[39] ^ s3[49];
            h3 = c8 ^ (c22 << 1 | c3 >>> 31);
            l3 = c9 ^ (c3 << 1 | c22 >>> 31);
            s3[0] ^= h3;
            s3[1] ^= l3;
            s3[10] ^= h3;
            s3[11] ^= l3;
            s3[20] ^= h3;
            s3[21] ^= l3;
            s3[30] ^= h3;
            s3[31] ^= l3;
            s3[40] ^= h3;
            s3[41] ^= l3;
            h3 = c0 ^ (c4 << 1 | c5 >>> 31);
            l3 = c1 ^ (c5 << 1 | c4 >>> 31);
            s3[2] ^= h3;
            s3[3] ^= l3;
            s3[12] ^= h3;
            s3[13] ^= l3;
            s3[22] ^= h3;
            s3[23] ^= l3;
            s3[32] ^= h3;
            s3[33] ^= l3;
            s3[42] ^= h3;
            s3[43] ^= l3;
            h3 = c22 ^ (c6 << 1 | c7 >>> 31);
            l3 = c3 ^ (c7 << 1 | c6 >>> 31);
            s3[4] ^= h3;
            s3[5] ^= l3;
            s3[14] ^= h3;
            s3[15] ^= l3;
            s3[24] ^= h3;
            s3[25] ^= l3;
            s3[34] ^= h3;
            s3[35] ^= l3;
            s3[44] ^= h3;
            s3[45] ^= l3;
            h3 = c4 ^ (c8 << 1 | c9 >>> 31);
            l3 = c5 ^ (c9 << 1 | c8 >>> 31);
            s3[6] ^= h3;
            s3[7] ^= l3;
            s3[16] ^= h3;
            s3[17] ^= l3;
            s3[26] ^= h3;
            s3[27] ^= l3;
            s3[36] ^= h3;
            s3[37] ^= l3;
            s3[46] ^= h3;
            s3[47] ^= l3;
            h3 = c6 ^ (c0 << 1 | c1 >>> 31);
            l3 = c7 ^ (c1 << 1 | c0 >>> 31);
            s3[8] ^= h3;
            s3[9] ^= l3;
            s3[18] ^= h3;
            s3[19] ^= l3;
            s3[28] ^= h3;
            s3[29] ^= l3;
            s3[38] ^= h3;
            s3[39] ^= l3;
            s3[48] ^= h3;
            s3[49] ^= l3;
            b0 = s3[0];
            b1 = s3[1];
            b32 = s3[11] << 4 | s3[10] >>> 28;
            b33 = s3[10] << 4 | s3[11] >>> 28;
            b14 = s3[20] << 3 | s3[21] >>> 29;
            b15 = s3[21] << 3 | s3[20] >>> 29;
            b46 = s3[31] << 9 | s3[30] >>> 23;
            b47 = s3[30] << 9 | s3[31] >>> 23;
            b28 = s3[40] << 18 | s3[41] >>> 14;
            b29 = s3[41] << 18 | s3[40] >>> 14;
            b20 = s3[2] << 1 | s3[3] >>> 31;
            b21 = s3[3] << 1 | s3[2] >>> 31;
            b2 = s3[13] << 12 | s3[12] >>> 20;
            b3 = s3[12] << 12 | s3[13] >>> 20;
            b34 = s3[22] << 10 | s3[23] >>> 22;
            b35 = s3[23] << 10 | s3[22] >>> 22;
            b16 = s3[33] << 13 | s3[32] >>> 19;
            b17 = s3[32] << 13 | s3[33] >>> 19;
            b48 = s3[42] << 2 | s3[43] >>> 30;
            b49 = s3[43] << 2 | s3[42] >>> 30;
            b40 = s3[5] << 30 | s3[4] >>> 2;
            b41 = s3[4] << 30 | s3[5] >>> 2;
            b22 = s3[14] << 6 | s3[15] >>> 26;
            b23 = s3[15] << 6 | s3[14] >>> 26;
            b4 = s3[25] << 11 | s3[24] >>> 21;
            b5 = s3[24] << 11 | s3[25] >>> 21;
            b36 = s3[34] << 15 | s3[35] >>> 17;
            b37 = s3[35] << 15 | s3[34] >>> 17;
            b18 = s3[45] << 29 | s3[44] >>> 3;
            b19 = s3[44] << 29 | s3[45] >>> 3;
            b10 = s3[6] << 28 | s3[7] >>> 4;
            b11 = s3[7] << 28 | s3[6] >>> 4;
            b42 = s3[17] << 23 | s3[16] >>> 9;
            b43 = s3[16] << 23 | s3[17] >>> 9;
            b24 = s3[26] << 25 | s3[27] >>> 7;
            b25 = s3[27] << 25 | s3[26] >>> 7;
            b6 = s3[36] << 21 | s3[37] >>> 11;
            b7 = s3[37] << 21 | s3[36] >>> 11;
            b38 = s3[47] << 24 | s3[46] >>> 8;
            b39 = s3[46] << 24 | s3[47] >>> 8;
            b30 = s3[8] << 27 | s3[9] >>> 5;
            b31 = s3[9] << 27 | s3[8] >>> 5;
            b12 = s3[18] << 20 | s3[19] >>> 12;
            b13 = s3[19] << 20 | s3[18] >>> 12;
            b44 = s3[29] << 7 | s3[28] >>> 25;
            b45 = s3[28] << 7 | s3[29] >>> 25;
            b26 = s3[38] << 8 | s3[39] >>> 24;
            b27 = s3[39] << 8 | s3[38] >>> 24;
            b8 = s3[48] << 14 | s3[49] >>> 18;
            b9 = s3[49] << 14 | s3[48] >>> 18;
            s3[0] = b0 ^ ~b2 & b4;
            s3[1] = b1 ^ ~b3 & b5;
            s3[10] = b10 ^ ~b12 & b14;
            s3[11] = b11 ^ ~b13 & b15;
            s3[20] = b20 ^ ~b22 & b24;
            s3[21] = b21 ^ ~b23 & b25;
            s3[30] = b30 ^ ~b32 & b34;
            s3[31] = b31 ^ ~b33 & b35;
            s3[40] = b40 ^ ~b42 & b44;
            s3[41] = b41 ^ ~b43 & b45;
            s3[2] = b2 ^ ~b4 & b6;
            s3[3] = b3 ^ ~b5 & b7;
            s3[12] = b12 ^ ~b14 & b16;
            s3[13] = b13 ^ ~b15 & b17;
            s3[22] = b22 ^ ~b24 & b26;
            s3[23] = b23 ^ ~b25 & b27;
            s3[32] = b32 ^ ~b34 & b36;
            s3[33] = b33 ^ ~b35 & b37;
            s3[42] = b42 ^ ~b44 & b46;
            s3[43] = b43 ^ ~b45 & b47;
            s3[4] = b4 ^ ~b6 & b8;
            s3[5] = b5 ^ ~b7 & b9;
            s3[14] = b14 ^ ~b16 & b18;
            s3[15] = b15 ^ ~b17 & b19;
            s3[24] = b24 ^ ~b26 & b28;
            s3[25] = b25 ^ ~b27 & b29;
            s3[34] = b34 ^ ~b36 & b38;
            s3[35] = b35 ^ ~b37 & b39;
            s3[44] = b44 ^ ~b46 & b48;
            s3[45] = b45 ^ ~b47 & b49;
            s3[6] = b6 ^ ~b8 & b0;
            s3[7] = b7 ^ ~b9 & b1;
            s3[16] = b16 ^ ~b18 & b10;
            s3[17] = b17 ^ ~b19 & b11;
            s3[26] = b26 ^ ~b28 & b20;
            s3[27] = b27 ^ ~b29 & b21;
            s3[36] = b36 ^ ~b38 & b30;
            s3[37] = b37 ^ ~b39 & b31;
            s3[46] = b46 ^ ~b48 & b40;
            s3[47] = b47 ^ ~b49 & b41;
            s3[8] = b8 ^ ~b0 & b2;
            s3[9] = b9 ^ ~b1 & b3;
            s3[18] = b18 ^ ~b10 & b12;
            s3[19] = b19 ^ ~b11 & b13;
            s3[28] = b28 ^ ~b20 & b22;
            s3[29] = b29 ^ ~b21 & b23;
            s3[38] = b38 ^ ~b30 & b32;
            s3[39] = b39 ^ ~b31 & b33;
            s3[48] = b48 ^ ~b40 & b42;
            s3[49] = b49 ^ ~b41 & b43;
            s3[0] ^= RC[n2];
            s3[1] ^= RC[n2 + 1];
          }
        };
        if (COMMON_JS) {
          module.exports = methods;
        } else {
          for (var i3 = 0; i3 < methodNames.length; ++i3) {
            root[methodNames[i3]] = methods[methodNames[i3]];
          }
        }
      })();
    }
  });

  // node_modules/minimalistic-assert/index.js
  var require_minimalistic_assert = __commonJS({
    "node_modules/minimalistic-assert/index.js"(exports, module) {
      module.exports = assert3;
      function assert3(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      assert3.equal = function assertEqual2(l3, r3, msg) {
        if (l3 != r3)
          throw new Error(msg || "Assertion failed: " + l3 + " != " + r3);
      };
    }
  });

  // node_modules/inherits/inherits_browser.js
  var require_inherits_browser = __commonJS({
    "node_modules/inherits/inherits_browser.js"(exports, module) {
      if (typeof Object.create === "function") {
        module.exports = function inherits(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            ctor.prototype = Object.create(superCtor.prototype, {
              constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
          }
        };
      } else {
        module.exports = function inherits(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            var TempCtor = function() {
            };
            TempCtor.prototype = superCtor.prototype;
            ctor.prototype = new TempCtor();
            ctor.prototype.constructor = ctor;
          }
        };
      }
    }
  });

  // node_modules/hash.js/lib/hash/utils.js
  var require_utils = __commonJS({
    "node_modules/hash.js/lib/hash/utils.js"(exports) {
      "use strict";
      var assert3 = require_minimalistic_assert();
      var inherits = require_inherits_browser();
      exports.inherits = inherits;
      function isSurrogatePair(msg, i3) {
        if ((msg.charCodeAt(i3) & 64512) !== 55296) {
          return false;
        }
        if (i3 < 0 || i3 + 1 >= msg.length) {
          return false;
        }
        return (msg.charCodeAt(i3 + 1) & 64512) === 56320;
      }
      function toArray(msg, enc) {
        if (Array.isArray(msg))
          return msg.slice();
        if (!msg)
          return [];
        var res = [];
        if (typeof msg === "string") {
          if (!enc) {
            var p3 = 0;
            for (var i3 = 0; i3 < msg.length; i3++) {
              var c3 = msg.charCodeAt(i3);
              if (c3 < 128) {
                res[p3++] = c3;
              } else if (c3 < 2048) {
                res[p3++] = c3 >> 6 | 192;
                res[p3++] = c3 & 63 | 128;
              } else if (isSurrogatePair(msg, i3)) {
                c3 = 65536 + ((c3 & 1023) << 10) + (msg.charCodeAt(++i3) & 1023);
                res[p3++] = c3 >> 18 | 240;
                res[p3++] = c3 >> 12 & 63 | 128;
                res[p3++] = c3 >> 6 & 63 | 128;
                res[p3++] = c3 & 63 | 128;
              } else {
                res[p3++] = c3 >> 12 | 224;
                res[p3++] = c3 >> 6 & 63 | 128;
                res[p3++] = c3 & 63 | 128;
              }
            }
          } else if (enc === "hex") {
            msg = msg.replace(/[^a-z0-9]+/ig, "");
            if (msg.length % 2 !== 0)
              msg = "0" + msg;
            for (i3 = 0; i3 < msg.length; i3 += 2)
              res.push(parseInt(msg[i3] + msg[i3 + 1], 16));
          }
        } else {
          for (i3 = 0; i3 < msg.length; i3++)
            res[i3] = msg[i3] | 0;
        }
        return res;
      }
      exports.toArray = toArray;
      function toHex2(msg) {
        var res = "";
        for (var i3 = 0; i3 < msg.length; i3++)
          res += zero2(msg[i3].toString(16));
        return res;
      }
      exports.toHex = toHex2;
      function htonl(w4) {
        var res = w4 >>> 24 | w4 >>> 8 & 65280 | w4 << 8 & 16711680 | (w4 & 255) << 24;
        return res >>> 0;
      }
      exports.htonl = htonl;
      function toHex32(msg, endian) {
        var res = "";
        for (var i3 = 0; i3 < msg.length; i3++) {
          var w4 = msg[i3];
          if (endian === "little")
            w4 = htonl(w4);
          res += zero8(w4.toString(16));
        }
        return res;
      }
      exports.toHex32 = toHex32;
      function zero2(word) {
        if (word.length === 1)
          return "0" + word;
        else
          return word;
      }
      exports.zero2 = zero2;
      function zero8(word) {
        if (word.length === 7)
          return "0" + word;
        else if (word.length === 6)
          return "00" + word;
        else if (word.length === 5)
          return "000" + word;
        else if (word.length === 4)
          return "0000" + word;
        else if (word.length === 3)
          return "00000" + word;
        else if (word.length === 2)
          return "000000" + word;
        else if (word.length === 1)
          return "0000000" + word;
        else
          return word;
      }
      exports.zero8 = zero8;
      function join32(msg, start, end, endian) {
        var len = end - start;
        assert3(len % 4 === 0);
        var res = new Array(len / 4);
        for (var i3 = 0, k3 = start; i3 < res.length; i3++, k3 += 4) {
          var w4;
          if (endian === "big")
            w4 = msg[k3] << 24 | msg[k3 + 1] << 16 | msg[k3 + 2] << 8 | msg[k3 + 3];
          else
            w4 = msg[k3 + 3] << 24 | msg[k3 + 2] << 16 | msg[k3 + 1] << 8 | msg[k3];
          res[i3] = w4 >>> 0;
        }
        return res;
      }
      exports.join32 = join32;
      function split32(msg, endian) {
        var res = new Array(msg.length * 4);
        for (var i3 = 0, k3 = 0; i3 < msg.length; i3++, k3 += 4) {
          var m3 = msg[i3];
          if (endian === "big") {
            res[k3] = m3 >>> 24;
            res[k3 + 1] = m3 >>> 16 & 255;
            res[k3 + 2] = m3 >>> 8 & 255;
            res[k3 + 3] = m3 & 255;
          } else {
            res[k3 + 3] = m3 >>> 24;
            res[k3 + 2] = m3 >>> 16 & 255;
            res[k3 + 1] = m3 >>> 8 & 255;
            res[k3] = m3 & 255;
          }
        }
        return res;
      }
      exports.split32 = split32;
      function rotr32(w4, b2) {
        return w4 >>> b2 | w4 << 32 - b2;
      }
      exports.rotr32 = rotr32;
      function rotl32(w4, b2) {
        return w4 << b2 | w4 >>> 32 - b2;
      }
      exports.rotl32 = rotl32;
      function sum32(a3, b2) {
        return a3 + b2 >>> 0;
      }
      exports.sum32 = sum32;
      function sum32_3(a3, b2, c3) {
        return a3 + b2 + c3 >>> 0;
      }
      exports.sum32_3 = sum32_3;
      function sum32_4(a3, b2, c3, d3) {
        return a3 + b2 + c3 + d3 >>> 0;
      }
      exports.sum32_4 = sum32_4;
      function sum32_5(a3, b2, c3, d3, e3) {
        return a3 + b2 + c3 + d3 + e3 >>> 0;
      }
      exports.sum32_5 = sum32_5;
      function sum64(buf, pos, ah, al) {
        var bh = buf[pos];
        var bl = buf[pos + 1];
        var lo = al + bl >>> 0;
        var hi = (lo < al ? 1 : 0) + ah + bh;
        buf[pos] = hi >>> 0;
        buf[pos + 1] = lo;
      }
      exports.sum64 = sum64;
      function sum64_hi(ah, al, bh, bl) {
        var lo = al + bl >>> 0;
        var hi = (lo < al ? 1 : 0) + ah + bh;
        return hi >>> 0;
      }
      exports.sum64_hi = sum64_hi;
      function sum64_lo(ah, al, bh, bl) {
        var lo = al + bl;
        return lo >>> 0;
      }
      exports.sum64_lo = sum64_lo;
      function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
        var carry = 0;
        var lo = al;
        lo = lo + bl >>> 0;
        carry += lo < al ? 1 : 0;
        lo = lo + cl >>> 0;
        carry += lo < cl ? 1 : 0;
        lo = lo + dl >>> 0;
        carry += lo < dl ? 1 : 0;
        var hi = ah + bh + ch + dh + carry;
        return hi >>> 0;
      }
      exports.sum64_4_hi = sum64_4_hi;
      function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
        var lo = al + bl + cl + dl;
        return lo >>> 0;
      }
      exports.sum64_4_lo = sum64_4_lo;
      function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
        var carry = 0;
        var lo = al;
        lo = lo + bl >>> 0;
        carry += lo < al ? 1 : 0;
        lo = lo + cl >>> 0;
        carry += lo < cl ? 1 : 0;
        lo = lo + dl >>> 0;
        carry += lo < dl ? 1 : 0;
        lo = lo + el >>> 0;
        carry += lo < el ? 1 : 0;
        var hi = ah + bh + ch + dh + eh + carry;
        return hi >>> 0;
      }
      exports.sum64_5_hi = sum64_5_hi;
      function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
        var lo = al + bl + cl + dl + el;
        return lo >>> 0;
      }
      exports.sum64_5_lo = sum64_5_lo;
      function rotr64_hi(ah, al, num) {
        var r3 = al << 32 - num | ah >>> num;
        return r3 >>> 0;
      }
      exports.rotr64_hi = rotr64_hi;
      function rotr64_lo(ah, al, num) {
        var r3 = ah << 32 - num | al >>> num;
        return r3 >>> 0;
      }
      exports.rotr64_lo = rotr64_lo;
      function shr64_hi(ah, al, num) {
        return ah >>> num;
      }
      exports.shr64_hi = shr64_hi;
      function shr64_lo(ah, al, num) {
        var r3 = ah << 32 - num | al >>> num;
        return r3 >>> 0;
      }
      exports.shr64_lo = shr64_lo;
    }
  });

  // node_modules/hash.js/lib/hash/common.js
  var require_common = __commonJS({
    "node_modules/hash.js/lib/hash/common.js"(exports) {
      "use strict";
      var utils = require_utils();
      var assert3 = require_minimalistic_assert();
      function BlockHash() {
        this.pending = null;
        this.pendingTotal = 0;
        this.blockSize = this.constructor.blockSize;
        this.outSize = this.constructor.outSize;
        this.hmacStrength = this.constructor.hmacStrength;
        this.padLength = this.constructor.padLength / 8;
        this.endian = "big";
        this._delta8 = this.blockSize / 8;
        this._delta32 = this.blockSize / 32;
      }
      exports.BlockHash = BlockHash;
      BlockHash.prototype.update = function update2(msg, enc) {
        msg = utils.toArray(msg, enc);
        if (!this.pending)
          this.pending = msg;
        else
          this.pending = this.pending.concat(msg);
        this.pendingTotal += msg.length;
        if (this.pending.length >= this._delta8) {
          msg = this.pending;
          var r3 = msg.length % this._delta8;
          this.pending = msg.slice(msg.length - r3, msg.length);
          if (this.pending.length === 0)
            this.pending = null;
          msg = utils.join32(msg, 0, msg.length - r3, this.endian);
          for (var i3 = 0; i3 < msg.length; i3 += this._delta32)
            this._update(msg, i3, i3 + this._delta32);
        }
        return this;
      };
      BlockHash.prototype.digest = function digest(enc) {
        this.update(this._pad());
        assert3(this.pending === null);
        return this._digest(enc);
      };
      BlockHash.prototype._pad = function pad() {
        var len = this.pendingTotal;
        var bytes = this._delta8;
        var k3 = bytes - (len + this.padLength) % bytes;
        var res = new Array(k3 + this.padLength);
        res[0] = 128;
        for (var i3 = 1; i3 < k3; i3++)
          res[i3] = 0;
        len <<= 3;
        if (this.endian === "big") {
          for (var t3 = 8; t3 < this.padLength; t3++)
            res[i3++] = 0;
          res[i3++] = 0;
          res[i3++] = 0;
          res[i3++] = 0;
          res[i3++] = 0;
          res[i3++] = len >>> 24 & 255;
          res[i3++] = len >>> 16 & 255;
          res[i3++] = len >>> 8 & 255;
          res[i3++] = len & 255;
        } else {
          res[i3++] = len & 255;
          res[i3++] = len >>> 8 & 255;
          res[i3++] = len >>> 16 & 255;
          res[i3++] = len >>> 24 & 255;
          res[i3++] = 0;
          res[i3++] = 0;
          res[i3++] = 0;
          res[i3++] = 0;
          for (t3 = 8; t3 < this.padLength; t3++)
            res[i3++] = 0;
        }
        return res;
      };
    }
  });

  // node_modules/hash.js/lib/hash/sha/common.js
  var require_common2 = __commonJS({
    "node_modules/hash.js/lib/hash/sha/common.js"(exports) {
      "use strict";
      var utils = require_utils();
      var rotr32 = utils.rotr32;
      function ft_1(s3, x3, y3, z3) {
        if (s3 === 0)
          return ch32(x3, y3, z3);
        if (s3 === 1 || s3 === 3)
          return p32(x3, y3, z3);
        if (s3 === 2)
          return maj32(x3, y3, z3);
      }
      exports.ft_1 = ft_1;
      function ch32(x3, y3, z3) {
        return x3 & y3 ^ ~x3 & z3;
      }
      exports.ch32 = ch32;
      function maj32(x3, y3, z3) {
        return x3 & y3 ^ x3 & z3 ^ y3 & z3;
      }
      exports.maj32 = maj32;
      function p32(x3, y3, z3) {
        return x3 ^ y3 ^ z3;
      }
      exports.p32 = p32;
      function s0_256(x3) {
        return rotr32(x3, 2) ^ rotr32(x3, 13) ^ rotr32(x3, 22);
      }
      exports.s0_256 = s0_256;
      function s1_256(x3) {
        return rotr32(x3, 6) ^ rotr32(x3, 11) ^ rotr32(x3, 25);
      }
      exports.s1_256 = s1_256;
      function g0_256(x3) {
        return rotr32(x3, 7) ^ rotr32(x3, 18) ^ x3 >>> 3;
      }
      exports.g0_256 = g0_256;
      function g1_256(x3) {
        return rotr32(x3, 17) ^ rotr32(x3, 19) ^ x3 >>> 10;
      }
      exports.g1_256 = g1_256;
    }
  });

  // node_modules/hash.js/lib/hash/sha/1.js
  var require__ = __commonJS({
    "node_modules/hash.js/lib/hash/sha/1.js"(exports, module) {
      "use strict";
      var utils = require_utils();
      var common = require_common();
      var shaCommon = require_common2();
      var rotl32 = utils.rotl32;
      var sum32 = utils.sum32;
      var sum32_5 = utils.sum32_5;
      var ft_1 = shaCommon.ft_1;
      var BlockHash = common.BlockHash;
      var sha1_K = [
        1518500249,
        1859775393,
        2400959708,
        3395469782
      ];
      function SHA1() {
        if (!(this instanceof SHA1))
          return new SHA1();
        BlockHash.call(this);
        this.h = [
          1732584193,
          4023233417,
          2562383102,
          271733878,
          3285377520
        ];
        this.W = new Array(80);
      }
      utils.inherits(SHA1, BlockHash);
      module.exports = SHA1;
      SHA1.blockSize = 512;
      SHA1.outSize = 160;
      SHA1.hmacStrength = 80;
      SHA1.padLength = 64;
      SHA1.prototype._update = function _update(msg, start) {
        var W2 = this.W;
        for (var i3 = 0; i3 < 16; i3++)
          W2[i3] = msg[start + i3];
        for (; i3 < W2.length; i3++)
          W2[i3] = rotl32(W2[i3 - 3] ^ W2[i3 - 8] ^ W2[i3 - 14] ^ W2[i3 - 16], 1);
        var a3 = this.h[0];
        var b2 = this.h[1];
        var c3 = this.h[2];
        var d3 = this.h[3];
        var e3 = this.h[4];
        for (i3 = 0; i3 < W2.length; i3++) {
          var s3 = ~~(i3 / 20);
          var t3 = sum32_5(rotl32(a3, 5), ft_1(s3, b2, c3, d3), e3, W2[i3], sha1_K[s3]);
          e3 = d3;
          d3 = c3;
          c3 = rotl32(b2, 30);
          b2 = a3;
          a3 = t3;
        }
        this.h[0] = sum32(this.h[0], a3);
        this.h[1] = sum32(this.h[1], b2);
        this.h[2] = sum32(this.h[2], c3);
        this.h[3] = sum32(this.h[3], d3);
        this.h[4] = sum32(this.h[4], e3);
      };
      SHA1.prototype._digest = function digest(enc) {
        if (enc === "hex")
          return utils.toHex32(this.h, "big");
        else
          return utils.split32(this.h, "big");
      };
    }
  });

  // node_modules/hash.js/lib/hash/sha/256.js
  var require__2 = __commonJS({
    "node_modules/hash.js/lib/hash/sha/256.js"(exports, module) {
      "use strict";
      var utils = require_utils();
      var common = require_common();
      var shaCommon = require_common2();
      var assert3 = require_minimalistic_assert();
      var sum32 = utils.sum32;
      var sum32_4 = utils.sum32_4;
      var sum32_5 = utils.sum32_5;
      var ch32 = shaCommon.ch32;
      var maj32 = shaCommon.maj32;
      var s0_256 = shaCommon.s0_256;
      var s1_256 = shaCommon.s1_256;
      var g0_256 = shaCommon.g0_256;
      var g1_256 = shaCommon.g1_256;
      var BlockHash = common.BlockHash;
      var sha256_K = [
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
      ];
      function SHA256() {
        if (!(this instanceof SHA256))
          return new SHA256();
        BlockHash.call(this);
        this.h = [
          1779033703,
          3144134277,
          1013904242,
          2773480762,
          1359893119,
          2600822924,
          528734635,
          1541459225
        ];
        this.k = sha256_K;
        this.W = new Array(64);
      }
      utils.inherits(SHA256, BlockHash);
      module.exports = SHA256;
      SHA256.blockSize = 512;
      SHA256.outSize = 256;
      SHA256.hmacStrength = 192;
      SHA256.padLength = 64;
      SHA256.prototype._update = function _update(msg, start) {
        var W2 = this.W;
        for (var i3 = 0; i3 < 16; i3++)
          W2[i3] = msg[start + i3];
        for (; i3 < W2.length; i3++)
          W2[i3] = sum32_4(g1_256(W2[i3 - 2]), W2[i3 - 7], g0_256(W2[i3 - 15]), W2[i3 - 16]);
        var a3 = this.h[0];
        var b2 = this.h[1];
        var c3 = this.h[2];
        var d3 = this.h[3];
        var e3 = this.h[4];
        var f3 = this.h[5];
        var g3 = this.h[6];
        var h3 = this.h[7];
        assert3(this.k.length === W2.length);
        for (i3 = 0; i3 < W2.length; i3++) {
          var T1 = sum32_5(h3, s1_256(e3), ch32(e3, f3, g3), this.k[i3], W2[i3]);
          var T22 = sum32(s0_256(a3), maj32(a3, b2, c3));
          h3 = g3;
          g3 = f3;
          f3 = e3;
          e3 = sum32(d3, T1);
          d3 = c3;
          c3 = b2;
          b2 = a3;
          a3 = sum32(T1, T22);
        }
        this.h[0] = sum32(this.h[0], a3);
        this.h[1] = sum32(this.h[1], b2);
        this.h[2] = sum32(this.h[2], c3);
        this.h[3] = sum32(this.h[3], d3);
        this.h[4] = sum32(this.h[4], e3);
        this.h[5] = sum32(this.h[5], f3);
        this.h[6] = sum32(this.h[6], g3);
        this.h[7] = sum32(this.h[7], h3);
      };
      SHA256.prototype._digest = function digest(enc) {
        if (enc === "hex")
          return utils.toHex32(this.h, "big");
        else
          return utils.split32(this.h, "big");
      };
    }
  });

  // node_modules/hash.js/lib/hash/sha/224.js
  var require__3 = __commonJS({
    "node_modules/hash.js/lib/hash/sha/224.js"(exports, module) {
      "use strict";
      var utils = require_utils();
      var SHA256 = require__2();
      function SHA224() {
        if (!(this instanceof SHA224))
          return new SHA224();
        SHA256.call(this);
        this.h = [
          3238371032,
          914150663,
          812702999,
          4144912697,
          4290775857,
          1750603025,
          1694076839,
          3204075428
        ];
      }
      utils.inherits(SHA224, SHA256);
      module.exports = SHA224;
      SHA224.blockSize = 512;
      SHA224.outSize = 224;
      SHA224.hmacStrength = 192;
      SHA224.padLength = 64;
      SHA224.prototype._digest = function digest(enc) {
        if (enc === "hex")
          return utils.toHex32(this.h.slice(0, 7), "big");
        else
          return utils.split32(this.h.slice(0, 7), "big");
      };
    }
  });

  // node_modules/hash.js/lib/hash/sha/512.js
  var require__4 = __commonJS({
    "node_modules/hash.js/lib/hash/sha/512.js"(exports, module) {
      "use strict";
      var utils = require_utils();
      var common = require_common();
      var assert3 = require_minimalistic_assert();
      var rotr64_hi = utils.rotr64_hi;
      var rotr64_lo = utils.rotr64_lo;
      var shr64_hi = utils.shr64_hi;
      var shr64_lo = utils.shr64_lo;
      var sum64 = utils.sum64;
      var sum64_hi = utils.sum64_hi;
      var sum64_lo = utils.sum64_lo;
      var sum64_4_hi = utils.sum64_4_hi;
      var sum64_4_lo = utils.sum64_4_lo;
      var sum64_5_hi = utils.sum64_5_hi;
      var sum64_5_lo = utils.sum64_5_lo;
      var BlockHash = common.BlockHash;
      var sha512_K = [
        1116352408,
        3609767458,
        1899447441,
        602891725,
        3049323471,
        3964484399,
        3921009573,
        2173295548,
        961987163,
        4081628472,
        1508970993,
        3053834265,
        2453635748,
        2937671579,
        2870763221,
        3664609560,
        3624381080,
        2734883394,
        310598401,
        1164996542,
        607225278,
        1323610764,
        1426881987,
        3590304994,
        1925078388,
        4068182383,
        2162078206,
        991336113,
        2614888103,
        633803317,
        3248222580,
        3479774868,
        3835390401,
        2666613458,
        4022224774,
        944711139,
        264347078,
        2341262773,
        604807628,
        2007800933,
        770255983,
        1495990901,
        1249150122,
        1856431235,
        1555081692,
        3175218132,
        1996064986,
        2198950837,
        2554220882,
        3999719339,
        2821834349,
        766784016,
        2952996808,
        2566594879,
        3210313671,
        3203337956,
        3336571891,
        1034457026,
        3584528711,
        2466948901,
        113926993,
        3758326383,
        338241895,
        168717936,
        666307205,
        1188179964,
        773529912,
        1546045734,
        1294757372,
        1522805485,
        1396182291,
        2643833823,
        1695183700,
        2343527390,
        1986661051,
        1014477480,
        2177026350,
        1206759142,
        2456956037,
        344077627,
        2730485921,
        1290863460,
        2820302411,
        3158454273,
        3259730800,
        3505952657,
        3345764771,
        106217008,
        3516065817,
        3606008344,
        3600352804,
        1432725776,
        4094571909,
        1467031594,
        275423344,
        851169720,
        430227734,
        3100823752,
        506948616,
        1363258195,
        659060556,
        3750685593,
        883997877,
        3785050280,
        958139571,
        3318307427,
        1322822218,
        3812723403,
        1537002063,
        2003034995,
        1747873779,
        3602036899,
        1955562222,
        1575990012,
        2024104815,
        1125592928,
        2227730452,
        2716904306,
        2361852424,
        442776044,
        2428436474,
        593698344,
        2756734187,
        3733110249,
        3204031479,
        2999351573,
        3329325298,
        3815920427,
        3391569614,
        3928383900,
        3515267271,
        566280711,
        3940187606,
        3454069534,
        4118630271,
        4000239992,
        116418474,
        1914138554,
        174292421,
        2731055270,
        289380356,
        3203993006,
        460393269,
        320620315,
        685471733,
        587496836,
        852142971,
        1086792851,
        1017036298,
        365543100,
        1126000580,
        2618297676,
        1288033470,
        3409855158,
        1501505948,
        4234509866,
        1607167915,
        987167468,
        1816402316,
        1246189591
      ];
      function SHA512() {
        if (!(this instanceof SHA512))
          return new SHA512();
        BlockHash.call(this);
        this.h = [
          1779033703,
          4089235720,
          3144134277,
          2227873595,
          1013904242,
          4271175723,
          2773480762,
          1595750129,
          1359893119,
          2917565137,
          2600822924,
          725511199,
          528734635,
          4215389547,
          1541459225,
          327033209
        ];
        this.k = sha512_K;
        this.W = new Array(160);
      }
      utils.inherits(SHA512, BlockHash);
      module.exports = SHA512;
      SHA512.blockSize = 1024;
      SHA512.outSize = 512;
      SHA512.hmacStrength = 192;
      SHA512.padLength = 128;
      SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
        var W2 = this.W;
        for (var i3 = 0; i3 < 32; i3++)
          W2[i3] = msg[start + i3];
        for (; i3 < W2.length; i3 += 2) {
          var c0_hi = g1_512_hi(W2[i3 - 4], W2[i3 - 3]);
          var c0_lo = g1_512_lo(W2[i3 - 4], W2[i3 - 3]);
          var c1_hi = W2[i3 - 14];
          var c1_lo = W2[i3 - 13];
          var c2_hi = g0_512_hi(W2[i3 - 30], W2[i3 - 29]);
          var c2_lo = g0_512_lo(W2[i3 - 30], W2[i3 - 29]);
          var c3_hi = W2[i3 - 32];
          var c3_lo = W2[i3 - 31];
          W2[i3] = sum64_4_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);
          W2[i3 + 1] = sum64_4_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);
        }
      };
      SHA512.prototype._update = function _update(msg, start) {
        this._prepareBlock(msg, start);
        var W2 = this.W;
        var ah = this.h[0];
        var al = this.h[1];
        var bh = this.h[2];
        var bl = this.h[3];
        var ch = this.h[4];
        var cl = this.h[5];
        var dh = this.h[6];
        var dl = this.h[7];
        var eh = this.h[8];
        var el = this.h[9];
        var fh = this.h[10];
        var fl = this.h[11];
        var gh = this.h[12];
        var gl = this.h[13];
        var hh = this.h[14];
        var hl = this.h[15];
        assert3(this.k.length === W2.length);
        for (var i3 = 0; i3 < W2.length; i3 += 2) {
          var c0_hi = hh;
          var c0_lo = hl;
          var c1_hi = s1_512_hi(eh, el);
          var c1_lo = s1_512_lo(eh, el);
          var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
          var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
          var c3_hi = this.k[i3];
          var c3_lo = this.k[i3 + 1];
          var c4_hi = W2[i3];
          var c4_lo = W2[i3 + 1];
          var T1_hi = sum64_5_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);
          var T1_lo = sum64_5_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);
          c0_hi = s0_512_hi(ah, al);
          c0_lo = s0_512_lo(ah, al);
          c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
          c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);
          var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
          var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
          hh = gh;
          hl = gl;
          gh = fh;
          gl = fl;
          fh = eh;
          fl = el;
          eh = sum64_hi(dh, dl, T1_hi, T1_lo);
          el = sum64_lo(dl, dl, T1_hi, T1_lo);
          dh = ch;
          dl = cl;
          ch = bh;
          cl = bl;
          bh = ah;
          bl = al;
          ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
          al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
        }
        sum64(this.h, 0, ah, al);
        sum64(this.h, 2, bh, bl);
        sum64(this.h, 4, ch, cl);
        sum64(this.h, 6, dh, dl);
        sum64(this.h, 8, eh, el);
        sum64(this.h, 10, fh, fl);
        sum64(this.h, 12, gh, gl);
        sum64(this.h, 14, hh, hl);
      };
      SHA512.prototype._digest = function digest(enc) {
        if (enc === "hex")
          return utils.toHex32(this.h, "big");
        else
          return utils.split32(this.h, "big");
      };
      function ch64_hi(xh, xl, yh, yl, zh) {
        var r3 = xh & yh ^ ~xh & zh;
        if (r3 < 0)
          r3 += 4294967296;
        return r3;
      }
      function ch64_lo(xh, xl, yh, yl, zh, zl) {
        var r3 = xl & yl ^ ~xl & zl;
        if (r3 < 0)
          r3 += 4294967296;
        return r3;
      }
      function maj64_hi(xh, xl, yh, yl, zh) {
        var r3 = xh & yh ^ xh & zh ^ yh & zh;
        if (r3 < 0)
          r3 += 4294967296;
        return r3;
      }
      function maj64_lo(xh, xl, yh, yl, zh, zl) {
        var r3 = xl & yl ^ xl & zl ^ yl & zl;
        if (r3 < 0)
          r3 += 4294967296;
        return r3;
      }
      function s0_512_hi(xh, xl) {
        var c0_hi = rotr64_hi(xh, xl, 28);
        var c1_hi = rotr64_hi(xl, xh, 2);
        var c2_hi = rotr64_hi(xl, xh, 7);
        var r3 = c0_hi ^ c1_hi ^ c2_hi;
        if (r3 < 0)
          r3 += 4294967296;
        return r3;
      }
      function s0_512_lo(xh, xl) {
        var c0_lo = rotr64_lo(xh, xl, 28);
        var c1_lo = rotr64_lo(xl, xh, 2);
        var c2_lo = rotr64_lo(xl, xh, 7);
        var r3 = c0_lo ^ c1_lo ^ c2_lo;
        if (r3 < 0)
          r3 += 4294967296;
        return r3;
      }
      function s1_512_hi(xh, xl) {
        var c0_hi = rotr64_hi(xh, xl, 14);
        var c1_hi = rotr64_hi(xh, xl, 18);
        var c2_hi = rotr64_hi(xl, xh, 9);
        var r3 = c0_hi ^ c1_hi ^ c2_hi;
        if (r3 < 0)
          r3 += 4294967296;
        return r3;
      }
      function s1_512_lo(xh, xl) {
        var c0_lo = rotr64_lo(xh, xl, 14);
        var c1_lo = rotr64_lo(xh, xl, 18);
        var c2_lo = rotr64_lo(xl, xh, 9);
        var r3 = c0_lo ^ c1_lo ^ c2_lo;
        if (r3 < 0)
          r3 += 4294967296;
        return r3;
      }
      function g0_512_hi(xh, xl) {
        var c0_hi = rotr64_hi(xh, xl, 1);
        var c1_hi = rotr64_hi(xh, xl, 8);
        var c2_hi = shr64_hi(xh, xl, 7);
        var r3 = c0_hi ^ c1_hi ^ c2_hi;
        if (r3 < 0)
          r3 += 4294967296;
        return r3;
      }
      function g0_512_lo(xh, xl) {
        var c0_lo = rotr64_lo(xh, xl, 1);
        var c1_lo = rotr64_lo(xh, xl, 8);
        var c2_lo = shr64_lo(xh, xl, 7);
        var r3 = c0_lo ^ c1_lo ^ c2_lo;
        if (r3 < 0)
          r3 += 4294967296;
        return r3;
      }
      function g1_512_hi(xh, xl) {
        var c0_hi = rotr64_hi(xh, xl, 19);
        var c1_hi = rotr64_hi(xl, xh, 29);
        var c2_hi = shr64_hi(xh, xl, 6);
        var r3 = c0_hi ^ c1_hi ^ c2_hi;
        if (r3 < 0)
          r3 += 4294967296;
        return r3;
      }
      function g1_512_lo(xh, xl) {
        var c0_lo = rotr64_lo(xh, xl, 19);
        var c1_lo = rotr64_lo(xl, xh, 29);
        var c2_lo = shr64_lo(xh, xl, 6);
        var r3 = c0_lo ^ c1_lo ^ c2_lo;
        if (r3 < 0)
          r3 += 4294967296;
        return r3;
      }
    }
  });

  // node_modules/hash.js/lib/hash/sha/384.js
  var require__5 = __commonJS({
    "node_modules/hash.js/lib/hash/sha/384.js"(exports, module) {
      "use strict";
      var utils = require_utils();
      var SHA512 = require__4();
      function SHA384() {
        if (!(this instanceof SHA384))
          return new SHA384();
        SHA512.call(this);
        this.h = [
          3418070365,
          3238371032,
          1654270250,
          914150663,
          2438529370,
          812702999,
          355462360,
          4144912697,
          1731405415,
          4290775857,
          2394180231,
          1750603025,
          3675008525,
          1694076839,
          1203062813,
          3204075428
        ];
      }
      utils.inherits(SHA384, SHA512);
      module.exports = SHA384;
      SHA384.blockSize = 1024;
      SHA384.outSize = 384;
      SHA384.hmacStrength = 192;
      SHA384.padLength = 128;
      SHA384.prototype._digest = function digest(enc) {
        if (enc === "hex")
          return utils.toHex32(this.h.slice(0, 12), "big");
        else
          return utils.split32(this.h.slice(0, 12), "big");
      };
    }
  });

  // node_modules/hash.js/lib/hash/sha.js
  var require_sha = __commonJS({
    "node_modules/hash.js/lib/hash/sha.js"(exports) {
      "use strict";
      exports.sha1 = require__();
      exports.sha224 = require__3();
      exports.sha256 = require__2();
      exports.sha384 = require__5();
      exports.sha512 = require__4();
    }
  });

  // node_modules/hash.js/lib/hash/ripemd.js
  var require_ripemd = __commonJS({
    "node_modules/hash.js/lib/hash/ripemd.js"(exports) {
      "use strict";
      var utils = require_utils();
      var common = require_common();
      var rotl32 = utils.rotl32;
      var sum32 = utils.sum32;
      var sum32_3 = utils.sum32_3;
      var sum32_4 = utils.sum32_4;
      var BlockHash = common.BlockHash;
      function RIPEMD160() {
        if (!(this instanceof RIPEMD160))
          return new RIPEMD160();
        BlockHash.call(this);
        this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
        this.endian = "little";
      }
      utils.inherits(RIPEMD160, BlockHash);
      exports.ripemd160 = RIPEMD160;
      RIPEMD160.blockSize = 512;
      RIPEMD160.outSize = 160;
      RIPEMD160.hmacStrength = 192;
      RIPEMD160.padLength = 64;
      RIPEMD160.prototype._update = function update2(msg, start) {
        var A4 = this.h[0];
        var B2 = this.h[1];
        var C3 = this.h[2];
        var D3 = this.h[3];
        var E4 = this.h[4];
        var Ah = A4;
        var Bh = B2;
        var Ch = C3;
        var Dh = D3;
        var Eh = E4;
        for (var j3 = 0; j3 < 80; j3++) {
          var T4 = sum32(rotl32(sum32_4(A4, f3(j3, B2, C3, D3), msg[r3[j3] + start], K2(j3)), s3[j3]), E4);
          A4 = E4;
          E4 = D3;
          D3 = rotl32(C3, 10);
          C3 = B2;
          B2 = T4;
          T4 = sum32(rotl32(sum32_4(Ah, f3(79 - j3, Bh, Ch, Dh), msg[rh[j3] + start], Kh(j3)), sh[j3]), Eh);
          Ah = Eh;
          Eh = Dh;
          Dh = rotl32(Ch, 10);
          Ch = Bh;
          Bh = T4;
        }
        T4 = sum32_3(this.h[1], C3, Dh);
        this.h[1] = sum32_3(this.h[2], D3, Eh);
        this.h[2] = sum32_3(this.h[3], E4, Ah);
        this.h[3] = sum32_3(this.h[4], A4, Bh);
        this.h[4] = sum32_3(this.h[0], B2, Ch);
        this.h[0] = T4;
      };
      RIPEMD160.prototype._digest = function digest(enc) {
        if (enc === "hex")
          return utils.toHex32(this.h, "little");
        else
          return utils.split32(this.h, "little");
      };
      function f3(j3, x3, y3, z3) {
        if (j3 <= 15)
          return x3 ^ y3 ^ z3;
        else if (j3 <= 31)
          return x3 & y3 | ~x3 & z3;
        else if (j3 <= 47)
          return (x3 | ~y3) ^ z3;
        else if (j3 <= 63)
          return x3 & z3 | y3 & ~z3;
        else
          return x3 ^ (y3 | ~z3);
      }
      function K2(j3) {
        if (j3 <= 15)
          return 0;
        else if (j3 <= 31)
          return 1518500249;
        else if (j3 <= 47)
          return 1859775393;
        else if (j3 <= 63)
          return 2400959708;
        else
          return 2840853838;
      }
      function Kh(j3) {
        if (j3 <= 15)
          return 1352829926;
        else if (j3 <= 31)
          return 1548603684;
        else if (j3 <= 47)
          return 1836072691;
        else if (j3 <= 63)
          return 2053994217;
        else
          return 0;
      }
      var r3 = [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        7,
        4,
        13,
        1,
        10,
        6,
        15,
        3,
        12,
        0,
        9,
        5,
        2,
        14,
        11,
        8,
        3,
        10,
        14,
        4,
        9,
        15,
        8,
        1,
        2,
        7,
        0,
        6,
        13,
        11,
        5,
        12,
        1,
        9,
        11,
        10,
        0,
        8,
        12,
        4,
        13,
        3,
        7,
        15,
        14,
        5,
        6,
        2,
        4,
        0,
        5,
        9,
        7,
        12,
        2,
        10,
        14,
        1,
        3,
        8,
        11,
        6,
        15,
        13
      ];
      var rh = [
        5,
        14,
        7,
        0,
        9,
        2,
        11,
        4,
        13,
        6,
        15,
        8,
        1,
        10,
        3,
        12,
        6,
        11,
        3,
        7,
        0,
        13,
        5,
        10,
        14,
        15,
        8,
        12,
        4,
        9,
        1,
        2,
        15,
        5,
        1,
        3,
        7,
        14,
        6,
        9,
        11,
        8,
        12,
        2,
        10,
        0,
        4,
        13,
        8,
        6,
        4,
        1,
        3,
        11,
        15,
        0,
        5,
        12,
        2,
        13,
        9,
        7,
        10,
        14,
        12,
        15,
        10,
        4,
        1,
        5,
        8,
        7,
        6,
        2,
        13,
        14,
        0,
        3,
        9,
        11
      ];
      var s3 = [
        11,
        14,
        15,
        12,
        5,
        8,
        7,
        9,
        11,
        13,
        14,
        15,
        6,
        7,
        9,
        8,
        7,
        6,
        8,
        13,
        11,
        9,
        7,
        15,
        7,
        12,
        15,
        9,
        11,
        7,
        13,
        12,
        11,
        13,
        6,
        7,
        14,
        9,
        13,
        15,
        14,
        8,
        13,
        6,
        5,
        12,
        7,
        5,
        11,
        12,
        14,
        15,
        14,
        15,
        9,
        8,
        9,
        14,
        5,
        6,
        8,
        6,
        5,
        12,
        9,
        15,
        5,
        11,
        6,
        8,
        13,
        12,
        5,
        12,
        13,
        14,
        11,
        8,
        5,
        6
      ];
      var sh = [
        8,
        9,
        9,
        11,
        13,
        15,
        15,
        5,
        7,
        7,
        8,
        11,
        14,
        14,
        12,
        6,
        9,
        13,
        15,
        7,
        12,
        8,
        9,
        11,
        7,
        7,
        12,
        7,
        6,
        15,
        13,
        11,
        9,
        7,
        15,
        11,
        8,
        6,
        6,
        14,
        12,
        13,
        5,
        14,
        13,
        13,
        7,
        5,
        15,
        5,
        8,
        11,
        14,
        14,
        6,
        14,
        6,
        9,
        12,
        9,
        12,
        5,
        15,
        8,
        8,
        5,
        12,
        9,
        12,
        5,
        14,
        6,
        8,
        13,
        6,
        5,
        15,
        13,
        11,
        11
      ];
    }
  });

  // node_modules/hash.js/lib/hash/hmac.js
  var require_hmac = __commonJS({
    "node_modules/hash.js/lib/hash/hmac.js"(exports, module) {
      "use strict";
      var utils = require_utils();
      var assert3 = require_minimalistic_assert();
      function Hmac(hash3, key2, enc) {
        if (!(this instanceof Hmac))
          return new Hmac(hash3, key2, enc);
        this.Hash = hash3;
        this.blockSize = hash3.blockSize / 8;
        this.outSize = hash3.outSize / 8;
        this.inner = null;
        this.outer = null;
        this._init(utils.toArray(key2, enc));
      }
      module.exports = Hmac;
      Hmac.prototype._init = function init2(key2) {
        if (key2.length > this.blockSize)
          key2 = new this.Hash().update(key2).digest();
        assert3(key2.length <= this.blockSize);
        for (var i3 = key2.length; i3 < this.blockSize; i3++)
          key2.push(0);
        for (i3 = 0; i3 < key2.length; i3++)
          key2[i3] ^= 54;
        this.inner = new this.Hash().update(key2);
        for (i3 = 0; i3 < key2.length; i3++)
          key2[i3] ^= 106;
        this.outer = new this.Hash().update(key2);
      };
      Hmac.prototype.update = function update2(msg, enc) {
        this.inner.update(msg, enc);
        return this;
      };
      Hmac.prototype.digest = function digest(enc) {
        this.outer.update(this.inner.digest());
        return this.outer.digest(enc);
      };
    }
  });

  // node_modules/hash.js/lib/hash.js
  var require_hash = __commonJS({
    "node_modules/hash.js/lib/hash.js"(exports) {
      var hash3 = exports;
      hash3.utils = require_utils();
      hash3.common = require_common();
      hash3.sha = require_sha();
      hash3.ripemd = require_ripemd();
      hash3.hmac = require_hmac();
      hash3.sha1 = hash3.sha.sha1;
      hash3.sha256 = hash3.sha.sha256;
      hash3.sha224 = hash3.sha.sha224;
      hash3.sha384 = hash3.sha.sha384;
      hash3.sha512 = hash3.sha.sha512;
      hash3.ripemd160 = hash3.ripemd.ripemd160;
    }
  });

  // node_modules/aes-js/index.js
  var require_aes_js = __commonJS({
    "node_modules/aes-js/index.js"(exports, module) {
      "use strict";
      (function(root) {
        function checkInt(value) {
          return parseInt(value) === value;
        }
        function checkInts(arrayish) {
          if (!checkInt(arrayish.length)) {
            return false;
          }
          for (var i3 = 0; i3 < arrayish.length; i3++) {
            if (!checkInt(arrayish[i3]) || arrayish[i3] < 0 || arrayish[i3] > 255) {
              return false;
            }
          }
          return true;
        }
        function coerceArray(arg, copy) {
          if (arg.buffer && ArrayBuffer.isView(arg) && arg.name === "Uint8Array") {
            if (copy) {
              if (arg.slice) {
                arg = arg.slice();
              } else {
                arg = Array.prototype.slice.call(arg);
              }
            }
            return arg;
          }
          if (Array.isArray(arg)) {
            if (!checkInts(arg)) {
              throw new Error("Array contains invalid value: " + arg);
            }
            return new Uint8Array(arg);
          }
          if (checkInt(arg.length) && checkInts(arg)) {
            return new Uint8Array(arg);
          }
          throw new Error("unsupported array-like object");
        }
        function createArray(length) {
          return new Uint8Array(length);
        }
        function copyArray(sourceArray, targetArray, targetStart, sourceStart, sourceEnd) {
          if (sourceStart != null || sourceEnd != null) {
            if (sourceArray.slice) {
              sourceArray = sourceArray.slice(sourceStart, sourceEnd);
            } else {
              sourceArray = Array.prototype.slice.call(sourceArray, sourceStart, sourceEnd);
            }
          }
          targetArray.set(sourceArray, targetStart);
        }
        var convertUtf8 = function() {
          function toBytes(text) {
            var result = [], i3 = 0;
            text = encodeURI(text);
            while (i3 < text.length) {
              var c3 = text.charCodeAt(i3++);
              if (c3 === 37) {
                result.push(parseInt(text.substr(i3, 2), 16));
                i3 += 2;
              } else {
                result.push(c3);
              }
            }
            return coerceArray(result);
          }
          function fromBytes(bytes) {
            var result = [], i3 = 0;
            while (i3 < bytes.length) {
              var c3 = bytes[i3];
              if (c3 < 128) {
                result.push(String.fromCharCode(c3));
                i3++;
              } else if (c3 > 191 && c3 < 224) {
                result.push(String.fromCharCode((c3 & 31) << 6 | bytes[i3 + 1] & 63));
                i3 += 2;
              } else {
                result.push(String.fromCharCode((c3 & 15) << 12 | (bytes[i3 + 1] & 63) << 6 | bytes[i3 + 2] & 63));
                i3 += 3;
              }
            }
            return result.join("");
          }
          return {
            toBytes,
            fromBytes
          };
        }();
        var convertHex = function() {
          function toBytes(text) {
            var result = [];
            for (var i3 = 0; i3 < text.length; i3 += 2) {
              result.push(parseInt(text.substr(i3, 2), 16));
            }
            return result;
          }
          var Hex = "0123456789abcdef";
          function fromBytes(bytes) {
            var result = [];
            for (var i3 = 0; i3 < bytes.length; i3++) {
              var v3 = bytes[i3];
              result.push(Hex[(v3 & 240) >> 4] + Hex[v3 & 15]);
            }
            return result.join("");
          }
          return {
            toBytes,
            fromBytes
          };
        }();
        var numberOfRounds = { 16: 10, 24: 12, 32: 14 };
        var rcon = [1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145];
        var S2 = [99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22];
        var Si = [82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125];
        var T1 = [3328402341, 4168907908, 4000806809, 4135287693, 4294111757, 3597364157, 3731845041, 2445657428, 1613770832, 33620227, 3462883241, 1445669757, 3892248089, 3050821474, 1303096294, 3967186586, 2412431941, 528646813, 2311702848, 4202528135, 4026202645, 2992200171, 2387036105, 4226871307, 1101901292, 3017069671, 1604494077, 1169141738, 597466303, 1403299063, 3832705686, 2613100635, 1974974402, 3791519004, 1033081774, 1277568618, 1815492186, 2118074177, 4126668546, 2211236943, 1748251740, 1369810420, 3521504564, 4193382664, 3799085459, 2883115123, 1647391059, 706024767, 134480908, 2512897874, 1176707941, 2646852446, 806885416, 932615841, 168101135, 798661301, 235341577, 605164086, 461406363, 3756188221, 3454790438, 1311188841, 2142417613, 3933566367, 302582043, 495158174, 1479289972, 874125870, 907746093, 3698224818, 3025820398, 1537253627, 2756858614, 1983593293, 3084310113, 2108928974, 1378429307, 3722699582, 1580150641, 327451799, 2790478837, 3117535592, 0, 3253595436, 1075847264, 3825007647, 2041688520, 3059440621, 3563743934, 2378943302, 1740553945, 1916352843, 2487896798, 2555137236, 2958579944, 2244988746, 3151024235, 3320835882, 1336584933, 3992714006, 2252555205, 2588757463, 1714631509, 293963156, 2319795663, 3925473552, 67240454, 4269768577, 2689618160, 2017213508, 631218106, 1269344483, 2723238387, 1571005438, 2151694528, 93294474, 1066570413, 563977660, 1882732616, 4059428100, 1673313503, 2008463041, 2950355573, 1109467491, 537923632, 3858759450, 4260623118, 3218264685, 2177748300, 403442708, 638784309, 3287084079, 3193921505, 899127202, 2286175436, 773265209, 2479146071, 1437050866, 4236148354, 2050833735, 3362022572, 3126681063, 840505643, 3866325909, 3227541664, 427917720, 2655997905, 2749160575, 1143087718, 1412049534, 999329963, 193497219, 2353415882, 3354324521, 1807268051, 672404540, 2816401017, 3160301282, 369822493, 2916866934, 3688947771, 1681011286, 1949973070, 336202270, 2454276571, 201721354, 1210328172, 3093060836, 2680341085, 3184776046, 1135389935, 3294782118, 965841320, 831886756, 3554993207, 4068047243, 3588745010, 2345191491, 1849112409, 3664604599, 26054028, 2983581028, 2622377682, 1235855840, 3630984372, 2891339514, 4092916743, 3488279077, 3395642799, 4101667470, 1202630377, 268961816, 1874508501, 4034427016, 1243948399, 1546530418, 941366308, 1470539505, 1941222599, 2546386513, 3421038627, 2715671932, 3899946140, 1042226977, 2521517021, 1639824860, 227249030, 260737669, 3765465232, 2084453954, 1907733956, 3429263018, 2420656344, 100860677, 4160157185, 470683154, 3261161891, 1781871967, 2924959737, 1773779408, 394692241, 2579611992, 974986535, 664706745, 3655459128, 3958962195, 731420851, 571543859, 3530123707, 2849626480, 126783113, 865375399, 765172662, 1008606754, 361203602, 3387549984, 2278477385, 2857719295, 1344809080, 2782912378, 59542671, 1503764984, 160008576, 437062935, 1707065306, 3622233649, 2218934982, 3496503480, 2185314755, 697932208, 1512910199, 504303377, 2075177163, 2824099068, 1841019862, 739644986];
        var T22 = [2781242211, 2230877308, 2582542199, 2381740923, 234877682, 3184946027, 2984144751, 1418839493, 1348481072, 50462977, 2848876391, 2102799147, 434634494, 1656084439, 3863849899, 2599188086, 1167051466, 2636087938, 1082771913, 2281340285, 368048890, 3954334041, 3381544775, 201060592, 3963727277, 1739838676, 4250903202, 3930435503, 3206782108, 4149453988, 2531553906, 1536934080, 3262494647, 484572669, 2923271059, 1783375398, 1517041206, 1098792767, 49674231, 1334037708, 1550332980, 4098991525, 886171109, 150598129, 2481090929, 1940642008, 1398944049, 1059722517, 201851908, 1385547719, 1699095331, 1587397571, 674240536, 2704774806, 252314885, 3039795866, 151914247, 908333586, 2602270848, 1038082786, 651029483, 1766729511, 3447698098, 2682942837, 454166793, 2652734339, 1951935532, 775166490, 758520603, 3000790638, 4004797018, 4217086112, 4137964114, 1299594043, 1639438038, 3464344499, 2068982057, 1054729187, 1901997871, 2534638724, 4121318227, 1757008337, 0, 750906861, 1614815264, 535035132, 3363418545, 3988151131, 3201591914, 1183697867, 3647454910, 1265776953, 3734260298, 3566750796, 3903871064, 1250283471, 1807470800, 717615087, 3847203498, 384695291, 3313910595, 3617213773, 1432761139, 2484176261, 3481945413, 283769337, 100925954, 2180939647, 4037038160, 1148730428, 3123027871, 3813386408, 4087501137, 4267549603, 3229630528, 2315620239, 2906624658, 3156319645, 1215313976, 82966005, 3747855548, 3245848246, 1974459098, 1665278241, 807407632, 451280895, 251524083, 1841287890, 1283575245, 337120268, 891687699, 801369324, 3787349855, 2721421207, 3431482436, 959321879, 1469301956, 4065699751, 2197585534, 1199193405, 2898814052, 3887750493, 724703513, 2514908019, 2696962144, 2551808385, 3516813135, 2141445340, 1715741218, 2119445034, 2872807568, 2198571144, 3398190662, 700968686, 3547052216, 1009259540, 2041044702, 3803995742, 487983883, 1991105499, 1004265696, 1449407026, 1316239930, 504629770, 3683797321, 168560134, 1816667172, 3837287516, 1570751170, 1857934291, 4014189740, 2797888098, 2822345105, 2754712981, 936633572, 2347923833, 852879335, 1133234376, 1500395319, 3084545389, 2348912013, 1689376213, 3533459022, 3762923945, 3034082412, 4205598294, 133428468, 634383082, 2949277029, 2398386810, 3913789102, 403703816, 3580869306, 2297460856, 1867130149, 1918643758, 607656988, 4049053350, 3346248884, 1368901318, 600565992, 2090982877, 2632479860, 557719327, 3717614411, 3697393085, 2249034635, 2232388234, 2430627952, 1115438654, 3295786421, 2865522278, 3633334344, 84280067, 33027830, 303828494, 2747425121, 1600795957, 4188952407, 3496589753, 2434238086, 1486471617, 658119965, 3106381470, 953803233, 334231800, 3005978776, 857870609, 3151128937, 1890179545, 2298973838, 2805175444, 3056442267, 574365214, 2450884487, 550103529, 1233637070, 4289353045, 2018519080, 2057691103, 2399374476, 4166623649, 2148108681, 387583245, 3664101311, 836232934, 3330556482, 3100665960, 3280093505, 2955516313, 2002398509, 287182607, 3413881008, 4238890068, 3597515707, 975967766];
        var T32 = [1671808611, 2089089148, 2006576759, 2072901243, 4061003762, 1807603307, 1873927791, 3310653893, 810573872, 16974337, 1739181671, 729634347, 4263110654, 3613570519, 2883997099, 1989864566, 3393556426, 2191335298, 3376449993, 2106063485, 4195741690, 1508618841, 1204391495, 4027317232, 2917941677, 3563566036, 2734514082, 2951366063, 2629772188, 2767672228, 1922491506, 3227229120, 3082974647, 4246528509, 2477669779, 644500518, 911895606, 1061256767, 4144166391, 3427763148, 878471220, 2784252325, 3845444069, 4043897329, 1905517169, 3631459288, 827548209, 356461077, 67897348, 3344078279, 593839651, 3277757891, 405286936, 2527147926, 84871685, 2595565466, 118033927, 305538066, 2157648768, 3795705826, 3945188843, 661212711, 2999812018, 1973414517, 152769033, 2208177539, 745822252, 439235610, 455947803, 1857215598, 1525593178, 2700827552, 1391895634, 994932283, 3596728278, 3016654259, 695947817, 3812548067, 795958831, 2224493444, 1408607827, 3513301457, 0, 3979133421, 543178784, 4229948412, 2982705585, 1542305371, 1790891114, 3410398667, 3201918910, 961245753, 1256100938, 1289001036, 1491644504, 3477767631, 3496721360, 4012557807, 2867154858, 4212583931, 1137018435, 1305975373, 861234739, 2241073541, 1171229253, 4178635257, 33948674, 2139225727, 1357946960, 1011120188, 2679776671, 2833468328, 1374921297, 2751356323, 1086357568, 2408187279, 2460827538, 2646352285, 944271416, 4110742005, 3168756668, 3066132406, 3665145818, 560153121, 271589392, 4279952895, 4077846003, 3530407890, 3444343245, 202643468, 322250259, 3962553324, 1608629855, 2543990167, 1154254916, 389623319, 3294073796, 2817676711, 2122513534, 1028094525, 1689045092, 1575467613, 422261273, 1939203699, 1621147744, 2174228865, 1339137615, 3699352540, 577127458, 712922154, 2427141008, 2290289544, 1187679302, 3995715566, 3100863416, 339486740, 3732514782, 1591917662, 186455563, 3681988059, 3762019296, 844522546, 978220090, 169743370, 1239126601, 101321734, 611076132, 1558493276, 3260915650, 3547250131, 2901361580, 1655096418, 2443721105, 2510565781, 3828863972, 2039214713, 3878868455, 3359869896, 928607799, 1840765549, 2374762893, 3580146133, 1322425422, 2850048425, 1823791212, 1459268694, 4094161908, 3928346602, 1706019429, 2056189050, 2934523822, 135794696, 3134549946, 2022240376, 628050469, 779246638, 472135708, 2800834470, 3032970164, 3327236038, 3894660072, 3715932637, 1956440180, 522272287, 1272813131, 3185336765, 2340818315, 2323976074, 1888542832, 1044544574, 3049550261, 1722469478, 1222152264, 50660867, 4127324150, 236067854, 1638122081, 895445557, 1475980887, 3117443513, 2257655686, 3243809217, 489110045, 2662934430, 3778599393, 4162055160, 2561878936, 288563729, 1773916777, 3648039385, 2391345038, 2493985684, 2612407707, 505560094, 2274497927, 3911240169, 3460925390, 1442818645, 678973480, 3749357023, 2358182796, 2717407649, 2306869641, 219617805, 3218761151, 3862026214, 1120306242, 1756942440, 1103331905, 2578459033, 762796589, 252780047, 2966125488, 1425844308, 3151392187, 372911126];
        var T4 = [1667474886, 2088535288, 2004326894, 2071694838, 4075949567, 1802223062, 1869591006, 3318043793, 808472672, 16843522, 1734846926, 724270422, 4278065639, 3621216949, 2880169549, 1987484396, 3402253711, 2189597983, 3385409673, 2105378810, 4210693615, 1499065266, 1195886990, 4042263547, 2913856577, 3570689971, 2728590687, 2947541573, 2627518243, 2762274643, 1920112356, 3233831835, 3082273397, 4261223649, 2475929149, 640051788, 909531756, 1061110142, 4160160501, 3435941763, 875846760, 2779116625, 3857003729, 4059105529, 1903268834, 3638064043, 825316194, 353713962, 67374088, 3351728789, 589522246, 3284360861, 404236336, 2526454071, 84217610, 2593830191, 117901582, 303183396, 2155911963, 3806477791, 3958056653, 656894286, 2998062463, 1970642922, 151591698, 2206440989, 741110872, 437923380, 454765878, 1852748508, 1515908788, 2694904667, 1381168804, 993742198, 3604373943, 3014905469, 690584402, 3823320797, 791638366, 2223281939, 1398011302, 3520161977, 0, 3991743681, 538992704, 4244381667, 2981218425, 1532751286, 1785380564, 3419096717, 3200178535, 960056178, 1246420628, 1280103576, 1482221744, 3486468741, 3503319995, 4025428677, 2863326543, 4227536621, 1128514950, 1296947098, 859002214, 2240123921, 1162203018, 4193849577, 33687044, 2139062782, 1347481760, 1010582648, 2678045221, 2829640523, 1364325282, 2745433693, 1077985408, 2408548869, 2459086143, 2644360225, 943212656, 4126475505, 3166494563, 3065430391, 3671750063, 555836226, 269496352, 4294908645, 4092792573, 3537006015, 3452783745, 202118168, 320025894, 3974901699, 1600119230, 2543297077, 1145359496, 387397934, 3301201811, 2812801621, 2122220284, 1027426170, 1684319432, 1566435258, 421079858, 1936954854, 1616945344, 2172753945, 1330631070, 3705438115, 572679748, 707427924, 2425400123, 2290647819, 1179044492, 4008585671, 3099120491, 336870440, 3739122087, 1583276732, 185277718, 3688593069, 3772791771, 842159716, 976899700, 168435220, 1229577106, 101059084, 606366792, 1549591736, 3267517855, 3553849021, 2897014595, 1650632388, 2442242105, 2509612081, 3840161747, 2038008818, 3890688725, 3368567691, 926374254, 1835907034, 2374863873, 3587531953, 1313788572, 2846482505, 1819063512, 1448540844, 4109633523, 3941213647, 1701162954, 2054852340, 2930698567, 134748176, 3132806511, 2021165296, 623210314, 774795868, 471606328, 2795958615, 3031746419, 3334885783, 3907527627, 3722280097, 1953799400, 522133822, 1263263126, 3183336545, 2341176845, 2324333839, 1886425312, 1044267644, 3048588401, 1718004428, 1212733584, 50529542, 4143317495, 235803164, 1633788866, 892690282, 1465383342, 3115962473, 2256965911, 3250673817, 488449850, 2661202215, 3789633753, 4177007595, 2560144171, 286339874, 1768537042, 3654906025, 2391705863, 2492770099, 2610673197, 505291324, 2273808917, 3924369609, 3469625735, 1431699370, 673740880, 3755965093, 2358021891, 2711746649, 2307489801, 218961690, 3217021541, 3873845719, 1111672452, 1751693520, 1094828930, 2576986153, 757954394, 252645662, 2964376443, 1414855848, 3149649517, 370555436];
        var T5 = [1374988112, 2118214995, 437757123, 975658646, 1001089995, 530400753, 2902087851, 1273168787, 540080725, 2910219766, 2295101073, 4110568485, 1340463100, 3307916247, 641025152, 3043140495, 3736164937, 632953703, 1172967064, 1576976609, 3274667266, 2169303058, 2370213795, 1809054150, 59727847, 361929877, 3211623147, 2505202138, 3569255213, 1484005843, 1239443753, 2395588676, 1975683434, 4102977912, 2572697195, 666464733, 3202437046, 4035489047, 3374361702, 2110667444, 1675577880, 3843699074, 2538681184, 1649639237, 2976151520, 3144396420, 4269907996, 4178062228, 1883793496, 2403728665, 2497604743, 1383856311, 2876494627, 1917518562, 3810496343, 1716890410, 3001755655, 800440835, 2261089178, 3543599269, 807962610, 599762354, 33778362, 3977675356, 2328828971, 2809771154, 4077384432, 1315562145, 1708848333, 101039829, 3509871135, 3299278474, 875451293, 2733856160, 92987698, 2767645557, 193195065, 1080094634, 1584504582, 3178106961, 1042385657, 2531067453, 3711829422, 1306967366, 2438237621, 1908694277, 67556463, 1615861247, 429456164, 3602770327, 2302690252, 1742315127, 2968011453, 126454664, 3877198648, 2043211483, 2709260871, 2084704233, 4169408201, 0, 159417987, 841739592, 504459436, 1817866830, 4245618683, 260388950, 1034867998, 908933415, 168810852, 1750902305, 2606453969, 607530554, 202008497, 2472011535, 3035535058, 463180190, 2160117071, 1641816226, 1517767529, 470948374, 3801332234, 3231722213, 1008918595, 303765277, 235474187, 4069246893, 766945465, 337553864, 1475418501, 2943682380, 4003061179, 2743034109, 4144047775, 1551037884, 1147550661, 1543208500, 2336434550, 3408119516, 3069049960, 3102011747, 3610369226, 1113818384, 328671808, 2227573024, 2236228733, 3535486456, 2935566865, 3341394285, 496906059, 3702665459, 226906860, 2009195472, 733156972, 2842737049, 294930682, 1206477858, 2835123396, 2700099354, 1451044056, 573804783, 2269728455, 3644379585, 2362090238, 2564033334, 2801107407, 2776292904, 3669462566, 1068351396, 742039012, 1350078989, 1784663195, 1417561698, 4136440770, 2430122216, 775550814, 2193862645, 2673705150, 1775276924, 1876241833, 3475313331, 3366754619, 270040487, 3902563182, 3678124923, 3441850377, 1851332852, 3969562369, 2203032232, 3868552805, 2868897406, 566021896, 4011190502, 3135740889, 1248802510, 3936291284, 699432150, 832877231, 708780849, 3332740144, 899835584, 1951317047, 4236429990, 3767586992, 866637845, 4043610186, 1106041591, 2144161806, 395441711, 1984812685, 1139781709, 3433712980, 3835036895, 2664543715, 1282050075, 3240894392, 1181045119, 2640243204, 25965917, 4203181171, 4211818798, 3009879386, 2463879762, 3910161971, 1842759443, 2597806476, 933301370, 1509430414, 3943906441, 3467192302, 3076639029, 3776767469, 2051518780, 2631065433, 1441952575, 404016761, 1942435775, 1408749034, 1610459739, 3745345300, 2017778566, 3400528769, 3110650942, 941896748, 3265478751, 371049330, 3168937228, 675039627, 4279080257, 967311729, 135050206, 3635733660, 1683407248, 2076935265, 3576870512, 1215061108, 3501741890];
        var T6 = [1347548327, 1400783205, 3273267108, 2520393566, 3409685355, 4045380933, 2880240216, 2471224067, 1428173050, 4138563181, 2441661558, 636813900, 4233094615, 3620022987, 2149987652, 2411029155, 1239331162, 1730525723, 2554718734, 3781033664, 46346101, 310463728, 2743944855, 3328955385, 3875770207, 2501218972, 3955191162, 3667219033, 768917123, 3545789473, 692707433, 1150208456, 1786102409, 2029293177, 1805211710, 3710368113, 3065962831, 401639597, 1724457132, 3028143674, 409198410, 2196052529, 1620529459, 1164071807, 3769721975, 2226875310, 486441376, 2499348523, 1483753576, 428819965, 2274680428, 3075636216, 598438867, 3799141122, 1474502543, 711349675, 129166120, 53458370, 2592523643, 2782082824, 4063242375, 2988687269, 3120694122, 1559041666, 730517276, 2460449204, 4042459122, 2706270690, 3446004468, 3573941694, 533804130, 2328143614, 2637442643, 2695033685, 839224033, 1973745387, 957055980, 2856345839, 106852767, 1371368976, 4181598602, 1033297158, 2933734917, 1179510461, 3046200461, 91341917, 1862534868, 4284502037, 605657339, 2547432937, 3431546947, 2003294622, 3182487618, 2282195339, 954669403, 3682191598, 1201765386, 3917234703, 3388507166, 0, 2198438022, 1211247597, 2887651696, 1315723890, 4227665663, 1443857720, 507358933, 657861945, 1678381017, 560487590, 3516619604, 975451694, 2970356327, 261314535, 3535072918, 2652609425, 1333838021, 2724322336, 1767536459, 370938394, 182621114, 3854606378, 1128014560, 487725847, 185469197, 2918353863, 3106780840, 3356761769, 2237133081, 1286567175, 3152976349, 4255350624, 2683765030, 3160175349, 3309594171, 878443390, 1988838185, 3704300486, 1756818940, 1673061617, 3403100636, 272786309, 1075025698, 545572369, 2105887268, 4174560061, 296679730, 1841768865, 1260232239, 4091327024, 3960309330, 3497509347, 1814803222, 2578018489, 4195456072, 575138148, 3299409036, 446754879, 3629546796, 4011996048, 3347532110, 3252238545, 4270639778, 915985419, 3483825537, 681933534, 651868046, 2755636671, 3828103837, 223377554, 2607439820, 1649704518, 3270937875, 3901806776, 1580087799, 4118987695, 3198115200, 2087309459, 2842678573, 3016697106, 1003007129, 2802849917, 1860738147, 2077965243, 164439672, 4100872472, 32283319, 2827177882, 1709610350, 2125135846, 136428751, 3874428392, 3652904859, 3460984630, 3572145929, 3593056380, 2939266226, 824852259, 818324884, 3224740454, 930369212, 2801566410, 2967507152, 355706840, 1257309336, 4148292826, 243256656, 790073846, 2373340630, 1296297904, 1422699085, 3756299780, 3818836405, 457992840, 3099667487, 2135319889, 77422314, 1560382517, 1945798516, 788204353, 1521706781, 1385356242, 870912086, 325965383, 2358957921, 2050466060, 2388260884, 2313884476, 4006521127, 901210569, 3990953189, 1014646705, 1503449823, 1062597235, 2031621326, 3212035895, 3931371469, 1533017514, 350174575, 2256028891, 2177544179, 1052338372, 741876788, 1606591296, 1914052035, 213705253, 2334669897, 1107234197, 1899603969, 3725069491, 2631447780, 2422494913, 1635502980, 1893020342, 1950903388, 1120974935];
        var T7 = [2807058932, 1699970625, 2764249623, 1586903591, 1808481195, 1173430173, 1487645946, 59984867, 4199882800, 1844882806, 1989249228, 1277555970, 3623636965, 3419915562, 1149249077, 2744104290, 1514790577, 459744698, 244860394, 3235995134, 1963115311, 4027744588, 2544078150, 4190530515, 1608975247, 2627016082, 2062270317, 1507497298, 2200818878, 567498868, 1764313568, 3359936201, 2305455554, 2037970062, 1047239e3, 1910319033, 1337376481, 2904027272, 2892417312, 984907214, 1243112415, 830661914, 861968209, 2135253587, 2011214180, 2927934315, 2686254721, 731183368, 1750626376, 4246310725, 1820824798, 4172763771, 3542330227, 48394827, 2404901663, 2871682645, 671593195, 3254988725, 2073724613, 145085239, 2280796200, 2779915199, 1790575107, 2187128086, 472615631, 3029510009, 4075877127, 3802222185, 4107101658, 3201631749, 1646252340, 4270507174, 1402811438, 1436590835, 3778151818, 3950355702, 3963161475, 4020912224, 2667994737, 273792366, 2331590177, 104699613, 95345982, 3175501286, 2377486676, 1560637892, 3564045318, 369057872, 4213447064, 3919042237, 1137477952, 2658625497, 1119727848, 2340947849, 1530455833, 4007360968, 172466556, 266959938, 516552836, 0, 2256734592, 3980931627, 1890328081, 1917742170, 4294704398, 945164165, 3575528878, 958871085, 3647212047, 2787207260, 1423022939, 775562294, 1739656202, 3876557655, 2530391278, 2443058075, 3310321856, 547512796, 1265195639, 437656594, 3121275539, 719700128, 3762502690, 387781147, 218828297, 3350065803, 2830708150, 2848461854, 428169201, 122466165, 3720081049, 1627235199, 648017665, 4122762354, 1002783846, 2117360635, 695634755, 3336358691, 4234721005, 4049844452, 3704280881, 2232435299, 574624663, 287343814, 612205898, 1039717051, 840019705, 2708326185, 793451934, 821288114, 1391201670, 3822090177, 376187827, 3113855344, 1224348052, 1679968233, 2361698556, 1058709744, 752375421, 2431590963, 1321699145, 3519142200, 2734591178, 188127444, 2177869557, 3727205754, 2384911031, 3215212461, 2648976442, 2450346104, 3432737375, 1180849278, 331544205, 3102249176, 4150144569, 2952102595, 2159976285, 2474404304, 766078933, 313773861, 2570832044, 2108100632, 1668212892, 3145456443, 2013908262, 418672217, 3070356634, 2594734927, 1852171925, 3867060991, 3473416636, 3907448597, 2614737639, 919489135, 164948639, 2094410160, 2997825956, 590424639, 2486224549, 1723872674, 3157750862, 3399941250, 3501252752, 3625268135, 2555048196, 3673637356, 1343127501, 4130281361, 3599595085, 2957853679, 1297403050, 81781910, 3051593425, 2283490410, 532201772, 1367295589, 3926170974, 895287692, 1953757831, 1093597963, 492483431, 3528626907, 1446242576, 1192455638, 1636604631, 209336225, 344873464, 1015671571, 669961897, 3375740769, 3857572124, 2973530695, 3747192018, 1933530610, 3464042516, 935293895, 3454686199, 2858115069, 1863638845, 3683022916, 4085369519, 3292445032, 875313188, 1080017571, 3279033885, 621591778, 1233856572, 2504130317, 24197544, 3017672716, 3835484340, 3247465558, 2220981195, 3060847922, 1551124588, 1463996600];
        var T8 = [4104605777, 1097159550, 396673818, 660510266, 2875968315, 2638606623, 4200115116, 3808662347, 821712160, 1986918061, 3430322568, 38544885, 3856137295, 718002117, 893681702, 1654886325, 2975484382, 3122358053, 3926825029, 4274053469, 796197571, 1290801793, 1184342925, 3556361835, 2405426947, 2459735317, 1836772287, 1381620373, 3196267988, 1948373848, 3764988233, 3385345166, 3263785589, 2390325492, 1480485785, 3111247143, 3780097726, 2293045232, 548169417, 3459953789, 3746175075, 439452389, 1362321559, 1400849762, 1685577905, 1806599355, 2174754046, 137073913, 1214797936, 1174215055, 3731654548, 2079897426, 1943217067, 1258480242, 529487843, 1437280870, 3945269170, 3049390895, 3313212038, 923313619, 679998e3, 3215307299, 57326082, 377642221, 3474729866, 2041877159, 133361907, 1776460110, 3673476453, 96392454, 878845905, 2801699524, 777231668, 4082475170, 2330014213, 4142626212, 2213296395, 1626319424, 1906247262, 1846563261, 562755902, 3708173718, 1040559837, 3871163981, 1418573201, 3294430577, 114585348, 1343618912, 2566595609, 3186202582, 1078185097, 3651041127, 3896688048, 2307622919, 425408743, 3371096953, 2081048481, 1108339068, 2216610296, 0, 2156299017, 736970802, 292596766, 1517440620, 251657213, 2235061775, 2933202493, 758720310, 265905162, 1554391400, 1532285339, 908999204, 174567692, 1474760595, 4002861748, 2610011675, 3234156416, 3693126241, 2001430874, 303699484, 2478443234, 2687165888, 585122620, 454499602, 151849742, 2345119218, 3064510765, 514443284, 4044981591, 1963412655, 2581445614, 2137062819, 19308535, 1928707164, 1715193156, 4219352155, 1126790795, 600235211, 3992742070, 3841024952, 836553431, 1669664834, 2535604243, 3323011204, 1243905413, 3141400786, 4180808110, 698445255, 2653899549, 2989552604, 2253581325, 3252932727, 3004591147, 1891211689, 2487810577, 3915653703, 4237083816, 4030667424, 2100090966, 865136418, 1229899655, 953270745, 3399679628, 3557504664, 4118925222, 2061379749, 3079546586, 2915017791, 983426092, 2022837584, 1607244650, 2118541908, 2366882550, 3635996816, 972512814, 3283088770, 1568718495, 3499326569, 3576539503, 621982671, 2895723464, 410887952, 2623762152, 1002142683, 645401037, 1494807662, 2595684844, 1335535747, 2507040230, 4293295786, 3167684641, 367585007, 3885750714, 1865862730, 2668221674, 2960971305, 2763173681, 1059270954, 2777952454, 2724642869, 1320957812, 2194319100, 2429595872, 2815956275, 77089521, 3973773121, 3444575871, 2448830231, 1305906550, 4021308739, 2857194700, 2516901860, 3518358430, 1787304780, 740276417, 1699839814, 1592394909, 2352307457, 2272556026, 188821243, 1729977011, 3687994002, 274084841, 3594982253, 3613494426, 2701949495, 4162096729, 322734571, 2837966542, 1640576439, 484830689, 1202797690, 3537852828, 4067639125, 349075736, 3342319475, 4157467219, 4255800159, 1030690015, 1155237496, 2951971274, 1757691577, 607398968, 2738905026, 499347990, 3794078908, 1011452712, 227885567, 2818666809, 213114376, 3034881240, 1455525988, 3414450555, 850817237, 1817998408, 3092726480];
        var U1 = [0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554, 708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108, 1181045119, 1417561698, 1517767529, 3767586992, 4003061179, 4236429990, 4069246893, 3635733660, 3602770327, 3299278474, 3400528769, 2430122216, 2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058, 3135740889, 3678124923, 3576870512, 3341394285, 3374361702, 3810496343, 3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029, 3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995, 899835584, 666464733, 699432150, 59727847, 226906860, 530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414, 1942435775, 2110667444, 1876241833, 1641816226, 2910219766, 2743034109, 2976151520, 3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422, 3543599269, 3240894392, 3475313331, 3843699074, 3943906441, 4178062228, 4144047775, 1306967366, 1139781709, 1374988112, 1610459739, 1975683434, 2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896, 800440835, 92987698, 193195065, 429456164, 395441711, 1984812685, 2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311, 1551037884, 101039829, 135050206, 437757123, 337553864, 1042385657, 807962610, 573804783, 742039012, 2531067453, 2564033334, 2328828971, 2227573024, 2935566865, 2700099354, 3001755655, 3168937228, 3868552805, 3902563182, 4203181171, 4102977912, 3736164937, 3501741890, 3265478751, 3433712980, 1106041591, 1340463100, 1576976609, 1408749034, 2043211483, 2009195472, 1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354, 159417987, 126454664, 361929877, 463180190, 2709260871, 2943682380, 3178106961, 3009879386, 2572697195, 2538681184, 2236228733, 2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971, 3877198648, 4110568485, 4211818798, 2597806476, 2497604743, 2261089178, 2295101073, 2733856160, 2902087851, 3202437046, 2968011453, 3936291284, 3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302, 3231722213, 2051518780, 1951317047, 1716890410, 1750902305, 1113818384, 1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330, 404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369, 3801332234, 4035489047, 4269907996, 3569255213, 3669462566, 3366754619, 3332740144, 2631065433, 2463879762, 2160117071, 2395588676, 2767645557, 2868897406, 3102011747, 3069049960, 202008497, 33778362, 270040487, 504459436, 875451293, 975658646, 675039627, 641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661, 1248802510, 1484005843, 1451044056, 933301370, 967311729, 733156972, 632953703, 260388950, 25965917, 328671808, 496906059, 1206477858, 1239443753, 1543208500, 1441952575, 2144161806, 1908694277, 1675577880, 1842759443, 3610369226, 3644379585, 3408119516, 3307916247, 4011190502, 3776767469, 4077384432, 4245618683, 2809771154, 2842737049, 3144396420, 3043140495, 2673705150, 2438237621, 2203032232, 2370213795];
        var U2 = [0, 185469197, 370938394, 487725847, 741876788, 657861945, 975451694, 824852259, 1483753576, 1400783205, 1315723890, 1164071807, 1950903388, 2135319889, 1649704518, 1767536459, 2967507152, 3152976349, 2801566410, 2918353863, 2631447780, 2547432937, 2328143614, 2177544179, 3901806776, 3818836405, 4270639778, 4118987695, 3299409036, 3483825537, 3535072918, 3652904859, 2077965243, 1893020342, 1841768865, 1724457132, 1474502543, 1559041666, 1107234197, 1257309336, 598438867, 681933534, 901210569, 1052338372, 261314535, 77422314, 428819965, 310463728, 3409685355, 3224740454, 3710368113, 3593056380, 3875770207, 3960309330, 4045380933, 4195456072, 2471224067, 2554718734, 2237133081, 2388260884, 3212035895, 3028143674, 2842678573, 2724322336, 4138563181, 4255350624, 3769721975, 3955191162, 3667219033, 3516619604, 3431546947, 3347532110, 2933734917, 2782082824, 3099667487, 3016697106, 2196052529, 2313884476, 2499348523, 2683765030, 1179510461, 1296297904, 1347548327, 1533017514, 1786102409, 1635502980, 2087309459, 2003294622, 507358933, 355706840, 136428751, 53458370, 839224033, 957055980, 605657339, 790073846, 2373340630, 2256028891, 2607439820, 2422494913, 2706270690, 2856345839, 3075636216, 3160175349, 3573941694, 3725069491, 3273267108, 3356761769, 4181598602, 4063242375, 4011996048, 3828103837, 1033297158, 915985419, 730517276, 545572369, 296679730, 446754879, 129166120, 213705253, 1709610350, 1860738147, 1945798516, 2029293177, 1239331162, 1120974935, 1606591296, 1422699085, 4148292826, 4233094615, 3781033664, 3931371469, 3682191598, 3497509347, 3446004468, 3328955385, 2939266226, 2755636671, 3106780840, 2988687269, 2198438022, 2282195339, 2501218972, 2652609425, 1201765386, 1286567175, 1371368976, 1521706781, 1805211710, 1620529459, 2105887268, 1988838185, 533804130, 350174575, 164439672, 46346101, 870912086, 954669403, 636813900, 788204353, 2358957921, 2274680428, 2592523643, 2441661558, 2695033685, 2880240216, 3065962831, 3182487618, 3572145929, 3756299780, 3270937875, 3388507166, 4174560061, 4091327024, 4006521127, 3854606378, 1014646705, 930369212, 711349675, 560487590, 272786309, 457992840, 106852767, 223377554, 1678381017, 1862534868, 1914052035, 2031621326, 1211247597, 1128014560, 1580087799, 1428173050, 32283319, 182621114, 401639597, 486441376, 768917123, 651868046, 1003007129, 818324884, 1503449823, 1385356242, 1333838021, 1150208456, 1973745387, 2125135846, 1673061617, 1756818940, 2970356327, 3120694122, 2802849917, 2887651696, 2637442643, 2520393566, 2334669897, 2149987652, 3917234703, 3799141122, 4284502037, 4100872472, 3309594171, 3460984630, 3545789473, 3629546796, 2050466060, 1899603969, 1814803222, 1730525723, 1443857720, 1560382517, 1075025698, 1260232239, 575138148, 692707433, 878443390, 1062597235, 243256656, 91341917, 409198410, 325965383, 3403100636, 3252238545, 3704300486, 3620022987, 3874428392, 3990953189, 4042459122, 4227665663, 2460449204, 2578018489, 2226875310, 2411029155, 3198115200, 3046200461, 2827177882, 2743944855];
        var U3 = [0, 218828297, 437656594, 387781147, 875313188, 958871085, 775562294, 590424639, 1750626376, 1699970625, 1917742170, 2135253587, 1551124588, 1367295589, 1180849278, 1265195639, 3501252752, 3720081049, 3399941250, 3350065803, 3835484340, 3919042237, 4270507174, 4085369519, 3102249176, 3051593425, 2734591178, 2952102595, 2361698556, 2177869557, 2530391278, 2614737639, 3145456443, 3060847922, 2708326185, 2892417312, 2404901663, 2187128086, 2504130317, 2555048196, 3542330227, 3727205754, 3375740769, 3292445032, 3876557655, 3926170974, 4246310725, 4027744588, 1808481195, 1723872674, 1910319033, 2094410160, 1608975247, 1391201670, 1173430173, 1224348052, 59984867, 244860394, 428169201, 344873464, 935293895, 984907214, 766078933, 547512796, 1844882806, 1627235199, 2011214180, 2062270317, 1507497298, 1423022939, 1137477952, 1321699145, 95345982, 145085239, 532201772, 313773861, 830661914, 1015671571, 731183368, 648017665, 3175501286, 2957853679, 2807058932, 2858115069, 2305455554, 2220981195, 2474404304, 2658625497, 3575528878, 3625268135, 3473416636, 3254988725, 3778151818, 3963161475, 4213447064, 4130281361, 3599595085, 3683022916, 3432737375, 3247465558, 3802222185, 4020912224, 4172763771, 4122762354, 3201631749, 3017672716, 2764249623, 2848461854, 2331590177, 2280796200, 2431590963, 2648976442, 104699613, 188127444, 472615631, 287343814, 840019705, 1058709744, 671593195, 621591778, 1852171925, 1668212892, 1953757831, 2037970062, 1514790577, 1463996600, 1080017571, 1297403050, 3673637356, 3623636965, 3235995134, 3454686199, 4007360968, 3822090177, 4107101658, 4190530515, 2997825956, 3215212461, 2830708150, 2779915199, 2256734592, 2340947849, 2627016082, 2443058075, 172466556, 122466165, 273792366, 492483431, 1047239e3, 861968209, 612205898, 695634755, 1646252340, 1863638845, 2013908262, 1963115311, 1446242576, 1530455833, 1277555970, 1093597963, 1636604631, 1820824798, 2073724613, 1989249228, 1436590835, 1487645946, 1337376481, 1119727848, 164948639, 81781910, 331544205, 516552836, 1039717051, 821288114, 669961897, 719700128, 2973530695, 3157750862, 2871682645, 2787207260, 2232435299, 2283490410, 2667994737, 2450346104, 3647212047, 3564045318, 3279033885, 3464042516, 3980931627, 3762502690, 4150144569, 4199882800, 3070356634, 3121275539, 2904027272, 2686254721, 2200818878, 2384911031, 2570832044, 2486224549, 3747192018, 3528626907, 3310321856, 3359936201, 3950355702, 3867060991, 4049844452, 4234721005, 1739656202, 1790575107, 2108100632, 1890328081, 1402811438, 1586903591, 1233856572, 1149249077, 266959938, 48394827, 369057872, 418672217, 1002783846, 919489135, 567498868, 752375421, 209336225, 24197544, 376187827, 459744698, 945164165, 895287692, 574624663, 793451934, 1679968233, 1764313568, 2117360635, 1933530610, 1343127501, 1560637892, 1243112415, 1192455638, 3704280881, 3519142200, 3336358691, 3419915562, 3907448597, 3857572124, 4075877127, 4294704398, 3029510009, 3113855344, 2927934315, 2744104290, 2159976285, 2377486676, 2594734927, 2544078150];
        var U4 = [0, 151849742, 303699484, 454499602, 607398968, 758720310, 908999204, 1059270954, 1214797936, 1097159550, 1517440620, 1400849762, 1817998408, 1699839814, 2118541908, 2001430874, 2429595872, 2581445614, 2194319100, 2345119218, 3034881240, 3186202582, 2801699524, 2951971274, 3635996816, 3518358430, 3399679628, 3283088770, 4237083816, 4118925222, 4002861748, 3885750714, 1002142683, 850817237, 698445255, 548169417, 529487843, 377642221, 227885567, 77089521, 1943217067, 2061379749, 1640576439, 1757691577, 1474760595, 1592394909, 1174215055, 1290801793, 2875968315, 2724642869, 3111247143, 2960971305, 2405426947, 2253581325, 2638606623, 2487810577, 3808662347, 3926825029, 4044981591, 4162096729, 3342319475, 3459953789, 3576539503, 3693126241, 1986918061, 2137062819, 1685577905, 1836772287, 1381620373, 1532285339, 1078185097, 1229899655, 1040559837, 923313619, 740276417, 621982671, 439452389, 322734571, 137073913, 19308535, 3871163981, 4021308739, 4104605777, 4255800159, 3263785589, 3414450555, 3499326569, 3651041127, 2933202493, 2815956275, 3167684641, 3049390895, 2330014213, 2213296395, 2566595609, 2448830231, 1305906550, 1155237496, 1607244650, 1455525988, 1776460110, 1626319424, 2079897426, 1928707164, 96392454, 213114376, 396673818, 514443284, 562755902, 679998e3, 865136418, 983426092, 3708173718, 3557504664, 3474729866, 3323011204, 4180808110, 4030667424, 3945269170, 3794078908, 2507040230, 2623762152, 2272556026, 2390325492, 2975484382, 3092726480, 2738905026, 2857194700, 3973773121, 3856137295, 4274053469, 4157467219, 3371096953, 3252932727, 3673476453, 3556361835, 2763173681, 2915017791, 3064510765, 3215307299, 2156299017, 2307622919, 2459735317, 2610011675, 2081048481, 1963412655, 1846563261, 1729977011, 1480485785, 1362321559, 1243905413, 1126790795, 878845905, 1030690015, 645401037, 796197571, 274084841, 425408743, 38544885, 188821243, 3613494426, 3731654548, 3313212038, 3430322568, 4082475170, 4200115116, 3780097726, 3896688048, 2668221674, 2516901860, 2366882550, 2216610296, 3141400786, 2989552604, 2837966542, 2687165888, 1202797690, 1320957812, 1437280870, 1554391400, 1669664834, 1787304780, 1906247262, 2022837584, 265905162, 114585348, 499347990, 349075736, 736970802, 585122620, 972512814, 821712160, 2595684844, 2478443234, 2293045232, 2174754046, 3196267988, 3079546586, 2895723464, 2777952454, 3537852828, 3687994002, 3234156416, 3385345166, 4142626212, 4293295786, 3841024952, 3992742070, 174567692, 57326082, 410887952, 292596766, 777231668, 660510266, 1011452712, 893681702, 1108339068, 1258480242, 1343618912, 1494807662, 1715193156, 1865862730, 1948373848, 2100090966, 2701949495, 2818666809, 3004591147, 3122358053, 2235061775, 2352307457, 2535604243, 2653899549, 3915653703, 3764988233, 4219352155, 4067639125, 3444575871, 3294430577, 3746175075, 3594982253, 836553431, 953270745, 600235211, 718002117, 367585007, 484830689, 133361907, 251657213, 2041877159, 1891211689, 1806599355, 1654886325, 1568718495, 1418573201, 1335535747, 1184342925];
        function convertToInt32(bytes) {
          var result = [];
          for (var i3 = 0; i3 < bytes.length; i3 += 4) {
            result.push(bytes[i3] << 24 | bytes[i3 + 1] << 16 | bytes[i3 + 2] << 8 | bytes[i3 + 3]);
          }
          return result;
        }
        var AES = function(key2) {
          if (!(this instanceof AES)) {
            throw Error("AES must be instanitated with `new`");
          }
          Object.defineProperty(this, "key", {
            value: coerceArray(key2, true)
          });
          this._prepare();
        };
        AES.prototype._prepare = function() {
          var rounds = numberOfRounds[this.key.length];
          if (rounds == null) {
            throw new Error("invalid key size (must be 16, 24 or 32 bytes)");
          }
          this._Ke = [];
          this._Kd = [];
          for (var i3 = 0; i3 <= rounds; i3++) {
            this._Ke.push([0, 0, 0, 0]);
            this._Kd.push([0, 0, 0, 0]);
          }
          var roundKeyCount = (rounds + 1) * 4;
          var KC = this.key.length / 4;
          var tk = convertToInt32(this.key);
          var index;
          for (var i3 = 0; i3 < KC; i3++) {
            index = i3 >> 2;
            this._Ke[index][i3 % 4] = tk[i3];
            this._Kd[rounds - index][i3 % 4] = tk[i3];
          }
          var rconpointer = 0;
          var t3 = KC, tt;
          while (t3 < roundKeyCount) {
            tt = tk[KC - 1];
            tk[0] ^= S2[tt >> 16 & 255] << 24 ^ S2[tt >> 8 & 255] << 16 ^ S2[tt & 255] << 8 ^ S2[tt >> 24 & 255] ^ rcon[rconpointer] << 24;
            rconpointer += 1;
            if (KC != 8) {
              for (var i3 = 1; i3 < KC; i3++) {
                tk[i3] ^= tk[i3 - 1];
              }
            } else {
              for (var i3 = 1; i3 < KC / 2; i3++) {
                tk[i3] ^= tk[i3 - 1];
              }
              tt = tk[KC / 2 - 1];
              tk[KC / 2] ^= S2[tt & 255] ^ S2[tt >> 8 & 255] << 8 ^ S2[tt >> 16 & 255] << 16 ^ S2[tt >> 24 & 255] << 24;
              for (var i3 = KC / 2 + 1; i3 < KC; i3++) {
                tk[i3] ^= tk[i3 - 1];
              }
            }
            var i3 = 0, r3, c3;
            while (i3 < KC && t3 < roundKeyCount) {
              r3 = t3 >> 2;
              c3 = t3 % 4;
              this._Ke[r3][c3] = tk[i3];
              this._Kd[rounds - r3][c3] = tk[i3++];
              t3++;
            }
          }
          for (var r3 = 1; r3 < rounds; r3++) {
            for (var c3 = 0; c3 < 4; c3++) {
              tt = this._Kd[r3][c3];
              this._Kd[r3][c3] = U1[tt >> 24 & 255] ^ U2[tt >> 16 & 255] ^ U3[tt >> 8 & 255] ^ U4[tt & 255];
            }
          }
        };
        AES.prototype.encrypt = function(plaintext) {
          if (plaintext.length != 16) {
            throw new Error("invalid plaintext size (must be 16 bytes)");
          }
          var rounds = this._Ke.length - 1;
          var a3 = [0, 0, 0, 0];
          var t3 = convertToInt32(plaintext);
          for (var i3 = 0; i3 < 4; i3++) {
            t3[i3] ^= this._Ke[0][i3];
          }
          for (var r3 = 1; r3 < rounds; r3++) {
            for (var i3 = 0; i3 < 4; i3++) {
              a3[i3] = T1[t3[i3] >> 24 & 255] ^ T22[t3[(i3 + 1) % 4] >> 16 & 255] ^ T32[t3[(i3 + 2) % 4] >> 8 & 255] ^ T4[t3[(i3 + 3) % 4] & 255] ^ this._Ke[r3][i3];
            }
            t3 = a3.slice();
          }
          var result = createArray(16), tt;
          for (var i3 = 0; i3 < 4; i3++) {
            tt = this._Ke[rounds][i3];
            result[4 * i3] = (S2[t3[i3] >> 24 & 255] ^ tt >> 24) & 255;
            result[4 * i3 + 1] = (S2[t3[(i3 + 1) % 4] >> 16 & 255] ^ tt >> 16) & 255;
            result[4 * i3 + 2] = (S2[t3[(i3 + 2) % 4] >> 8 & 255] ^ tt >> 8) & 255;
            result[4 * i3 + 3] = (S2[t3[(i3 + 3) % 4] & 255] ^ tt) & 255;
          }
          return result;
        };
        AES.prototype.decrypt = function(ciphertext) {
          if (ciphertext.length != 16) {
            throw new Error("invalid ciphertext size (must be 16 bytes)");
          }
          var rounds = this._Kd.length - 1;
          var a3 = [0, 0, 0, 0];
          var t3 = convertToInt32(ciphertext);
          for (var i3 = 0; i3 < 4; i3++) {
            t3[i3] ^= this._Kd[0][i3];
          }
          for (var r3 = 1; r3 < rounds; r3++) {
            for (var i3 = 0; i3 < 4; i3++) {
              a3[i3] = T5[t3[i3] >> 24 & 255] ^ T6[t3[(i3 + 3) % 4] >> 16 & 255] ^ T7[t3[(i3 + 2) % 4] >> 8 & 255] ^ T8[t3[(i3 + 1) % 4] & 255] ^ this._Kd[r3][i3];
            }
            t3 = a3.slice();
          }
          var result = createArray(16), tt;
          for (var i3 = 0; i3 < 4; i3++) {
            tt = this._Kd[rounds][i3];
            result[4 * i3] = (Si[t3[i3] >> 24 & 255] ^ tt >> 24) & 255;
            result[4 * i3 + 1] = (Si[t3[(i3 + 3) % 4] >> 16 & 255] ^ tt >> 16) & 255;
            result[4 * i3 + 2] = (Si[t3[(i3 + 2) % 4] >> 8 & 255] ^ tt >> 8) & 255;
            result[4 * i3 + 3] = (Si[t3[(i3 + 1) % 4] & 255] ^ tt) & 255;
          }
          return result;
        };
        var ModeOfOperationECB = function(key2) {
          if (!(this instanceof ModeOfOperationECB)) {
            throw Error("AES must be instanitated with `new`");
          }
          this.description = "Electronic Code Block";
          this.name = "ecb";
          this._aes = new AES(key2);
        };
        ModeOfOperationECB.prototype.encrypt = function(plaintext) {
          plaintext = coerceArray(plaintext);
          if (plaintext.length % 16 !== 0) {
            throw new Error("invalid plaintext size (must be multiple of 16 bytes)");
          }
          var ciphertext = createArray(plaintext.length);
          var block = createArray(16);
          for (var i3 = 0; i3 < plaintext.length; i3 += 16) {
            copyArray(plaintext, block, 0, i3, i3 + 16);
            block = this._aes.encrypt(block);
            copyArray(block, ciphertext, i3);
          }
          return ciphertext;
        };
        ModeOfOperationECB.prototype.decrypt = function(ciphertext) {
          ciphertext = coerceArray(ciphertext);
          if (ciphertext.length % 16 !== 0) {
            throw new Error("invalid ciphertext size (must be multiple of 16 bytes)");
          }
          var plaintext = createArray(ciphertext.length);
          var block = createArray(16);
          for (var i3 = 0; i3 < ciphertext.length; i3 += 16) {
            copyArray(ciphertext, block, 0, i3, i3 + 16);
            block = this._aes.decrypt(block);
            copyArray(block, plaintext, i3);
          }
          return plaintext;
        };
        var ModeOfOperationCBC = function(key2, iv) {
          if (!(this instanceof ModeOfOperationCBC)) {
            throw Error("AES must be instanitated with `new`");
          }
          this.description = "Cipher Block Chaining";
          this.name = "cbc";
          if (!iv) {
            iv = createArray(16);
          } else if (iv.length != 16) {
            throw new Error("invalid initialation vector size (must be 16 bytes)");
          }
          this._lastCipherblock = coerceArray(iv, true);
          this._aes = new AES(key2);
        };
        ModeOfOperationCBC.prototype.encrypt = function(plaintext) {
          plaintext = coerceArray(plaintext);
          if (plaintext.length % 16 !== 0) {
            throw new Error("invalid plaintext size (must be multiple of 16 bytes)");
          }
          var ciphertext = createArray(plaintext.length);
          var block = createArray(16);
          for (var i3 = 0; i3 < plaintext.length; i3 += 16) {
            copyArray(plaintext, block, 0, i3, i3 + 16);
            for (var j3 = 0; j3 < 16; j3++) {
              block[j3] ^= this._lastCipherblock[j3];
            }
            this._lastCipherblock = this._aes.encrypt(block);
            copyArray(this._lastCipherblock, ciphertext, i3);
          }
          return ciphertext;
        };
        ModeOfOperationCBC.prototype.decrypt = function(ciphertext) {
          ciphertext = coerceArray(ciphertext);
          if (ciphertext.length % 16 !== 0) {
            throw new Error("invalid ciphertext size (must be multiple of 16 bytes)");
          }
          var plaintext = createArray(ciphertext.length);
          var block = createArray(16);
          for (var i3 = 0; i3 < ciphertext.length; i3 += 16) {
            copyArray(ciphertext, block, 0, i3, i3 + 16);
            block = this._aes.decrypt(block);
            for (var j3 = 0; j3 < 16; j3++) {
              plaintext[i3 + j3] = block[j3] ^ this._lastCipherblock[j3];
            }
            copyArray(ciphertext, this._lastCipherblock, 0, i3, i3 + 16);
          }
          return plaintext;
        };
        var ModeOfOperationCFB = function(key2, iv, segmentSize) {
          if (!(this instanceof ModeOfOperationCFB)) {
            throw Error("AES must be instanitated with `new`");
          }
          this.description = "Cipher Feedback";
          this.name = "cfb";
          if (!iv) {
            iv = createArray(16);
          } else if (iv.length != 16) {
            throw new Error("invalid initialation vector size (must be 16 size)");
          }
          if (!segmentSize) {
            segmentSize = 1;
          }
          this.segmentSize = segmentSize;
          this._shiftRegister = coerceArray(iv, true);
          this._aes = new AES(key2);
        };
        ModeOfOperationCFB.prototype.encrypt = function(plaintext) {
          if (plaintext.length % this.segmentSize != 0) {
            throw new Error("invalid plaintext size (must be segmentSize bytes)");
          }
          var encrypted = coerceArray(plaintext, true);
          var xorSegment;
          for (var i3 = 0; i3 < encrypted.length; i3 += this.segmentSize) {
            xorSegment = this._aes.encrypt(this._shiftRegister);
            for (var j3 = 0; j3 < this.segmentSize; j3++) {
              encrypted[i3 + j3] ^= xorSegment[j3];
            }
            copyArray(this._shiftRegister, this._shiftRegister, 0, this.segmentSize);
            copyArray(encrypted, this._shiftRegister, 16 - this.segmentSize, i3, i3 + this.segmentSize);
          }
          return encrypted;
        };
        ModeOfOperationCFB.prototype.decrypt = function(ciphertext) {
          if (ciphertext.length % this.segmentSize != 0) {
            throw new Error("invalid ciphertext size (must be segmentSize bytes)");
          }
          var plaintext = coerceArray(ciphertext, true);
          var xorSegment;
          for (var i3 = 0; i3 < plaintext.length; i3 += this.segmentSize) {
            xorSegment = this._aes.encrypt(this._shiftRegister);
            for (var j3 = 0; j3 < this.segmentSize; j3++) {
              plaintext[i3 + j3] ^= xorSegment[j3];
            }
            copyArray(this._shiftRegister, this._shiftRegister, 0, this.segmentSize);
            copyArray(ciphertext, this._shiftRegister, 16 - this.segmentSize, i3, i3 + this.segmentSize);
          }
          return plaintext;
        };
        var ModeOfOperationOFB = function(key2, iv) {
          if (!(this instanceof ModeOfOperationOFB)) {
            throw Error("AES must be instanitated with `new`");
          }
          this.description = "Output Feedback";
          this.name = "ofb";
          if (!iv) {
            iv = createArray(16);
          } else if (iv.length != 16) {
            throw new Error("invalid initialation vector size (must be 16 bytes)");
          }
          this._lastPrecipher = coerceArray(iv, true);
          this._lastPrecipherIndex = 16;
          this._aes = new AES(key2);
        };
        ModeOfOperationOFB.prototype.encrypt = function(plaintext) {
          var encrypted = coerceArray(plaintext, true);
          for (var i3 = 0; i3 < encrypted.length; i3++) {
            if (this._lastPrecipherIndex === 16) {
              this._lastPrecipher = this._aes.encrypt(this._lastPrecipher);
              this._lastPrecipherIndex = 0;
            }
            encrypted[i3] ^= this._lastPrecipher[this._lastPrecipherIndex++];
          }
          return encrypted;
        };
        ModeOfOperationOFB.prototype.decrypt = ModeOfOperationOFB.prototype.encrypt;
        var Counter = function(initialValue) {
          if (!(this instanceof Counter)) {
            throw Error("Counter must be instanitated with `new`");
          }
          if (initialValue !== 0 && !initialValue) {
            initialValue = 1;
          }
          if (typeof initialValue === "number") {
            this._counter = createArray(16);
            this.setValue(initialValue);
          } else {
            this.setBytes(initialValue);
          }
        };
        Counter.prototype.setValue = function(value) {
          if (typeof value !== "number" || parseInt(value) != value) {
            throw new Error("invalid counter value (must be an integer)");
          }
          for (var index = 15; index >= 0; --index) {
            this._counter[index] = value % 256;
            value = value >> 8;
          }
        };
        Counter.prototype.setBytes = function(bytes) {
          bytes = coerceArray(bytes, true);
          if (bytes.length != 16) {
            throw new Error("invalid counter bytes size (must be 16 bytes)");
          }
          this._counter = bytes;
        };
        Counter.prototype.increment = function() {
          for (var i3 = 15; i3 >= 0; i3--) {
            if (this._counter[i3] === 255) {
              this._counter[i3] = 0;
            } else {
              this._counter[i3]++;
              break;
            }
          }
        };
        var ModeOfOperationCTR = function(key2, counter) {
          if (!(this instanceof ModeOfOperationCTR)) {
            throw Error("AES must be instanitated with `new`");
          }
          this.description = "Counter";
          this.name = "ctr";
          if (!(counter instanceof Counter)) {
            counter = new Counter(counter);
          }
          this._counter = counter;
          this._remainingCounter = null;
          this._remainingCounterIndex = 16;
          this._aes = new AES(key2);
        };
        ModeOfOperationCTR.prototype.encrypt = function(plaintext) {
          var encrypted = coerceArray(plaintext, true);
          for (var i3 = 0; i3 < encrypted.length; i3++) {
            if (this._remainingCounterIndex === 16) {
              this._remainingCounter = this._aes.encrypt(this._counter._counter);
              this._remainingCounterIndex = 0;
              this._counter.increment();
            }
            encrypted[i3] ^= this._remainingCounter[this._remainingCounterIndex++];
          }
          return encrypted;
        };
        ModeOfOperationCTR.prototype.decrypt = ModeOfOperationCTR.prototype.encrypt;
        function pkcs7pad(data4) {
          data4 = coerceArray(data4, true);
          var padder = 16 - data4.length % 16;
          var result = createArray(data4.length + padder);
          copyArray(data4, result);
          for (var i3 = data4.length; i3 < result.length; i3++) {
            result[i3] = padder;
          }
          return result;
        }
        function pkcs7strip(data4) {
          data4 = coerceArray(data4, true);
          if (data4.length < 16) {
            throw new Error("PKCS#7 invalid length");
          }
          var padder = data4[data4.length - 1];
          if (padder > 16) {
            throw new Error("PKCS#7 padding byte out of range");
          }
          var length = data4.length - padder;
          for (var i3 = 0; i3 < padder; i3++) {
            if (data4[length + i3] !== padder) {
              throw new Error("PKCS#7 invalid padding byte");
            }
          }
          var result = createArray(length);
          copyArray(data4, result, 0, 0, length);
          return result;
        }
        var aesjs = {
          AES,
          Counter,
          ModeOfOperation: {
            ecb: ModeOfOperationECB,
            cbc: ModeOfOperationCBC,
            cfb: ModeOfOperationCFB,
            ofb: ModeOfOperationOFB,
            ctr: ModeOfOperationCTR
          },
          utils: {
            hex: convertHex,
            utf8: convertUtf8
          },
          padding: {
            pkcs7: {
              pad: pkcs7pad,
              strip: pkcs7strip
            }
          },
          _arrayTest: {
            coerceArray,
            createArray,
            copyArray
          }
        };
        if (typeof exports !== "undefined") {
          module.exports = aesjs;
        } else if (typeof define === "function" && define.amd) {
          define(aesjs);
        } else {
          if (root.aesjs) {
            aesjs._aesjs = root.aesjs;
          }
          root.aesjs = aesjs;
        }
      })(exports);
    }
  });

  // node_modules/scrypt-js/scrypt.js
  var require_scrypt = __commonJS({
    "node_modules/scrypt-js/scrypt.js"(exports, module) {
      "use strict";
      (function(root) {
        const MAX_VALUE = 2147483647;
        function SHA256(m3) {
          const K2 = new Uint32Array([
            1116352408,
            1899447441,
            3049323471,
            3921009573,
            961987163,
            1508970993,
            2453635748,
            2870763221,
            3624381080,
            310598401,
            607225278,
            1426881987,
            1925078388,
            2162078206,
            2614888103,
            3248222580,
            3835390401,
            4022224774,
            264347078,
            604807628,
            770255983,
            1249150122,
            1555081692,
            1996064986,
            2554220882,
            2821834349,
            2952996808,
            3210313671,
            3336571891,
            3584528711,
            113926993,
            338241895,
            666307205,
            773529912,
            1294757372,
            1396182291,
            1695183700,
            1986661051,
            2177026350,
            2456956037,
            2730485921,
            2820302411,
            3259730800,
            3345764771,
            3516065817,
            3600352804,
            4094571909,
            275423344,
            430227734,
            506948616,
            659060556,
            883997877,
            958139571,
            1322822218,
            1537002063,
            1747873779,
            1955562222,
            2024104815,
            2227730452,
            2361852424,
            2428436474,
            2756734187,
            3204031479,
            3329325298
          ]);
          let h0 = 1779033703, h1 = 3144134277, h22 = 1013904242, h3 = 2773480762;
          let h4 = 1359893119, h5 = 2600822924, h6 = 528734635, h7 = 1541459225;
          const w4 = new Uint32Array(64);
          function blocks(p4) {
            let off = 0, len = p4.length;
            while (len >= 64) {
              let a3 = h0, b2 = h1, c3 = h22, d3 = h3, e3 = h4, f3 = h5, g3 = h6, h8 = h7, u3, i4, j3, t1, t22;
              for (i4 = 0; i4 < 16; i4++) {
                j3 = off + i4 * 4;
                w4[i4] = (p4[j3] & 255) << 24 | (p4[j3 + 1] & 255) << 16 | (p4[j3 + 2] & 255) << 8 | p4[j3 + 3] & 255;
              }
              for (i4 = 16; i4 < 64; i4++) {
                u3 = w4[i4 - 2];
                t1 = (u3 >>> 17 | u3 << 32 - 17) ^ (u3 >>> 19 | u3 << 32 - 19) ^ u3 >>> 10;
                u3 = w4[i4 - 15];
                t22 = (u3 >>> 7 | u3 << 32 - 7) ^ (u3 >>> 18 | u3 << 32 - 18) ^ u3 >>> 3;
                w4[i4] = (t1 + w4[i4 - 7] | 0) + (t22 + w4[i4 - 16] | 0) | 0;
              }
              for (i4 = 0; i4 < 64; i4++) {
                t1 = (((e3 >>> 6 | e3 << 32 - 6) ^ (e3 >>> 11 | e3 << 32 - 11) ^ (e3 >>> 25 | e3 << 32 - 25)) + (e3 & f3 ^ ~e3 & g3) | 0) + (h8 + (K2[i4] + w4[i4] | 0) | 0) | 0;
                t22 = ((a3 >>> 2 | a3 << 32 - 2) ^ (a3 >>> 13 | a3 << 32 - 13) ^ (a3 >>> 22 | a3 << 32 - 22)) + (a3 & b2 ^ a3 & c3 ^ b2 & c3) | 0;
                h8 = g3;
                g3 = f3;
                f3 = e3;
                e3 = d3 + t1 | 0;
                d3 = c3;
                c3 = b2;
                b2 = a3;
                a3 = t1 + t22 | 0;
              }
              h0 = h0 + a3 | 0;
              h1 = h1 + b2 | 0;
              h22 = h22 + c3 | 0;
              h3 = h3 + d3 | 0;
              h4 = h4 + e3 | 0;
              h5 = h5 + f3 | 0;
              h6 = h6 + g3 | 0;
              h7 = h7 + h8 | 0;
              off += 64;
              len -= 64;
            }
          }
          blocks(m3);
          let i3, bytesLeft = m3.length % 64, bitLenHi = m3.length / 536870912 | 0, bitLenLo = m3.length << 3, numZeros = bytesLeft < 56 ? 56 : 120, p3 = m3.slice(m3.length - bytesLeft, m3.length);
          p3.push(128);
          for (i3 = bytesLeft + 1; i3 < numZeros; i3++) {
            p3.push(0);
          }
          p3.push(bitLenHi >>> 24 & 255);
          p3.push(bitLenHi >>> 16 & 255);
          p3.push(bitLenHi >>> 8 & 255);
          p3.push(bitLenHi >>> 0 & 255);
          p3.push(bitLenLo >>> 24 & 255);
          p3.push(bitLenLo >>> 16 & 255);
          p3.push(bitLenLo >>> 8 & 255);
          p3.push(bitLenLo >>> 0 & 255);
          blocks(p3);
          return [
            h0 >>> 24 & 255,
            h0 >>> 16 & 255,
            h0 >>> 8 & 255,
            h0 >>> 0 & 255,
            h1 >>> 24 & 255,
            h1 >>> 16 & 255,
            h1 >>> 8 & 255,
            h1 >>> 0 & 255,
            h22 >>> 24 & 255,
            h22 >>> 16 & 255,
            h22 >>> 8 & 255,
            h22 >>> 0 & 255,
            h3 >>> 24 & 255,
            h3 >>> 16 & 255,
            h3 >>> 8 & 255,
            h3 >>> 0 & 255,
            h4 >>> 24 & 255,
            h4 >>> 16 & 255,
            h4 >>> 8 & 255,
            h4 >>> 0 & 255,
            h5 >>> 24 & 255,
            h5 >>> 16 & 255,
            h5 >>> 8 & 255,
            h5 >>> 0 & 255,
            h6 >>> 24 & 255,
            h6 >>> 16 & 255,
            h6 >>> 8 & 255,
            h6 >>> 0 & 255,
            h7 >>> 24 & 255,
            h7 >>> 16 & 255,
            h7 >>> 8 & 255,
            h7 >>> 0 & 255
          ];
        }
        function PBKDF2_HMAC_SHA256_OneIter(password, salt, dkLen) {
          password = password.length <= 64 ? password : SHA256(password);
          const innerLen = 64 + salt.length + 4;
          const inner = new Array(innerLen);
          const outerKey = new Array(64);
          let i3;
          let dk = [];
          for (i3 = 0; i3 < 64; i3++) {
            inner[i3] = 54;
          }
          for (i3 = 0; i3 < password.length; i3++) {
            inner[i3] ^= password[i3];
          }
          for (i3 = 0; i3 < salt.length; i3++) {
            inner[64 + i3] = salt[i3];
          }
          for (i3 = innerLen - 4; i3 < innerLen; i3++) {
            inner[i3] = 0;
          }
          for (i3 = 0; i3 < 64; i3++)
            outerKey[i3] = 92;
          for (i3 = 0; i3 < password.length; i3++)
            outerKey[i3] ^= password[i3];
          function incrementCounter() {
            for (let i4 = innerLen - 1; i4 >= innerLen - 4; i4--) {
              inner[i4]++;
              if (inner[i4] <= 255)
                return;
              inner[i4] = 0;
            }
          }
          while (dkLen >= 32) {
            incrementCounter();
            dk = dk.concat(SHA256(outerKey.concat(SHA256(inner))));
            dkLen -= 32;
          }
          if (dkLen > 0) {
            incrementCounter();
            dk = dk.concat(SHA256(outerKey.concat(SHA256(inner))).slice(0, dkLen));
          }
          return dk;
        }
        function blockmix_salsa8(BY, Yi, r3, x3, _X) {
          let i3;
          arraycopy(BY, (2 * r3 - 1) * 16, _X, 0, 16);
          for (i3 = 0; i3 < 2 * r3; i3++) {
            blockxor(BY, i3 * 16, _X, 16);
            salsa20_8(_X, x3);
            arraycopy(_X, 0, BY, Yi + i3 * 16, 16);
          }
          for (i3 = 0; i3 < r3; i3++) {
            arraycopy(BY, Yi + i3 * 2 * 16, BY, i3 * 16, 16);
          }
          for (i3 = 0; i3 < r3; i3++) {
            arraycopy(BY, Yi + (i3 * 2 + 1) * 16, BY, (i3 + r3) * 16, 16);
          }
        }
        function R2(a3, b2) {
          return a3 << b2 | a3 >>> 32 - b2;
        }
        function salsa20_8(B2, x3) {
          arraycopy(B2, 0, x3, 0, 16);
          for (let i3 = 8; i3 > 0; i3 -= 2) {
            x3[4] ^= R2(x3[0] + x3[12], 7);
            x3[8] ^= R2(x3[4] + x3[0], 9);
            x3[12] ^= R2(x3[8] + x3[4], 13);
            x3[0] ^= R2(x3[12] + x3[8], 18);
            x3[9] ^= R2(x3[5] + x3[1], 7);
            x3[13] ^= R2(x3[9] + x3[5], 9);
            x3[1] ^= R2(x3[13] + x3[9], 13);
            x3[5] ^= R2(x3[1] + x3[13], 18);
            x3[14] ^= R2(x3[10] + x3[6], 7);
            x3[2] ^= R2(x3[14] + x3[10], 9);
            x3[6] ^= R2(x3[2] + x3[14], 13);
            x3[10] ^= R2(x3[6] + x3[2], 18);
            x3[3] ^= R2(x3[15] + x3[11], 7);
            x3[7] ^= R2(x3[3] + x3[15], 9);
            x3[11] ^= R2(x3[7] + x3[3], 13);
            x3[15] ^= R2(x3[11] + x3[7], 18);
            x3[1] ^= R2(x3[0] + x3[3], 7);
            x3[2] ^= R2(x3[1] + x3[0], 9);
            x3[3] ^= R2(x3[2] + x3[1], 13);
            x3[0] ^= R2(x3[3] + x3[2], 18);
            x3[6] ^= R2(x3[5] + x3[4], 7);
            x3[7] ^= R2(x3[6] + x3[5], 9);
            x3[4] ^= R2(x3[7] + x3[6], 13);
            x3[5] ^= R2(x3[4] + x3[7], 18);
            x3[11] ^= R2(x3[10] + x3[9], 7);
            x3[8] ^= R2(x3[11] + x3[10], 9);
            x3[9] ^= R2(x3[8] + x3[11], 13);
            x3[10] ^= R2(x3[9] + x3[8], 18);
            x3[12] ^= R2(x3[15] + x3[14], 7);
            x3[13] ^= R2(x3[12] + x3[15], 9);
            x3[14] ^= R2(x3[13] + x3[12], 13);
            x3[15] ^= R2(x3[14] + x3[13], 18);
          }
          for (let i3 = 0; i3 < 16; ++i3) {
            B2[i3] += x3[i3];
          }
        }
        function blockxor(S2, Si, D3, len) {
          for (let i3 = 0; i3 < len; i3++) {
            D3[i3] ^= S2[Si + i3];
          }
        }
        function arraycopy(src, srcPos, dest, destPos, length) {
          while (length--) {
            dest[destPos++] = src[srcPos++];
          }
        }
        function checkBufferish(o3) {
          if (!o3 || typeof o3.length !== "number") {
            return false;
          }
          for (let i3 = 0; i3 < o3.length; i3++) {
            const v3 = o3[i3];
            if (typeof v3 !== "number" || v3 % 1 || v3 < 0 || v3 >= 256) {
              return false;
            }
          }
          return true;
        }
        function ensureInteger(value, name2) {
          if (typeof value !== "number" || value % 1) {
            throw new Error("invalid " + name2);
          }
          return value;
        }
        function _scrypt(password, salt, N4, r3, p3, dkLen, callback) {
          N4 = ensureInteger(N4, "N");
          r3 = ensureInteger(r3, "r");
          p3 = ensureInteger(p3, "p");
          dkLen = ensureInteger(dkLen, "dkLen");
          if (N4 === 0 || (N4 & N4 - 1) !== 0) {
            throw new Error("N must be power of 2");
          }
          if (N4 > MAX_VALUE / 128 / r3) {
            throw new Error("N too large");
          }
          if (r3 > MAX_VALUE / 128 / p3) {
            throw new Error("r too large");
          }
          if (!checkBufferish(password)) {
            throw new Error("password must be an array or buffer");
          }
          password = Array.prototype.slice.call(password);
          if (!checkBufferish(salt)) {
            throw new Error("salt must be an array or buffer");
          }
          salt = Array.prototype.slice.call(salt);
          let b2 = PBKDF2_HMAC_SHA256_OneIter(password, salt, p3 * 128 * r3);
          const B2 = new Uint32Array(p3 * 32 * r3);
          for (let i3 = 0; i3 < B2.length; i3++) {
            const j3 = i3 * 4;
            B2[i3] = (b2[j3 + 3] & 255) << 24 | (b2[j3 + 2] & 255) << 16 | (b2[j3 + 1] & 255) << 8 | (b2[j3 + 0] & 255) << 0;
          }
          const XY = new Uint32Array(64 * r3);
          const V2 = new Uint32Array(32 * r3 * N4);
          const Yi = 32 * r3;
          const x3 = new Uint32Array(16);
          const _X = new Uint32Array(16);
          const totalOps = p3 * N4 * 2;
          let currentOp = 0;
          let lastPercent10 = null;
          let stop = false;
          let state = 0;
          let i0 = 0, i1;
          let Bi;
          const limit = callback ? parseInt(1e3 / r3) : 4294967295;
          const nextTick = typeof setImmediate !== "undefined" ? setImmediate : setTimeout;
          const incrementalSMix = function() {
            if (stop) {
              return callback(new Error("cancelled"), currentOp / totalOps);
            }
            let steps;
            switch (state) {
              case 0:
                Bi = i0 * 32 * r3;
                arraycopy(B2, Bi, XY, 0, Yi);
                state = 1;
                i1 = 0;
              case 1:
                steps = N4 - i1;
                if (steps > limit) {
                  steps = limit;
                }
                for (let i3 = 0; i3 < steps; i3++) {
                  arraycopy(XY, 0, V2, (i1 + i3) * Yi, Yi);
                  blockmix_salsa8(XY, Yi, r3, x3, _X);
                }
                i1 += steps;
                currentOp += steps;
                if (callback) {
                  const percent10 = parseInt(1e3 * currentOp / totalOps);
                  if (percent10 !== lastPercent10) {
                    stop = callback(null, currentOp / totalOps);
                    if (stop) {
                      break;
                    }
                    lastPercent10 = percent10;
                  }
                }
                if (i1 < N4) {
                  break;
                }
                i1 = 0;
                state = 2;
              case 2:
                steps = N4 - i1;
                if (steps > limit) {
                  steps = limit;
                }
                for (let i3 = 0; i3 < steps; i3++) {
                  const offset = (2 * r3 - 1) * 16;
                  const j3 = XY[offset] & N4 - 1;
                  blockxor(V2, j3 * Yi, XY, Yi);
                  blockmix_salsa8(XY, Yi, r3, x3, _X);
                }
                i1 += steps;
                currentOp += steps;
                if (callback) {
                  const percent10 = parseInt(1e3 * currentOp / totalOps);
                  if (percent10 !== lastPercent10) {
                    stop = callback(null, currentOp / totalOps);
                    if (stop) {
                      break;
                    }
                    lastPercent10 = percent10;
                  }
                }
                if (i1 < N4) {
                  break;
                }
                arraycopy(XY, 0, B2, Bi, Yi);
                i0++;
                if (i0 < p3) {
                  state = 0;
                  break;
                }
                b2 = [];
                for (let i3 = 0; i3 < B2.length; i3++) {
                  b2.push(B2[i3] >> 0 & 255);
                  b2.push(B2[i3] >> 8 & 255);
                  b2.push(B2[i3] >> 16 & 255);
                  b2.push(B2[i3] >> 24 & 255);
                }
                const derivedKey = PBKDF2_HMAC_SHA256_OneIter(password, b2, dkLen);
                if (callback) {
                  callback(null, 1, derivedKey);
                }
                return derivedKey;
            }
            if (callback) {
              nextTick(incrementalSMix);
            }
          };
          if (!callback) {
            while (true) {
              const derivedKey = incrementalSMix();
              if (derivedKey != void 0) {
                return derivedKey;
              }
            }
          }
          incrementalSMix();
        }
        const lib = {
          scrypt: function(password, salt, N4, r3, p3, dkLen, progressCallback) {
            return new Promise(function(resolve, reject) {
              let lastProgress = 0;
              if (progressCallback) {
                progressCallback(0);
              }
              _scrypt(password, salt, N4, r3, p3, dkLen, function(error, progress, key2) {
                if (error) {
                  reject(error);
                } else if (key2) {
                  if (progressCallback && lastProgress !== 1) {
                    progressCallback(1);
                  }
                  resolve(new Uint8Array(key2));
                } else if (progressCallback && progress !== lastProgress) {
                  lastProgress = progress;
                  return progressCallback(progress);
                }
              });
            });
          },
          syncScrypt: function(password, salt, N4, r3, p3, dkLen) {
            return new Uint8Array(_scrypt(password, salt, N4, r3, p3, dkLen));
          }
        };
        if (typeof exports !== "undefined") {
          module.exports = lib;
        } else if (typeof define === "function" && define.amd) {
          define(lib);
        } else if (root) {
          if (root.scrypt) {
            root._scrypt = root.scrypt;
          }
          root.scrypt = lib;
        }
      })(exports);
    }
  });

  // node_modules/bech32/index.js
  var require_bech32 = __commonJS({
    "node_modules/bech32/index.js"(exports, module) {
      "use strict";
      var ALPHABET = "qpzry9x8gf2tvdw0s3jn54khce6mua7l";
      var ALPHABET_MAP = {};
      for (z3 = 0; z3 < ALPHABET.length; z3++) {
        x3 = ALPHABET.charAt(z3);
        if (ALPHABET_MAP[x3] !== void 0)
          throw new TypeError(x3 + " is ambiguous");
        ALPHABET_MAP[x3] = z3;
      }
      var x3;
      var z3;
      function polymodStep(pre) {
        var b2 = pre >> 25;
        return (pre & 33554431) << 5 ^ -(b2 >> 0 & 1) & 996825010 ^ -(b2 >> 1 & 1) & 642813549 ^ -(b2 >> 2 & 1) & 513874426 ^ -(b2 >> 3 & 1) & 1027748829 ^ -(b2 >> 4 & 1) & 705979059;
      }
      function prefixChk(prefix) {
        var chk = 1;
        for (var i3 = 0; i3 < prefix.length; ++i3) {
          var c3 = prefix.charCodeAt(i3);
          if (c3 < 33 || c3 > 126)
            return "Invalid prefix (" + prefix + ")";
          chk = polymodStep(chk) ^ c3 >> 5;
        }
        chk = polymodStep(chk);
        for (i3 = 0; i3 < prefix.length; ++i3) {
          var v3 = prefix.charCodeAt(i3);
          chk = polymodStep(chk) ^ v3 & 31;
        }
        return chk;
      }
      function encode4(prefix, words6, LIMIT) {
        LIMIT = LIMIT || 90;
        if (prefix.length + 7 + words6.length > LIMIT)
          throw new TypeError("Exceeds length limit");
        prefix = prefix.toLowerCase();
        var chk = prefixChk(prefix);
        if (typeof chk === "string")
          throw new Error(chk);
        var result = prefix + "1";
        for (var i3 = 0; i3 < words6.length; ++i3) {
          var x4 = words6[i3];
          if (x4 >> 5 !== 0)
            throw new Error("Non 5-bit word");
          chk = polymodStep(chk) ^ x4;
          result += ALPHABET.charAt(x4);
        }
        for (i3 = 0; i3 < 6; ++i3) {
          chk = polymodStep(chk);
        }
        chk ^= 1;
        for (i3 = 0; i3 < 6; ++i3) {
          var v3 = chk >> (5 - i3) * 5 & 31;
          result += ALPHABET.charAt(v3);
        }
        return result;
      }
      function __decode(str, LIMIT) {
        LIMIT = LIMIT || 90;
        if (str.length < 8)
          return str + " too short";
        if (str.length > LIMIT)
          return "Exceeds length limit";
        var lowered = str.toLowerCase();
        var uppered = str.toUpperCase();
        if (str !== lowered && str !== uppered)
          return "Mixed-case string " + str;
        str = lowered;
        var split = str.lastIndexOf("1");
        if (split === -1)
          return "No separator character for " + str;
        if (split === 0)
          return "Missing prefix for " + str;
        var prefix = str.slice(0, split);
        var wordChars = str.slice(split + 1);
        if (wordChars.length < 6)
          return "Data too short";
        var chk = prefixChk(prefix);
        if (typeof chk === "string")
          return chk;
        var words6 = [];
        for (var i3 = 0; i3 < wordChars.length; ++i3) {
          var c3 = wordChars.charAt(i3);
          var v3 = ALPHABET_MAP[c3];
          if (v3 === void 0)
            return "Unknown character " + c3;
          chk = polymodStep(chk) ^ v3;
          if (i3 + 6 >= wordChars.length)
            continue;
          words6.push(v3);
        }
        if (chk !== 1)
          return "Invalid checksum for " + str;
        return { prefix, words: words6 };
      }
      function decodeUnsafe() {
        var res = __decode.apply(null, arguments);
        if (typeof res === "object")
          return res;
      }
      function decode3(str) {
        var res = __decode.apply(null, arguments);
        if (typeof res === "object")
          return res;
        throw new Error(res);
      }
      function convert(data4, inBits, outBits, pad) {
        var value = 0;
        var bits = 0;
        var maxV = (1 << outBits) - 1;
        var result = [];
        for (var i3 = 0; i3 < data4.length; ++i3) {
          value = value << inBits | data4[i3];
          bits += inBits;
          while (bits >= outBits) {
            bits -= outBits;
            result.push(value >> bits & maxV);
          }
        }
        if (pad) {
          if (bits > 0) {
            result.push(value << outBits - bits & maxV);
          }
        } else {
          if (bits >= inBits)
            return "Excess padding";
          if (value << outBits - bits & maxV)
            return "Non-zero padding";
        }
        return result;
      }
      function toWordsUnsafe(bytes) {
        var res = convert(bytes, 8, 5, true);
        if (Array.isArray(res))
          return res;
      }
      function toWords(bytes) {
        var res = convert(bytes, 8, 5, true);
        if (Array.isArray(res))
          return res;
        throw new Error(res);
      }
      function fromWordsUnsafe(words6) {
        var res = convert(words6, 5, 8, false);
        if (Array.isArray(res))
          return res;
      }
      function fromWords(words6) {
        var res = convert(words6, 5, 8, false);
        if (Array.isArray(res))
          return res;
        throw new Error(res);
      }
      module.exports = {
        decodeUnsafe,
        decode: decode3,
        encode: encode4,
        toWordsUnsafe,
        toWords,
        fromWordsUnsafe,
        fromWords
      };
    }
  });

  // node_modules/eventemitter3/index.js
  var require_eventemitter3 = __commonJS({
    "node_modules/eventemitter3/index.js"(exports, module) {
      "use strict";
      var has = Object.prototype.hasOwnProperty;
      var prefix = "~";
      function Events() {
      }
      if (Object.create) {
        Events.prototype = Object.create(null);
        if (!new Events().__proto__)
          prefix = false;
      }
      function EE(fn, context, once) {
        this.fn = fn;
        this.context = context;
        this.once = once || false;
      }
      function addListener(emitter, event, fn, context, once) {
        if (typeof fn !== "function") {
          throw new TypeError("The listener must be a function");
        }
        var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
        if (!emitter._events[evt])
          emitter._events[evt] = listener, emitter._eventsCount++;
        else if (!emitter._events[evt].fn)
          emitter._events[evt].push(listener);
        else
          emitter._events[evt] = [emitter._events[evt], listener];
        return emitter;
      }
      function clearEvent(emitter, evt) {
        if (--emitter._eventsCount === 0)
          emitter._events = new Events();
        else
          delete emitter._events[evt];
      }
      function EventEmitter5() {
        this._events = new Events();
        this._eventsCount = 0;
      }
      EventEmitter5.prototype.eventNames = function eventNames() {
        var names2 = [], events, name2;
        if (this._eventsCount === 0)
          return names2;
        for (name2 in events = this._events) {
          if (has.call(events, name2))
            names2.push(prefix ? name2.slice(1) : name2);
        }
        if (Object.getOwnPropertySymbols) {
          return names2.concat(Object.getOwnPropertySymbols(events));
        }
        return names2;
      };
      EventEmitter5.prototype.listeners = function listeners(event) {
        var evt = prefix ? prefix + event : event, handlers = this._events[evt];
        if (!handlers)
          return [];
        if (handlers.fn)
          return [handlers.fn];
        for (var i3 = 0, l3 = handlers.length, ee = new Array(l3); i3 < l3; i3++) {
          ee[i3] = handlers[i3].fn;
        }
        return ee;
      };
      EventEmitter5.prototype.listenerCount = function listenerCount(event) {
        var evt = prefix ? prefix + event : event, listeners = this._events[evt];
        if (!listeners)
          return 0;
        if (listeners.fn)
          return 1;
        return listeners.length;
      };
      EventEmitter5.prototype.emit = function emit(event, a1, a22, a3, a4, a5) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt])
          return false;
        var listeners = this._events[evt], len = arguments.length, args, i3;
        if (listeners.fn) {
          if (listeners.once)
            this.removeListener(event, listeners.fn, void 0, true);
          switch (len) {
            case 1:
              return listeners.fn.call(listeners.context), true;
            case 2:
              return listeners.fn.call(listeners.context, a1), true;
            case 3:
              return listeners.fn.call(listeners.context, a1, a22), true;
            case 4:
              return listeners.fn.call(listeners.context, a1, a22, a3), true;
            case 5:
              return listeners.fn.call(listeners.context, a1, a22, a3, a4), true;
            case 6:
              return listeners.fn.call(listeners.context, a1, a22, a3, a4, a5), true;
          }
          for (i3 = 1, args = new Array(len - 1); i3 < len; i3++) {
            args[i3 - 1] = arguments[i3];
          }
          listeners.fn.apply(listeners.context, args);
        } else {
          var length = listeners.length, j3;
          for (i3 = 0; i3 < length; i3++) {
            if (listeners[i3].once)
              this.removeListener(event, listeners[i3].fn, void 0, true);
            switch (len) {
              case 1:
                listeners[i3].fn.call(listeners[i3].context);
                break;
              case 2:
                listeners[i3].fn.call(listeners[i3].context, a1);
                break;
              case 3:
                listeners[i3].fn.call(listeners[i3].context, a1, a22);
                break;
              case 4:
                listeners[i3].fn.call(listeners[i3].context, a1, a22, a3);
                break;
              default:
                if (!args)
                  for (j3 = 1, args = new Array(len - 1); j3 < len; j3++) {
                    args[j3 - 1] = arguments[j3];
                  }
                listeners[i3].fn.apply(listeners[i3].context, args);
            }
          }
        }
        return true;
      };
      EventEmitter5.prototype.on = function on(event, fn, context) {
        return addListener(this, event, fn, context, false);
      };
      EventEmitter5.prototype.once = function once(event, fn, context) {
        return addListener(this, event, fn, context, true);
      };
      EventEmitter5.prototype.removeListener = function removeListener(event, fn, context, once) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt])
          return this;
        if (!fn) {
          clearEvent(this, evt);
          return this;
        }
        var listeners = this._events[evt];
        if (listeners.fn) {
          if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
            clearEvent(this, evt);
          }
        } else {
          for (var i3 = 0, events = [], length = listeners.length; i3 < length; i3++) {
            if (listeners[i3].fn !== fn || once && !listeners[i3].once || context && listeners[i3].context !== context) {
              events.push(listeners[i3]);
            }
          }
          if (events.length)
            this._events[evt] = events.length === 1 ? events[0] : events;
          else
            clearEvent(this, evt);
        }
        return this;
      };
      EventEmitter5.prototype.removeAllListeners = function removeAllListeners(event) {
        var evt;
        if (event) {
          evt = prefix ? prefix + event : event;
          if (this._events[evt])
            clearEvent(this, evt);
        } else {
          this._events = new Events();
          this._eventsCount = 0;
        }
        return this;
      };
      EventEmitter5.prototype.off = EventEmitter5.prototype.removeListener;
      EventEmitter5.prototype.addListener = EventEmitter5.prototype.on;
      EventEmitter5.prefixed = prefix;
      EventEmitter5.EventEmitter = EventEmitter5;
      if (typeof module !== "undefined") {
        module.exports = EventEmitter5;
      }
    }
  });

  // node_modules/events/events.js
  var require_events = __commonJS({
    "node_modules/events/events.js"(exports, module) {
      "use strict";
      var R2 = typeof Reflect === "object" ? Reflect : null;
      var ReflectApply = R2 && typeof R2.apply === "function" ? R2.apply : function ReflectApply2(target, receiver, args) {
        return Function.prototype.apply.call(target, receiver, args);
      };
      var ReflectOwnKeys;
      if (R2 && typeof R2.ownKeys === "function") {
        ReflectOwnKeys = R2.ownKeys;
      } else if (Object.getOwnPropertySymbols) {
        ReflectOwnKeys = function ReflectOwnKeys2(target) {
          return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
        };
      } else {
        ReflectOwnKeys = function ReflectOwnKeys2(target) {
          return Object.getOwnPropertyNames(target);
        };
      }
      function ProcessEmitWarning(warning) {
        if (console && console.warn)
          console.warn(warning);
      }
      var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
        return value !== value;
      };
      function EventEmitter5() {
        EventEmitter5.init.call(this);
      }
      module.exports = EventEmitter5;
      module.exports.once = once;
      EventEmitter5.EventEmitter = EventEmitter5;
      EventEmitter5.prototype._events = void 0;
      EventEmitter5.prototype._eventsCount = 0;
      EventEmitter5.prototype._maxListeners = void 0;
      var defaultMaxListeners = 10;
      function checkListener(listener) {
        if (typeof listener !== "function") {
          throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
        }
      }
      Object.defineProperty(EventEmitter5, "defaultMaxListeners", {
        enumerable: true,
        get: function() {
          return defaultMaxListeners;
        },
        set: function(arg) {
          if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
            throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
          }
          defaultMaxListeners = arg;
        }
      });
      EventEmitter5.init = function() {
        if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        }
        this._maxListeners = this._maxListeners || void 0;
      };
      EventEmitter5.prototype.setMaxListeners = function setMaxListeners(n2) {
        if (typeof n2 !== "number" || n2 < 0 || NumberIsNaN(n2)) {
          throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n2 + ".");
        }
        this._maxListeners = n2;
        return this;
      };
      function _getMaxListeners(that) {
        if (that._maxListeners === void 0)
          return EventEmitter5.defaultMaxListeners;
        return that._maxListeners;
      }
      EventEmitter5.prototype.getMaxListeners = function getMaxListeners() {
        return _getMaxListeners(this);
      };
      EventEmitter5.prototype.emit = function emit(type) {
        var args = [];
        for (var i3 = 1; i3 < arguments.length; i3++)
          args.push(arguments[i3]);
        var doError = type === "error";
        var events = this._events;
        if (events !== void 0)
          doError = doError && events.error === void 0;
        else if (!doError)
          return false;
        if (doError) {
          var er;
          if (args.length > 0)
            er = args[0];
          if (er instanceof Error) {
            throw er;
          }
          var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
          err.context = er;
          throw err;
        }
        var handler = events[type];
        if (handler === void 0)
          return false;
        if (typeof handler === "function") {
          ReflectApply(handler, this, args);
        } else {
          var len = handler.length;
          var listeners = arrayClone(handler, len);
          for (var i3 = 0; i3 < len; ++i3)
            ReflectApply(listeners[i3], this, args);
        }
        return true;
      };
      function _addListener(target, type, listener, prepend) {
        var m3;
        var events;
        var existing;
        checkListener(listener);
        events = target._events;
        if (events === void 0) {
          events = target._events = Object.create(null);
          target._eventsCount = 0;
        } else {
          if (events.newListener !== void 0) {
            target.emit("newListener", type, listener.listener ? listener.listener : listener);
            events = target._events;
          }
          existing = events[type];
        }
        if (existing === void 0) {
          existing = events[type] = listener;
          ++target._eventsCount;
        } else {
          if (typeof existing === "function") {
            existing = events[type] = prepend ? [listener, existing] : [existing, listener];
          } else if (prepend) {
            existing.unshift(listener);
          } else {
            existing.push(listener);
          }
          m3 = _getMaxListeners(target);
          if (m3 > 0 && existing.length > m3 && !existing.warned) {
            existing.warned = true;
            var w4 = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
            w4.name = "MaxListenersExceededWarning";
            w4.emitter = target;
            w4.type = type;
            w4.count = existing.length;
            ProcessEmitWarning(w4);
          }
        }
        return target;
      }
      EventEmitter5.prototype.addListener = function addListener(type, listener) {
        return _addListener(this, type, listener, false);
      };
      EventEmitter5.prototype.on = EventEmitter5.prototype.addListener;
      EventEmitter5.prototype.prependListener = function prependListener(type, listener) {
        return _addListener(this, type, listener, true);
      };
      function onceWrapper() {
        if (!this.fired) {
          this.target.removeListener(this.type, this.wrapFn);
          this.fired = true;
          if (arguments.length === 0)
            return this.listener.call(this.target);
          return this.listener.apply(this.target, arguments);
        }
      }
      function _onceWrap(target, type, listener) {
        var state = { fired: false, wrapFn: void 0, target, type, listener };
        var wrapped = onceWrapper.bind(state);
        wrapped.listener = listener;
        state.wrapFn = wrapped;
        return wrapped;
      }
      EventEmitter5.prototype.once = function once2(type, listener) {
        checkListener(listener);
        this.on(type, _onceWrap(this, type, listener));
        return this;
      };
      EventEmitter5.prototype.prependOnceListener = function prependOnceListener(type, listener) {
        checkListener(listener);
        this.prependListener(type, _onceWrap(this, type, listener));
        return this;
      };
      EventEmitter5.prototype.removeListener = function removeListener(type, listener) {
        var list, events, position, i3, originalListener;
        checkListener(listener);
        events = this._events;
        if (events === void 0)
          return this;
        list = events[type];
        if (list === void 0)
          return this;
        if (list === listener || list.listener === listener) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else {
            delete events[type];
            if (events.removeListener)
              this.emit("removeListener", type, list.listener || listener);
          }
        } else if (typeof list !== "function") {
          position = -1;
          for (i3 = list.length - 1; i3 >= 0; i3--) {
            if (list[i3] === listener || list[i3].listener === listener) {
              originalListener = list[i3].listener;
              position = i3;
              break;
            }
          }
          if (position < 0)
            return this;
          if (position === 0)
            list.shift();
          else {
            spliceOne(list, position);
          }
          if (list.length === 1)
            events[type] = list[0];
          if (events.removeListener !== void 0)
            this.emit("removeListener", type, originalListener || listener);
        }
        return this;
      };
      EventEmitter5.prototype.off = EventEmitter5.prototype.removeListener;
      EventEmitter5.prototype.removeAllListeners = function removeAllListeners(type) {
        var listeners, events, i3;
        events = this._events;
        if (events === void 0)
          return this;
        if (events.removeListener === void 0) {
          if (arguments.length === 0) {
            this._events = Object.create(null);
            this._eventsCount = 0;
          } else if (events[type] !== void 0) {
            if (--this._eventsCount === 0)
              this._events = Object.create(null);
            else
              delete events[type];
          }
          return this;
        }
        if (arguments.length === 0) {
          var keys = Object.keys(events);
          var key2;
          for (i3 = 0; i3 < keys.length; ++i3) {
            key2 = keys[i3];
            if (key2 === "removeListener")
              continue;
            this.removeAllListeners(key2);
          }
          this.removeAllListeners("removeListener");
          this._events = Object.create(null);
          this._eventsCount = 0;
          return this;
        }
        listeners = events[type];
        if (typeof listeners === "function") {
          this.removeListener(type, listeners);
        } else if (listeners !== void 0) {
          for (i3 = listeners.length - 1; i3 >= 0; i3--) {
            this.removeListener(type, listeners[i3]);
          }
        }
        return this;
      };
      function _listeners(target, type, unwrap) {
        var events = target._events;
        if (events === void 0)
          return [];
        var evlistener = events[type];
        if (evlistener === void 0)
          return [];
        if (typeof evlistener === "function")
          return unwrap ? [evlistener.listener || evlistener] : [evlistener];
        return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
      }
      EventEmitter5.prototype.listeners = function listeners(type) {
        return _listeners(this, type, true);
      };
      EventEmitter5.prototype.rawListeners = function rawListeners(type) {
        return _listeners(this, type, false);
      };
      EventEmitter5.listenerCount = function(emitter, type) {
        if (typeof emitter.listenerCount === "function") {
          return emitter.listenerCount(type);
        } else {
          return listenerCount.call(emitter, type);
        }
      };
      EventEmitter5.prototype.listenerCount = listenerCount;
      function listenerCount(type) {
        var events = this._events;
        if (events !== void 0) {
          var evlistener = events[type];
          if (typeof evlistener === "function") {
            return 1;
          } else if (evlistener !== void 0) {
            return evlistener.length;
          }
        }
        return 0;
      }
      EventEmitter5.prototype.eventNames = function eventNames() {
        return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
      };
      function arrayClone(arr, n2) {
        var copy = new Array(n2);
        for (var i3 = 0; i3 < n2; ++i3)
          copy[i3] = arr[i3];
        return copy;
      }
      function spliceOne(list, index) {
        for (; index + 1 < list.length; index++)
          list[index] = list[index + 1];
        list.pop();
      }
      function unwrapListeners(arr) {
        var ret = new Array(arr.length);
        for (var i3 = 0; i3 < ret.length; ++i3) {
          ret[i3] = arr[i3].listener || arr[i3];
        }
        return ret;
      }
      function once(emitter, name2) {
        return new Promise(function(resolve, reject) {
          function errorListener(err) {
            emitter.removeListener(name2, resolver);
            reject(err);
          }
          function resolver() {
            if (typeof emitter.removeListener === "function") {
              emitter.removeListener("error", errorListener);
            }
            resolve([].slice.call(arguments));
          }
          ;
          eventTargetAgnosticAddListener(emitter, name2, resolver, { once: true });
          if (name2 !== "error") {
            addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
          }
        });
      }
      function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
        if (typeof emitter.on === "function") {
          eventTargetAgnosticAddListener(emitter, "error", handler, flags);
        }
      }
      function eventTargetAgnosticAddListener(emitter, name2, listener, flags) {
        if (typeof emitter.on === "function") {
          if (flags.once) {
            emitter.once(name2, listener);
          } else {
            emitter.on(name2, listener);
          }
        } else if (typeof emitter.addEventListener === "function") {
          emitter.addEventListener(name2, function wrapListener(arg) {
            if (flags.once) {
              emitter.removeEventListener(name2, wrapListener);
            }
            listener(arg);
          });
        } else {
          throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
        }
      }
    }
  });

  // node_modules/@walletconnect/environment/dist/cjs/crypto.js
  var require_crypto = __commonJS({
    "node_modules/@walletconnect/environment/dist/cjs/crypto.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isBrowserCryptoAvailable = exports.getSubtleCrypto = exports.getBrowerCrypto = void 0;
      function getBrowerCrypto2() {
        return (global === null || global === void 0 ? void 0 : global.crypto) || (global === null || global === void 0 ? void 0 : global.msCrypto) || {};
      }
      exports.getBrowerCrypto = getBrowerCrypto2;
      function getSubtleCrypto2() {
        const browserCrypto = getBrowerCrypto2();
        return browserCrypto.subtle || browserCrypto.webkitSubtle;
      }
      exports.getSubtleCrypto = getSubtleCrypto2;
      function isBrowserCryptoAvailable() {
        return !!getBrowerCrypto2() && !!getSubtleCrypto2();
      }
      exports.isBrowserCryptoAvailable = isBrowserCryptoAvailable;
    }
  });

  // node_modules/@walletconnect/environment/dist/cjs/env.js
  var require_env = __commonJS({
    "node_modules/@walletconnect/environment/dist/cjs/env.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isBrowser = exports.isNode = exports.isReactNative = void 0;
      function isReactNative() {
        return typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative";
      }
      exports.isReactNative = isReactNative;
      function isNode3() {
        return typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.node !== "undefined";
      }
      exports.isNode = isNode3;
      function isBrowser2() {
        return !isReactNative() && !isNode3();
      }
      exports.isBrowser = isBrowser2;
    }
  });

  // node_modules/@walletconnect/environment/dist/cjs/index.js
  var require_cjs = __commonJS({
    "node_modules/@walletconnect/environment/dist/cjs/index.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o3, m3, k3, k22) {
        if (k22 === void 0)
          k22 = k3;
        Object.defineProperty(o3, k22, { enumerable: true, get: function() {
          return m3[k3];
        } });
      } : function(o3, m3, k3, k22) {
        if (k22 === void 0)
          k22 = k3;
        o3[k22] = m3[k3];
      });
      var __exportStar = exports && exports.__exportStar || function(m3, exports2) {
        for (var p3 in m3)
          if (p3 !== "default" && !exports2.hasOwnProperty(p3))
            __createBinding(exports2, m3, p3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      __exportStar(require_crypto(), exports);
      __exportStar(require_env(), exports);
    }
  });

  // node_modules/cross-fetch/dist/browser-ponyfill.js
  var require_browser_ponyfill = __commonJS({
    "node_modules/cross-fetch/dist/browser-ponyfill.js"(exports, module) {
      var global2 = typeof self !== "undefined" ? self : exports;
      var __self__ = function() {
        function F3() {
          this.fetch = false;
          this.DOMException = global2.DOMException;
        }
        F3.prototype = global2;
        return new F3();
      }();
      (function(self2) {
        var irrelevant = function(exports2) {
          var support = {
            searchParams: "URLSearchParams" in self2,
            iterable: "Symbol" in self2 && "iterator" in Symbol,
            blob: "FileReader" in self2 && "Blob" in self2 && function() {
              try {
                new Blob();
                return true;
              } catch (e3) {
                return false;
              }
            }(),
            formData: "FormData" in self2,
            arrayBuffer: "ArrayBuffer" in self2
          };
          function isDataView(obj) {
            return obj && DataView.prototype.isPrototypeOf(obj);
          }
          if (support.arrayBuffer) {
            var viewClasses = [
              "[object Int8Array]",
              "[object Uint8Array]",
              "[object Uint8ClampedArray]",
              "[object Int16Array]",
              "[object Uint16Array]",
              "[object Int32Array]",
              "[object Uint32Array]",
              "[object Float32Array]",
              "[object Float64Array]"
            ];
            var isArrayBufferView = ArrayBuffer.isView || function(obj) {
              return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
            };
          }
          function normalizeName(name2) {
            if (typeof name2 !== "string") {
              name2 = String(name2);
            }
            if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name2)) {
              throw new TypeError("Invalid character in header field name");
            }
            return name2.toLowerCase();
          }
          function normalizeValue(value) {
            if (typeof value !== "string") {
              value = String(value);
            }
            return value;
          }
          function iteratorFor(items) {
            var iterator = {
              next: function() {
                var value = items.shift();
                return { done: value === void 0, value };
              }
            };
            if (support.iterable) {
              iterator[Symbol.iterator] = function() {
                return iterator;
              };
            }
            return iterator;
          }
          function Headers(headers) {
            this.map = {};
            if (headers instanceof Headers) {
              headers.forEach(function(value, name2) {
                this.append(name2, value);
              }, this);
            } else if (Array.isArray(headers)) {
              headers.forEach(function(header) {
                this.append(header[0], header[1]);
              }, this);
            } else if (headers) {
              Object.getOwnPropertyNames(headers).forEach(function(name2) {
                this.append(name2, headers[name2]);
              }, this);
            }
          }
          Headers.prototype.append = function(name2, value) {
            name2 = normalizeName(name2);
            value = normalizeValue(value);
            var oldValue = this.map[name2];
            this.map[name2] = oldValue ? oldValue + ", " + value : value;
          };
          Headers.prototype["delete"] = function(name2) {
            delete this.map[normalizeName(name2)];
          };
          Headers.prototype.get = function(name2) {
            name2 = normalizeName(name2);
            return this.has(name2) ? this.map[name2] : null;
          };
          Headers.prototype.has = function(name2) {
            return this.map.hasOwnProperty(normalizeName(name2));
          };
          Headers.prototype.set = function(name2, value) {
            this.map[normalizeName(name2)] = normalizeValue(value);
          };
          Headers.prototype.forEach = function(callback, thisArg) {
            for (var name2 in this.map) {
              if (this.map.hasOwnProperty(name2)) {
                callback.call(thisArg, this.map[name2], name2, this);
              }
            }
          };
          Headers.prototype.keys = function() {
            var items = [];
            this.forEach(function(value, name2) {
              items.push(name2);
            });
            return iteratorFor(items);
          };
          Headers.prototype.values = function() {
            var items = [];
            this.forEach(function(value) {
              items.push(value);
            });
            return iteratorFor(items);
          };
          Headers.prototype.entries = function() {
            var items = [];
            this.forEach(function(value, name2) {
              items.push([name2, value]);
            });
            return iteratorFor(items);
          };
          if (support.iterable) {
            Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
          }
          function consumed(body) {
            if (body.bodyUsed) {
              return Promise.reject(new TypeError("Already read"));
            }
            body.bodyUsed = true;
          }
          function fileReaderReady(reader) {
            return new Promise(function(resolve, reject) {
              reader.onload = function() {
                resolve(reader.result);
              };
              reader.onerror = function() {
                reject(reader.error);
              };
            });
          }
          function readBlobAsArrayBuffer(blob) {
            var reader = new FileReader();
            var promise = fileReaderReady(reader);
            reader.readAsArrayBuffer(blob);
            return promise;
          }
          function readBlobAsText(blob) {
            var reader = new FileReader();
            var promise = fileReaderReady(reader);
            reader.readAsText(blob);
            return promise;
          }
          function readArrayBufferAsText(buf) {
            var view = new Uint8Array(buf);
            var chars = new Array(view.length);
            for (var i3 = 0; i3 < view.length; i3++) {
              chars[i3] = String.fromCharCode(view[i3]);
            }
            return chars.join("");
          }
          function bufferClone(buf) {
            if (buf.slice) {
              return buf.slice(0);
            } else {
              var view = new Uint8Array(buf.byteLength);
              view.set(new Uint8Array(buf));
              return view.buffer;
            }
          }
          function Body() {
            this.bodyUsed = false;
            this._initBody = function(body) {
              this._bodyInit = body;
              if (!body) {
                this._bodyText = "";
              } else if (typeof body === "string") {
                this._bodyText = body;
              } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
                this._bodyBlob = body;
              } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
                this._bodyFormData = body;
              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                this._bodyText = body.toString();
              } else if (support.arrayBuffer && support.blob && isDataView(body)) {
                this._bodyArrayBuffer = bufferClone(body.buffer);
                this._bodyInit = new Blob([this._bodyArrayBuffer]);
              } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
                this._bodyArrayBuffer = bufferClone(body);
              } else {
                this._bodyText = body = Object.prototype.toString.call(body);
              }
              if (!this.headers.get("content-type")) {
                if (typeof body === "string") {
                  this.headers.set("content-type", "text/plain;charset=UTF-8");
                } else if (this._bodyBlob && this._bodyBlob.type) {
                  this.headers.set("content-type", this._bodyBlob.type);
                } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                  this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
                }
              }
            };
            if (support.blob) {
              this.blob = function() {
                var rejected = consumed(this);
                if (rejected) {
                  return rejected;
                }
                if (this._bodyBlob) {
                  return Promise.resolve(this._bodyBlob);
                } else if (this._bodyArrayBuffer) {
                  return Promise.resolve(new Blob([this._bodyArrayBuffer]));
                } else if (this._bodyFormData) {
                  throw new Error("could not read FormData body as blob");
                } else {
                  return Promise.resolve(new Blob([this._bodyText]));
                }
              };
              this.arrayBuffer = function() {
                if (this._bodyArrayBuffer) {
                  return consumed(this) || Promise.resolve(this._bodyArrayBuffer);
                } else {
                  return this.blob().then(readBlobAsArrayBuffer);
                }
              };
            }
            this.text = function() {
              var rejected = consumed(this);
              if (rejected) {
                return rejected;
              }
              if (this._bodyBlob) {
                return readBlobAsText(this._bodyBlob);
              } else if (this._bodyArrayBuffer) {
                return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
              } else if (this._bodyFormData) {
                throw new Error("could not read FormData body as text");
              } else {
                return Promise.resolve(this._bodyText);
              }
            };
            if (support.formData) {
              this.formData = function() {
                return this.text().then(decode3);
              };
            }
            this.json = function() {
              return this.text().then(JSON.parse);
            };
            return this;
          }
          var methods = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
          function normalizeMethod(method) {
            var upcased = method.toUpperCase();
            return methods.indexOf(upcased) > -1 ? upcased : method;
          }
          function Request(input, options) {
            options = options || {};
            var body = options.body;
            if (input instanceof Request) {
              if (input.bodyUsed) {
                throw new TypeError("Already read");
              }
              this.url = input.url;
              this.credentials = input.credentials;
              if (!options.headers) {
                this.headers = new Headers(input.headers);
              }
              this.method = input.method;
              this.mode = input.mode;
              this.signal = input.signal;
              if (!body && input._bodyInit != null) {
                body = input._bodyInit;
                input.bodyUsed = true;
              }
            } else {
              this.url = String(input);
            }
            this.credentials = options.credentials || this.credentials || "same-origin";
            if (options.headers || !this.headers) {
              this.headers = new Headers(options.headers);
            }
            this.method = normalizeMethod(options.method || this.method || "GET");
            this.mode = options.mode || this.mode || null;
            this.signal = options.signal || this.signal;
            this.referrer = null;
            if ((this.method === "GET" || this.method === "HEAD") && body) {
              throw new TypeError("Body not allowed for GET or HEAD requests");
            }
            this._initBody(body);
          }
          Request.prototype.clone = function() {
            return new Request(this, { body: this._bodyInit });
          };
          function decode3(body) {
            var form = new FormData();
            body.trim().split("&").forEach(function(bytes) {
              if (bytes) {
                var split = bytes.split("=");
                var name2 = split.shift().replace(/\+/g, " ");
                var value = split.join("=").replace(/\+/g, " ");
                form.append(decodeURIComponent(name2), decodeURIComponent(value));
              }
            });
            return form;
          }
          function parseHeaders(rawHeaders) {
            var headers = new Headers();
            var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
            preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
              var parts = line.split(":");
              var key2 = parts.shift().trim();
              if (key2) {
                var value = parts.join(":").trim();
                headers.append(key2, value);
              }
            });
            return headers;
          }
          Body.call(Request.prototype);
          function Response(bodyInit, options) {
            if (!options) {
              options = {};
            }
            this.type = "default";
            this.status = options.status === void 0 ? 200 : options.status;
            this.ok = this.status >= 200 && this.status < 300;
            this.statusText = "statusText" in options ? options.statusText : "OK";
            this.headers = new Headers(options.headers);
            this.url = options.url || "";
            this._initBody(bodyInit);
          }
          Body.call(Response.prototype);
          Response.prototype.clone = function() {
            return new Response(this._bodyInit, {
              status: this.status,
              statusText: this.statusText,
              headers: new Headers(this.headers),
              url: this.url
            });
          };
          Response.error = function() {
            var response = new Response(null, { status: 0, statusText: "" });
            response.type = "error";
            return response;
          };
          var redirectStatuses = [301, 302, 303, 307, 308];
          Response.redirect = function(url, status) {
            if (redirectStatuses.indexOf(status) === -1) {
              throw new RangeError("Invalid status code");
            }
            return new Response(null, { status, headers: { location: url } });
          };
          exports2.DOMException = self2.DOMException;
          try {
            new exports2.DOMException();
          } catch (err) {
            exports2.DOMException = function(message, name2) {
              this.message = message;
              this.name = name2;
              var error = Error(message);
              this.stack = error.stack;
            };
            exports2.DOMException.prototype = Object.create(Error.prototype);
            exports2.DOMException.prototype.constructor = exports2.DOMException;
          }
          function fetch3(input, init2) {
            return new Promise(function(resolve, reject) {
              var request = new Request(input, init2);
              if (request.signal && request.signal.aborted) {
                return reject(new exports2.DOMException("Aborted", "AbortError"));
              }
              var xhr = new XMLHttpRequest();
              function abortXhr() {
                xhr.abort();
              }
              xhr.onload = function() {
                var options = {
                  status: xhr.status,
                  statusText: xhr.statusText,
                  headers: parseHeaders(xhr.getAllResponseHeaders() || "")
                };
                options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
                var body = "response" in xhr ? xhr.response : xhr.responseText;
                resolve(new Response(body, options));
              };
              xhr.onerror = function() {
                reject(new TypeError("Network request failed"));
              };
              xhr.ontimeout = function() {
                reject(new TypeError("Network request failed"));
              };
              xhr.onabort = function() {
                reject(new exports2.DOMException("Aborted", "AbortError"));
              };
              xhr.open(request.method, request.url, true);
              if (request.credentials === "include") {
                xhr.withCredentials = true;
              } else if (request.credentials === "omit") {
                xhr.withCredentials = false;
              }
              if ("responseType" in xhr && support.blob) {
                xhr.responseType = "blob";
              }
              request.headers.forEach(function(value, name2) {
                xhr.setRequestHeader(name2, value);
              });
              if (request.signal) {
                request.signal.addEventListener("abort", abortXhr);
                xhr.onreadystatechange = function() {
                  if (xhr.readyState === 4) {
                    request.signal.removeEventListener("abort", abortXhr);
                  }
                };
              }
              xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
            });
          }
          fetch3.polyfill = true;
          if (!self2.fetch) {
            self2.fetch = fetch3;
            self2.Headers = Headers;
            self2.Request = Request;
            self2.Response = Response;
          }
          exports2.Headers = Headers;
          exports2.Request = Request;
          exports2.Response = Response;
          exports2.fetch = fetch3;
          Object.defineProperty(exports2, "__esModule", { value: true });
          return exports2;
        }({});
      })(__self__);
      __self__.fetch.ponyfill = true;
      delete __self__.fetch.polyfill;
      var ctx = __self__;
      exports = ctx.fetch;
      exports.default = ctx.fetch;
      exports.fetch = ctx.fetch;
      exports.Headers = ctx.Headers;
      exports.Request = ctx.Request;
      exports.Response = ctx.Response;
      module.exports = exports;
    }
  });

  // node_modules/@walletconnect/safe-json/dist/esm/index.js
  function safeJsonParse(value) {
    if (typeof value !== "string") {
      throw new Error(`Cannot safe json parse value of type ${typeof value}`);
    }
    try {
      return JSON.parse(value);
    } catch (_a) {
      return value;
    }
  }
  function safeJsonStringify(value) {
    return typeof value === "string" ? value : JSON.stringify(value);
  }
  var init_esm = __esm({
    "node_modules/@walletconnect/safe-json/dist/esm/index.js"() {
    }
  });

  // node_modules/@walletconnect/window-getters/dist/cjs/index.js
  var require_cjs2 = __commonJS({
    "node_modules/@walletconnect/window-getters/dist/cjs/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getLocalStorage = exports.getLocalStorageOrThrow = exports.getCrypto = exports.getCryptoOrThrow = exports.getLocation = exports.getLocationOrThrow = exports.getNavigator = exports.getNavigatorOrThrow = exports.getDocument = exports.getDocumentOrThrow = exports.getFromWindowOrThrow = exports.getFromWindow = void 0;
      function getFromWindow3(name2) {
        let res = void 0;
        if (typeof window !== "undefined" && typeof window[name2] !== "undefined") {
          res = window[name2];
        }
        return res;
      }
      exports.getFromWindow = getFromWindow3;
      function getFromWindowOrThrow3(name2) {
        const res = getFromWindow3(name2);
        if (!res) {
          throw new Error(`${name2} is not defined in Window`);
        }
        return res;
      }
      exports.getFromWindowOrThrow = getFromWindowOrThrow3;
      function getDocumentOrThrow3() {
        return getFromWindowOrThrow3("document");
      }
      exports.getDocumentOrThrow = getDocumentOrThrow3;
      function getDocument3() {
        return getFromWindow3("document");
      }
      exports.getDocument = getDocument3;
      function getNavigatorOrThrow3() {
        return getFromWindowOrThrow3("navigator");
      }
      exports.getNavigatorOrThrow = getNavigatorOrThrow3;
      function getNavigator3() {
        return getFromWindow3("navigator");
      }
      exports.getNavigator = getNavigator3;
      function getLocationOrThrow3() {
        return getFromWindowOrThrow3("location");
      }
      exports.getLocationOrThrow = getLocationOrThrow3;
      function getLocation3() {
        return getFromWindow3("location");
      }
      exports.getLocation = getLocation3;
      function getCryptoOrThrow3() {
        return getFromWindowOrThrow3("crypto");
      }
      exports.getCryptoOrThrow = getCryptoOrThrow3;
      function getCrypto3() {
        return getFromWindow3("crypto");
      }
      exports.getCrypto = getCrypto3;
      function getLocalStorageOrThrow3() {
        return getFromWindowOrThrow3("localStorage");
      }
      exports.getLocalStorageOrThrow = getLocalStorageOrThrow3;
      function getLocalStorage3() {
        return getFromWindow3("localStorage");
      }
      exports.getLocalStorage = getLocalStorage3;
    }
  });

  // node_modules/@walletconnect/window-metadata/dist/cjs/index.js
  var require_cjs3 = __commonJS({
    "node_modules/@walletconnect/window-metadata/dist/cjs/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getWindowMetadata = void 0;
      var window_getters_1 = require_cjs2();
      function getWindowMetadata2() {
        let doc;
        let loc;
        try {
          doc = window_getters_1.getDocumentOrThrow();
          loc = window_getters_1.getLocationOrThrow();
        } catch (e3) {
          return null;
        }
        function getIcons() {
          const links = doc.getElementsByTagName("link");
          const icons2 = [];
          for (let i3 = 0; i3 < links.length; i3++) {
            const link = links[i3];
            const rel = link.getAttribute("rel");
            if (rel) {
              if (rel.toLowerCase().indexOf("icon") > -1) {
                const href = link.getAttribute("href");
                if (href) {
                  if (href.toLowerCase().indexOf("https:") === -1 && href.toLowerCase().indexOf("http:") === -1 && href.indexOf("//") !== 0) {
                    let absoluteHref = loc.protocol + "//" + loc.host;
                    if (href.indexOf("/") === 0) {
                      absoluteHref += href;
                    } else {
                      const path = loc.pathname.split("/");
                      path.pop();
                      const finalPath = path.join("/");
                      absoluteHref += finalPath + "/" + href;
                    }
                    icons2.push(absoluteHref);
                  } else if (href.indexOf("//") === 0) {
                    const absoluteUrl = loc.protocol + href;
                    icons2.push(absoluteUrl);
                  } else {
                    icons2.push(href);
                  }
                }
              }
            }
          }
          return icons2;
        }
        function getWindowMetadataOfAny(...args) {
          const metaTags = doc.getElementsByTagName("meta");
          for (let i3 = 0; i3 < metaTags.length; i3++) {
            const tag = metaTags[i3];
            const attributes = ["itemprop", "property", "name"].map((target) => tag.getAttribute(target)).filter((attr) => {
              if (attr) {
                return args.includes(attr);
              }
              return false;
            });
            if (attributes.length && attributes) {
              const content = tag.getAttribute("content");
              if (content) {
                return content;
              }
            }
          }
          return "";
        }
        function getName() {
          let name3 = getWindowMetadataOfAny("name", "og:site_name", "og:title", "twitter:title");
          if (!name3) {
            name3 = doc.title;
          }
          return name3;
        }
        function getDescription() {
          const description2 = getWindowMetadataOfAny("description", "og:description", "twitter:description", "keywords");
          return description2;
        }
        const name2 = getName();
        const description = getDescription();
        const url = loc.origin;
        const icons = getIcons();
        const meta = {
          description,
          url,
          icons,
          name: name2
        };
        return meta;
      }
      exports.getWindowMetadata = getWindowMetadata2;
    }
  });

  // node_modules/@walletconnect/browser-utils/node_modules/detect-browser/es/index.js
  function detect(userAgent) {
    if (!!userAgent) {
      return parseUserAgent(userAgent);
    }
    if (typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative") {
      return new ReactNativeInfo();
    }
    if (typeof navigator !== "undefined") {
      return parseUserAgent(navigator.userAgent);
    }
    return getNodeVersion();
  }
  function matchUserAgent(ua) {
    return ua !== "" && userAgentRules.reduce(function(matched, _a) {
      var browser = _a[0], regex = _a[1];
      if (matched) {
        return matched;
      }
      var uaMatch = regex.exec(ua);
      return !!uaMatch && [browser, uaMatch];
    }, false);
  }
  function parseUserAgent(ua) {
    var matchedRule = matchUserAgent(ua);
    if (!matchedRule) {
      return null;
    }
    var name2 = matchedRule[0], match = matchedRule[1];
    if (name2 === "searchbot") {
      return new BotInfo();
    }
    var versionParts = match[1] && match[1].split(/[._]/).slice(0, 3);
    if (versionParts) {
      if (versionParts.length < REQUIRED_VERSION_PARTS) {
        versionParts = __spreadArrays(versionParts, createVersionParts(REQUIRED_VERSION_PARTS - versionParts.length));
      }
    } else {
      versionParts = [];
    }
    var version26 = versionParts.join(".");
    var os = detectOS(ua);
    var searchBotMatch = SEARCHBOT_OS_REGEX.exec(ua);
    if (searchBotMatch && searchBotMatch[1]) {
      return new SearchBotDeviceInfo(name2, version26, os, searchBotMatch[1]);
    }
    return new BrowserInfo(name2, version26, os);
  }
  function detectOS(ua) {
    for (var ii = 0, count = operatingSystemRules.length; ii < count; ii++) {
      var _a = operatingSystemRules[ii], os = _a[0], regex = _a[1];
      var match = regex.exec(ua);
      if (match) {
        return os;
      }
    }
    return null;
  }
  function getNodeVersion() {
    var isNode3 = typeof process !== "undefined" && process.version;
    return isNode3 ? new NodeInfo(process.version.slice(1)) : null;
  }
  function createVersionParts(count) {
    var output = [];
    for (var ii = 0; ii < count; ii++) {
      output.push("0");
    }
    return output;
  }
  var __spreadArrays, BrowserInfo, NodeInfo, SearchBotDeviceInfo, BotInfo, ReactNativeInfo, SEARCHBOX_UA_REGEX, SEARCHBOT_OS_REGEX, REQUIRED_VERSION_PARTS, userAgentRules, operatingSystemRules;
  var init_es = __esm({
    "node_modules/@walletconnect/browser-utils/node_modules/detect-browser/es/index.js"() {
      __spreadArrays = function() {
        for (var s3 = 0, i3 = 0, il = arguments.length; i3 < il; i3++)
          s3 += arguments[i3].length;
        for (var r3 = Array(s3), k3 = 0, i3 = 0; i3 < il; i3++)
          for (var a3 = arguments[i3], j3 = 0, jl = a3.length; j3 < jl; j3++, k3++)
            r3[k3] = a3[j3];
        return r3;
      };
      BrowserInfo = function() {
        function BrowserInfo2(name2, version26, os) {
          this.name = name2;
          this.version = version26;
          this.os = os;
          this.type = "browser";
        }
        return BrowserInfo2;
      }();
      NodeInfo = function() {
        function NodeInfo2(version26) {
          this.version = version26;
          this.type = "node";
          this.name = "node";
          this.os = process.platform;
        }
        return NodeInfo2;
      }();
      SearchBotDeviceInfo = function() {
        function SearchBotDeviceInfo2(name2, version26, os, bot) {
          this.name = name2;
          this.version = version26;
          this.os = os;
          this.bot = bot;
          this.type = "bot-device";
        }
        return SearchBotDeviceInfo2;
      }();
      BotInfo = function() {
        function BotInfo2() {
          this.type = "bot";
          this.bot = true;
          this.name = "bot";
          this.version = null;
          this.os = null;
        }
        return BotInfo2;
      }();
      ReactNativeInfo = function() {
        function ReactNativeInfo2() {
          this.type = "react-native";
          this.name = "react-native";
          this.version = null;
          this.os = null;
        }
        return ReactNativeInfo2;
      }();
      SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;
      SEARCHBOT_OS_REGEX = /(nuhk|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/;
      REQUIRED_VERSION_PARTS = 3;
      userAgentRules = [
        ["aol", /AOLShield\/([0-9\._]+)/],
        ["edge", /Edge\/([0-9\._]+)/],
        ["edge-ios", /EdgiOS\/([0-9\._]+)/],
        ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
        ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
        ["samsung", /SamsungBrowser\/([0-9\.]+)/],
        ["silk", /\bSilk\/([0-9._-]+)\b/],
        ["miui", /MiuiBrowser\/([0-9\.]+)$/],
        ["beaker", /BeakerBrowser\/([0-9\.]+)/],
        ["edge-chromium", /EdgA?\/([0-9\.]+)/],
        [
          "chromium-webview",
          /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/
        ],
        ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
        ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
        ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
        ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
        ["fxios", /FxiOS\/([0-9\.]+)/],
        ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
        ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
        ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
        ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
        ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
        ["ie", /MSIE\s(7\.0)/],
        ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
        ["android", /Android\s([0-9\.]+)/],
        ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
        ["safari", /Version\/([0-9\._]+).*Safari/],
        ["facebook", /FBAV\/([0-9\.]+)/],
        ["instagram", /Instagram\s([0-9\.]+)/],
        ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
        ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
        ["searchbot", SEARCHBOX_UA_REGEX]
      ];
      operatingSystemRules = [
        ["iOS", /iP(hone|od|ad)/],
        ["Android OS", /Android/],
        ["BlackBerry OS", /BlackBerry|BB10/],
        ["Windows Mobile", /IEMobile/],
        ["Amazon OS", /Kindle/],
        ["Windows 3.11", /Win16/],
        ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
        ["Windows 98", /(Windows 98)|(Win98)/],
        ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
        ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
        ["Windows Server 2003", /(Windows NT 5.2)/],
        ["Windows Vista", /(Windows NT 6.0)/],
        ["Windows 7", /(Windows NT 6.1)/],
        ["Windows 8", /(Windows NT 6.2)/],
        ["Windows 8.1", /(Windows NT 6.3)/],
        ["Windows 10", /(Windows NT 10.0)/],
        ["Windows ME", /Windows ME/],
        ["Open BSD", /OpenBSD/],
        ["Sun OS", /SunOS/],
        ["Chrome OS", /CrOS/],
        ["Linux", /(Linux)|(X11)/],
        ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
        ["QNX", /QNX/],
        ["BeOS", /BeOS/],
        ["OS/2", /OS\/2/]
      ];
    }
  });

  // node_modules/@walletconnect/browser-utils/dist/esm/browser.js
  function detectEnv(userAgent) {
    return detect(userAgent);
  }
  function detectOS2() {
    const env3 = detectEnv();
    return env3 && env3.os ? env3.os : void 0;
  }
  function isAndroid() {
    const os = detectOS2();
    return os ? os.toLowerCase().includes("android") : false;
  }
  function isIOS() {
    const os = detectOS2();
    return os ? os.toLowerCase().includes("ios") || os.toLowerCase().includes("mac") && navigator.maxTouchPoints > 1 : false;
  }
  function isMobile() {
    const os = detectOS2();
    return os ? isAndroid() || isIOS() : false;
  }
  function isNode2() {
    const env3 = detectEnv();
    const result = env3 && env3.name ? env3.name.toLowerCase() === "node" : false;
    return result;
  }
  function isBrowser() {
    const result = !isNode2() && !!getNavigator2();
    return result;
  }
  function getClientMeta() {
    return windowMetadata.getWindowMetadata();
  }
  var windowMetadata, windowGetters, getFromWindow2, getFromWindowOrThrow2, getDocumentOrThrow2, getDocument2, getNavigatorOrThrow2, getNavigator2, getLocationOrThrow2, getLocation2, getCryptoOrThrow2, getCrypto2, getLocalStorageOrThrow2, getLocalStorage2;
  var init_browser = __esm({
    "node_modules/@walletconnect/browser-utils/dist/esm/browser.js"() {
      windowMetadata = __toModule(require_cjs3());
      windowGetters = __toModule(require_cjs2());
      init_es();
      getFromWindow2 = windowGetters.getFromWindow;
      getFromWindowOrThrow2 = windowGetters.getFromWindowOrThrow;
      getDocumentOrThrow2 = windowGetters.getDocumentOrThrow;
      getDocument2 = windowGetters.getDocument;
      getNavigatorOrThrow2 = windowGetters.getNavigatorOrThrow;
      getNavigator2 = windowGetters.getNavigator;
      getLocationOrThrow2 = windowGetters.getLocationOrThrow;
      getLocation2 = windowGetters.getLocation;
      getCryptoOrThrow2 = windowGetters.getCryptoOrThrow;
      getCrypto2 = windowGetters.getCrypto;
      getLocalStorageOrThrow2 = windowGetters.getLocalStorageOrThrow;
      getLocalStorage2 = windowGetters.getLocalStorage;
    }
  });

  // node_modules/@walletconnect/browser-utils/dist/esm/json.js
  var safeJsonParse2, safeJsonStringify2;
  var init_json = __esm({
    "node_modules/@walletconnect/browser-utils/dist/esm/json.js"() {
      init_esm();
      safeJsonParse2 = safeJsonParse;
      safeJsonStringify2 = safeJsonStringify;
    }
  });

  // node_modules/@walletconnect/browser-utils/dist/esm/local.js
  function setLocal(key2, data4) {
    const raw = safeJsonStringify2(data4);
    const local = getLocalStorage2();
    if (local) {
      local.setItem(key2, raw);
    }
  }
  function getLocal(key2) {
    let data4 = null;
    let raw = null;
    const local = getLocalStorage2();
    if (local) {
      raw = local.getItem(key2);
    }
    data4 = raw ? safeJsonParse2(raw) : raw;
    return data4;
  }
  function removeLocal(key2) {
    const local = getLocalStorage2();
    if (local) {
      local.removeItem(key2);
    }
  }
  var init_local = __esm({
    "node_modules/@walletconnect/browser-utils/dist/esm/local.js"() {
      init_json();
      init_browser();
    }
  });

  // node_modules/@walletconnect/browser-utils/dist/esm/mobile.js
  function formatIOSMobile(uri, entry) {
    const encodedUri = encodeURIComponent(uri);
    return entry.universalLink ? `${entry.universalLink}/wc?uri=${encodedUri}` : entry.deepLink ? `${entry.deepLink}${entry.deepLink.endsWith(":") ? "//" : "/"}wc?uri=${encodedUri}` : "";
  }
  function saveMobileLinkInfo(data4) {
    const focusUri = data4.href.split("?")[0];
    setLocal(mobileLinkChoiceKey, Object.assign(Object.assign({}, data4), { href: focusUri }));
  }
  function getMobileRegistryEntry(registry, name2) {
    return registry.filter((entry) => entry.name.toLowerCase().includes(name2.toLowerCase()))[0];
  }
  function getMobileLinkRegistry(registry, whitelist) {
    let links = registry;
    if (whitelist) {
      links = whitelist.map((name2) => getMobileRegistryEntry(registry, name2)).filter(Boolean);
    }
    return links;
  }
  var mobileLinkChoiceKey;
  var init_mobile = __esm({
    "node_modules/@walletconnect/browser-utils/dist/esm/mobile.js"() {
      init_local();
      mobileLinkChoiceKey = "WALLETCONNECT_DEEPLINK_CHOICE";
    }
  });

  // node_modules/@walletconnect/browser-utils/dist/esm/registry.js
  function getWalletRegistryUrl() {
    return API_URL + "/api/v2/wallets";
  }
  function getDappRegistryUrl() {
    return API_URL + "/api/v2/dapps";
  }
  function formatMobileRegistryEntry(entry, platform = "mobile") {
    var _a;
    return {
      name: entry.name || "",
      shortName: entry.metadata.shortName || "",
      color: entry.metadata.colors.primary || "",
      logo: (_a = entry.image_url.sm) !== null && _a !== void 0 ? _a : "",
      universalLink: entry[platform].universal || "",
      deepLink: entry[platform].native || ""
    };
  }
  function formatMobileRegistry(registry, platform = "mobile") {
    return Object.values(registry).filter((entry) => !!entry[platform].universal || !!entry[platform].native).map((entry) => formatMobileRegistryEntry(entry, platform));
  }
  var API_URL;
  var init_registry = __esm({
    "node_modules/@walletconnect/browser-utils/dist/esm/registry.js"() {
      API_URL = "https://registry.walletconnect.com";
    }
  });

  // node_modules/@walletconnect/browser-utils/dist/esm/index.js
  var esm_exports3 = {};
  __export(esm_exports3, {
    detectEnv: () => detectEnv,
    detectOS: () => detectOS2,
    formatIOSMobile: () => formatIOSMobile,
    formatMobileRegistry: () => formatMobileRegistry,
    formatMobileRegistryEntry: () => formatMobileRegistryEntry,
    getClientMeta: () => getClientMeta,
    getCrypto: () => getCrypto2,
    getCryptoOrThrow: () => getCryptoOrThrow2,
    getDappRegistryUrl: () => getDappRegistryUrl,
    getDocument: () => getDocument2,
    getDocumentOrThrow: () => getDocumentOrThrow2,
    getFromWindow: () => getFromWindow2,
    getFromWindowOrThrow: () => getFromWindowOrThrow2,
    getLocal: () => getLocal,
    getLocalStorage: () => getLocalStorage2,
    getLocalStorageOrThrow: () => getLocalStorageOrThrow2,
    getLocation: () => getLocation2,
    getLocationOrThrow: () => getLocationOrThrow2,
    getMobileLinkRegistry: () => getMobileLinkRegistry,
    getMobileRegistryEntry: () => getMobileRegistryEntry,
    getNavigator: () => getNavigator2,
    getNavigatorOrThrow: () => getNavigatorOrThrow2,
    getWalletRegistryUrl: () => getWalletRegistryUrl,
    isAndroid: () => isAndroid,
    isBrowser: () => isBrowser,
    isIOS: () => isIOS,
    isMobile: () => isMobile,
    isNode: () => isNode2,
    mobileLinkChoiceKey: () => mobileLinkChoiceKey,
    removeLocal: () => removeLocal,
    safeJsonParse: () => safeJsonParse2,
    safeJsonStringify: () => safeJsonStringify2,
    saveMobileLinkInfo: () => saveMobileLinkInfo,
    setLocal: () => setLocal
  });
  var init_esm2 = __esm({
    "node_modules/@walletconnect/browser-utils/dist/esm/index.js"() {
      init_browser();
      init_json();
      init_local();
      init_mobile();
      init_registry();
    }
  });

  // node_modules/@walletconnect/utils/node_modules/bn.js/lib/bn.js
  var require_bn2 = __commonJS({
    "node_modules/@walletconnect/utils/node_modules/bn.js/lib/bn.js"(exports, module) {
      (function(module2, exports2) {
        "use strict";
        function assert3(val, msg) {
          if (!val)
            throw new Error(msg || "Assertion failed");
        }
        function inherits(ctor, superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
        function BN4(number, base2, endian) {
          if (BN4.isBN(number)) {
            return number;
          }
          this.negative = 0;
          this.words = null;
          this.length = 0;
          this.red = null;
          if (number !== null) {
            if (base2 === "le" || base2 === "be") {
              endian = base2;
              base2 = 10;
            }
            this._init(number || 0, base2 || 10, endian || "be");
          }
        }
        if (typeof module2 === "object") {
          module2.exports = BN4;
        } else {
          exports2.BN = BN4;
        }
        BN4.BN = BN4;
        BN4.wordSize = 26;
        var Buffer2;
        try {
          Buffer2 = require_buffer().Buffer;
        } catch (e3) {
        }
        BN4.isBN = function isBN(num) {
          if (num instanceof BN4) {
            return true;
          }
          return num !== null && typeof num === "object" && num.constructor.wordSize === BN4.wordSize && Array.isArray(num.words);
        };
        BN4.max = function max(left, right) {
          if (left.cmp(right) > 0)
            return left;
          return right;
        };
        BN4.min = function min(left, right) {
          if (left.cmp(right) < 0)
            return left;
          return right;
        };
        BN4.prototype._init = function init2(number, base2, endian) {
          if (typeof number === "number") {
            return this._initNumber(number, base2, endian);
          }
          if (typeof number === "object") {
            return this._initArray(number, base2, endian);
          }
          if (base2 === "hex") {
            base2 = 16;
          }
          assert3(base2 === (base2 | 0) && base2 >= 2 && base2 <= 36);
          number = number.toString().replace(/\s+/g, "");
          var start = 0;
          if (number[0] === "-") {
            start++;
          }
          if (base2 === 16) {
            this._parseHex(number, start);
          } else {
            this._parseBase(number, base2, start);
          }
          if (number[0] === "-") {
            this.negative = 1;
          }
          this.strip();
          if (endian !== "le")
            return;
          this._initArray(this.toArray(), base2, endian);
        };
        BN4.prototype._initNumber = function _initNumber(number, base2, endian) {
          if (number < 0) {
            this.negative = 1;
            number = -number;
          }
          if (number < 67108864) {
            this.words = [number & 67108863];
            this.length = 1;
          } else if (number < 4503599627370496) {
            this.words = [
              number & 67108863,
              number / 67108864 & 67108863
            ];
            this.length = 2;
          } else {
            assert3(number < 9007199254740992);
            this.words = [
              number & 67108863,
              number / 67108864 & 67108863,
              1
            ];
            this.length = 3;
          }
          if (endian !== "le")
            return;
          this._initArray(this.toArray(), base2, endian);
        };
        BN4.prototype._initArray = function _initArray(number, base2, endian) {
          assert3(typeof number.length === "number");
          if (number.length <= 0) {
            this.words = [0];
            this.length = 1;
            return this;
          }
          this.length = Math.ceil(number.length / 3);
          this.words = new Array(this.length);
          for (var i3 = 0; i3 < this.length; i3++) {
            this.words[i3] = 0;
          }
          var j3, w4;
          var off = 0;
          if (endian === "be") {
            for (i3 = number.length - 1, j3 = 0; i3 >= 0; i3 -= 3) {
              w4 = number[i3] | number[i3 - 1] << 8 | number[i3 - 2] << 16;
              this.words[j3] |= w4 << off & 67108863;
              this.words[j3 + 1] = w4 >>> 26 - off & 67108863;
              off += 24;
              if (off >= 26) {
                off -= 26;
                j3++;
              }
            }
          } else if (endian === "le") {
            for (i3 = 0, j3 = 0; i3 < number.length; i3 += 3) {
              w4 = number[i3] | number[i3 + 1] << 8 | number[i3 + 2] << 16;
              this.words[j3] |= w4 << off & 67108863;
              this.words[j3 + 1] = w4 >>> 26 - off & 67108863;
              off += 24;
              if (off >= 26) {
                off -= 26;
                j3++;
              }
            }
          }
          return this.strip();
        };
        function parseHex(str, start, end) {
          var r3 = 0;
          var len = Math.min(str.length, end);
          for (var i3 = start; i3 < len; i3++) {
            var c3 = str.charCodeAt(i3) - 48;
            r3 <<= 4;
            if (c3 >= 49 && c3 <= 54) {
              r3 |= c3 - 49 + 10;
            } else if (c3 >= 17 && c3 <= 22) {
              r3 |= c3 - 17 + 10;
            } else {
              r3 |= c3 & 15;
            }
          }
          return r3;
        }
        BN4.prototype._parseHex = function _parseHex(number, start) {
          this.length = Math.ceil((number.length - start) / 6);
          this.words = new Array(this.length);
          for (var i3 = 0; i3 < this.length; i3++) {
            this.words[i3] = 0;
          }
          var j3, w4;
          var off = 0;
          for (i3 = number.length - 6, j3 = 0; i3 >= start; i3 -= 6) {
            w4 = parseHex(number, i3, i3 + 6);
            this.words[j3] |= w4 << off & 67108863;
            this.words[j3 + 1] |= w4 >>> 26 - off & 4194303;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j3++;
            }
          }
          if (i3 + 6 !== start) {
            w4 = parseHex(number, start, i3 + 6);
            this.words[j3] |= w4 << off & 67108863;
            this.words[j3 + 1] |= w4 >>> 26 - off & 4194303;
          }
          this.strip();
        };
        function parseBase(str, start, end, mul3) {
          var r3 = 0;
          var len = Math.min(str.length, end);
          for (var i3 = start; i3 < len; i3++) {
            var c3 = str.charCodeAt(i3) - 48;
            r3 *= mul3;
            if (c3 >= 49) {
              r3 += c3 - 49 + 10;
            } else if (c3 >= 17) {
              r3 += c3 - 17 + 10;
            } else {
              r3 += c3;
            }
          }
          return r3;
        }
        BN4.prototype._parseBase = function _parseBase(number, base2, start) {
          this.words = [0];
          this.length = 1;
          for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base2) {
            limbLen++;
          }
          limbLen--;
          limbPow = limbPow / base2 | 0;
          var total = number.length - start;
          var mod = total % limbLen;
          var end = Math.min(total, total - mod) + start;
          var word = 0;
          for (var i3 = start; i3 < end; i3 += limbLen) {
            word = parseBase(number, i3, i3 + limbLen, base2);
            this.imuln(limbPow);
            if (this.words[0] + word < 67108864) {
              this.words[0] += word;
            } else {
              this._iaddn(word);
            }
          }
          if (mod !== 0) {
            var pow = 1;
            word = parseBase(number, i3, number.length, base2);
            for (i3 = 0; i3 < mod; i3++) {
              pow *= base2;
            }
            this.imuln(pow);
            if (this.words[0] + word < 67108864) {
              this.words[0] += word;
            } else {
              this._iaddn(word);
            }
          }
        };
        BN4.prototype.copy = function copy(dest) {
          dest.words = new Array(this.length);
          for (var i3 = 0; i3 < this.length; i3++) {
            dest.words[i3] = this.words[i3];
          }
          dest.length = this.length;
          dest.negative = this.negative;
          dest.red = this.red;
        };
        BN4.prototype.clone = function clone() {
          var r3 = new BN4(null);
          this.copy(r3);
          return r3;
        };
        BN4.prototype._expand = function _expand(size) {
          while (this.length < size) {
            this.words[this.length++] = 0;
          }
          return this;
        };
        BN4.prototype.strip = function strip() {
          while (this.length > 1 && this.words[this.length - 1] === 0) {
            this.length--;
          }
          return this._normSign();
        };
        BN4.prototype._normSign = function _normSign() {
          if (this.length === 1 && this.words[0] === 0) {
            this.negative = 0;
          }
          return this;
        };
        BN4.prototype.inspect = function inspect4() {
          return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
        };
        var zeros2 = [
          "",
          "0",
          "00",
          "000",
          "0000",
          "00000",
          "000000",
          "0000000",
          "00000000",
          "000000000",
          "0000000000",
          "00000000000",
          "000000000000",
          "0000000000000",
          "00000000000000",
          "000000000000000",
          "0000000000000000",
          "00000000000000000",
          "000000000000000000",
          "0000000000000000000",
          "00000000000000000000",
          "000000000000000000000",
          "0000000000000000000000",
          "00000000000000000000000",
          "000000000000000000000000",
          "0000000000000000000000000"
        ];
        var groupSizes = [
          0,
          0,
          25,
          16,
          12,
          11,
          10,
          9,
          8,
          8,
          7,
          7,
          7,
          7,
          6,
          6,
          6,
          6,
          6,
          6,
          6,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5
        ];
        var groupBases = [
          0,
          0,
          33554432,
          43046721,
          16777216,
          48828125,
          60466176,
          40353607,
          16777216,
          43046721,
          1e7,
          19487171,
          35831808,
          62748517,
          7529536,
          11390625,
          16777216,
          24137569,
          34012224,
          47045881,
          64e6,
          4084101,
          5153632,
          6436343,
          7962624,
          9765625,
          11881376,
          14348907,
          17210368,
          20511149,
          243e5,
          28629151,
          33554432,
          39135393,
          45435424,
          52521875,
          60466176
        ];
        BN4.prototype.toString = function toString(base2, padding2) {
          base2 = base2 || 10;
          padding2 = padding2 | 0 || 1;
          var out;
          if (base2 === 16 || base2 === "hex") {
            out = "";
            var off = 0;
            var carry = 0;
            for (var i3 = 0; i3 < this.length; i3++) {
              var w4 = this.words[i3];
              var word = ((w4 << off | carry) & 16777215).toString(16);
              carry = w4 >>> 24 - off & 16777215;
              if (carry !== 0 || i3 !== this.length - 1) {
                out = zeros2[6 - word.length] + word + out;
              } else {
                out = word + out;
              }
              off += 2;
              if (off >= 26) {
                off -= 26;
                i3--;
              }
            }
            if (carry !== 0) {
              out = carry.toString(16) + out;
            }
            while (out.length % padding2 !== 0) {
              out = "0" + out;
            }
            if (this.negative !== 0) {
              out = "-" + out;
            }
            return out;
          }
          if (base2 === (base2 | 0) && base2 >= 2 && base2 <= 36) {
            var groupSize = groupSizes[base2];
            var groupBase = groupBases[base2];
            out = "";
            var c3 = this.clone();
            c3.negative = 0;
            while (!c3.isZero()) {
              var r3 = c3.modn(groupBase).toString(base2);
              c3 = c3.idivn(groupBase);
              if (!c3.isZero()) {
                out = zeros2[groupSize - r3.length] + r3 + out;
              } else {
                out = r3 + out;
              }
            }
            if (this.isZero()) {
              out = "0" + out;
            }
            while (out.length % padding2 !== 0) {
              out = "0" + out;
            }
            if (this.negative !== 0) {
              out = "-" + out;
            }
            return out;
          }
          assert3(false, "Base should be between 2 and 36");
        };
        BN4.prototype.toNumber = function toNumber() {
          var ret = this.words[0];
          if (this.length === 2) {
            ret += this.words[1] * 67108864;
          } else if (this.length === 3 && this.words[2] === 1) {
            ret += 4503599627370496 + this.words[1] * 67108864;
          } else if (this.length > 2) {
            assert3(false, "Number can only safely store up to 53 bits");
          }
          return this.negative !== 0 ? -ret : ret;
        };
        BN4.prototype.toJSON = function toJSON2() {
          return this.toString(16);
        };
        BN4.prototype.toBuffer = function toBuffer(endian, length) {
          assert3(typeof Buffer2 !== "undefined");
          return this.toArrayLike(Buffer2, endian, length);
        };
        BN4.prototype.toArray = function toArray(endian, length) {
          return this.toArrayLike(Array, endian, length);
        };
        BN4.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
          var byteLength = this.byteLength();
          var reqLength = length || Math.max(1, byteLength);
          assert3(byteLength <= reqLength, "byte array longer than desired length");
          assert3(reqLength > 0, "Requested array length <= 0");
          this.strip();
          var littleEndian = endian === "le";
          var res = new ArrayType(reqLength);
          var b2, i3;
          var q3 = this.clone();
          if (!littleEndian) {
            for (i3 = 0; i3 < reqLength - byteLength; i3++) {
              res[i3] = 0;
            }
            for (i3 = 0; !q3.isZero(); i3++) {
              b2 = q3.andln(255);
              q3.iushrn(8);
              res[reqLength - i3 - 1] = b2;
            }
          } else {
            for (i3 = 0; !q3.isZero(); i3++) {
              b2 = q3.andln(255);
              q3.iushrn(8);
              res[i3] = b2;
            }
            for (; i3 < reqLength; i3++) {
              res[i3] = 0;
            }
          }
          return res;
        };
        if (Math.clz32) {
          BN4.prototype._countBits = function _countBits(w4) {
            return 32 - Math.clz32(w4);
          };
        } else {
          BN4.prototype._countBits = function _countBits(w4) {
            var t3 = w4;
            var r3 = 0;
            if (t3 >= 4096) {
              r3 += 13;
              t3 >>>= 13;
            }
            if (t3 >= 64) {
              r3 += 7;
              t3 >>>= 7;
            }
            if (t3 >= 8) {
              r3 += 4;
              t3 >>>= 4;
            }
            if (t3 >= 2) {
              r3 += 2;
              t3 >>>= 2;
            }
            return r3 + t3;
          };
        }
        BN4.prototype._zeroBits = function _zeroBits(w4) {
          if (w4 === 0)
            return 26;
          var t3 = w4;
          var r3 = 0;
          if ((t3 & 8191) === 0) {
            r3 += 13;
            t3 >>>= 13;
          }
          if ((t3 & 127) === 0) {
            r3 += 7;
            t3 >>>= 7;
          }
          if ((t3 & 15) === 0) {
            r3 += 4;
            t3 >>>= 4;
          }
          if ((t3 & 3) === 0) {
            r3 += 2;
            t3 >>>= 2;
          }
          if ((t3 & 1) === 0) {
            r3++;
          }
          return r3;
        };
        BN4.prototype.bitLength = function bitLength() {
          var w4 = this.words[this.length - 1];
          var hi = this._countBits(w4);
          return (this.length - 1) * 26 + hi;
        };
        function toBitArray(num) {
          var w4 = new Array(num.bitLength());
          for (var bit = 0; bit < w4.length; bit++) {
            var off = bit / 26 | 0;
            var wbit = bit % 26;
            w4[bit] = (num.words[off] & 1 << wbit) >>> wbit;
          }
          return w4;
        }
        BN4.prototype.zeroBits = function zeroBits() {
          if (this.isZero())
            return 0;
          var r3 = 0;
          for (var i3 = 0; i3 < this.length; i3++) {
            var b2 = this._zeroBits(this.words[i3]);
            r3 += b2;
            if (b2 !== 26)
              break;
          }
          return r3;
        };
        BN4.prototype.byteLength = function byteLength() {
          return Math.ceil(this.bitLength() / 8);
        };
        BN4.prototype.toTwos = function toTwos(width) {
          if (this.negative !== 0) {
            return this.abs().inotn(width).iaddn(1);
          }
          return this.clone();
        };
        BN4.prototype.fromTwos = function fromTwos(width) {
          if (this.testn(width - 1)) {
            return this.notn(width).iaddn(1).ineg();
          }
          return this.clone();
        };
        BN4.prototype.isNeg = function isNeg() {
          return this.negative !== 0;
        };
        BN4.prototype.neg = function neg3() {
          return this.clone().ineg();
        };
        BN4.prototype.ineg = function ineg() {
          if (!this.isZero()) {
            this.negative ^= 1;
          }
          return this;
        };
        BN4.prototype.iuor = function iuor(num) {
          while (this.length < num.length) {
            this.words[this.length++] = 0;
          }
          for (var i3 = 0; i3 < num.length; i3++) {
            this.words[i3] = this.words[i3] | num.words[i3];
          }
          return this.strip();
        };
        BN4.prototype.ior = function ior(num) {
          assert3((this.negative | num.negative) === 0);
          return this.iuor(num);
        };
        BN4.prototype.or = function or(num) {
          if (this.length > num.length)
            return this.clone().ior(num);
          return num.clone().ior(this);
        };
        BN4.prototype.uor = function uor(num) {
          if (this.length > num.length)
            return this.clone().iuor(num);
          return num.clone().iuor(this);
        };
        BN4.prototype.iuand = function iuand(num) {
          var b2;
          if (this.length > num.length) {
            b2 = num;
          } else {
            b2 = this;
          }
          for (var i3 = 0; i3 < b2.length; i3++) {
            this.words[i3] = this.words[i3] & num.words[i3];
          }
          this.length = b2.length;
          return this.strip();
        };
        BN4.prototype.iand = function iand(num) {
          assert3((this.negative | num.negative) === 0);
          return this.iuand(num);
        };
        BN4.prototype.and = function and(num) {
          if (this.length > num.length)
            return this.clone().iand(num);
          return num.clone().iand(this);
        };
        BN4.prototype.uand = function uand(num) {
          if (this.length > num.length)
            return this.clone().iuand(num);
          return num.clone().iuand(this);
        };
        BN4.prototype.iuxor = function iuxor(num) {
          var a3;
          var b2;
          if (this.length > num.length) {
            a3 = this;
            b2 = num;
          } else {
            a3 = num;
            b2 = this;
          }
          for (var i3 = 0; i3 < b2.length; i3++) {
            this.words[i3] = a3.words[i3] ^ b2.words[i3];
          }
          if (this !== a3) {
            for (; i3 < a3.length; i3++) {
              this.words[i3] = a3.words[i3];
            }
          }
          this.length = a3.length;
          return this.strip();
        };
        BN4.prototype.ixor = function ixor(num) {
          assert3((this.negative | num.negative) === 0);
          return this.iuxor(num);
        };
        BN4.prototype.xor = function xor(num) {
          if (this.length > num.length)
            return this.clone().ixor(num);
          return num.clone().ixor(this);
        };
        BN4.prototype.uxor = function uxor(num) {
          if (this.length > num.length)
            return this.clone().iuxor(num);
          return num.clone().iuxor(this);
        };
        BN4.prototype.inotn = function inotn(width) {
          assert3(typeof width === "number" && width >= 0);
          var bytesNeeded = Math.ceil(width / 26) | 0;
          var bitsLeft = width % 26;
          this._expand(bytesNeeded);
          if (bitsLeft > 0) {
            bytesNeeded--;
          }
          for (var i3 = 0; i3 < bytesNeeded; i3++) {
            this.words[i3] = ~this.words[i3] & 67108863;
          }
          if (bitsLeft > 0) {
            this.words[i3] = ~this.words[i3] & 67108863 >> 26 - bitsLeft;
          }
          return this.strip();
        };
        BN4.prototype.notn = function notn(width) {
          return this.clone().inotn(width);
        };
        BN4.prototype.setn = function setn(bit, val) {
          assert3(typeof bit === "number" && bit >= 0);
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          this._expand(off + 1);
          if (val) {
            this.words[off] = this.words[off] | 1 << wbit;
          } else {
            this.words[off] = this.words[off] & ~(1 << wbit);
          }
          return this.strip();
        };
        BN4.prototype.iadd = function iadd(num) {
          var r3;
          if (this.negative !== 0 && num.negative === 0) {
            this.negative = 0;
            r3 = this.isub(num);
            this.negative ^= 1;
            return this._normSign();
          } else if (this.negative === 0 && num.negative !== 0) {
            num.negative = 0;
            r3 = this.isub(num);
            num.negative = 1;
            return r3._normSign();
          }
          var a3, b2;
          if (this.length > num.length) {
            a3 = this;
            b2 = num;
          } else {
            a3 = num;
            b2 = this;
          }
          var carry = 0;
          for (var i3 = 0; i3 < b2.length; i3++) {
            r3 = (a3.words[i3] | 0) + (b2.words[i3] | 0) + carry;
            this.words[i3] = r3 & 67108863;
            carry = r3 >>> 26;
          }
          for (; carry !== 0 && i3 < a3.length; i3++) {
            r3 = (a3.words[i3] | 0) + carry;
            this.words[i3] = r3 & 67108863;
            carry = r3 >>> 26;
          }
          this.length = a3.length;
          if (carry !== 0) {
            this.words[this.length] = carry;
            this.length++;
          } else if (a3 !== this) {
            for (; i3 < a3.length; i3++) {
              this.words[i3] = a3.words[i3];
            }
          }
          return this;
        };
        BN4.prototype.add = function add3(num) {
          var res;
          if (num.negative !== 0 && this.negative === 0) {
            num.negative = 0;
            res = this.sub(num);
            num.negative ^= 1;
            return res;
          } else if (num.negative === 0 && this.negative !== 0) {
            this.negative = 0;
            res = num.sub(this);
            this.negative = 1;
            return res;
          }
          if (this.length > num.length)
            return this.clone().iadd(num);
          return num.clone().iadd(this);
        };
        BN4.prototype.isub = function isub(num) {
          if (num.negative !== 0) {
            num.negative = 0;
            var r3 = this.iadd(num);
            num.negative = 1;
            return r3._normSign();
          } else if (this.negative !== 0) {
            this.negative = 0;
            this.iadd(num);
            this.negative = 1;
            return this._normSign();
          }
          var cmp = this.cmp(num);
          if (cmp === 0) {
            this.negative = 0;
            this.length = 1;
            this.words[0] = 0;
            return this;
          }
          var a3, b2;
          if (cmp > 0) {
            a3 = this;
            b2 = num;
          } else {
            a3 = num;
            b2 = this;
          }
          var carry = 0;
          for (var i3 = 0; i3 < b2.length; i3++) {
            r3 = (a3.words[i3] | 0) - (b2.words[i3] | 0) + carry;
            carry = r3 >> 26;
            this.words[i3] = r3 & 67108863;
          }
          for (; carry !== 0 && i3 < a3.length; i3++) {
            r3 = (a3.words[i3] | 0) + carry;
            carry = r3 >> 26;
            this.words[i3] = r3 & 67108863;
          }
          if (carry === 0 && i3 < a3.length && a3 !== this) {
            for (; i3 < a3.length; i3++) {
              this.words[i3] = a3.words[i3];
            }
          }
          this.length = Math.max(this.length, i3);
          if (a3 !== this) {
            this.negative = 1;
          }
          return this.strip();
        };
        BN4.prototype.sub = function sub(num) {
          return this.clone().isub(num);
        };
        function smallMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative;
          var len = self2.length + num.length | 0;
          out.length = len;
          len = len - 1 | 0;
          var a3 = self2.words[0] | 0;
          var b2 = num.words[0] | 0;
          var r3 = a3 * b2;
          var lo = r3 & 67108863;
          var carry = r3 / 67108864 | 0;
          out.words[0] = lo;
          for (var k3 = 1; k3 < len; k3++) {
            var ncarry = carry >>> 26;
            var rword = carry & 67108863;
            var maxJ = Math.min(k3, num.length - 1);
            for (var j3 = Math.max(0, k3 - self2.length + 1); j3 <= maxJ; j3++) {
              var i3 = k3 - j3 | 0;
              a3 = self2.words[i3] | 0;
              b2 = num.words[j3] | 0;
              r3 = a3 * b2 + rword;
              ncarry += r3 / 67108864 | 0;
              rword = r3 & 67108863;
            }
            out.words[k3] = rword | 0;
            carry = ncarry | 0;
          }
          if (carry !== 0) {
            out.words[k3] = carry | 0;
          } else {
            out.length--;
          }
          return out.strip();
        }
        var comb10MulTo = function comb10MulTo2(self2, num, out) {
          var a3 = self2.words;
          var b2 = num.words;
          var o3 = out.words;
          var c3 = 0;
          var lo;
          var mid;
          var hi;
          var a0 = a3[0] | 0;
          var al0 = a0 & 8191;
          var ah0 = a0 >>> 13;
          var a1 = a3[1] | 0;
          var al1 = a1 & 8191;
          var ah1 = a1 >>> 13;
          var a22 = a3[2] | 0;
          var al2 = a22 & 8191;
          var ah2 = a22 >>> 13;
          var a32 = a3[3] | 0;
          var al3 = a32 & 8191;
          var ah3 = a32 >>> 13;
          var a4 = a3[4] | 0;
          var al4 = a4 & 8191;
          var ah4 = a4 >>> 13;
          var a5 = a3[5] | 0;
          var al5 = a5 & 8191;
          var ah5 = a5 >>> 13;
          var a6 = a3[6] | 0;
          var al6 = a6 & 8191;
          var ah6 = a6 >>> 13;
          var a7 = a3[7] | 0;
          var al7 = a7 & 8191;
          var ah7 = a7 >>> 13;
          var a8 = a3[8] | 0;
          var al8 = a8 & 8191;
          var ah8 = a8 >>> 13;
          var a9 = a3[9] | 0;
          var al9 = a9 & 8191;
          var ah9 = a9 >>> 13;
          var b0 = b2[0] | 0;
          var bl0 = b0 & 8191;
          var bh0 = b0 >>> 13;
          var b1 = b2[1] | 0;
          var bl1 = b1 & 8191;
          var bh1 = b1 >>> 13;
          var b22 = b2[2] | 0;
          var bl2 = b22 & 8191;
          var bh2 = b22 >>> 13;
          var b3 = b2[3] | 0;
          var bl3 = b3 & 8191;
          var bh3 = b3 >>> 13;
          var b4 = b2[4] | 0;
          var bl4 = b4 & 8191;
          var bh4 = b4 >>> 13;
          var b5 = b2[5] | 0;
          var bl5 = b5 & 8191;
          var bh5 = b5 >>> 13;
          var b6 = b2[6] | 0;
          var bl6 = b6 & 8191;
          var bh6 = b6 >>> 13;
          var b7 = b2[7] | 0;
          var bl7 = b7 & 8191;
          var bh7 = b7 >>> 13;
          var b8 = b2[8] | 0;
          var bl8 = b8 & 8191;
          var bh8 = b8 >>> 13;
          var b9 = b2[9] | 0;
          var bl9 = b9 & 8191;
          var bh9 = b9 >>> 13;
          out.negative = self2.negative ^ num.negative;
          out.length = 19;
          lo = Math.imul(al0, bl0);
          mid = Math.imul(al0, bh0);
          mid = mid + Math.imul(ah0, bl0) | 0;
          hi = Math.imul(ah0, bh0);
          var w0 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
          c3 = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
          w0 &= 67108863;
          lo = Math.imul(al1, bl0);
          mid = Math.imul(al1, bh0);
          mid = mid + Math.imul(ah1, bl0) | 0;
          hi = Math.imul(ah1, bh0);
          lo = lo + Math.imul(al0, bl1) | 0;
          mid = mid + Math.imul(al0, bh1) | 0;
          mid = mid + Math.imul(ah0, bl1) | 0;
          hi = hi + Math.imul(ah0, bh1) | 0;
          var w1 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
          c3 = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
          w1 &= 67108863;
          lo = Math.imul(al2, bl0);
          mid = Math.imul(al2, bh0);
          mid = mid + Math.imul(ah2, bl0) | 0;
          hi = Math.imul(ah2, bh0);
          lo = lo + Math.imul(al1, bl1) | 0;
          mid = mid + Math.imul(al1, bh1) | 0;
          mid = mid + Math.imul(ah1, bl1) | 0;
          hi = hi + Math.imul(ah1, bh1) | 0;
          lo = lo + Math.imul(al0, bl2) | 0;
          mid = mid + Math.imul(al0, bh2) | 0;
          mid = mid + Math.imul(ah0, bl2) | 0;
          hi = hi + Math.imul(ah0, bh2) | 0;
          var w22 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
          c3 = (hi + (mid >>> 13) | 0) + (w22 >>> 26) | 0;
          w22 &= 67108863;
          lo = Math.imul(al3, bl0);
          mid = Math.imul(al3, bh0);
          mid = mid + Math.imul(ah3, bl0) | 0;
          hi = Math.imul(ah3, bh0);
          lo = lo + Math.imul(al2, bl1) | 0;
          mid = mid + Math.imul(al2, bh1) | 0;
          mid = mid + Math.imul(ah2, bl1) | 0;
          hi = hi + Math.imul(ah2, bh1) | 0;
          lo = lo + Math.imul(al1, bl2) | 0;
          mid = mid + Math.imul(al1, bh2) | 0;
          mid = mid + Math.imul(ah1, bl2) | 0;
          hi = hi + Math.imul(ah1, bh2) | 0;
          lo = lo + Math.imul(al0, bl3) | 0;
          mid = mid + Math.imul(al0, bh3) | 0;
          mid = mid + Math.imul(ah0, bl3) | 0;
          hi = hi + Math.imul(ah0, bh3) | 0;
          var w32 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
          c3 = (hi + (mid >>> 13) | 0) + (w32 >>> 26) | 0;
          w32 &= 67108863;
          lo = Math.imul(al4, bl0);
          mid = Math.imul(al4, bh0);
          mid = mid + Math.imul(ah4, bl0) | 0;
          hi = Math.imul(ah4, bh0);
          lo = lo + Math.imul(al3, bl1) | 0;
          mid = mid + Math.imul(al3, bh1) | 0;
          mid = mid + Math.imul(ah3, bl1) | 0;
          hi = hi + Math.imul(ah3, bh1) | 0;
          lo = lo + Math.imul(al2, bl2) | 0;
          mid = mid + Math.imul(al2, bh2) | 0;
          mid = mid + Math.imul(ah2, bl2) | 0;
          hi = hi + Math.imul(ah2, bh2) | 0;
          lo = lo + Math.imul(al1, bl3) | 0;
          mid = mid + Math.imul(al1, bh3) | 0;
          mid = mid + Math.imul(ah1, bl3) | 0;
          hi = hi + Math.imul(ah1, bh3) | 0;
          lo = lo + Math.imul(al0, bl4) | 0;
          mid = mid + Math.imul(al0, bh4) | 0;
          mid = mid + Math.imul(ah0, bl4) | 0;
          hi = hi + Math.imul(ah0, bh4) | 0;
          var w4 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
          c3 = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
          w4 &= 67108863;
          lo = Math.imul(al5, bl0);
          mid = Math.imul(al5, bh0);
          mid = mid + Math.imul(ah5, bl0) | 0;
          hi = Math.imul(ah5, bh0);
          lo = lo + Math.imul(al4, bl1) | 0;
          mid = mid + Math.imul(al4, bh1) | 0;
          mid = mid + Math.imul(ah4, bl1) | 0;
          hi = hi + Math.imul(ah4, bh1) | 0;
          lo = lo + Math.imul(al3, bl2) | 0;
          mid = mid + Math.imul(al3, bh2) | 0;
          mid = mid + Math.imul(ah3, bl2) | 0;
          hi = hi + Math.imul(ah3, bh2) | 0;
          lo = lo + Math.imul(al2, bl3) | 0;
          mid = mid + Math.imul(al2, bh3) | 0;
          mid = mid + Math.imul(ah2, bl3) | 0;
          hi = hi + Math.imul(ah2, bh3) | 0;
          lo = lo + Math.imul(al1, bl4) | 0;
          mid = mid + Math.imul(al1, bh4) | 0;
          mid = mid + Math.imul(ah1, bl4) | 0;
          hi = hi + Math.imul(ah1, bh4) | 0;
          lo = lo + Math.imul(al0, bl5) | 0;
          mid = mid + Math.imul(al0, bh5) | 0;
          mid = mid + Math.imul(ah0, bl5) | 0;
          hi = hi + Math.imul(ah0, bh5) | 0;
          var w5 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
          c3 = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
          w5 &= 67108863;
          lo = Math.imul(al6, bl0);
          mid = Math.imul(al6, bh0);
          mid = mid + Math.imul(ah6, bl0) | 0;
          hi = Math.imul(ah6, bh0);
          lo = lo + Math.imul(al5, bl1) | 0;
          mid = mid + Math.imul(al5, bh1) | 0;
          mid = mid + Math.imul(ah5, bl1) | 0;
          hi = hi + Math.imul(ah5, bh1) | 0;
          lo = lo + Math.imul(al4, bl2) | 0;
          mid = mid + Math.imul(al4, bh2) | 0;
          mid = mid + Math.imul(ah4, bl2) | 0;
          hi = hi + Math.imul(ah4, bh2) | 0;
          lo = lo + Math.imul(al3, bl3) | 0;
          mid = mid + Math.imul(al3, bh3) | 0;
          mid = mid + Math.imul(ah3, bl3) | 0;
          hi = hi + Math.imul(ah3, bh3) | 0;
          lo = lo + Math.imul(al2, bl4) | 0;
          mid = mid + Math.imul(al2, bh4) | 0;
          mid = mid + Math.imul(ah2, bl4) | 0;
          hi = hi + Math.imul(ah2, bh4) | 0;
          lo = lo + Math.imul(al1, bl5) | 0;
          mid = mid + Math.imul(al1, bh5) | 0;
          mid = mid + Math.imul(ah1, bl5) | 0;
          hi = hi + Math.imul(ah1, bh5) | 0;
          lo = lo + Math.imul(al0, bl6) | 0;
          mid = mid + Math.imul(al0, bh6) | 0;
          mid = mid + Math.imul(ah0, bl6) | 0;
          hi = hi + Math.imul(ah0, bh6) | 0;
          var w6 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
          c3 = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
          w6 &= 67108863;
          lo = Math.imul(al7, bl0);
          mid = Math.imul(al7, bh0);
          mid = mid + Math.imul(ah7, bl0) | 0;
          hi = Math.imul(ah7, bh0);
          lo = lo + Math.imul(al6, bl1) | 0;
          mid = mid + Math.imul(al6, bh1) | 0;
          mid = mid + Math.imul(ah6, bl1) | 0;
          hi = hi + Math.imul(ah6, bh1) | 0;
          lo = lo + Math.imul(al5, bl2) | 0;
          mid = mid + Math.imul(al5, bh2) | 0;
          mid = mid + Math.imul(ah5, bl2) | 0;
          hi = hi + Math.imul(ah5, bh2) | 0;
          lo = lo + Math.imul(al4, bl3) | 0;
          mid = mid + Math.imul(al4, bh3) | 0;
          mid = mid + Math.imul(ah4, bl3) | 0;
          hi = hi + Math.imul(ah4, bh3) | 0;
          lo = lo + Math.imul(al3, bl4) | 0;
          mid = mid + Math.imul(al3, bh4) | 0;
          mid = mid + Math.imul(ah3, bl4) | 0;
          hi = hi + Math.imul(ah3, bh4) | 0;
          lo = lo + Math.imul(al2, bl5) | 0;
          mid = mid + Math.imul(al2, bh5) | 0;
          mid = mid + Math.imul(ah2, bl5) | 0;
          hi = hi + Math.imul(ah2, bh5) | 0;
          lo = lo + Math.imul(al1, bl6) | 0;
          mid = mid + Math.imul(al1, bh6) | 0;
          mid = mid + Math.imul(ah1, bl6) | 0;
          hi = hi + Math.imul(ah1, bh6) | 0;
          lo = lo + Math.imul(al0, bl7) | 0;
          mid = mid + Math.imul(al0, bh7) | 0;
          mid = mid + Math.imul(ah0, bl7) | 0;
          hi = hi + Math.imul(ah0, bh7) | 0;
          var w7 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
          c3 = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
          w7 &= 67108863;
          lo = Math.imul(al8, bl0);
          mid = Math.imul(al8, bh0);
          mid = mid + Math.imul(ah8, bl0) | 0;
          hi = Math.imul(ah8, bh0);
          lo = lo + Math.imul(al7, bl1) | 0;
          mid = mid + Math.imul(al7, bh1) | 0;
          mid = mid + Math.imul(ah7, bl1) | 0;
          hi = hi + Math.imul(ah7, bh1) | 0;
          lo = lo + Math.imul(al6, bl2) | 0;
          mid = mid + Math.imul(al6, bh2) | 0;
          mid = mid + Math.imul(ah6, bl2) | 0;
          hi = hi + Math.imul(ah6, bh2) | 0;
          lo = lo + Math.imul(al5, bl3) | 0;
          mid = mid + Math.imul(al5, bh3) | 0;
          mid = mid + Math.imul(ah5, bl3) | 0;
          hi = hi + Math.imul(ah5, bh3) | 0;
          lo = lo + Math.imul(al4, bl4) | 0;
          mid = mid + Math.imul(al4, bh4) | 0;
          mid = mid + Math.imul(ah4, bl4) | 0;
          hi = hi + Math.imul(ah4, bh4) | 0;
          lo = lo + Math.imul(al3, bl5) | 0;
          mid = mid + Math.imul(al3, bh5) | 0;
          mid = mid + Math.imul(ah3, bl5) | 0;
          hi = hi + Math.imul(ah3, bh5) | 0;
          lo = lo + Math.imul(al2, bl6) | 0;
          mid = mid + Math.imul(al2, bh6) | 0;
          mid = mid + Math.imul(ah2, bl6) | 0;
          hi = hi + Math.imul(ah2, bh6) | 0;
          lo = lo + Math.imul(al1, bl7) | 0;
          mid = mid + Math.imul(al1, bh7) | 0;
          mid = mid + Math.imul(ah1, bl7) | 0;
          hi = hi + Math.imul(ah1, bh7) | 0;
          lo = lo + Math.imul(al0, bl8) | 0;
          mid = mid + Math.imul(al0, bh8) | 0;
          mid = mid + Math.imul(ah0, bl8) | 0;
          hi = hi + Math.imul(ah0, bh8) | 0;
          var w8 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
          c3 = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
          w8 &= 67108863;
          lo = Math.imul(al9, bl0);
          mid = Math.imul(al9, bh0);
          mid = mid + Math.imul(ah9, bl0) | 0;
          hi = Math.imul(ah9, bh0);
          lo = lo + Math.imul(al8, bl1) | 0;
          mid = mid + Math.imul(al8, bh1) | 0;
          mid = mid + Math.imul(ah8, bl1) | 0;
          hi = hi + Math.imul(ah8, bh1) | 0;
          lo = lo + Math.imul(al7, bl2) | 0;
          mid = mid + Math.imul(al7, bh2) | 0;
          mid = mid + Math.imul(ah7, bl2) | 0;
          hi = hi + Math.imul(ah7, bh2) | 0;
          lo = lo + Math.imul(al6, bl3) | 0;
          mid = mid + Math.imul(al6, bh3) | 0;
          mid = mid + Math.imul(ah6, bl3) | 0;
          hi = hi + Math.imul(ah6, bh3) | 0;
          lo = lo + Math.imul(al5, bl4) | 0;
          mid = mid + Math.imul(al5, bh4) | 0;
          mid = mid + Math.imul(ah5, bl4) | 0;
          hi = hi + Math.imul(ah5, bh4) | 0;
          lo = lo + Math.imul(al4, bl5) | 0;
          mid = mid + Math.imul(al4, bh5) | 0;
          mid = mid + Math.imul(ah4, bl5) | 0;
          hi = hi + Math.imul(ah4, bh5) | 0;
          lo = lo + Math.imul(al3, bl6) | 0;
          mid = mid + Math.imul(al3, bh6) | 0;
          mid = mid + Math.imul(ah3, bl6) | 0;
          hi = hi + Math.imul(ah3, bh6) | 0;
          lo = lo + Math.imul(al2, bl7) | 0;
          mid = mid + Math.imul(al2, bh7) | 0;
          mid = mid + Math.imul(ah2, bl7) | 0;
          hi = hi + Math.imul(ah2, bh7) | 0;
          lo = lo + Math.imul(al1, bl8) | 0;
          mid = mid + Math.imul(al1, bh8) | 0;
          mid = mid + Math.imul(ah1, bl8) | 0;
          hi = hi + Math.imul(ah1, bh8) | 0;
          lo = lo + Math.imul(al0, bl9) | 0;
          mid = mid + Math.imul(al0, bh9) | 0;
          mid = mid + Math.imul(ah0, bl9) | 0;
          hi = hi + Math.imul(ah0, bh9) | 0;
          var w9 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
          c3 = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
          w9 &= 67108863;
          lo = Math.imul(al9, bl1);
          mid = Math.imul(al9, bh1);
          mid = mid + Math.imul(ah9, bl1) | 0;
          hi = Math.imul(ah9, bh1);
          lo = lo + Math.imul(al8, bl2) | 0;
          mid = mid + Math.imul(al8, bh2) | 0;
          mid = mid + Math.imul(ah8, bl2) | 0;
          hi = hi + Math.imul(ah8, bh2) | 0;
          lo = lo + Math.imul(al7, bl3) | 0;
          mid = mid + Math.imul(al7, bh3) | 0;
          mid = mid + Math.imul(ah7, bl3) | 0;
          hi = hi + Math.imul(ah7, bh3) | 0;
          lo = lo + Math.imul(al6, bl4) | 0;
          mid = mid + Math.imul(al6, bh4) | 0;
          mid = mid + Math.imul(ah6, bl4) | 0;
          hi = hi + Math.imul(ah6, bh4) | 0;
          lo = lo + Math.imul(al5, bl5) | 0;
          mid = mid + Math.imul(al5, bh5) | 0;
          mid = mid + Math.imul(ah5, bl5) | 0;
          hi = hi + Math.imul(ah5, bh5) | 0;
          lo = lo + Math.imul(al4, bl6) | 0;
          mid = mid + Math.imul(al4, bh6) | 0;
          mid = mid + Math.imul(ah4, bl6) | 0;
          hi = hi + Math.imul(ah4, bh6) | 0;
          lo = lo + Math.imul(al3, bl7) | 0;
          mid = mid + Math.imul(al3, bh7) | 0;
          mid = mid + Math.imul(ah3, bl7) | 0;
          hi = hi + Math.imul(ah3, bh7) | 0;
          lo = lo + Math.imul(al2, bl8) | 0;
          mid = mid + Math.imul(al2, bh8) | 0;
          mid = mid + Math.imul(ah2, bl8) | 0;
          hi = hi + Math.imul(ah2, bh8) | 0;
          lo = lo + Math.imul(al1, bl9) | 0;
          mid = mid + Math.imul(al1, bh9) | 0;
          mid = mid + Math.imul(ah1, bl9) | 0;
          hi = hi + Math.imul(ah1, bh9) | 0;
          var w10 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
          c3 = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
          w10 &= 67108863;
          lo = Math.imul(al9, bl2);
          mid = Math.imul(al9, bh2);
          mid = mid + Math.imul(ah9, bl2) | 0;
          hi = Math.imul(ah9, bh2);
          lo = lo + Math.imul(al8, bl3) | 0;
          mid = mid + Math.imul(al8, bh3) | 0;
          mid = mid + Math.imul(ah8, bl3) | 0;
          hi = hi + Math.imul(ah8, bh3) | 0;
          lo = lo + Math.imul(al7, bl4) | 0;
          mid = mid + Math.imul(al7, bh4) | 0;
          mid = mid + Math.imul(ah7, bl4) | 0;
          hi = hi + Math.imul(ah7, bh4) | 0;
          lo = lo + Math.imul(al6, bl5) | 0;
          mid = mid + Math.imul(al6, bh5) | 0;
          mid = mid + Math.imul(ah6, bl5) | 0;
          hi = hi + Math.imul(ah6, bh5) | 0;
          lo = lo + Math.imul(al5, bl6) | 0;
          mid = mid + Math.imul(al5, bh6) | 0;
          mid = mid + Math.imul(ah5, bl6) | 0;
          hi = hi + Math.imul(ah5, bh6) | 0;
          lo = lo + Math.imul(al4, bl7) | 0;
          mid = mid + Math.imul(al4, bh7) | 0;
          mid = mid + Math.imul(ah4, bl7) | 0;
          hi = hi + Math.imul(ah4, bh7) | 0;
          lo = lo + Math.imul(al3, bl8) | 0;
          mid = mid + Math.imul(al3, bh8) | 0;
          mid = mid + Math.imul(ah3, bl8) | 0;
          hi = hi + Math.imul(ah3, bh8) | 0;
          lo = lo + Math.imul(al2, bl9) | 0;
          mid = mid + Math.imul(al2, bh9) | 0;
          mid = mid + Math.imul(ah2, bl9) | 0;
          hi = hi + Math.imul(ah2, bh9) | 0;
          var w11 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
          c3 = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
          w11 &= 67108863;
          lo = Math.imul(al9, bl3);
          mid = Math.imul(al9, bh3);
          mid = mid + Math.imul(ah9, bl3) | 0;
          hi = Math.imul(ah9, bh3);
          lo = lo + Math.imul(al8, bl4) | 0;
          mid = mid + Math.imul(al8, bh4) | 0;
          mid = mid + Math.imul(ah8, bl4) | 0;
          hi = hi + Math.imul(ah8, bh4) | 0;
          lo = lo + Math.imul(al7, bl5) | 0;
          mid = mid + Math.imul(al7, bh5) | 0;
          mid = mid + Math.imul(ah7, bl5) | 0;
          hi = hi + Math.imul(ah7, bh5) | 0;
          lo = lo + Math.imul(al6, bl6) | 0;
          mid = mid + Math.imul(al6, bh6) | 0;
          mid = mid + Math.imul(ah6, bl6) | 0;
          hi = hi + Math.imul(ah6, bh6) | 0;
          lo = lo + Math.imul(al5, bl7) | 0;
          mid = mid + Math.imul(al5, bh7) | 0;
          mid = mid + Math.imul(ah5, bl7) | 0;
          hi = hi + Math.imul(ah5, bh7) | 0;
          lo = lo + Math.imul(al4, bl8) | 0;
          mid = mid + Math.imul(al4, bh8) | 0;
          mid = mid + Math.imul(ah4, bl8) | 0;
          hi = hi + Math.imul(ah4, bh8) | 0;
          lo = lo + Math.imul(al3, bl9) | 0;
          mid = mid + Math.imul(al3, bh9) | 0;
          mid = mid + Math.imul(ah3, bl9) | 0;
          hi = hi + Math.imul(ah3, bh9) | 0;
          var w12 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
          c3 = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
          w12 &= 67108863;
          lo = Math.imul(al9, bl4);
          mid = Math.imul(al9, bh4);
          mid = mid + Math.imul(ah9, bl4) | 0;
          hi = Math.imul(ah9, bh4);
          lo = lo + Math.imul(al8, bl5) | 0;
          mid = mid + Math.imul(al8, bh5) | 0;
          mid = mid + Math.imul(ah8, bl5) | 0;
          hi = hi + Math.imul(ah8, bh5) | 0;
          lo = lo + Math.imul(al7, bl6) | 0;
          mid = mid + Math.imul(al7, bh6) | 0;
          mid = mid + Math.imul(ah7, bl6) | 0;
          hi = hi + Math.imul(ah7, bh6) | 0;
          lo = lo + Math.imul(al6, bl7) | 0;
          mid = mid + Math.imul(al6, bh7) | 0;
          mid = mid + Math.imul(ah6, bl7) | 0;
          hi = hi + Math.imul(ah6, bh7) | 0;
          lo = lo + Math.imul(al5, bl8) | 0;
          mid = mid + Math.imul(al5, bh8) | 0;
          mid = mid + Math.imul(ah5, bl8) | 0;
          hi = hi + Math.imul(ah5, bh8) | 0;
          lo = lo + Math.imul(al4, bl9) | 0;
          mid = mid + Math.imul(al4, bh9) | 0;
          mid = mid + Math.imul(ah4, bl9) | 0;
          hi = hi + Math.imul(ah4, bh9) | 0;
          var w13 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
          c3 = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
          w13 &= 67108863;
          lo = Math.imul(al9, bl5);
          mid = Math.imul(al9, bh5);
          mid = mid + Math.imul(ah9, bl5) | 0;
          hi = Math.imul(ah9, bh5);
          lo = lo + Math.imul(al8, bl6) | 0;
          mid = mid + Math.imul(al8, bh6) | 0;
          mid = mid + Math.imul(ah8, bl6) | 0;
          hi = hi + Math.imul(ah8, bh6) | 0;
          lo = lo + Math.imul(al7, bl7) | 0;
          mid = mid + Math.imul(al7, bh7) | 0;
          mid = mid + Math.imul(ah7, bl7) | 0;
          hi = hi + Math.imul(ah7, bh7) | 0;
          lo = lo + Math.imul(al6, bl8) | 0;
          mid = mid + Math.imul(al6, bh8) | 0;
          mid = mid + Math.imul(ah6, bl8) | 0;
          hi = hi + Math.imul(ah6, bh8) | 0;
          lo = lo + Math.imul(al5, bl9) | 0;
          mid = mid + Math.imul(al5, bh9) | 0;
          mid = mid + Math.imul(ah5, bl9) | 0;
          hi = hi + Math.imul(ah5, bh9) | 0;
          var w14 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
          c3 = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
          w14 &= 67108863;
          lo = Math.imul(al9, bl6);
          mid = Math.imul(al9, bh6);
          mid = mid + Math.imul(ah9, bl6) | 0;
          hi = Math.imul(ah9, bh6);
          lo = lo + Math.imul(al8, bl7) | 0;
          mid = mid + Math.imul(al8, bh7) | 0;
          mid = mid + Math.imul(ah8, bl7) | 0;
          hi = hi + Math.imul(ah8, bh7) | 0;
          lo = lo + Math.imul(al7, bl8) | 0;
          mid = mid + Math.imul(al7, bh8) | 0;
          mid = mid + Math.imul(ah7, bl8) | 0;
          hi = hi + Math.imul(ah7, bh8) | 0;
          lo = lo + Math.imul(al6, bl9) | 0;
          mid = mid + Math.imul(al6, bh9) | 0;
          mid = mid + Math.imul(ah6, bl9) | 0;
          hi = hi + Math.imul(ah6, bh9) | 0;
          var w15 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
          c3 = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
          w15 &= 67108863;
          lo = Math.imul(al9, bl7);
          mid = Math.imul(al9, bh7);
          mid = mid + Math.imul(ah9, bl7) | 0;
          hi = Math.imul(ah9, bh7);
          lo = lo + Math.imul(al8, bl8) | 0;
          mid = mid + Math.imul(al8, bh8) | 0;
          mid = mid + Math.imul(ah8, bl8) | 0;
          hi = hi + Math.imul(ah8, bh8) | 0;
          lo = lo + Math.imul(al7, bl9) | 0;
          mid = mid + Math.imul(al7, bh9) | 0;
          mid = mid + Math.imul(ah7, bl9) | 0;
          hi = hi + Math.imul(ah7, bh9) | 0;
          var w16 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
          c3 = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
          w16 &= 67108863;
          lo = Math.imul(al9, bl8);
          mid = Math.imul(al9, bh8);
          mid = mid + Math.imul(ah9, bl8) | 0;
          hi = Math.imul(ah9, bh8);
          lo = lo + Math.imul(al8, bl9) | 0;
          mid = mid + Math.imul(al8, bh9) | 0;
          mid = mid + Math.imul(ah8, bl9) | 0;
          hi = hi + Math.imul(ah8, bh9) | 0;
          var w17 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
          c3 = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
          w17 &= 67108863;
          lo = Math.imul(al9, bl9);
          mid = Math.imul(al9, bh9);
          mid = mid + Math.imul(ah9, bl9) | 0;
          hi = Math.imul(ah9, bh9);
          var w18 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
          c3 = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
          w18 &= 67108863;
          o3[0] = w0;
          o3[1] = w1;
          o3[2] = w22;
          o3[3] = w32;
          o3[4] = w4;
          o3[5] = w5;
          o3[6] = w6;
          o3[7] = w7;
          o3[8] = w8;
          o3[9] = w9;
          o3[10] = w10;
          o3[11] = w11;
          o3[12] = w12;
          o3[13] = w13;
          o3[14] = w14;
          o3[15] = w15;
          o3[16] = w16;
          o3[17] = w17;
          o3[18] = w18;
          if (c3 !== 0) {
            o3[19] = c3;
            out.length++;
          }
          return out;
        };
        if (!Math.imul) {
          comb10MulTo = smallMulTo;
        }
        function bigMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative;
          out.length = self2.length + num.length;
          var carry = 0;
          var hncarry = 0;
          for (var k3 = 0; k3 < out.length - 1; k3++) {
            var ncarry = hncarry;
            hncarry = 0;
            var rword = carry & 67108863;
            var maxJ = Math.min(k3, num.length - 1);
            for (var j3 = Math.max(0, k3 - self2.length + 1); j3 <= maxJ; j3++) {
              var i3 = k3 - j3;
              var a3 = self2.words[i3] | 0;
              var b2 = num.words[j3] | 0;
              var r3 = a3 * b2;
              var lo = r3 & 67108863;
              ncarry = ncarry + (r3 / 67108864 | 0) | 0;
              lo = lo + rword | 0;
              rword = lo & 67108863;
              ncarry = ncarry + (lo >>> 26) | 0;
              hncarry += ncarry >>> 26;
              ncarry &= 67108863;
            }
            out.words[k3] = rword;
            carry = ncarry;
            ncarry = hncarry;
          }
          if (carry !== 0) {
            out.words[k3] = carry;
          } else {
            out.length--;
          }
          return out.strip();
        }
        function jumboMulTo(self2, num, out) {
          var fftm = new FFTM();
          return fftm.mulp(self2, num, out);
        }
        BN4.prototype.mulTo = function mulTo(num, out) {
          var res;
          var len = this.length + num.length;
          if (this.length === 10 && num.length === 10) {
            res = comb10MulTo(this, num, out);
          } else if (len < 63) {
            res = smallMulTo(this, num, out);
          } else if (len < 1024) {
            res = bigMulTo(this, num, out);
          } else {
            res = jumboMulTo(this, num, out);
          }
          return res;
        };
        function FFTM(x3, y3) {
          this.x = x3;
          this.y = y3;
        }
        FFTM.prototype.makeRBT = function makeRBT(N4) {
          var t3 = new Array(N4);
          var l3 = BN4.prototype._countBits(N4) - 1;
          for (var i3 = 0; i3 < N4; i3++) {
            t3[i3] = this.revBin(i3, l3, N4);
          }
          return t3;
        };
        FFTM.prototype.revBin = function revBin(x3, l3, N4) {
          if (x3 === 0 || x3 === N4 - 1)
            return x3;
          var rb = 0;
          for (var i3 = 0; i3 < l3; i3++) {
            rb |= (x3 & 1) << l3 - i3 - 1;
            x3 >>= 1;
          }
          return rb;
        };
        FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N4) {
          for (var i3 = 0; i3 < N4; i3++) {
            rtws[i3] = rws[rbt[i3]];
            itws[i3] = iws[rbt[i3]];
          }
        };
        FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N4, rbt) {
          this.permute(rbt, rws, iws, rtws, itws, N4);
          for (var s3 = 1; s3 < N4; s3 <<= 1) {
            var l3 = s3 << 1;
            var rtwdf = Math.cos(2 * Math.PI / l3);
            var itwdf = Math.sin(2 * Math.PI / l3);
            for (var p3 = 0; p3 < N4; p3 += l3) {
              var rtwdf_ = rtwdf;
              var itwdf_ = itwdf;
              for (var j3 = 0; j3 < s3; j3++) {
                var re = rtws[p3 + j3];
                var ie = itws[p3 + j3];
                var ro = rtws[p3 + j3 + s3];
                var io = itws[p3 + j3 + s3];
                var rx = rtwdf_ * ro - itwdf_ * io;
                io = rtwdf_ * io + itwdf_ * ro;
                ro = rx;
                rtws[p3 + j3] = re + ro;
                itws[p3 + j3] = ie + io;
                rtws[p3 + j3 + s3] = re - ro;
                itws[p3 + j3 + s3] = ie - io;
                if (j3 !== l3) {
                  rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                  itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                  rtwdf_ = rx;
                }
              }
            }
          }
        };
        FFTM.prototype.guessLen13b = function guessLen13b(n2, m3) {
          var N4 = Math.max(m3, n2) | 1;
          var odd = N4 & 1;
          var i3 = 0;
          for (N4 = N4 / 2 | 0; N4; N4 = N4 >>> 1) {
            i3++;
          }
          return 1 << i3 + 1 + odd;
        };
        FFTM.prototype.conjugate = function conjugate(rws, iws, N4) {
          if (N4 <= 1)
            return;
          for (var i3 = 0; i3 < N4 / 2; i3++) {
            var t3 = rws[i3];
            rws[i3] = rws[N4 - i3 - 1];
            rws[N4 - i3 - 1] = t3;
            t3 = iws[i3];
            iws[i3] = -iws[N4 - i3 - 1];
            iws[N4 - i3 - 1] = -t3;
          }
        };
        FFTM.prototype.normalize13b = function normalize13b(ws, N4) {
          var carry = 0;
          for (var i3 = 0; i3 < N4 / 2; i3++) {
            var w4 = Math.round(ws[2 * i3 + 1] / N4) * 8192 + Math.round(ws[2 * i3] / N4) + carry;
            ws[i3] = w4 & 67108863;
            if (w4 < 67108864) {
              carry = 0;
            } else {
              carry = w4 / 67108864 | 0;
            }
          }
          return ws;
        };
        FFTM.prototype.convert13b = function convert13b(ws, len, rws, N4) {
          var carry = 0;
          for (var i3 = 0; i3 < len; i3++) {
            carry = carry + (ws[i3] | 0);
            rws[2 * i3] = carry & 8191;
            carry = carry >>> 13;
            rws[2 * i3 + 1] = carry & 8191;
            carry = carry >>> 13;
          }
          for (i3 = 2 * len; i3 < N4; ++i3) {
            rws[i3] = 0;
          }
          assert3(carry === 0);
          assert3((carry & ~8191) === 0);
        };
        FFTM.prototype.stub = function stub(N4) {
          var ph = new Array(N4);
          for (var i3 = 0; i3 < N4; i3++) {
            ph[i3] = 0;
          }
          return ph;
        };
        FFTM.prototype.mulp = function mulp(x3, y3, out) {
          var N4 = 2 * this.guessLen13b(x3.length, y3.length);
          var rbt = this.makeRBT(N4);
          var _4 = this.stub(N4);
          var rws = new Array(N4);
          var rwst = new Array(N4);
          var iwst = new Array(N4);
          var nrws = new Array(N4);
          var nrwst = new Array(N4);
          var niwst = new Array(N4);
          var rmws = out.words;
          rmws.length = N4;
          this.convert13b(x3.words, x3.length, rws, N4);
          this.convert13b(y3.words, y3.length, nrws, N4);
          this.transform(rws, _4, rwst, iwst, N4, rbt);
          this.transform(nrws, _4, nrwst, niwst, N4, rbt);
          for (var i3 = 0; i3 < N4; i3++) {
            var rx = rwst[i3] * nrwst[i3] - iwst[i3] * niwst[i3];
            iwst[i3] = rwst[i3] * niwst[i3] + iwst[i3] * nrwst[i3];
            rwst[i3] = rx;
          }
          this.conjugate(rwst, iwst, N4);
          this.transform(rwst, iwst, rmws, _4, N4, rbt);
          this.conjugate(rmws, _4, N4);
          this.normalize13b(rmws, N4);
          out.negative = x3.negative ^ y3.negative;
          out.length = x3.length + y3.length;
          return out.strip();
        };
        BN4.prototype.mul = function mul3(num) {
          var out = new BN4(null);
          out.words = new Array(this.length + num.length);
          return this.mulTo(num, out);
        };
        BN4.prototype.mulf = function mulf(num) {
          var out = new BN4(null);
          out.words = new Array(this.length + num.length);
          return jumboMulTo(this, num, out);
        };
        BN4.prototype.imul = function imul(num) {
          return this.clone().mulTo(num, this);
        };
        BN4.prototype.imuln = function imuln(num) {
          assert3(typeof num === "number");
          assert3(num < 67108864);
          var carry = 0;
          for (var i3 = 0; i3 < this.length; i3++) {
            var w4 = (this.words[i3] | 0) * num;
            var lo = (w4 & 67108863) + (carry & 67108863);
            carry >>= 26;
            carry += w4 / 67108864 | 0;
            carry += lo >>> 26;
            this.words[i3] = lo & 67108863;
          }
          if (carry !== 0) {
            this.words[i3] = carry;
            this.length++;
          }
          return this;
        };
        BN4.prototype.muln = function muln(num) {
          return this.clone().imuln(num);
        };
        BN4.prototype.sqr = function sqr() {
          return this.mul(this);
        };
        BN4.prototype.isqr = function isqr() {
          return this.imul(this.clone());
        };
        BN4.prototype.pow = function pow(num) {
          var w4 = toBitArray(num);
          if (w4.length === 0)
            return new BN4(1);
          var res = this;
          for (var i3 = 0; i3 < w4.length; i3++, res = res.sqr()) {
            if (w4[i3] !== 0)
              break;
          }
          if (++i3 < w4.length) {
            for (var q3 = res.sqr(); i3 < w4.length; i3++, q3 = q3.sqr()) {
              if (w4[i3] === 0)
                continue;
              res = res.mul(q3);
            }
          }
          return res;
        };
        BN4.prototype.iushln = function iushln(bits) {
          assert3(typeof bits === "number" && bits >= 0);
          var r3 = bits % 26;
          var s3 = (bits - r3) / 26;
          var carryMask = 67108863 >>> 26 - r3 << 26 - r3;
          var i3;
          if (r3 !== 0) {
            var carry = 0;
            for (i3 = 0; i3 < this.length; i3++) {
              var newCarry = this.words[i3] & carryMask;
              var c3 = (this.words[i3] | 0) - newCarry << r3;
              this.words[i3] = c3 | carry;
              carry = newCarry >>> 26 - r3;
            }
            if (carry) {
              this.words[i3] = carry;
              this.length++;
            }
          }
          if (s3 !== 0) {
            for (i3 = this.length - 1; i3 >= 0; i3--) {
              this.words[i3 + s3] = this.words[i3];
            }
            for (i3 = 0; i3 < s3; i3++) {
              this.words[i3] = 0;
            }
            this.length += s3;
          }
          return this.strip();
        };
        BN4.prototype.ishln = function ishln(bits) {
          assert3(this.negative === 0);
          return this.iushln(bits);
        };
        BN4.prototype.iushrn = function iushrn(bits, hint, extended) {
          assert3(typeof bits === "number" && bits >= 0);
          var h3;
          if (hint) {
            h3 = (hint - hint % 26) / 26;
          } else {
            h3 = 0;
          }
          var r3 = bits % 26;
          var s3 = Math.min((bits - r3) / 26, this.length);
          var mask = 67108863 ^ 67108863 >>> r3 << r3;
          var maskedWords = extended;
          h3 -= s3;
          h3 = Math.max(0, h3);
          if (maskedWords) {
            for (var i3 = 0; i3 < s3; i3++) {
              maskedWords.words[i3] = this.words[i3];
            }
            maskedWords.length = s3;
          }
          if (s3 === 0) {
          } else if (this.length > s3) {
            this.length -= s3;
            for (i3 = 0; i3 < this.length; i3++) {
              this.words[i3] = this.words[i3 + s3];
            }
          } else {
            this.words[0] = 0;
            this.length = 1;
          }
          var carry = 0;
          for (i3 = this.length - 1; i3 >= 0 && (carry !== 0 || i3 >= h3); i3--) {
            var word = this.words[i3] | 0;
            this.words[i3] = carry << 26 - r3 | word >>> r3;
            carry = word & mask;
          }
          if (maskedWords && carry !== 0) {
            maskedWords.words[maskedWords.length++] = carry;
          }
          if (this.length === 0) {
            this.words[0] = 0;
            this.length = 1;
          }
          return this.strip();
        };
        BN4.prototype.ishrn = function ishrn(bits, hint, extended) {
          assert3(this.negative === 0);
          return this.iushrn(bits, hint, extended);
        };
        BN4.prototype.shln = function shln(bits) {
          return this.clone().ishln(bits);
        };
        BN4.prototype.ushln = function ushln(bits) {
          return this.clone().iushln(bits);
        };
        BN4.prototype.shrn = function shrn(bits) {
          return this.clone().ishrn(bits);
        };
        BN4.prototype.ushrn = function ushrn(bits) {
          return this.clone().iushrn(bits);
        };
        BN4.prototype.testn = function testn(bit) {
          assert3(typeof bit === "number" && bit >= 0);
          var r3 = bit % 26;
          var s3 = (bit - r3) / 26;
          var q3 = 1 << r3;
          if (this.length <= s3)
            return false;
          var w4 = this.words[s3];
          return !!(w4 & q3);
        };
        BN4.prototype.imaskn = function imaskn(bits) {
          assert3(typeof bits === "number" && bits >= 0);
          var r3 = bits % 26;
          var s3 = (bits - r3) / 26;
          assert3(this.negative === 0, "imaskn works only with positive numbers");
          if (this.length <= s3) {
            return this;
          }
          if (r3 !== 0) {
            s3++;
          }
          this.length = Math.min(s3, this.length);
          if (r3 !== 0) {
            var mask = 67108863 ^ 67108863 >>> r3 << r3;
            this.words[this.length - 1] &= mask;
          }
          return this.strip();
        };
        BN4.prototype.maskn = function maskn(bits) {
          return this.clone().imaskn(bits);
        };
        BN4.prototype.iaddn = function iaddn(num) {
          assert3(typeof num === "number");
          assert3(num < 67108864);
          if (num < 0)
            return this.isubn(-num);
          if (this.negative !== 0) {
            if (this.length === 1 && (this.words[0] | 0) < num) {
              this.words[0] = num - (this.words[0] | 0);
              this.negative = 0;
              return this;
            }
            this.negative = 0;
            this.isubn(num);
            this.negative = 1;
            return this;
          }
          return this._iaddn(num);
        };
        BN4.prototype._iaddn = function _iaddn(num) {
          this.words[0] += num;
          for (var i3 = 0; i3 < this.length && this.words[i3] >= 67108864; i3++) {
            this.words[i3] -= 67108864;
            if (i3 === this.length - 1) {
              this.words[i3 + 1] = 1;
            } else {
              this.words[i3 + 1]++;
            }
          }
          this.length = Math.max(this.length, i3 + 1);
          return this;
        };
        BN4.prototype.isubn = function isubn(num) {
          assert3(typeof num === "number");
          assert3(num < 67108864);
          if (num < 0)
            return this.iaddn(-num);
          if (this.negative !== 0) {
            this.negative = 0;
            this.iaddn(num);
            this.negative = 1;
            return this;
          }
          this.words[0] -= num;
          if (this.length === 1 && this.words[0] < 0) {
            this.words[0] = -this.words[0];
            this.negative = 1;
          } else {
            for (var i3 = 0; i3 < this.length && this.words[i3] < 0; i3++) {
              this.words[i3] += 67108864;
              this.words[i3 + 1] -= 1;
            }
          }
          return this.strip();
        };
        BN4.prototype.addn = function addn(num) {
          return this.clone().iaddn(num);
        };
        BN4.prototype.subn = function subn(num) {
          return this.clone().isubn(num);
        };
        BN4.prototype.iabs = function iabs() {
          this.negative = 0;
          return this;
        };
        BN4.prototype.abs = function abs() {
          return this.clone().iabs();
        };
        BN4.prototype._ishlnsubmul = function _ishlnsubmul(num, mul3, shift) {
          var len = num.length + shift;
          var i3;
          this._expand(len);
          var w4;
          var carry = 0;
          for (i3 = 0; i3 < num.length; i3++) {
            w4 = (this.words[i3 + shift] | 0) + carry;
            var right = (num.words[i3] | 0) * mul3;
            w4 -= right & 67108863;
            carry = (w4 >> 26) - (right / 67108864 | 0);
            this.words[i3 + shift] = w4 & 67108863;
          }
          for (; i3 < this.length - shift; i3++) {
            w4 = (this.words[i3 + shift] | 0) + carry;
            carry = w4 >> 26;
            this.words[i3 + shift] = w4 & 67108863;
          }
          if (carry === 0)
            return this.strip();
          assert3(carry === -1);
          carry = 0;
          for (i3 = 0; i3 < this.length; i3++) {
            w4 = -(this.words[i3] | 0) + carry;
            carry = w4 >> 26;
            this.words[i3] = w4 & 67108863;
          }
          this.negative = 1;
          return this.strip();
        };
        BN4.prototype._wordDiv = function _wordDiv(num, mode) {
          var shift = this.length - num.length;
          var a3 = this.clone();
          var b2 = num;
          var bhi = b2.words[b2.length - 1] | 0;
          var bhiBits = this._countBits(bhi);
          shift = 26 - bhiBits;
          if (shift !== 0) {
            b2 = b2.ushln(shift);
            a3.iushln(shift);
            bhi = b2.words[b2.length - 1] | 0;
          }
          var m3 = a3.length - b2.length;
          var q3;
          if (mode !== "mod") {
            q3 = new BN4(null);
            q3.length = m3 + 1;
            q3.words = new Array(q3.length);
            for (var i3 = 0; i3 < q3.length; i3++) {
              q3.words[i3] = 0;
            }
          }
          var diff = a3.clone()._ishlnsubmul(b2, 1, m3);
          if (diff.negative === 0) {
            a3 = diff;
            if (q3) {
              q3.words[m3] = 1;
            }
          }
          for (var j3 = m3 - 1; j3 >= 0; j3--) {
            var qj = (a3.words[b2.length + j3] | 0) * 67108864 + (a3.words[b2.length + j3 - 1] | 0);
            qj = Math.min(qj / bhi | 0, 67108863);
            a3._ishlnsubmul(b2, qj, j3);
            while (a3.negative !== 0) {
              qj--;
              a3.negative = 0;
              a3._ishlnsubmul(b2, 1, j3);
              if (!a3.isZero()) {
                a3.negative ^= 1;
              }
            }
            if (q3) {
              q3.words[j3] = qj;
            }
          }
          if (q3) {
            q3.strip();
          }
          a3.strip();
          if (mode !== "div" && shift !== 0) {
            a3.iushrn(shift);
          }
          return {
            div: q3 || null,
            mod: a3
          };
        };
        BN4.prototype.divmod = function divmod(num, mode, positive) {
          assert3(!num.isZero());
          if (this.isZero()) {
            return {
              div: new BN4(0),
              mod: new BN4(0)
            };
          }
          var div, mod, res;
          if (this.negative !== 0 && num.negative === 0) {
            res = this.neg().divmod(num, mode);
            if (mode !== "mod") {
              div = res.div.neg();
            }
            if (mode !== "div") {
              mod = res.mod.neg();
              if (positive && mod.negative !== 0) {
                mod.iadd(num);
              }
            }
            return {
              div,
              mod
            };
          }
          if (this.negative === 0 && num.negative !== 0) {
            res = this.divmod(num.neg(), mode);
            if (mode !== "mod") {
              div = res.div.neg();
            }
            return {
              div,
              mod: res.mod
            };
          }
          if ((this.negative & num.negative) !== 0) {
            res = this.neg().divmod(num.neg(), mode);
            if (mode !== "div") {
              mod = res.mod.neg();
              if (positive && mod.negative !== 0) {
                mod.isub(num);
              }
            }
            return {
              div: res.div,
              mod
            };
          }
          if (num.length > this.length || this.cmp(num) < 0) {
            return {
              div: new BN4(0),
              mod: this
            };
          }
          if (num.length === 1) {
            if (mode === "div") {
              return {
                div: this.divn(num.words[0]),
                mod: null
              };
            }
            if (mode === "mod") {
              return {
                div: null,
                mod: new BN4(this.modn(num.words[0]))
              };
            }
            return {
              div: this.divn(num.words[0]),
              mod: new BN4(this.modn(num.words[0]))
            };
          }
          return this._wordDiv(num, mode);
        };
        BN4.prototype.div = function div(num) {
          return this.divmod(num, "div", false).div;
        };
        BN4.prototype.mod = function mod(num) {
          return this.divmod(num, "mod", false).mod;
        };
        BN4.prototype.umod = function umod(num) {
          return this.divmod(num, "mod", true).mod;
        };
        BN4.prototype.divRound = function divRound(num) {
          var dm = this.divmod(num);
          if (dm.mod.isZero())
            return dm.div;
          var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
          var half = num.ushrn(1);
          var r22 = num.andln(1);
          var cmp = mod.cmp(half);
          if (cmp < 0 || r22 === 1 && cmp === 0)
            return dm.div;
          return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
        };
        BN4.prototype.modn = function modn(num) {
          assert3(num <= 67108863);
          var p3 = (1 << 26) % num;
          var acc = 0;
          for (var i3 = this.length - 1; i3 >= 0; i3--) {
            acc = (p3 * acc + (this.words[i3] | 0)) % num;
          }
          return acc;
        };
        BN4.prototype.idivn = function idivn(num) {
          assert3(num <= 67108863);
          var carry = 0;
          for (var i3 = this.length - 1; i3 >= 0; i3--) {
            var w4 = (this.words[i3] | 0) + carry * 67108864;
            this.words[i3] = w4 / num | 0;
            carry = w4 % num;
          }
          return this.strip();
        };
        BN4.prototype.divn = function divn(num) {
          return this.clone().idivn(num);
        };
        BN4.prototype.egcd = function egcd(p3) {
          assert3(p3.negative === 0);
          assert3(!p3.isZero());
          var x3 = this;
          var y3 = p3.clone();
          if (x3.negative !== 0) {
            x3 = x3.umod(p3);
          } else {
            x3 = x3.clone();
          }
          var A4 = new BN4(1);
          var B2 = new BN4(0);
          var C3 = new BN4(0);
          var D3 = new BN4(1);
          var g3 = 0;
          while (x3.isEven() && y3.isEven()) {
            x3.iushrn(1);
            y3.iushrn(1);
            ++g3;
          }
          var yp = y3.clone();
          var xp = x3.clone();
          while (!x3.isZero()) {
            for (var i3 = 0, im = 1; (x3.words[0] & im) === 0 && i3 < 26; ++i3, im <<= 1)
              ;
            if (i3 > 0) {
              x3.iushrn(i3);
              while (i3-- > 0) {
                if (A4.isOdd() || B2.isOdd()) {
                  A4.iadd(yp);
                  B2.isub(xp);
                }
                A4.iushrn(1);
                B2.iushrn(1);
              }
            }
            for (var j3 = 0, jm = 1; (y3.words[0] & jm) === 0 && j3 < 26; ++j3, jm <<= 1)
              ;
            if (j3 > 0) {
              y3.iushrn(j3);
              while (j3-- > 0) {
                if (C3.isOdd() || D3.isOdd()) {
                  C3.iadd(yp);
                  D3.isub(xp);
                }
                C3.iushrn(1);
                D3.iushrn(1);
              }
            }
            if (x3.cmp(y3) >= 0) {
              x3.isub(y3);
              A4.isub(C3);
              B2.isub(D3);
            } else {
              y3.isub(x3);
              C3.isub(A4);
              D3.isub(B2);
            }
          }
          return {
            a: C3,
            b: D3,
            gcd: y3.iushln(g3)
          };
        };
        BN4.prototype._invmp = function _invmp(p3) {
          assert3(p3.negative === 0);
          assert3(!p3.isZero());
          var a3 = this;
          var b2 = p3.clone();
          if (a3.negative !== 0) {
            a3 = a3.umod(p3);
          } else {
            a3 = a3.clone();
          }
          var x1 = new BN4(1);
          var x22 = new BN4(0);
          var delta = b2.clone();
          while (a3.cmpn(1) > 0 && b2.cmpn(1) > 0) {
            for (var i3 = 0, im = 1; (a3.words[0] & im) === 0 && i3 < 26; ++i3, im <<= 1)
              ;
            if (i3 > 0) {
              a3.iushrn(i3);
              while (i3-- > 0) {
                if (x1.isOdd()) {
                  x1.iadd(delta);
                }
                x1.iushrn(1);
              }
            }
            for (var j3 = 0, jm = 1; (b2.words[0] & jm) === 0 && j3 < 26; ++j3, jm <<= 1)
              ;
            if (j3 > 0) {
              b2.iushrn(j3);
              while (j3-- > 0) {
                if (x22.isOdd()) {
                  x22.iadd(delta);
                }
                x22.iushrn(1);
              }
            }
            if (a3.cmp(b2) >= 0) {
              a3.isub(b2);
              x1.isub(x22);
            } else {
              b2.isub(a3);
              x22.isub(x1);
            }
          }
          var res;
          if (a3.cmpn(1) === 0) {
            res = x1;
          } else {
            res = x22;
          }
          if (res.cmpn(0) < 0) {
            res.iadd(p3);
          }
          return res;
        };
        BN4.prototype.gcd = function gcd(num) {
          if (this.isZero())
            return num.abs();
          if (num.isZero())
            return this.abs();
          var a3 = this.clone();
          var b2 = num.clone();
          a3.negative = 0;
          b2.negative = 0;
          for (var shift = 0; a3.isEven() && b2.isEven(); shift++) {
            a3.iushrn(1);
            b2.iushrn(1);
          }
          do {
            while (a3.isEven()) {
              a3.iushrn(1);
            }
            while (b2.isEven()) {
              b2.iushrn(1);
            }
            var r3 = a3.cmp(b2);
            if (r3 < 0) {
              var t3 = a3;
              a3 = b2;
              b2 = t3;
            } else if (r3 === 0 || b2.cmpn(1) === 0) {
              break;
            }
            a3.isub(b2);
          } while (true);
          return b2.iushln(shift);
        };
        BN4.prototype.invm = function invm(num) {
          return this.egcd(num).a.umod(num);
        };
        BN4.prototype.isEven = function isEven() {
          return (this.words[0] & 1) === 0;
        };
        BN4.prototype.isOdd = function isOdd() {
          return (this.words[0] & 1) === 1;
        };
        BN4.prototype.andln = function andln(num) {
          return this.words[0] & num;
        };
        BN4.prototype.bincn = function bincn(bit) {
          assert3(typeof bit === "number");
          var r3 = bit % 26;
          var s3 = (bit - r3) / 26;
          var q3 = 1 << r3;
          if (this.length <= s3) {
            this._expand(s3 + 1);
            this.words[s3] |= q3;
            return this;
          }
          var carry = q3;
          for (var i3 = s3; carry !== 0 && i3 < this.length; i3++) {
            var w4 = this.words[i3] | 0;
            w4 += carry;
            carry = w4 >>> 26;
            w4 &= 67108863;
            this.words[i3] = w4;
          }
          if (carry !== 0) {
            this.words[i3] = carry;
            this.length++;
          }
          return this;
        };
        BN4.prototype.isZero = function isZero() {
          return this.length === 1 && this.words[0] === 0;
        };
        BN4.prototype.cmpn = function cmpn(num) {
          var negative = num < 0;
          if (this.negative !== 0 && !negative)
            return -1;
          if (this.negative === 0 && negative)
            return 1;
          this.strip();
          var res;
          if (this.length > 1) {
            res = 1;
          } else {
            if (negative) {
              num = -num;
            }
            assert3(num <= 67108863, "Number is too big");
            var w4 = this.words[0] | 0;
            res = w4 === num ? 0 : w4 < num ? -1 : 1;
          }
          if (this.negative !== 0)
            return -res | 0;
          return res;
        };
        BN4.prototype.cmp = function cmp(num) {
          if (this.negative !== 0 && num.negative === 0)
            return -1;
          if (this.negative === 0 && num.negative !== 0)
            return 1;
          var res = this.ucmp(num);
          if (this.negative !== 0)
            return -res | 0;
          return res;
        };
        BN4.prototype.ucmp = function ucmp(num) {
          if (this.length > num.length)
            return 1;
          if (this.length < num.length)
            return -1;
          var res = 0;
          for (var i3 = this.length - 1; i3 >= 0; i3--) {
            var a3 = this.words[i3] | 0;
            var b2 = num.words[i3] | 0;
            if (a3 === b2)
              continue;
            if (a3 < b2) {
              res = -1;
            } else if (a3 > b2) {
              res = 1;
            }
            break;
          }
          return res;
        };
        BN4.prototype.gtn = function gtn(num) {
          return this.cmpn(num) === 1;
        };
        BN4.prototype.gt = function gt(num) {
          return this.cmp(num) === 1;
        };
        BN4.prototype.gten = function gten(num) {
          return this.cmpn(num) >= 0;
        };
        BN4.prototype.gte = function gte(num) {
          return this.cmp(num) >= 0;
        };
        BN4.prototype.ltn = function ltn(num) {
          return this.cmpn(num) === -1;
        };
        BN4.prototype.lt = function lt(num) {
          return this.cmp(num) === -1;
        };
        BN4.prototype.lten = function lten(num) {
          return this.cmpn(num) <= 0;
        };
        BN4.prototype.lte = function lte(num) {
          return this.cmp(num) <= 0;
        };
        BN4.prototype.eqn = function eqn(num) {
          return this.cmpn(num) === 0;
        };
        BN4.prototype.eq = function eq4(num) {
          return this.cmp(num) === 0;
        };
        BN4.red = function red(num) {
          return new Red(num);
        };
        BN4.prototype.toRed = function toRed(ctx) {
          assert3(!this.red, "Already a number in reduction context");
          assert3(this.negative === 0, "red works only with positives");
          return ctx.convertTo(this)._forceRed(ctx);
        };
        BN4.prototype.fromRed = function fromRed() {
          assert3(this.red, "fromRed works only with numbers in reduction context");
          return this.red.convertFrom(this);
        };
        BN4.prototype._forceRed = function _forceRed(ctx) {
          this.red = ctx;
          return this;
        };
        BN4.prototype.forceRed = function forceRed(ctx) {
          assert3(!this.red, "Already a number in reduction context");
          return this._forceRed(ctx);
        };
        BN4.prototype.redAdd = function redAdd(num) {
          assert3(this.red, "redAdd works only with red numbers");
          return this.red.add(this, num);
        };
        BN4.prototype.redIAdd = function redIAdd(num) {
          assert3(this.red, "redIAdd works only with red numbers");
          return this.red.iadd(this, num);
        };
        BN4.prototype.redSub = function redSub(num) {
          assert3(this.red, "redSub works only with red numbers");
          return this.red.sub(this, num);
        };
        BN4.prototype.redISub = function redISub(num) {
          assert3(this.red, "redISub works only with red numbers");
          return this.red.isub(this, num);
        };
        BN4.prototype.redShl = function redShl(num) {
          assert3(this.red, "redShl works only with red numbers");
          return this.red.shl(this, num);
        };
        BN4.prototype.redMul = function redMul(num) {
          assert3(this.red, "redMul works only with red numbers");
          this.red._verify2(this, num);
          return this.red.mul(this, num);
        };
        BN4.prototype.redIMul = function redIMul(num) {
          assert3(this.red, "redMul works only with red numbers");
          this.red._verify2(this, num);
          return this.red.imul(this, num);
        };
        BN4.prototype.redSqr = function redSqr() {
          assert3(this.red, "redSqr works only with red numbers");
          this.red._verify1(this);
          return this.red.sqr(this);
        };
        BN4.prototype.redISqr = function redISqr() {
          assert3(this.red, "redISqr works only with red numbers");
          this.red._verify1(this);
          return this.red.isqr(this);
        };
        BN4.prototype.redSqrt = function redSqrt() {
          assert3(this.red, "redSqrt works only with red numbers");
          this.red._verify1(this);
          return this.red.sqrt(this);
        };
        BN4.prototype.redInvm = function redInvm() {
          assert3(this.red, "redInvm works only with red numbers");
          this.red._verify1(this);
          return this.red.invm(this);
        };
        BN4.prototype.redNeg = function redNeg() {
          assert3(this.red, "redNeg works only with red numbers");
          this.red._verify1(this);
          return this.red.neg(this);
        };
        BN4.prototype.redPow = function redPow(num) {
          assert3(this.red && !num.red, "redPow(normalNum)");
          this.red._verify1(this);
          return this.red.pow(this, num);
        };
        var primes = {
          k256: null,
          p224: null,
          p192: null,
          p25519: null
        };
        function MPrime(name2, p3) {
          this.name = name2;
          this.p = new BN4(p3, 16);
          this.n = this.p.bitLength();
          this.k = new BN4(1).iushln(this.n).isub(this.p);
          this.tmp = this._tmp();
        }
        MPrime.prototype._tmp = function _tmp() {
          var tmp = new BN4(null);
          tmp.words = new Array(Math.ceil(this.n / 13));
          return tmp;
        };
        MPrime.prototype.ireduce = function ireduce(num) {
          var r3 = num;
          var rlen;
          do {
            this.split(r3, this.tmp);
            r3 = this.imulK(r3);
            r3 = r3.iadd(this.tmp);
            rlen = r3.bitLength();
          } while (rlen > this.n);
          var cmp = rlen < this.n ? -1 : r3.ucmp(this.p);
          if (cmp === 0) {
            r3.words[0] = 0;
            r3.length = 1;
          } else if (cmp > 0) {
            r3.isub(this.p);
          } else {
            r3.strip();
          }
          return r3;
        };
        MPrime.prototype.split = function split(input, out) {
          input.iushrn(this.n, 0, out);
        };
        MPrime.prototype.imulK = function imulK(num) {
          return num.imul(this.k);
        };
        function K256() {
          MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
        }
        inherits(K256, MPrime);
        K256.prototype.split = function split(input, output) {
          var mask = 4194303;
          var outLen = Math.min(input.length, 9);
          for (var i3 = 0; i3 < outLen; i3++) {
            output.words[i3] = input.words[i3];
          }
          output.length = outLen;
          if (input.length <= 9) {
            input.words[0] = 0;
            input.length = 1;
            return;
          }
          var prev = input.words[9];
          output.words[output.length++] = prev & mask;
          for (i3 = 10; i3 < input.length; i3++) {
            var next = input.words[i3] | 0;
            input.words[i3 - 10] = (next & mask) << 4 | prev >>> 22;
            prev = next;
          }
          prev >>>= 22;
          input.words[i3 - 10] = prev;
          if (prev === 0 && input.length > 10) {
            input.length -= 10;
          } else {
            input.length -= 9;
          }
        };
        K256.prototype.imulK = function imulK(num) {
          num.words[num.length] = 0;
          num.words[num.length + 1] = 0;
          num.length += 2;
          var lo = 0;
          for (var i3 = 0; i3 < num.length; i3++) {
            var w4 = num.words[i3] | 0;
            lo += w4 * 977;
            num.words[i3] = lo & 67108863;
            lo = w4 * 64 + (lo / 67108864 | 0);
          }
          if (num.words[num.length - 1] === 0) {
            num.length--;
            if (num.words[num.length - 1] === 0) {
              num.length--;
            }
          }
          return num;
        };
        function P224() {
          MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
        }
        inherits(P224, MPrime);
        function P192() {
          MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
        }
        inherits(P192, MPrime);
        function P25519() {
          MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
        }
        inherits(P25519, MPrime);
        P25519.prototype.imulK = function imulK(num) {
          var carry = 0;
          for (var i3 = 0; i3 < num.length; i3++) {
            var hi = (num.words[i3] | 0) * 19 + carry;
            var lo = hi & 67108863;
            hi >>>= 26;
            num.words[i3] = lo;
            carry = hi;
          }
          if (carry !== 0) {
            num.words[num.length++] = carry;
          }
          return num;
        };
        BN4._prime = function prime(name2) {
          if (primes[name2])
            return primes[name2];
          var prime2;
          if (name2 === "k256") {
            prime2 = new K256();
          } else if (name2 === "p224") {
            prime2 = new P224();
          } else if (name2 === "p192") {
            prime2 = new P192();
          } else if (name2 === "p25519") {
            prime2 = new P25519();
          } else {
            throw new Error("Unknown prime " + name2);
          }
          primes[name2] = prime2;
          return prime2;
        };
        function Red(m3) {
          if (typeof m3 === "string") {
            var prime = BN4._prime(m3);
            this.m = prime.p;
            this.prime = prime;
          } else {
            assert3(m3.gtn(1), "modulus must be greater than 1");
            this.m = m3;
            this.prime = null;
          }
        }
        Red.prototype._verify1 = function _verify1(a3) {
          assert3(a3.negative === 0, "red works only with positives");
          assert3(a3.red, "red works only with red numbers");
        };
        Red.prototype._verify2 = function _verify2(a3, b2) {
          assert3((a3.negative | b2.negative) === 0, "red works only with positives");
          assert3(a3.red && a3.red === b2.red, "red works only with red numbers");
        };
        Red.prototype.imod = function imod(a3) {
          if (this.prime)
            return this.prime.ireduce(a3)._forceRed(this);
          return a3.umod(this.m)._forceRed(this);
        };
        Red.prototype.neg = function neg3(a3) {
          if (a3.isZero()) {
            return a3.clone();
          }
          return this.m.sub(a3)._forceRed(this);
        };
        Red.prototype.add = function add3(a3, b2) {
          this._verify2(a3, b2);
          var res = a3.add(b2);
          if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
          }
          return res._forceRed(this);
        };
        Red.prototype.iadd = function iadd(a3, b2) {
          this._verify2(a3, b2);
          var res = a3.iadd(b2);
          if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
          }
          return res;
        };
        Red.prototype.sub = function sub(a3, b2) {
          this._verify2(a3, b2);
          var res = a3.sub(b2);
          if (res.cmpn(0) < 0) {
            res.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Red.prototype.isub = function isub(a3, b2) {
          this._verify2(a3, b2);
          var res = a3.isub(b2);
          if (res.cmpn(0) < 0) {
            res.iadd(this.m);
          }
          return res;
        };
        Red.prototype.shl = function shl(a3, num) {
          this._verify1(a3);
          return this.imod(a3.ushln(num));
        };
        Red.prototype.imul = function imul(a3, b2) {
          this._verify2(a3, b2);
          return this.imod(a3.imul(b2));
        };
        Red.prototype.mul = function mul3(a3, b2) {
          this._verify2(a3, b2);
          return this.imod(a3.mul(b2));
        };
        Red.prototype.isqr = function isqr(a3) {
          return this.imul(a3, a3.clone());
        };
        Red.prototype.sqr = function sqr(a3) {
          return this.mul(a3, a3);
        };
        Red.prototype.sqrt = function sqrt(a3) {
          if (a3.isZero())
            return a3.clone();
          var mod3 = this.m.andln(3);
          assert3(mod3 % 2 === 1);
          if (mod3 === 3) {
            var pow = this.m.add(new BN4(1)).iushrn(2);
            return this.pow(a3, pow);
          }
          var q3 = this.m.subn(1);
          var s3 = 0;
          while (!q3.isZero() && q3.andln(1) === 0) {
            s3++;
            q3.iushrn(1);
          }
          assert3(!q3.isZero());
          var one = new BN4(1).toRed(this);
          var nOne = one.redNeg();
          var lpow = this.m.subn(1).iushrn(1);
          var z3 = this.m.bitLength();
          z3 = new BN4(2 * z3 * z3).toRed(this);
          while (this.pow(z3, lpow).cmp(nOne) !== 0) {
            z3.redIAdd(nOne);
          }
          var c3 = this.pow(z3, q3);
          var r3 = this.pow(a3, q3.addn(1).iushrn(1));
          var t3 = this.pow(a3, q3);
          var m3 = s3;
          while (t3.cmp(one) !== 0) {
            var tmp = t3;
            for (var i3 = 0; tmp.cmp(one) !== 0; i3++) {
              tmp = tmp.redSqr();
            }
            assert3(i3 < m3);
            var b2 = this.pow(c3, new BN4(1).iushln(m3 - i3 - 1));
            r3 = r3.redMul(b2);
            c3 = b2.redSqr();
            t3 = t3.redMul(c3);
            m3 = i3;
          }
          return r3;
        };
        Red.prototype.invm = function invm(a3) {
          var inv = a3._invmp(this.m);
          if (inv.negative !== 0) {
            inv.negative = 0;
            return this.imod(inv).redNeg();
          } else {
            return this.imod(inv);
          }
        };
        Red.prototype.pow = function pow(a3, num) {
          if (num.isZero())
            return new BN4(1).toRed(this);
          if (num.cmpn(1) === 0)
            return a3.clone();
          var windowSize = 4;
          var wnd = new Array(1 << windowSize);
          wnd[0] = new BN4(1).toRed(this);
          wnd[1] = a3;
          for (var i3 = 2; i3 < wnd.length; i3++) {
            wnd[i3] = this.mul(wnd[i3 - 1], a3);
          }
          var res = wnd[0];
          var current = 0;
          var currentLen = 0;
          var start = num.bitLength() % 26;
          if (start === 0) {
            start = 26;
          }
          for (i3 = num.length - 1; i3 >= 0; i3--) {
            var word = num.words[i3];
            for (var j3 = start - 1; j3 >= 0; j3--) {
              var bit = word >> j3 & 1;
              if (res !== wnd[0]) {
                res = this.sqr(res);
              }
              if (bit === 0 && current === 0) {
                currentLen = 0;
                continue;
              }
              current <<= 1;
              current |= bit;
              currentLen++;
              if (currentLen !== windowSize && (i3 !== 0 || j3 !== 0))
                continue;
              res = this.mul(res, wnd[current]);
              currentLen = 0;
              current = 0;
            }
            start = 26;
          }
          return res;
        };
        Red.prototype.convertTo = function convertTo(num) {
          var r3 = num.umod(this.m);
          return r3 === num ? r3.clone() : r3;
        };
        Red.prototype.convertFrom = function convertFrom(num) {
          var res = num.clone();
          res.red = null;
          return res;
        };
        BN4.mont = function mont(num) {
          return new Mont(num);
        };
        function Mont(m3) {
          Red.call(this, m3);
          this.shift = this.m.bitLength();
          if (this.shift % 26 !== 0) {
            this.shift += 26 - this.shift % 26;
          }
          this.r = new BN4(1).iushln(this.shift);
          this.r2 = this.imod(this.r.sqr());
          this.rinv = this.r._invmp(this.m);
          this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
          this.minv = this.minv.umod(this.r);
          this.minv = this.r.sub(this.minv);
        }
        inherits(Mont, Red);
        Mont.prototype.convertTo = function convertTo(num) {
          return this.imod(num.ushln(this.shift));
        };
        Mont.prototype.convertFrom = function convertFrom(num) {
          var r3 = this.imod(num.mul(this.rinv));
          r3.red = null;
          return r3;
        };
        Mont.prototype.imul = function imul(a3, b2) {
          if (a3.isZero() || b2.isZero()) {
            a3.words[0] = 0;
            a3.length = 1;
            return a3;
          }
          var t3 = a3.imul(b2);
          var c3 = t3.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
          var u3 = t3.isub(c3).iushrn(this.shift);
          var res = u3;
          if (u3.cmp(this.m) >= 0) {
            res = u3.isub(this.m);
          } else if (u3.cmpn(0) < 0) {
            res = u3.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Mont.prototype.mul = function mul3(a3, b2) {
          if (a3.isZero() || b2.isZero())
            return new BN4(0)._forceRed(this);
          var t3 = a3.mul(b2);
          var c3 = t3.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
          var u3 = t3.isub(c3).iushrn(this.shift);
          var res = u3;
          if (u3.cmp(this.m) >= 0) {
            res = u3.isub(this.m);
          } else if (u3.cmpn(0) < 0) {
            res = u3.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Mont.prototype.invm = function invm(a3) {
          var res = this.imod(a3._invmp(this.m).mul(this.r2));
          return res._forceRed(this);
        };
      })(typeof module === "undefined" || module, exports);
    }
  });

  // node_modules/is-typedarray/index.js
  var require_is_typedarray = __commonJS({
    "node_modules/is-typedarray/index.js"(exports, module) {
      module.exports = isTypedArray2;
      isTypedArray2.strict = isStrictTypedArray;
      isTypedArray2.loose = isLooseTypedArray;
      var toString = Object.prototype.toString;
      var names2 = {
        "[object Int8Array]": true,
        "[object Int16Array]": true,
        "[object Int32Array]": true,
        "[object Uint8Array]": true,
        "[object Uint8ClampedArray]": true,
        "[object Uint16Array]": true,
        "[object Uint32Array]": true,
        "[object Float32Array]": true,
        "[object Float64Array]": true
      };
      function isTypedArray2(arr) {
        return isStrictTypedArray(arr) || isLooseTypedArray(arr);
      }
      function isStrictTypedArray(arr) {
        return arr instanceof Int8Array || arr instanceof Int16Array || arr instanceof Int32Array || arr instanceof Uint8Array || arr instanceof Uint8ClampedArray || arr instanceof Uint16Array || arr instanceof Uint32Array || arr instanceof Float32Array || arr instanceof Float64Array;
      }
      function isLooseTypedArray(arr) {
        return names2[toString.call(arr)];
      }
    }
  });

  // node_modules/typedarray-to-buffer/index.js
  var require_typedarray_to_buffer = __commonJS({
    "node_modules/typedarray-to-buffer/index.js"(exports, module) {
      var isTypedArray2 = require_is_typedarray().strict;
      module.exports = function typedarrayToBuffer(arr) {
        if (isTypedArray2(arr)) {
          var buf = Buffer.from(arr.buffer);
          if (arr.byteLength !== arr.buffer.byteLength) {
            buf = buf.slice(arr.byteOffset, arr.byteOffset + arr.byteLength);
          }
          return buf;
        } else {
          return Buffer.from(arr);
        }
      };
    }
  });

  // node_modules/@walletconnect/utils/node_modules/js-sha3/src/sha3.js
  var require_sha32 = __commonJS({
    "node_modules/@walletconnect/utils/node_modules/js-sha3/src/sha3.js"(exports, module) {
      (function() {
        "use strict";
        var INPUT_ERROR = "input is invalid type";
        var FINALIZE_ERROR = "finalize already called";
        var WINDOW = typeof window === "object";
        var root = WINDOW ? window : {};
        if (root.JS_SHA3_NO_WINDOW) {
          WINDOW = false;
        }
        var WEB_WORKER = !WINDOW && typeof self === "object";
        var NODE_JS = !root.JS_SHA3_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
        if (NODE_JS) {
          root = global;
        } else if (WEB_WORKER) {
          root = self;
        }
        var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && typeof module === "object" && module.exports;
        var AMD = typeof define === "function" && define.amd;
        var ARRAY_BUFFER = !root.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
        var HEX_CHARS = "0123456789abcdef".split("");
        var SHAKE_PADDING = [31, 7936, 2031616, 520093696];
        var CSHAKE_PADDING = [4, 1024, 262144, 67108864];
        var KECCAK_PADDING = [1, 256, 65536, 16777216];
        var PADDING2 = [6, 1536, 393216, 100663296];
        var SHIFT = [0, 8, 16, 24];
        var RC = [
          1,
          0,
          32898,
          0,
          32906,
          2147483648,
          2147516416,
          2147483648,
          32907,
          0,
          2147483649,
          0,
          2147516545,
          2147483648,
          32777,
          2147483648,
          138,
          0,
          136,
          0,
          2147516425,
          0,
          2147483658,
          0,
          2147516555,
          0,
          139,
          2147483648,
          32905,
          2147483648,
          32771,
          2147483648,
          32770,
          2147483648,
          128,
          2147483648,
          32778,
          0,
          2147483658,
          2147483648,
          2147516545,
          2147483648,
          32896,
          2147483648,
          2147483649,
          0,
          2147516424,
          2147483648
        ];
        var BITS = [224, 256, 384, 512];
        var SHAKE_BITS = [128, 256];
        var OUTPUT_TYPES = ["hex", "buffer", "arrayBuffer", "array", "digest"];
        var CSHAKE_BYTEPAD = {
          "128": 168,
          "256": 136
        };
        if (root.JS_SHA3_NO_NODE_JS || !Array.isArray) {
          Array.isArray = function(obj) {
            return Object.prototype.toString.call(obj) === "[object Array]";
          };
        }
        if (ARRAY_BUFFER && (root.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
          ArrayBuffer.isView = function(obj) {
            return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
          };
        }
        var createOutputMethod = function(bits2, padding2, outputType) {
          return function(message) {
            return new Keccak(bits2, padding2, bits2).update(message)[outputType]();
          };
        };
        var createShakeOutputMethod = function(bits2, padding2, outputType) {
          return function(message, outputBits) {
            return new Keccak(bits2, padding2, outputBits).update(message)[outputType]();
          };
        };
        var createCshakeOutputMethod = function(bits2, padding2, outputType) {
          return function(message, outputBits, n2, s3) {
            return methods["cshake" + bits2].update(message, outputBits, n2, s3)[outputType]();
          };
        };
        var createKmacOutputMethod = function(bits2, padding2, outputType) {
          return function(key2, message, outputBits, s3) {
            return methods["kmac" + bits2].update(key2, message, outputBits, s3)[outputType]();
          };
        };
        var createOutputMethods = function(method, createMethod2, bits2, padding2) {
          for (var i4 = 0; i4 < OUTPUT_TYPES.length; ++i4) {
            var type = OUTPUT_TYPES[i4];
            method[type] = createMethod2(bits2, padding2, type);
          }
          return method;
        };
        var createMethod = function(bits2, padding2) {
          var method = createOutputMethod(bits2, padding2, "hex");
          method.create = function() {
            return new Keccak(bits2, padding2, bits2);
          };
          method.update = function(message) {
            return method.create().update(message);
          };
          return createOutputMethods(method, createOutputMethod, bits2, padding2);
        };
        var createShakeMethod = function(bits2, padding2) {
          var method = createShakeOutputMethod(bits2, padding2, "hex");
          method.create = function(outputBits) {
            return new Keccak(bits2, padding2, outputBits);
          };
          method.update = function(message, outputBits) {
            return method.create(outputBits).update(message);
          };
          return createOutputMethods(method, createShakeOutputMethod, bits2, padding2);
        };
        var createCshakeMethod = function(bits2, padding2) {
          var w4 = CSHAKE_BYTEPAD[bits2];
          var method = createCshakeOutputMethod(bits2, padding2, "hex");
          method.create = function(outputBits, n2, s3) {
            if (!n2 && !s3) {
              return methods["shake" + bits2].create(outputBits);
            } else {
              return new Keccak(bits2, padding2, outputBits).bytepad([n2, s3], w4);
            }
          };
          method.update = function(message, outputBits, n2, s3) {
            return method.create(outputBits, n2, s3).update(message);
          };
          return createOutputMethods(method, createCshakeOutputMethod, bits2, padding2);
        };
        var createKmacMethod = function(bits2, padding2) {
          var w4 = CSHAKE_BYTEPAD[bits2];
          var method = createKmacOutputMethod(bits2, padding2, "hex");
          method.create = function(key2, outputBits, s3) {
            return new Kmac(bits2, padding2, outputBits).bytepad(["KMAC", s3], w4).bytepad([key2], w4);
          };
          method.update = function(key2, message, outputBits, s3) {
            return method.create(key2, outputBits, s3).update(message);
          };
          return createOutputMethods(method, createKmacOutputMethod, bits2, padding2);
        };
        var algorithms = [
          { name: "keccak", padding: KECCAK_PADDING, bits: BITS, createMethod },
          { name: "sha3", padding: PADDING2, bits: BITS, createMethod },
          { name: "shake", padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod },
          { name: "cshake", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createCshakeMethod },
          { name: "kmac", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createKmacMethod }
        ];
        var methods = {}, methodNames = [];
        for (var i3 = 0; i3 < algorithms.length; ++i3) {
          var algorithm = algorithms[i3];
          var bits = algorithm.bits;
          for (var j3 = 0; j3 < bits.length; ++j3) {
            var methodName = algorithm.name + "_" + bits[j3];
            methodNames.push(methodName);
            methods[methodName] = algorithm.createMethod(bits[j3], algorithm.padding);
            if (algorithm.name !== "sha3") {
              var newMethodName = algorithm.name + bits[j3];
              methodNames.push(newMethodName);
              methods[newMethodName] = methods[methodName];
            }
          }
        }
        function Keccak(bits2, padding2, outputBits) {
          this.blocks = [];
          this.s = [];
          this.padding = padding2;
          this.outputBits = outputBits;
          this.reset = true;
          this.finalized = false;
          this.block = 0;
          this.start = 0;
          this.blockCount = 1600 - (bits2 << 1) >> 5;
          this.byteCount = this.blockCount << 2;
          this.outputBlocks = outputBits >> 5;
          this.extraBytes = (outputBits & 31) >> 3;
          for (var i4 = 0; i4 < 50; ++i4) {
            this.s[i4] = 0;
          }
        }
        Keccak.prototype.update = function(message) {
          if (this.finalized) {
            throw new Error(FINALIZE_ERROR);
          }
          var notString, type = typeof message;
          if (type !== "string") {
            if (type === "object") {
              if (message === null) {
                throw new Error(INPUT_ERROR);
              } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
                message = new Uint8Array(message);
              } else if (!Array.isArray(message)) {
                if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
                  throw new Error(INPUT_ERROR);
                }
              }
            } else {
              throw new Error(INPUT_ERROR);
            }
            notString = true;
          }
          var blocks = this.blocks, byteCount = this.byteCount, length = message.length, blockCount = this.blockCount, index = 0, s3 = this.s, i4, code;
          while (index < length) {
            if (this.reset) {
              this.reset = false;
              blocks[0] = this.block;
              for (i4 = 1; i4 < blockCount + 1; ++i4) {
                blocks[i4] = 0;
              }
            }
            if (notString) {
              for (i4 = this.start; index < length && i4 < byteCount; ++index) {
                blocks[i4 >> 2] |= message[index] << SHIFT[i4++ & 3];
              }
            } else {
              for (i4 = this.start; index < length && i4 < byteCount; ++index) {
                code = message.charCodeAt(index);
                if (code < 128) {
                  blocks[i4 >> 2] |= code << SHIFT[i4++ & 3];
                } else if (code < 2048) {
                  blocks[i4 >> 2] |= (192 | code >> 6) << SHIFT[i4++ & 3];
                  blocks[i4 >> 2] |= (128 | code & 63) << SHIFT[i4++ & 3];
                } else if (code < 55296 || code >= 57344) {
                  blocks[i4 >> 2] |= (224 | code >> 12) << SHIFT[i4++ & 3];
                  blocks[i4 >> 2] |= (128 | code >> 6 & 63) << SHIFT[i4++ & 3];
                  blocks[i4 >> 2] |= (128 | code & 63) << SHIFT[i4++ & 3];
                } else {
                  code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
                  blocks[i4 >> 2] |= (240 | code >> 18) << SHIFT[i4++ & 3];
                  blocks[i4 >> 2] |= (128 | code >> 12 & 63) << SHIFT[i4++ & 3];
                  blocks[i4 >> 2] |= (128 | code >> 6 & 63) << SHIFT[i4++ & 3];
                  blocks[i4 >> 2] |= (128 | code & 63) << SHIFT[i4++ & 3];
                }
              }
            }
            this.lastByteIndex = i4;
            if (i4 >= byteCount) {
              this.start = i4 - byteCount;
              this.block = blocks[blockCount];
              for (i4 = 0; i4 < blockCount; ++i4) {
                s3[i4] ^= blocks[i4];
              }
              f3(s3);
              this.reset = true;
            } else {
              this.start = i4;
            }
          }
          return this;
        };
        Keccak.prototype.encode = function(x3, right) {
          var o3 = x3 & 255, n2 = 1;
          var bytes = [o3];
          x3 = x3 >> 8;
          o3 = x3 & 255;
          while (o3 > 0) {
            bytes.unshift(o3);
            x3 = x3 >> 8;
            o3 = x3 & 255;
            ++n2;
          }
          if (right) {
            bytes.push(n2);
          } else {
            bytes.unshift(n2);
          }
          this.update(bytes);
          return bytes.length;
        };
        Keccak.prototype.encodeString = function(str) {
          var notString, type = typeof str;
          if (type !== "string") {
            if (type === "object") {
              if (str === null) {
                throw new Error(INPUT_ERROR);
              } else if (ARRAY_BUFFER && str.constructor === ArrayBuffer) {
                str = new Uint8Array(str);
              } else if (!Array.isArray(str)) {
                if (!ARRAY_BUFFER || !ArrayBuffer.isView(str)) {
                  throw new Error(INPUT_ERROR);
                }
              }
            } else {
              throw new Error(INPUT_ERROR);
            }
            notString = true;
          }
          var bytes = 0, length = str.length;
          if (notString) {
            bytes = length;
          } else {
            for (var i4 = 0; i4 < str.length; ++i4) {
              var code = str.charCodeAt(i4);
              if (code < 128) {
                bytes += 1;
              } else if (code < 2048) {
                bytes += 2;
              } else if (code < 55296 || code >= 57344) {
                bytes += 3;
              } else {
                code = 65536 + ((code & 1023) << 10 | str.charCodeAt(++i4) & 1023);
                bytes += 4;
              }
            }
          }
          bytes += this.encode(bytes * 8);
          this.update(str);
          return bytes;
        };
        Keccak.prototype.bytepad = function(strs, w4) {
          var bytes = this.encode(w4);
          for (var i4 = 0; i4 < strs.length; ++i4) {
            bytes += this.encodeString(strs[i4]);
          }
          var paddingBytes = w4 - bytes % w4;
          var zeros2 = [];
          zeros2.length = paddingBytes;
          this.update(zeros2);
          return this;
        };
        Keccak.prototype.finalize = function() {
          if (this.finalized) {
            return;
          }
          this.finalized = true;
          var blocks = this.blocks, i4 = this.lastByteIndex, blockCount = this.blockCount, s3 = this.s;
          blocks[i4 >> 2] |= this.padding[i4 & 3];
          if (this.lastByteIndex === this.byteCount) {
            blocks[0] = blocks[blockCount];
            for (i4 = 1; i4 < blockCount + 1; ++i4) {
              blocks[i4] = 0;
            }
          }
          blocks[blockCount - 1] |= 2147483648;
          for (i4 = 0; i4 < blockCount; ++i4) {
            s3[i4] ^= blocks[i4];
          }
          f3(s3);
        };
        Keccak.prototype.toString = Keccak.prototype.hex = function() {
          this.finalize();
          var blockCount = this.blockCount, s3 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i4 = 0, j4 = 0;
          var hex2 = "", block;
          while (j4 < outputBlocks) {
            for (i4 = 0; i4 < blockCount && j4 < outputBlocks; ++i4, ++j4) {
              block = s3[i4];
              hex2 += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15] + HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15] + HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15] + HEX_CHARS[block >> 28 & 15] + HEX_CHARS[block >> 24 & 15];
            }
            if (j4 % blockCount === 0) {
              f3(s3);
              i4 = 0;
            }
          }
          if (extraBytes) {
            block = s3[i4];
            hex2 += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15];
            if (extraBytes > 1) {
              hex2 += HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15];
            }
            if (extraBytes > 2) {
              hex2 += HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15];
            }
          }
          return hex2;
        };
        Keccak.prototype.arrayBuffer = function() {
          this.finalize();
          var blockCount = this.blockCount, s3 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i4 = 0, j4 = 0;
          var bytes = this.outputBits >> 3;
          var buffer;
          if (extraBytes) {
            buffer = new ArrayBuffer(outputBlocks + 1 << 2);
          } else {
            buffer = new ArrayBuffer(bytes);
          }
          var array = new Uint32Array(buffer);
          while (j4 < outputBlocks) {
            for (i4 = 0; i4 < blockCount && j4 < outputBlocks; ++i4, ++j4) {
              array[j4] = s3[i4];
            }
            if (j4 % blockCount === 0) {
              f3(s3);
            }
          }
          if (extraBytes) {
            array[i4] = s3[i4];
            buffer = buffer.slice(0, bytes);
          }
          return buffer;
        };
        Keccak.prototype.buffer = Keccak.prototype.arrayBuffer;
        Keccak.prototype.digest = Keccak.prototype.array = function() {
          this.finalize();
          var blockCount = this.blockCount, s3 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i4 = 0, j4 = 0;
          var array = [], offset, block;
          while (j4 < outputBlocks) {
            for (i4 = 0; i4 < blockCount && j4 < outputBlocks; ++i4, ++j4) {
              offset = j4 << 2;
              block = s3[i4];
              array[offset] = block & 255;
              array[offset + 1] = block >> 8 & 255;
              array[offset + 2] = block >> 16 & 255;
              array[offset + 3] = block >> 24 & 255;
            }
            if (j4 % blockCount === 0) {
              f3(s3);
            }
          }
          if (extraBytes) {
            offset = j4 << 2;
            block = s3[i4];
            array[offset] = block & 255;
            if (extraBytes > 1) {
              array[offset + 1] = block >> 8 & 255;
            }
            if (extraBytes > 2) {
              array[offset + 2] = block >> 16 & 255;
            }
          }
          return array;
        };
        function Kmac(bits2, padding2, outputBits) {
          Keccak.call(this, bits2, padding2, outputBits);
        }
        Kmac.prototype = new Keccak();
        Kmac.prototype.finalize = function() {
          this.encode(this.outputBits, true);
          return Keccak.prototype.finalize.call(this);
        };
        var f3 = function(s3) {
          var h3, l3, n2, c0, c1, c22, c3, c4, c5, c6, c7, c8, c9, b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33, b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
          for (n2 = 0; n2 < 48; n2 += 2) {
            c0 = s3[0] ^ s3[10] ^ s3[20] ^ s3[30] ^ s3[40];
            c1 = s3[1] ^ s3[11] ^ s3[21] ^ s3[31] ^ s3[41];
            c22 = s3[2] ^ s3[12] ^ s3[22] ^ s3[32] ^ s3[42];
            c3 = s3[3] ^ s3[13] ^ s3[23] ^ s3[33] ^ s3[43];
            c4 = s3[4] ^ s3[14] ^ s3[24] ^ s3[34] ^ s3[44];
            c5 = s3[5] ^ s3[15] ^ s3[25] ^ s3[35] ^ s3[45];
            c6 = s3[6] ^ s3[16] ^ s3[26] ^ s3[36] ^ s3[46];
            c7 = s3[7] ^ s3[17] ^ s3[27] ^ s3[37] ^ s3[47];
            c8 = s3[8] ^ s3[18] ^ s3[28] ^ s3[38] ^ s3[48];
            c9 = s3[9] ^ s3[19] ^ s3[29] ^ s3[39] ^ s3[49];
            h3 = c8 ^ (c22 << 1 | c3 >>> 31);
            l3 = c9 ^ (c3 << 1 | c22 >>> 31);
            s3[0] ^= h3;
            s3[1] ^= l3;
            s3[10] ^= h3;
            s3[11] ^= l3;
            s3[20] ^= h3;
            s3[21] ^= l3;
            s3[30] ^= h3;
            s3[31] ^= l3;
            s3[40] ^= h3;
            s3[41] ^= l3;
            h3 = c0 ^ (c4 << 1 | c5 >>> 31);
            l3 = c1 ^ (c5 << 1 | c4 >>> 31);
            s3[2] ^= h3;
            s3[3] ^= l3;
            s3[12] ^= h3;
            s3[13] ^= l3;
            s3[22] ^= h3;
            s3[23] ^= l3;
            s3[32] ^= h3;
            s3[33] ^= l3;
            s3[42] ^= h3;
            s3[43] ^= l3;
            h3 = c22 ^ (c6 << 1 | c7 >>> 31);
            l3 = c3 ^ (c7 << 1 | c6 >>> 31);
            s3[4] ^= h3;
            s3[5] ^= l3;
            s3[14] ^= h3;
            s3[15] ^= l3;
            s3[24] ^= h3;
            s3[25] ^= l3;
            s3[34] ^= h3;
            s3[35] ^= l3;
            s3[44] ^= h3;
            s3[45] ^= l3;
            h3 = c4 ^ (c8 << 1 | c9 >>> 31);
            l3 = c5 ^ (c9 << 1 | c8 >>> 31);
            s3[6] ^= h3;
            s3[7] ^= l3;
            s3[16] ^= h3;
            s3[17] ^= l3;
            s3[26] ^= h3;
            s3[27] ^= l3;
            s3[36] ^= h3;
            s3[37] ^= l3;
            s3[46] ^= h3;
            s3[47] ^= l3;
            h3 = c6 ^ (c0 << 1 | c1 >>> 31);
            l3 = c7 ^ (c1 << 1 | c0 >>> 31);
            s3[8] ^= h3;
            s3[9] ^= l3;
            s3[18] ^= h3;
            s3[19] ^= l3;
            s3[28] ^= h3;
            s3[29] ^= l3;
            s3[38] ^= h3;
            s3[39] ^= l3;
            s3[48] ^= h3;
            s3[49] ^= l3;
            b0 = s3[0];
            b1 = s3[1];
            b32 = s3[11] << 4 | s3[10] >>> 28;
            b33 = s3[10] << 4 | s3[11] >>> 28;
            b14 = s3[20] << 3 | s3[21] >>> 29;
            b15 = s3[21] << 3 | s3[20] >>> 29;
            b46 = s3[31] << 9 | s3[30] >>> 23;
            b47 = s3[30] << 9 | s3[31] >>> 23;
            b28 = s3[40] << 18 | s3[41] >>> 14;
            b29 = s3[41] << 18 | s3[40] >>> 14;
            b20 = s3[2] << 1 | s3[3] >>> 31;
            b21 = s3[3] << 1 | s3[2] >>> 31;
            b2 = s3[13] << 12 | s3[12] >>> 20;
            b3 = s3[12] << 12 | s3[13] >>> 20;
            b34 = s3[22] << 10 | s3[23] >>> 22;
            b35 = s3[23] << 10 | s3[22] >>> 22;
            b16 = s3[33] << 13 | s3[32] >>> 19;
            b17 = s3[32] << 13 | s3[33] >>> 19;
            b48 = s3[42] << 2 | s3[43] >>> 30;
            b49 = s3[43] << 2 | s3[42] >>> 30;
            b40 = s3[5] << 30 | s3[4] >>> 2;
            b41 = s3[4] << 30 | s3[5] >>> 2;
            b22 = s3[14] << 6 | s3[15] >>> 26;
            b23 = s3[15] << 6 | s3[14] >>> 26;
            b4 = s3[25] << 11 | s3[24] >>> 21;
            b5 = s3[24] << 11 | s3[25] >>> 21;
            b36 = s3[34] << 15 | s3[35] >>> 17;
            b37 = s3[35] << 15 | s3[34] >>> 17;
            b18 = s3[45] << 29 | s3[44] >>> 3;
            b19 = s3[44] << 29 | s3[45] >>> 3;
            b10 = s3[6] << 28 | s3[7] >>> 4;
            b11 = s3[7] << 28 | s3[6] >>> 4;
            b42 = s3[17] << 23 | s3[16] >>> 9;
            b43 = s3[16] << 23 | s3[17] >>> 9;
            b24 = s3[26] << 25 | s3[27] >>> 7;
            b25 = s3[27] << 25 | s3[26] >>> 7;
            b6 = s3[36] << 21 | s3[37] >>> 11;
            b7 = s3[37] << 21 | s3[36] >>> 11;
            b38 = s3[47] << 24 | s3[46] >>> 8;
            b39 = s3[46] << 24 | s3[47] >>> 8;
            b30 = s3[8] << 27 | s3[9] >>> 5;
            b31 = s3[9] << 27 | s3[8] >>> 5;
            b12 = s3[18] << 20 | s3[19] >>> 12;
            b13 = s3[19] << 20 | s3[18] >>> 12;
            b44 = s3[29] << 7 | s3[28] >>> 25;
            b45 = s3[28] << 7 | s3[29] >>> 25;
            b26 = s3[38] << 8 | s3[39] >>> 24;
            b27 = s3[39] << 8 | s3[38] >>> 24;
            b8 = s3[48] << 14 | s3[49] >>> 18;
            b9 = s3[49] << 14 | s3[48] >>> 18;
            s3[0] = b0 ^ ~b2 & b4;
            s3[1] = b1 ^ ~b3 & b5;
            s3[10] = b10 ^ ~b12 & b14;
            s3[11] = b11 ^ ~b13 & b15;
            s3[20] = b20 ^ ~b22 & b24;
            s3[21] = b21 ^ ~b23 & b25;
            s3[30] = b30 ^ ~b32 & b34;
            s3[31] = b31 ^ ~b33 & b35;
            s3[40] = b40 ^ ~b42 & b44;
            s3[41] = b41 ^ ~b43 & b45;
            s3[2] = b2 ^ ~b4 & b6;
            s3[3] = b3 ^ ~b5 & b7;
            s3[12] = b12 ^ ~b14 & b16;
            s3[13] = b13 ^ ~b15 & b17;
            s3[22] = b22 ^ ~b24 & b26;
            s3[23] = b23 ^ ~b25 & b27;
            s3[32] = b32 ^ ~b34 & b36;
            s3[33] = b33 ^ ~b35 & b37;
            s3[42] = b42 ^ ~b44 & b46;
            s3[43] = b43 ^ ~b45 & b47;
            s3[4] = b4 ^ ~b6 & b8;
            s3[5] = b5 ^ ~b7 & b9;
            s3[14] = b14 ^ ~b16 & b18;
            s3[15] = b15 ^ ~b17 & b19;
            s3[24] = b24 ^ ~b26 & b28;
            s3[25] = b25 ^ ~b27 & b29;
            s3[34] = b34 ^ ~b36 & b38;
            s3[35] = b35 ^ ~b37 & b39;
            s3[44] = b44 ^ ~b46 & b48;
            s3[45] = b45 ^ ~b47 & b49;
            s3[6] = b6 ^ ~b8 & b0;
            s3[7] = b7 ^ ~b9 & b1;
            s3[16] = b16 ^ ~b18 & b10;
            s3[17] = b17 ^ ~b19 & b11;
            s3[26] = b26 ^ ~b28 & b20;
            s3[27] = b27 ^ ~b29 & b21;
            s3[36] = b36 ^ ~b38 & b30;
            s3[37] = b37 ^ ~b39 & b31;
            s3[46] = b46 ^ ~b48 & b40;
            s3[47] = b47 ^ ~b49 & b41;
            s3[8] = b8 ^ ~b0 & b2;
            s3[9] = b9 ^ ~b1 & b3;
            s3[18] = b18 ^ ~b10 & b12;
            s3[19] = b19 ^ ~b11 & b13;
            s3[28] = b28 ^ ~b20 & b22;
            s3[29] = b29 ^ ~b21 & b23;
            s3[38] = b38 ^ ~b30 & b32;
            s3[39] = b39 ^ ~b31 & b33;
            s3[48] = b48 ^ ~b40 & b42;
            s3[49] = b49 ^ ~b41 & b43;
            s3[0] ^= RC[n2];
            s3[1] ^= RC[n2 + 1];
          }
        };
        if (COMMON_JS) {
          module.exports = methods;
        } else {
          for (i3 = 0; i3 < methodNames.length; ++i3) {
            root[methodNames[i3]] = methods[methodNames[i3]];
          }
          if (AMD) {
            define(function() {
              return methods;
            });
          }
        }
      })();
    }
  });

  // node_modules/strict-uri-encode/index.js
  var require_strict_uri_encode = __commonJS({
    "node_modules/strict-uri-encode/index.js"(exports, module) {
      "use strict";
      module.exports = (str) => encodeURIComponent(str).replace(/[!'()*]/g, (x3) => `%${x3.charCodeAt(0).toString(16).toUpperCase()}`);
    }
  });

  // node_modules/decode-uri-component/index.js
  var require_decode_uri_component = __commonJS({
    "node_modules/decode-uri-component/index.js"(exports, module) {
      "use strict";
      var token = "%[a-f0-9]{2}";
      var singleMatcher = new RegExp(token, "gi");
      var multiMatcher = new RegExp("(" + token + ")+", "gi");
      function decodeComponents(components, split) {
        try {
          return decodeURIComponent(components.join(""));
        } catch (err) {
        }
        if (components.length === 1) {
          return components;
        }
        split = split || 1;
        var left = components.slice(0, split);
        var right = components.slice(split);
        return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
      }
      function decode3(input) {
        try {
          return decodeURIComponent(input);
        } catch (err) {
          var tokens = input.match(singleMatcher);
          for (var i3 = 1; i3 < tokens.length; i3++) {
            input = decodeComponents(tokens, i3).join("");
            tokens = input.match(singleMatcher);
          }
          return input;
        }
      }
      function customDecodeURIComponent(input) {
        var replaceMap = {
          "%FE%FF": "\uFFFD\uFFFD",
          "%FF%FE": "\uFFFD\uFFFD"
        };
        var match = multiMatcher.exec(input);
        while (match) {
          try {
            replaceMap[match[0]] = decodeURIComponent(match[0]);
          } catch (err) {
            var result = decode3(match[0]);
            if (result !== match[0]) {
              replaceMap[match[0]] = result;
            }
          }
          match = multiMatcher.exec(input);
        }
        replaceMap["%C2"] = "\uFFFD";
        var entries = Object.keys(replaceMap);
        for (var i3 = 0; i3 < entries.length; i3++) {
          var key2 = entries[i3];
          input = input.replace(new RegExp(key2, "g"), replaceMap[key2]);
        }
        return input;
      }
      module.exports = function(encodedURI) {
        if (typeof encodedURI !== "string") {
          throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof encodedURI + "`");
        }
        try {
          encodedURI = encodedURI.replace(/\+/g, " ");
          return decodeURIComponent(encodedURI);
        } catch (err) {
          return customDecodeURIComponent(encodedURI);
        }
      };
    }
  });

  // node_modules/split-on-first/index.js
  var require_split_on_first = __commonJS({
    "node_modules/split-on-first/index.js"(exports, module) {
      "use strict";
      module.exports = (string, separator) => {
        if (!(typeof string === "string" && typeof separator === "string")) {
          throw new TypeError("Expected the arguments to be of type `string`");
        }
        if (separator === "") {
          return [string];
        }
        const separatorIndex = string.indexOf(separator);
        if (separatorIndex === -1) {
          return [string];
        }
        return [
          string.slice(0, separatorIndex),
          string.slice(separatorIndex + separator.length)
        ];
      };
    }
  });

  // node_modules/query-string/index.js
  var require_query_string = __commonJS({
    "node_modules/query-string/index.js"(exports) {
      "use strict";
      var strictUriEncode = require_strict_uri_encode();
      var decodeComponent = require_decode_uri_component();
      var splitOnFirst = require_split_on_first();
      var isNullOrUndefined = (value) => value === null || value === void 0;
      function encoderForArrayFormat(options) {
        switch (options.arrayFormat) {
          case "index":
            return (key2) => (result, value) => {
              const index = result.length;
              if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
                return result;
              }
              if (value === null) {
                return [...result, [encode4(key2, options), "[", index, "]"].join("")];
              }
              return [
                ...result,
                [encode4(key2, options), "[", encode4(index, options), "]=", encode4(value, options)].join("")
              ];
            };
          case "bracket":
            return (key2) => (result, value) => {
              if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
                return result;
              }
              if (value === null) {
                return [...result, [encode4(key2, options), "[]"].join("")];
              }
              return [...result, [encode4(key2, options), "[]=", encode4(value, options)].join("")];
            };
          case "comma":
          case "separator":
            return (key2) => (result, value) => {
              if (value === null || value === void 0 || value.length === 0) {
                return result;
              }
              if (result.length === 0) {
                return [[encode4(key2, options), "=", encode4(value, options)].join("")];
              }
              return [[result, encode4(value, options)].join(options.arrayFormatSeparator)];
            };
          default:
            return (key2) => (result, value) => {
              if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
                return result;
              }
              if (value === null) {
                return [...result, encode4(key2, options)];
              }
              return [...result, [encode4(key2, options), "=", encode4(value, options)].join("")];
            };
        }
      }
      function parserForArrayFormat(options) {
        let result;
        switch (options.arrayFormat) {
          case "index":
            return (key2, value, accumulator) => {
              result = /\[(\d*)\]$/.exec(key2);
              key2 = key2.replace(/\[\d*\]$/, "");
              if (!result) {
                accumulator[key2] = value;
                return;
              }
              if (accumulator[key2] === void 0) {
                accumulator[key2] = {};
              }
              accumulator[key2][result[1]] = value;
            };
          case "bracket":
            return (key2, value, accumulator) => {
              result = /(\[\])$/.exec(key2);
              key2 = key2.replace(/\[\]$/, "");
              if (!result) {
                accumulator[key2] = value;
                return;
              }
              if (accumulator[key2] === void 0) {
                accumulator[key2] = [value];
                return;
              }
              accumulator[key2] = [].concat(accumulator[key2], value);
            };
          case "comma":
          case "separator":
            return (key2, value, accumulator) => {
              const isArray = typeof value === "string" && value.split("").indexOf(options.arrayFormatSeparator) > -1;
              const newValue = isArray ? value.split(options.arrayFormatSeparator).map((item) => decode3(item, options)) : value === null ? value : decode3(value, options);
              accumulator[key2] = newValue;
            };
          default:
            return (key2, value, accumulator) => {
              if (accumulator[key2] === void 0) {
                accumulator[key2] = value;
                return;
              }
              accumulator[key2] = [].concat(accumulator[key2], value);
            };
        }
      }
      function validateArrayFormatSeparator(value) {
        if (typeof value !== "string" || value.length !== 1) {
          throw new TypeError("arrayFormatSeparator must be single character string");
        }
      }
      function encode4(value, options) {
        if (options.encode) {
          return options.strict ? strictUriEncode(value) : encodeURIComponent(value);
        }
        return value;
      }
      function decode3(value, options) {
        if (options.decode) {
          return decodeComponent(value);
        }
        return value;
      }
      function keysSorter(input) {
        if (Array.isArray(input)) {
          return input.sort();
        }
        if (typeof input === "object") {
          return keysSorter(Object.keys(input)).sort((a3, b2) => Number(a3) - Number(b2)).map((key2) => input[key2]);
        }
        return input;
      }
      function removeHash(input) {
        const hashStart = input.indexOf("#");
        if (hashStart !== -1) {
          input = input.slice(0, hashStart);
        }
        return input;
      }
      function getHash(url) {
        let hash3 = "";
        const hashStart = url.indexOf("#");
        if (hashStart !== -1) {
          hash3 = url.slice(hashStart);
        }
        return hash3;
      }
      function extract(input) {
        input = removeHash(input);
        const queryStart = input.indexOf("?");
        if (queryStart === -1) {
          return "";
        }
        return input.slice(queryStart + 1);
      }
      function parseValue(value, options) {
        if (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === "string" && value.trim() !== "")) {
          value = Number(value);
        } else if (options.parseBooleans && value !== null && (value.toLowerCase() === "true" || value.toLowerCase() === "false")) {
          value = value.toLowerCase() === "true";
        }
        return value;
      }
      function parse3(input, options) {
        options = Object.assign({
          decode: true,
          sort: true,
          arrayFormat: "none",
          arrayFormatSeparator: ",",
          parseNumbers: false,
          parseBooleans: false
        }, options);
        validateArrayFormatSeparator(options.arrayFormatSeparator);
        const formatter = parserForArrayFormat(options);
        const ret = Object.create(null);
        if (typeof input !== "string") {
          return ret;
        }
        input = input.trim().replace(/^[?#&]/, "");
        if (!input) {
          return ret;
        }
        for (const param of input.split("&")) {
          let [key2, value] = splitOnFirst(options.decode ? param.replace(/\+/g, " ") : param, "=");
          value = value === void 0 ? null : ["comma", "separator"].includes(options.arrayFormat) ? value : decode3(value, options);
          formatter(decode3(key2, options), value, ret);
        }
        for (const key2 of Object.keys(ret)) {
          const value = ret[key2];
          if (typeof value === "object" && value !== null) {
            for (const k3 of Object.keys(value)) {
              value[k3] = parseValue(value[k3], options);
            }
          } else {
            ret[key2] = parseValue(value, options);
          }
        }
        if (options.sort === false) {
          return ret;
        }
        return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key2) => {
          const value = ret[key2];
          if (Boolean(value) && typeof value === "object" && !Array.isArray(value)) {
            result[key2] = keysSorter(value);
          } else {
            result[key2] = value;
          }
          return result;
        }, Object.create(null));
      }
      exports.extract = extract;
      exports.parse = parse3;
      exports.stringify = (object, options) => {
        if (!object) {
          return "";
        }
        options = Object.assign({
          encode: true,
          strict: true,
          arrayFormat: "none",
          arrayFormatSeparator: ","
        }, options);
        validateArrayFormatSeparator(options.arrayFormatSeparator);
        const shouldFilter = (key2) => options.skipNull && isNullOrUndefined(object[key2]) || options.skipEmptyString && object[key2] === "";
        const formatter = encoderForArrayFormat(options);
        const objectCopy = {};
        for (const key2 of Object.keys(object)) {
          if (!shouldFilter(key2)) {
            objectCopy[key2] = object[key2];
          }
        }
        const keys = Object.keys(objectCopy);
        if (options.sort !== false) {
          keys.sort(options.sort);
        }
        return keys.map((key2) => {
          const value = object[key2];
          if (value === void 0) {
            return "";
          }
          if (value === null) {
            return encode4(key2, options);
          }
          if (Array.isArray(value)) {
            return value.reduce(formatter(key2), []).join("&");
          }
          return encode4(key2, options) + "=" + encode4(value, options);
        }).filter((x3) => x3.length > 0).join("&");
      };
      exports.parseUrl = (input, options) => {
        options = Object.assign({
          decode: true
        }, options);
        const [url, hash3] = splitOnFirst(input, "#");
        return Object.assign({
          url: url.split("?")[0] || "",
          query: parse3(extract(input), options)
        }, options && options.parseFragmentIdentifier && hash3 ? { fragmentIdentifier: decode3(hash3, options) } : {});
      };
      exports.stringifyUrl = (input, options) => {
        options = Object.assign({
          encode: true,
          strict: true
        }, options);
        const url = removeHash(input.url).split("?")[0] || "";
        const queryFromUrl = exports.extract(input.url);
        const parsedQueryFromUrl = exports.parse(queryFromUrl, { sort: false });
        const query = Object.assign(parsedQueryFromUrl, input.query);
        let queryString = exports.stringify(query, options);
        if (queryString) {
          queryString = `?${queryString}`;
        }
        let hash3 = getHash(input.url);
        if (input.fragmentIdentifier) {
          hash3 = `#${encode4(input.fragmentIdentifier, options)}`;
        }
        return `${url}${queryString}${hash3}`;
      };
    }
  });

  // node_modules/@walletconnect/socket-transport/node_modules/ws/browser.js
  var require_browser = __commonJS({
    "node_modules/@walletconnect/socket-transport/node_modules/ws/browser.js"(exports, module) {
      "use strict";
      module.exports = function() {
        throw new Error("ws does not work in the browser. Browser clients must use the native WebSocket object");
      };
    }
  });

  // node_modules/qrcode/lib/can-promise.js
  var require_can_promise = __commonJS({
    "node_modules/qrcode/lib/can-promise.js"(exports, module) {
      module.exports = function() {
        return typeof Promise === "function" && Promise.prototype && Promise.prototype.then;
      };
    }
  });

  // node_modules/qrcode/node_modules/isarray/index.js
  var require_isarray = __commonJS({
    "node_modules/qrcode/node_modules/isarray/index.js"(exports, module) {
      var toString = {}.toString;
      module.exports = Array.isArray || function(arr) {
        return toString.call(arr) == "[object Array]";
      };
    }
  });

  // node_modules/qrcode/lib/utils/typedarray-buffer.js
  var require_typedarray_buffer = __commonJS({
    "node_modules/qrcode/lib/utils/typedarray-buffer.js"(exports, module) {
      "use strict";
      var isArray = require_isarray();
      function typedArraySupport() {
        try {
          var arr = new Uint8Array(1);
          arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function() {
            return 42;
          } };
          return arr.foo() === 42;
        } catch (e3) {
          return false;
        }
      }
      Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
      var K_MAX_LENGTH = Buffer2.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
      function Buffer2(arg, offset, length) {
        if (!Buffer2.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer2)) {
          return new Buffer2(arg, offset, length);
        }
        if (typeof arg === "number") {
          return allocUnsafe(this, arg);
        }
        return from(this, arg, offset, length);
      }
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        Buffer2.prototype.__proto__ = Uint8Array.prototype;
        Buffer2.__proto__ = Uint8Array;
        if (typeof Symbol !== "undefined" && Symbol.species && Buffer2[Symbol.species] === Buffer2) {
          Object.defineProperty(Buffer2, Symbol.species, {
            value: null,
            configurable: true,
            enumerable: false,
            writable: false
          });
        }
      }
      function checked(length) {
        if (length >= K_MAX_LENGTH) {
          throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
        }
        return length | 0;
      }
      function isnan(val) {
        return val !== val;
      }
      function createBuffer(that, length) {
        var buf;
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          buf = new Uint8Array(length);
          buf.__proto__ = Buffer2.prototype;
        } else {
          buf = that;
          if (buf === null) {
            buf = new Buffer2(length);
          }
          buf.length = length;
        }
        return buf;
      }
      function allocUnsafe(that, size) {
        var buf = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
        if (!Buffer2.TYPED_ARRAY_SUPPORT) {
          for (var i3 = 0; i3 < size; ++i3) {
            buf[i3] = 0;
          }
        }
        return buf;
      }
      function fromString(that, string) {
        var length = byteLength(string) | 0;
        var buf = createBuffer(that, length);
        var actual = buf.write(string);
        if (actual !== length) {
          buf = buf.slice(0, actual);
        }
        return buf;
      }
      function fromArrayLike(that, array) {
        var length = array.length < 0 ? 0 : checked(array.length) | 0;
        var buf = createBuffer(that, length);
        for (var i3 = 0; i3 < length; i3 += 1) {
          buf[i3] = array[i3] & 255;
        }
        return buf;
      }
      function fromArrayBuffer(that, array, byteOffset, length) {
        if (byteOffset < 0 || array.byteLength < byteOffset) {
          throw new RangeError("'offset' is out of bounds");
        }
        if (array.byteLength < byteOffset + (length || 0)) {
          throw new RangeError("'length' is out of bounds");
        }
        var buf;
        if (byteOffset === void 0 && length === void 0) {
          buf = new Uint8Array(array);
        } else if (length === void 0) {
          buf = new Uint8Array(array, byteOffset);
        } else {
          buf = new Uint8Array(array, byteOffset, length);
        }
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          buf.__proto__ = Buffer2.prototype;
        } else {
          buf = fromArrayLike(that, buf);
        }
        return buf;
      }
      function fromObject(that, obj) {
        if (Buffer2.isBuffer(obj)) {
          var len = checked(obj.length) | 0;
          var buf = createBuffer(that, len);
          if (buf.length === 0) {
            return buf;
          }
          obj.copy(buf, 0, 0, len);
          return buf;
        }
        if (obj) {
          if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
            if (typeof obj.length !== "number" || isnan(obj.length)) {
              return createBuffer(that, 0);
            }
            return fromArrayLike(that, obj);
          }
          if (obj.type === "Buffer" && Array.isArray(obj.data)) {
            return fromArrayLike(that, obj.data);
          }
        }
        throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
      }
      function utf8ToBytes(string, units) {
        units = units || Infinity;
        var codePoint;
        var length = string.length;
        var leadSurrogate = null;
        var bytes = [];
        for (var i3 = 0; i3 < length; ++i3) {
          codePoint = string.charCodeAt(i3);
          if (codePoint > 55295 && codePoint < 57344) {
            if (!leadSurrogate) {
              if (codePoint > 56319) {
                if ((units -= 3) > -1)
                  bytes.push(239, 191, 189);
                continue;
              } else if (i3 + 1 === length) {
                if ((units -= 3) > -1)
                  bytes.push(239, 191, 189);
                continue;
              }
              leadSurrogate = codePoint;
              continue;
            }
            if (codePoint < 56320) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              leadSurrogate = codePoint;
              continue;
            }
            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
          } else if (leadSurrogate) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
          }
          leadSurrogate = null;
          if (codePoint < 128) {
            if ((units -= 1) < 0)
              break;
            bytes.push(codePoint);
          } else if (codePoint < 2048) {
            if ((units -= 2) < 0)
              break;
            bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
          } else if (codePoint < 65536) {
            if ((units -= 3) < 0)
              break;
            bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
          } else if (codePoint < 1114112) {
            if ((units -= 4) < 0)
              break;
            bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
          } else {
            throw new Error("Invalid code point");
          }
        }
        return bytes;
      }
      function byteLength(string) {
        if (Buffer2.isBuffer(string)) {
          return string.length;
        }
        if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
          return string.byteLength;
        }
        if (typeof string !== "string") {
          string = "" + string;
        }
        var len = string.length;
        if (len === 0)
          return 0;
        return utf8ToBytes(string).length;
      }
      function blitBuffer(src, dst, offset, length) {
        for (var i3 = 0; i3 < length; ++i3) {
          if (i3 + offset >= dst.length || i3 >= src.length)
            break;
          dst[i3 + offset] = src[i3];
        }
        return i3;
      }
      function utf8Write(buf, string, offset, length) {
        return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
      }
      function from(that, value, offset, length) {
        if (typeof value === "number") {
          throw new TypeError('"value" argument must not be a number');
        }
        if (typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer) {
          return fromArrayBuffer(that, value, offset, length);
        }
        if (typeof value === "string") {
          return fromString(that, value, offset);
        }
        return fromObject(that, value);
      }
      Buffer2.prototype.write = function write(string, offset, length) {
        if (offset === void 0) {
          length = this.length;
          offset = 0;
        } else if (length === void 0 && typeof offset === "string") {
          length = this.length;
          offset = 0;
        } else if (isFinite(offset)) {
          offset = offset | 0;
          if (isFinite(length)) {
            length = length | 0;
          } else {
            length = void 0;
          }
        }
        var remaining = this.length - offset;
        if (length === void 0 || length > remaining)
          length = remaining;
        if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
          throw new RangeError("Attempt to write outside buffer bounds");
        }
        return utf8Write(this, string, offset, length);
      };
      Buffer2.prototype.slice = function slice(start, end) {
        var len = this.length;
        start = ~~start;
        end = end === void 0 ? len : ~~end;
        if (start < 0) {
          start += len;
          if (start < 0)
            start = 0;
        } else if (start > len) {
          start = len;
        }
        if (end < 0) {
          end += len;
          if (end < 0)
            end = 0;
        } else if (end > len) {
          end = len;
        }
        if (end < start)
          end = start;
        var newBuf;
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          newBuf = this.subarray(start, end);
          newBuf.__proto__ = Buffer2.prototype;
        } else {
          var sliceLen = end - start;
          newBuf = new Buffer2(sliceLen, void 0);
          for (var i3 = 0; i3 < sliceLen; ++i3) {
            newBuf[i3] = this[i3 + start];
          }
        }
        return newBuf;
      };
      Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
        if (!start)
          start = 0;
        if (!end && end !== 0)
          end = this.length;
        if (targetStart >= target.length)
          targetStart = target.length;
        if (!targetStart)
          targetStart = 0;
        if (end > 0 && end < start)
          end = start;
        if (end === start)
          return 0;
        if (target.length === 0 || this.length === 0)
          return 0;
        if (targetStart < 0) {
          throw new RangeError("targetStart out of bounds");
        }
        if (start < 0 || start >= this.length)
          throw new RangeError("sourceStart out of bounds");
        if (end < 0)
          throw new RangeError("sourceEnd out of bounds");
        if (end > this.length)
          end = this.length;
        if (target.length - targetStart < end - start) {
          end = target.length - targetStart + start;
        }
        var len = end - start;
        var i3;
        if (this === target && start < targetStart && targetStart < end) {
          for (i3 = len - 1; i3 >= 0; --i3) {
            target[i3 + targetStart] = this[i3 + start];
          }
        } else if (len < 1e3 || !Buffer2.TYPED_ARRAY_SUPPORT) {
          for (i3 = 0; i3 < len; ++i3) {
            target[i3 + targetStart] = this[i3 + start];
          }
        } else {
          Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
        }
        return len;
      };
      Buffer2.prototype.fill = function fill(val, start, end) {
        if (typeof val === "string") {
          if (typeof start === "string") {
            start = 0;
            end = this.length;
          } else if (typeof end === "string") {
            end = this.length;
          }
          if (val.length === 1) {
            var code = val.charCodeAt(0);
            if (code < 256) {
              val = code;
            }
          }
        } else if (typeof val === "number") {
          val = val & 255;
        }
        if (start < 0 || this.length < start || this.length < end) {
          throw new RangeError("Out of range index");
        }
        if (end <= start) {
          return this;
        }
        start = start >>> 0;
        end = end === void 0 ? this.length : end >>> 0;
        if (!val)
          val = 0;
        var i3;
        if (typeof val === "number") {
          for (i3 = start; i3 < end; ++i3) {
            this[i3] = val;
          }
        } else {
          var bytes = Buffer2.isBuffer(val) ? val : new Buffer2(val);
          var len = bytes.length;
          for (i3 = 0; i3 < end - start; ++i3) {
            this[i3 + start] = bytes[i3 % len];
          }
        }
        return this;
      };
      Buffer2.concat = function concat2(list, length) {
        if (!isArray(list)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        if (list.length === 0) {
          return createBuffer(null, 0);
        }
        var i3;
        if (length === void 0) {
          length = 0;
          for (i3 = 0; i3 < list.length; ++i3) {
            length += list[i3].length;
          }
        }
        var buffer = allocUnsafe(null, length);
        var pos = 0;
        for (i3 = 0; i3 < list.length; ++i3) {
          var buf = list[i3];
          if (!Buffer2.isBuffer(buf)) {
            throw new TypeError('"list" argument must be an Array of Buffers');
          }
          buf.copy(buffer, pos);
          pos += buf.length;
        }
        return buffer;
      };
      Buffer2.byteLength = byteLength;
      Buffer2.prototype._isBuffer = true;
      Buffer2.isBuffer = function isBuffer2(b2) {
        return !!(b2 != null && b2._isBuffer);
      };
      module.exports.alloc = function(size) {
        var buffer = new Buffer2(size);
        buffer.fill(0);
        return buffer;
      };
      module.exports.from = function(data4) {
        return new Buffer2(data4);
      };
    }
  });

  // node_modules/qrcode/lib/core/utils.js
  var require_utils2 = __commonJS({
    "node_modules/qrcode/lib/core/utils.js"(exports) {
      var toSJISFunction;
      var CODEWORDS_COUNT = [
        0,
        26,
        44,
        70,
        100,
        134,
        172,
        196,
        242,
        292,
        346,
        404,
        466,
        532,
        581,
        655,
        733,
        815,
        901,
        991,
        1085,
        1156,
        1258,
        1364,
        1474,
        1588,
        1706,
        1828,
        1921,
        2051,
        2185,
        2323,
        2465,
        2611,
        2761,
        2876,
        3034,
        3196,
        3362,
        3532,
        3706
      ];
      exports.getSymbolSize = function getSymbolSize(version26) {
        if (!version26)
          throw new Error('"version" cannot be null or undefined');
        if (version26 < 1 || version26 > 40)
          throw new Error('"version" should be in range from 1 to 40');
        return version26 * 4 + 17;
      };
      exports.getSymbolTotalCodewords = function getSymbolTotalCodewords(version26) {
        return CODEWORDS_COUNT[version26];
      };
      exports.getBCHDigit = function(data4) {
        var digit = 0;
        while (data4 !== 0) {
          digit++;
          data4 >>>= 1;
        }
        return digit;
      };
      exports.setToSJISFunction = function setToSJISFunction(f3) {
        if (typeof f3 !== "function") {
          throw new Error('"toSJISFunc" is not a valid function.');
        }
        toSJISFunction = f3;
      };
      exports.isKanjiModeEnabled = function() {
        return typeof toSJISFunction !== "undefined";
      };
      exports.toSJIS = function toSJIS(kanji) {
        return toSJISFunction(kanji);
      };
    }
  });

  // node_modules/qrcode/lib/core/error-correction-level.js
  var require_error_correction_level = __commonJS({
    "node_modules/qrcode/lib/core/error-correction-level.js"(exports) {
      exports.L = { bit: 1 };
      exports.M = { bit: 0 };
      exports.Q = { bit: 3 };
      exports.H = { bit: 2 };
      function fromString(string) {
        if (typeof string !== "string") {
          throw new Error("Param is not a string");
        }
        var lcStr = string.toLowerCase();
        switch (lcStr) {
          case "l":
          case "low":
            return exports.L;
          case "m":
          case "medium":
            return exports.M;
          case "q":
          case "quartile":
            return exports.Q;
          case "h":
          case "high":
            return exports.H;
          default:
            throw new Error("Unknown EC Level: " + string);
        }
      }
      exports.isValid = function isValid(level) {
        return level && typeof level.bit !== "undefined" && level.bit >= 0 && level.bit < 4;
      };
      exports.from = function from(value, defaultValue) {
        if (exports.isValid(value)) {
          return value;
        }
        try {
          return fromString(value);
        } catch (e3) {
          return defaultValue;
        }
      };
    }
  });

  // node_modules/qrcode/lib/core/bit-buffer.js
  var require_bit_buffer = __commonJS({
    "node_modules/qrcode/lib/core/bit-buffer.js"(exports, module) {
      function BitBuffer() {
        this.buffer = [];
        this.length = 0;
      }
      BitBuffer.prototype = {
        get: function(index) {
          var bufIndex = Math.floor(index / 8);
          return (this.buffer[bufIndex] >>> 7 - index % 8 & 1) === 1;
        },
        put: function(num, length) {
          for (var i3 = 0; i3 < length; i3++) {
            this.putBit((num >>> length - i3 - 1 & 1) === 1);
          }
        },
        getLengthInBits: function() {
          return this.length;
        },
        putBit: function(bit) {
          var bufIndex = Math.floor(this.length / 8);
          if (this.buffer.length <= bufIndex) {
            this.buffer.push(0);
          }
          if (bit) {
            this.buffer[bufIndex] |= 128 >>> this.length % 8;
          }
          this.length++;
        }
      };
      module.exports = BitBuffer;
    }
  });

  // node_modules/qrcode/lib/core/bit-matrix.js
  var require_bit_matrix = __commonJS({
    "node_modules/qrcode/lib/core/bit-matrix.js"(exports, module) {
      var BufferUtil = require_typedarray_buffer();
      function BitMatrix(size) {
        if (!size || size < 1) {
          throw new Error("BitMatrix size must be defined and greater than 0");
        }
        this.size = size;
        this.data = BufferUtil.alloc(size * size);
        this.reservedBit = BufferUtil.alloc(size * size);
      }
      BitMatrix.prototype.set = function(row, col, value, reserved) {
        var index = row * this.size + col;
        this.data[index] = value;
        if (reserved)
          this.reservedBit[index] = true;
      };
      BitMatrix.prototype.get = function(row, col) {
        return this.data[row * this.size + col];
      };
      BitMatrix.prototype.xor = function(row, col, value) {
        this.data[row * this.size + col] ^= value;
      };
      BitMatrix.prototype.isReserved = function(row, col) {
        return this.reservedBit[row * this.size + col];
      };
      module.exports = BitMatrix;
    }
  });

  // node_modules/qrcode/lib/core/alignment-pattern.js
  var require_alignment_pattern = __commonJS({
    "node_modules/qrcode/lib/core/alignment-pattern.js"(exports) {
      var getSymbolSize = require_utils2().getSymbolSize;
      exports.getRowColCoords = function getRowColCoords(version26) {
        if (version26 === 1)
          return [];
        var posCount = Math.floor(version26 / 7) + 2;
        var size = getSymbolSize(version26);
        var intervals = size === 145 ? 26 : Math.ceil((size - 13) / (2 * posCount - 2)) * 2;
        var positions = [size - 7];
        for (var i3 = 1; i3 < posCount - 1; i3++) {
          positions[i3] = positions[i3 - 1] - intervals;
        }
        positions.push(6);
        return positions.reverse();
      };
      exports.getPositions = function getPositions(version26) {
        var coords = [];
        var pos = exports.getRowColCoords(version26);
        var posLength = pos.length;
        for (var i3 = 0; i3 < posLength; i3++) {
          for (var j3 = 0; j3 < posLength; j3++) {
            if (i3 === 0 && j3 === 0 || i3 === 0 && j3 === posLength - 1 || i3 === posLength - 1 && j3 === 0) {
              continue;
            }
            coords.push([pos[i3], pos[j3]]);
          }
        }
        return coords;
      };
    }
  });

  // node_modules/qrcode/lib/core/finder-pattern.js
  var require_finder_pattern = __commonJS({
    "node_modules/qrcode/lib/core/finder-pattern.js"(exports) {
      var getSymbolSize = require_utils2().getSymbolSize;
      var FINDER_PATTERN_SIZE = 7;
      exports.getPositions = function getPositions(version26) {
        var size = getSymbolSize(version26);
        return [
          [0, 0],
          [size - FINDER_PATTERN_SIZE, 0],
          [0, size - FINDER_PATTERN_SIZE]
        ];
      };
    }
  });

  // node_modules/qrcode/lib/core/mask-pattern.js
  var require_mask_pattern = __commonJS({
    "node_modules/qrcode/lib/core/mask-pattern.js"(exports) {
      exports.Patterns = {
        PATTERN000: 0,
        PATTERN001: 1,
        PATTERN010: 2,
        PATTERN011: 3,
        PATTERN100: 4,
        PATTERN101: 5,
        PATTERN110: 6,
        PATTERN111: 7
      };
      var PenaltyScores = {
        N1: 3,
        N2: 3,
        N3: 40,
        N4: 10
      };
      exports.isValid = function isValid(mask) {
        return mask != null && mask !== "" && !isNaN(mask) && mask >= 0 && mask <= 7;
      };
      exports.from = function from(value) {
        return exports.isValid(value) ? parseInt(value, 10) : void 0;
      };
      exports.getPenaltyN1 = function getPenaltyN1(data4) {
        var size = data4.size;
        var points = 0;
        var sameCountCol = 0;
        var sameCountRow = 0;
        var lastCol = null;
        var lastRow = null;
        for (var row = 0; row < size; row++) {
          sameCountCol = sameCountRow = 0;
          lastCol = lastRow = null;
          for (var col = 0; col < size; col++) {
            var module2 = data4.get(row, col);
            if (module2 === lastCol) {
              sameCountCol++;
            } else {
              if (sameCountCol >= 5)
                points += PenaltyScores.N1 + (sameCountCol - 5);
              lastCol = module2;
              sameCountCol = 1;
            }
            module2 = data4.get(col, row);
            if (module2 === lastRow) {
              sameCountRow++;
            } else {
              if (sameCountRow >= 5)
                points += PenaltyScores.N1 + (sameCountRow - 5);
              lastRow = module2;
              sameCountRow = 1;
            }
          }
          if (sameCountCol >= 5)
            points += PenaltyScores.N1 + (sameCountCol - 5);
          if (sameCountRow >= 5)
            points += PenaltyScores.N1 + (sameCountRow - 5);
        }
        return points;
      };
      exports.getPenaltyN2 = function getPenaltyN2(data4) {
        var size = data4.size;
        var points = 0;
        for (var row = 0; row < size - 1; row++) {
          for (var col = 0; col < size - 1; col++) {
            var last = data4.get(row, col) + data4.get(row, col + 1) + data4.get(row + 1, col) + data4.get(row + 1, col + 1);
            if (last === 4 || last === 0)
              points++;
          }
        }
        return points * PenaltyScores.N2;
      };
      exports.getPenaltyN3 = function getPenaltyN3(data4) {
        var size = data4.size;
        var points = 0;
        var bitsCol = 0;
        var bitsRow = 0;
        for (var row = 0; row < size; row++) {
          bitsCol = bitsRow = 0;
          for (var col = 0; col < size; col++) {
            bitsCol = bitsCol << 1 & 2047 | data4.get(row, col);
            if (col >= 10 && (bitsCol === 1488 || bitsCol === 93))
              points++;
            bitsRow = bitsRow << 1 & 2047 | data4.get(col, row);
            if (col >= 10 && (bitsRow === 1488 || bitsRow === 93))
              points++;
          }
        }
        return points * PenaltyScores.N3;
      };
      exports.getPenaltyN4 = function getPenaltyN4(data4) {
        var darkCount = 0;
        var modulesCount = data4.data.length;
        for (var i3 = 0; i3 < modulesCount; i3++)
          darkCount += data4.data[i3];
        var k3 = Math.abs(Math.ceil(darkCount * 100 / modulesCount / 5) - 10);
        return k3 * PenaltyScores.N4;
      };
      function getMaskAt(maskPattern, i3, j3) {
        switch (maskPattern) {
          case exports.Patterns.PATTERN000:
            return (i3 + j3) % 2 === 0;
          case exports.Patterns.PATTERN001:
            return i3 % 2 === 0;
          case exports.Patterns.PATTERN010:
            return j3 % 3 === 0;
          case exports.Patterns.PATTERN011:
            return (i3 + j3) % 3 === 0;
          case exports.Patterns.PATTERN100:
            return (Math.floor(i3 / 2) + Math.floor(j3 / 3)) % 2 === 0;
          case exports.Patterns.PATTERN101:
            return i3 * j3 % 2 + i3 * j3 % 3 === 0;
          case exports.Patterns.PATTERN110:
            return (i3 * j3 % 2 + i3 * j3 % 3) % 2 === 0;
          case exports.Patterns.PATTERN111:
            return (i3 * j3 % 3 + (i3 + j3) % 2) % 2 === 0;
          default:
            throw new Error("bad maskPattern:" + maskPattern);
        }
      }
      exports.applyMask = function applyMask(pattern, data4) {
        var size = data4.size;
        for (var col = 0; col < size; col++) {
          for (var row = 0; row < size; row++) {
            if (data4.isReserved(row, col))
              continue;
            data4.xor(row, col, getMaskAt(pattern, row, col));
          }
        }
      };
      exports.getBestMask = function getBestMask(data4, setupFormatFunc) {
        var numPatterns = Object.keys(exports.Patterns).length;
        var bestPattern = 0;
        var lowerPenalty = Infinity;
        for (var p3 = 0; p3 < numPatterns; p3++) {
          setupFormatFunc(p3);
          exports.applyMask(p3, data4);
          var penalty = exports.getPenaltyN1(data4) + exports.getPenaltyN2(data4) + exports.getPenaltyN3(data4) + exports.getPenaltyN4(data4);
          exports.applyMask(p3, data4);
          if (penalty < lowerPenalty) {
            lowerPenalty = penalty;
            bestPattern = p3;
          }
        }
        return bestPattern;
      };
    }
  });

  // node_modules/qrcode/lib/core/error-correction-code.js
  var require_error_correction_code = __commonJS({
    "node_modules/qrcode/lib/core/error-correction-code.js"(exports) {
      var ECLevel = require_error_correction_level();
      var EC_BLOCKS_TABLE = [
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        2,
        2,
        1,
        2,
        2,
        4,
        1,
        2,
        4,
        4,
        2,
        4,
        4,
        4,
        2,
        4,
        6,
        5,
        2,
        4,
        6,
        6,
        2,
        5,
        8,
        8,
        4,
        5,
        8,
        8,
        4,
        5,
        8,
        11,
        4,
        8,
        10,
        11,
        4,
        9,
        12,
        16,
        4,
        9,
        16,
        16,
        6,
        10,
        12,
        18,
        6,
        10,
        17,
        16,
        6,
        11,
        16,
        19,
        6,
        13,
        18,
        21,
        7,
        14,
        21,
        25,
        8,
        16,
        20,
        25,
        8,
        17,
        23,
        25,
        9,
        17,
        23,
        34,
        9,
        18,
        25,
        30,
        10,
        20,
        27,
        32,
        12,
        21,
        29,
        35,
        12,
        23,
        34,
        37,
        12,
        25,
        34,
        40,
        13,
        26,
        35,
        42,
        14,
        28,
        38,
        45,
        15,
        29,
        40,
        48,
        16,
        31,
        43,
        51,
        17,
        33,
        45,
        54,
        18,
        35,
        48,
        57,
        19,
        37,
        51,
        60,
        19,
        38,
        53,
        63,
        20,
        40,
        56,
        66,
        21,
        43,
        59,
        70,
        22,
        45,
        62,
        74,
        24,
        47,
        65,
        77,
        25,
        49,
        68,
        81
      ];
      var EC_CODEWORDS_TABLE = [
        7,
        10,
        13,
        17,
        10,
        16,
        22,
        28,
        15,
        26,
        36,
        44,
        20,
        36,
        52,
        64,
        26,
        48,
        72,
        88,
        36,
        64,
        96,
        112,
        40,
        72,
        108,
        130,
        48,
        88,
        132,
        156,
        60,
        110,
        160,
        192,
        72,
        130,
        192,
        224,
        80,
        150,
        224,
        264,
        96,
        176,
        260,
        308,
        104,
        198,
        288,
        352,
        120,
        216,
        320,
        384,
        132,
        240,
        360,
        432,
        144,
        280,
        408,
        480,
        168,
        308,
        448,
        532,
        180,
        338,
        504,
        588,
        196,
        364,
        546,
        650,
        224,
        416,
        600,
        700,
        224,
        442,
        644,
        750,
        252,
        476,
        690,
        816,
        270,
        504,
        750,
        900,
        300,
        560,
        810,
        960,
        312,
        588,
        870,
        1050,
        336,
        644,
        952,
        1110,
        360,
        700,
        1020,
        1200,
        390,
        728,
        1050,
        1260,
        420,
        784,
        1140,
        1350,
        450,
        812,
        1200,
        1440,
        480,
        868,
        1290,
        1530,
        510,
        924,
        1350,
        1620,
        540,
        980,
        1440,
        1710,
        570,
        1036,
        1530,
        1800,
        570,
        1064,
        1590,
        1890,
        600,
        1120,
        1680,
        1980,
        630,
        1204,
        1770,
        2100,
        660,
        1260,
        1860,
        2220,
        720,
        1316,
        1950,
        2310,
        750,
        1372,
        2040,
        2430
      ];
      exports.getBlocksCount = function getBlocksCount(version26, errorCorrectionLevel) {
        switch (errorCorrectionLevel) {
          case ECLevel.L:
            return EC_BLOCKS_TABLE[(version26 - 1) * 4 + 0];
          case ECLevel.M:
            return EC_BLOCKS_TABLE[(version26 - 1) * 4 + 1];
          case ECLevel.Q:
            return EC_BLOCKS_TABLE[(version26 - 1) * 4 + 2];
          case ECLevel.H:
            return EC_BLOCKS_TABLE[(version26 - 1) * 4 + 3];
          default:
            return void 0;
        }
      };
      exports.getTotalCodewordsCount = function getTotalCodewordsCount(version26, errorCorrectionLevel) {
        switch (errorCorrectionLevel) {
          case ECLevel.L:
            return EC_CODEWORDS_TABLE[(version26 - 1) * 4 + 0];
          case ECLevel.M:
            return EC_CODEWORDS_TABLE[(version26 - 1) * 4 + 1];
          case ECLevel.Q:
            return EC_CODEWORDS_TABLE[(version26 - 1) * 4 + 2];
          case ECLevel.H:
            return EC_CODEWORDS_TABLE[(version26 - 1) * 4 + 3];
          default:
            return void 0;
        }
      };
    }
  });

  // node_modules/qrcode/lib/core/galois-field.js
  var require_galois_field = __commonJS({
    "node_modules/qrcode/lib/core/galois-field.js"(exports) {
      var BufferUtil = require_typedarray_buffer();
      var EXP_TABLE = BufferUtil.alloc(512);
      var LOG_TABLE = BufferUtil.alloc(256);
      (function initTables() {
        var x3 = 1;
        for (var i3 = 0; i3 < 255; i3++) {
          EXP_TABLE[i3] = x3;
          LOG_TABLE[x3] = i3;
          x3 <<= 1;
          if (x3 & 256) {
            x3 ^= 285;
          }
        }
        for (i3 = 255; i3 < 512; i3++) {
          EXP_TABLE[i3] = EXP_TABLE[i3 - 255];
        }
      })();
      exports.log = function log(n2) {
        if (n2 < 1)
          throw new Error("log(" + n2 + ")");
        return LOG_TABLE[n2];
      };
      exports.exp = function exp(n2) {
        return EXP_TABLE[n2];
      };
      exports.mul = function mul3(x3, y3) {
        if (x3 === 0 || y3 === 0)
          return 0;
        return EXP_TABLE[LOG_TABLE[x3] + LOG_TABLE[y3]];
      };
    }
  });

  // node_modules/qrcode/lib/core/polynomial.js
  var require_polynomial = __commonJS({
    "node_modules/qrcode/lib/core/polynomial.js"(exports) {
      var BufferUtil = require_typedarray_buffer();
      var GF = require_galois_field();
      exports.mul = function mul3(p1, p22) {
        var coeff = BufferUtil.alloc(p1.length + p22.length - 1);
        for (var i3 = 0; i3 < p1.length; i3++) {
          for (var j3 = 0; j3 < p22.length; j3++) {
            coeff[i3 + j3] ^= GF.mul(p1[i3], p22[j3]);
          }
        }
        return coeff;
      };
      exports.mod = function mod(divident, divisor) {
        var result = BufferUtil.from(divident);
        while (result.length - divisor.length >= 0) {
          var coeff = result[0];
          for (var i3 = 0; i3 < divisor.length; i3++) {
            result[i3] ^= GF.mul(divisor[i3], coeff);
          }
          var offset = 0;
          while (offset < result.length && result[offset] === 0)
            offset++;
          result = result.slice(offset);
        }
        return result;
      };
      exports.generateECPolynomial = function generateECPolynomial(degree) {
        var poly = BufferUtil.from([1]);
        for (var i3 = 0; i3 < degree; i3++) {
          poly = exports.mul(poly, [1, GF.exp(i3)]);
        }
        return poly;
      };
    }
  });

  // node_modules/base64-js/index.js
  var require_base64_js = __commonJS({
    "node_modules/base64-js/index.js"(exports) {
      "use strict";
      exports.byteLength = byteLength;
      exports.toByteArray = toByteArray;
      exports.fromByteArray = fromByteArray;
      var lookup3 = [];
      var revLookup = [];
      var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
      var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      for (i3 = 0, len = code.length; i3 < len; ++i3) {
        lookup3[i3] = code[i3];
        revLookup[code.charCodeAt(i3)] = i3;
      }
      var i3;
      var len;
      revLookup["-".charCodeAt(0)] = 62;
      revLookup["_".charCodeAt(0)] = 63;
      function getLens(b64) {
        var len2 = b64.length;
        if (len2 % 4 > 0) {
          throw new Error("Invalid string. Length must be a multiple of 4");
        }
        var validLen = b64.indexOf("=");
        if (validLen === -1)
          validLen = len2;
        var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
        return [validLen, placeHoldersLen];
      }
      function byteLength(b64) {
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function _byteLength(b64, validLen, placeHoldersLen) {
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function toByteArray(b64) {
        var tmp;
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
        var curByte = 0;
        var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
        var i4;
        for (i4 = 0; i4 < len2; i4 += 4) {
          tmp = revLookup[b64.charCodeAt(i4)] << 18 | revLookup[b64.charCodeAt(i4 + 1)] << 12 | revLookup[b64.charCodeAt(i4 + 2)] << 6 | revLookup[b64.charCodeAt(i4 + 3)];
          arr[curByte++] = tmp >> 16 & 255;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 2) {
          tmp = revLookup[b64.charCodeAt(i4)] << 2 | revLookup[b64.charCodeAt(i4 + 1)] >> 4;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 1) {
          tmp = revLookup[b64.charCodeAt(i4)] << 10 | revLookup[b64.charCodeAt(i4 + 1)] << 4 | revLookup[b64.charCodeAt(i4 + 2)] >> 2;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        return arr;
      }
      function tripletToBase64(num) {
        return lookup3[num >> 18 & 63] + lookup3[num >> 12 & 63] + lookup3[num >> 6 & 63] + lookup3[num & 63];
      }
      function encodeChunk(uint8, start, end) {
        var tmp;
        var output = [];
        for (var i4 = start; i4 < end; i4 += 3) {
          tmp = (uint8[i4] << 16 & 16711680) + (uint8[i4 + 1] << 8 & 65280) + (uint8[i4 + 2] & 255);
          output.push(tripletToBase64(tmp));
        }
        return output.join("");
      }
      function fromByteArray(uint8) {
        var tmp;
        var len2 = uint8.length;
        var extraBytes = len2 % 3;
        var parts = [];
        var maxChunkLength = 16383;
        for (var i4 = 0, len22 = len2 - extraBytes; i4 < len22; i4 += maxChunkLength) {
          parts.push(encodeChunk(uint8, i4, i4 + maxChunkLength > len22 ? len22 : i4 + maxChunkLength));
        }
        if (extraBytes === 1) {
          tmp = uint8[len2 - 1];
          parts.push(lookup3[tmp >> 2] + lookup3[tmp << 4 & 63] + "==");
        } else if (extraBytes === 2) {
          tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
          parts.push(lookup3[tmp >> 10] + lookup3[tmp >> 4 & 63] + lookup3[tmp << 2 & 63] + "=");
        }
        return parts.join("");
      }
    }
  });

  // node_modules/ieee754/index.js
  var require_ieee754 = __commonJS({
    "node_modules/ieee754/index.js"(exports) {
      exports.read = function(buffer, offset, isLE, mLen, nBytes) {
        var e3, m3;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var nBits = -7;
        var i3 = isLE ? nBytes - 1 : 0;
        var d3 = isLE ? -1 : 1;
        var s3 = buffer[offset + i3];
        i3 += d3;
        e3 = s3 & (1 << -nBits) - 1;
        s3 >>= -nBits;
        nBits += eLen;
        for (; nBits > 0; e3 = e3 * 256 + buffer[offset + i3], i3 += d3, nBits -= 8) {
        }
        m3 = e3 & (1 << -nBits) - 1;
        e3 >>= -nBits;
        nBits += mLen;
        for (; nBits > 0; m3 = m3 * 256 + buffer[offset + i3], i3 += d3, nBits -= 8) {
        }
        if (e3 === 0) {
          e3 = 1 - eBias;
        } else if (e3 === eMax) {
          return m3 ? NaN : (s3 ? -1 : 1) * Infinity;
        } else {
          m3 = m3 + Math.pow(2, mLen);
          e3 = e3 - eBias;
        }
        return (s3 ? -1 : 1) * m3 * Math.pow(2, e3 - mLen);
      };
      exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
        var e3, m3, c3;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
        var i3 = isLE ? 0 : nBytes - 1;
        var d3 = isLE ? 1 : -1;
        var s3 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
        value = Math.abs(value);
        if (isNaN(value) || value === Infinity) {
          m3 = isNaN(value) ? 1 : 0;
          e3 = eMax;
        } else {
          e3 = Math.floor(Math.log(value) / Math.LN2);
          if (value * (c3 = Math.pow(2, -e3)) < 1) {
            e3--;
            c3 *= 2;
          }
          if (e3 + eBias >= 1) {
            value += rt / c3;
          } else {
            value += rt * Math.pow(2, 1 - eBias);
          }
          if (value * c3 >= 2) {
            e3++;
            c3 /= 2;
          }
          if (e3 + eBias >= eMax) {
            m3 = 0;
            e3 = eMax;
          } else if (e3 + eBias >= 1) {
            m3 = (value * c3 - 1) * Math.pow(2, mLen);
            e3 = e3 + eBias;
          } else {
            m3 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e3 = 0;
          }
        }
        for (; mLen >= 8; buffer[offset + i3] = m3 & 255, i3 += d3, m3 /= 256, mLen -= 8) {
        }
        e3 = e3 << mLen | m3;
        eLen += mLen;
        for (; eLen > 0; buffer[offset + i3] = e3 & 255, i3 += d3, e3 /= 256, eLen -= 8) {
        }
        buffer[offset + i3 - d3] |= s3 * 128;
      };
    }
  });

  // node_modules/buffer/index.js
  var require_buffer2 = __commonJS({
    "node_modules/buffer/index.js"(exports) {
      "use strict";
      var base64 = require_base64_js();
      var ieee754 = require_ieee754();
      var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
      exports.Buffer = Buffer2;
      exports.SlowBuffer = SlowBuffer;
      exports.INSPECT_MAX_BYTES = 50;
      var K_MAX_LENGTH = 2147483647;
      exports.kMaxLength = K_MAX_LENGTH;
      Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
      if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
        console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
      }
      function typedArraySupport() {
        try {
          var arr = new Uint8Array(1);
          var proto = { foo: function() {
            return 42;
          } };
          Object.setPrototypeOf(proto, Uint8Array.prototype);
          Object.setPrototypeOf(arr, proto);
          return arr.foo() === 42;
        } catch (e3) {
          return false;
        }
      }
      Object.defineProperty(Buffer2.prototype, "parent", {
        enumerable: true,
        get: function() {
          if (!Buffer2.isBuffer(this))
            return void 0;
          return this.buffer;
        }
      });
      Object.defineProperty(Buffer2.prototype, "offset", {
        enumerable: true,
        get: function() {
          if (!Buffer2.isBuffer(this))
            return void 0;
          return this.byteOffset;
        }
      });
      function createBuffer(length) {
        if (length > K_MAX_LENGTH) {
          throw new RangeError('The value "' + length + '" is invalid for option "size"');
        }
        var buf = new Uint8Array(length);
        Object.setPrototypeOf(buf, Buffer2.prototype);
        return buf;
      }
      function Buffer2(arg, encodingOrOffset, length) {
        if (typeof arg === "number") {
          if (typeof encodingOrOffset === "string") {
            throw new TypeError('The "string" argument must be of type string. Received type number');
          }
          return allocUnsafe(arg);
        }
        return from(arg, encodingOrOffset, length);
      }
      Buffer2.poolSize = 8192;
      function from(value, encodingOrOffset, length) {
        if (typeof value === "string") {
          return fromString(value, encodingOrOffset);
        }
        if (ArrayBuffer.isView(value)) {
          return fromArrayView(value);
        }
        if (value == null) {
          throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
        }
        if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof value === "number") {
          throw new TypeError('The "value" argument must not be of type number. Received type number');
        }
        var valueOf = value.valueOf && value.valueOf();
        if (valueOf != null && valueOf !== value) {
          return Buffer2.from(valueOf, encodingOrOffset, length);
        }
        var b2 = fromObject(value);
        if (b2)
          return b2;
        if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
          return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
        }
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
      }
      Buffer2.from = function(value, encodingOrOffset, length) {
        return from(value, encodingOrOffset, length);
      };
      Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
      Object.setPrototypeOf(Buffer2, Uint8Array);
      function assertSize(size) {
        if (typeof size !== "number") {
          throw new TypeError('"size" argument must be of type number');
        } else if (size < 0) {
          throw new RangeError('The value "' + size + '" is invalid for option "size"');
        }
      }
      function alloc(size, fill, encoding) {
        assertSize(size);
        if (size <= 0) {
          return createBuffer(size);
        }
        if (fill !== void 0) {
          return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
        }
        return createBuffer(size);
      }
      Buffer2.alloc = function(size, fill, encoding) {
        return alloc(size, fill, encoding);
      };
      function allocUnsafe(size) {
        assertSize(size);
        return createBuffer(size < 0 ? 0 : checked(size) | 0);
      }
      Buffer2.allocUnsafe = function(size) {
        return allocUnsafe(size);
      };
      Buffer2.allocUnsafeSlow = function(size) {
        return allocUnsafe(size);
      };
      function fromString(string, encoding) {
        if (typeof encoding !== "string" || encoding === "") {
          encoding = "utf8";
        }
        if (!Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        var length = byteLength(string, encoding) | 0;
        var buf = createBuffer(length);
        var actual = buf.write(string, encoding);
        if (actual !== length) {
          buf = buf.slice(0, actual);
        }
        return buf;
      }
      function fromArrayLike(array) {
        var length = array.length < 0 ? 0 : checked(array.length) | 0;
        var buf = createBuffer(length);
        for (var i3 = 0; i3 < length; i3 += 1) {
          buf[i3] = array[i3] & 255;
        }
        return buf;
      }
      function fromArrayView(arrayView) {
        if (isInstance(arrayView, Uint8Array)) {
          var copy = new Uint8Array(arrayView);
          return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
        }
        return fromArrayLike(arrayView);
      }
      function fromArrayBuffer(array, byteOffset, length) {
        if (byteOffset < 0 || array.byteLength < byteOffset) {
          throw new RangeError('"offset" is outside of buffer bounds');
        }
        if (array.byteLength < byteOffset + (length || 0)) {
          throw new RangeError('"length" is outside of buffer bounds');
        }
        var buf;
        if (byteOffset === void 0 && length === void 0) {
          buf = new Uint8Array(array);
        } else if (length === void 0) {
          buf = new Uint8Array(array, byteOffset);
        } else {
          buf = new Uint8Array(array, byteOffset, length);
        }
        Object.setPrototypeOf(buf, Buffer2.prototype);
        return buf;
      }
      function fromObject(obj) {
        if (Buffer2.isBuffer(obj)) {
          var len = checked(obj.length) | 0;
          var buf = createBuffer(len);
          if (buf.length === 0) {
            return buf;
          }
          obj.copy(buf, 0, 0, len);
          return buf;
        }
        if (obj.length !== void 0) {
          if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
            return createBuffer(0);
          }
          return fromArrayLike(obj);
        }
        if (obj.type === "Buffer" && Array.isArray(obj.data)) {
          return fromArrayLike(obj.data);
        }
      }
      function checked(length) {
        if (length >= K_MAX_LENGTH) {
          throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
        }
        return length | 0;
      }
      function SlowBuffer(length) {
        if (+length != length) {
          length = 0;
        }
        return Buffer2.alloc(+length);
      }
      Buffer2.isBuffer = function isBuffer2(b2) {
        return b2 != null && b2._isBuffer === true && b2 !== Buffer2.prototype;
      };
      Buffer2.compare = function compare(a3, b2) {
        if (isInstance(a3, Uint8Array))
          a3 = Buffer2.from(a3, a3.offset, a3.byteLength);
        if (isInstance(b2, Uint8Array))
          b2 = Buffer2.from(b2, b2.offset, b2.byteLength);
        if (!Buffer2.isBuffer(a3) || !Buffer2.isBuffer(b2)) {
          throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
        }
        if (a3 === b2)
          return 0;
        var x3 = a3.length;
        var y3 = b2.length;
        for (var i3 = 0, len = Math.min(x3, y3); i3 < len; ++i3) {
          if (a3[i3] !== b2[i3]) {
            x3 = a3[i3];
            y3 = b2[i3];
            break;
          }
        }
        if (x3 < y3)
          return -1;
        if (y3 < x3)
          return 1;
        return 0;
      };
      Buffer2.isEncoding = function isEncoding(encoding) {
        switch (String(encoding).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return true;
          default:
            return false;
        }
      };
      Buffer2.concat = function concat2(list, length) {
        if (!Array.isArray(list)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        if (list.length === 0) {
          return Buffer2.alloc(0);
        }
        var i3;
        if (length === void 0) {
          length = 0;
          for (i3 = 0; i3 < list.length; ++i3) {
            length += list[i3].length;
          }
        }
        var buffer = Buffer2.allocUnsafe(length);
        var pos = 0;
        for (i3 = 0; i3 < list.length; ++i3) {
          var buf = list[i3];
          if (isInstance(buf, Uint8Array)) {
            if (pos + buf.length > buffer.length) {
              Buffer2.from(buf).copy(buffer, pos);
            } else {
              Uint8Array.prototype.set.call(buffer, buf, pos);
            }
          } else if (!Buffer2.isBuffer(buf)) {
            throw new TypeError('"list" argument must be an Array of Buffers');
          } else {
            buf.copy(buffer, pos);
          }
          pos += buf.length;
        }
        return buffer;
      };
      function byteLength(string, encoding) {
        if (Buffer2.isBuffer(string)) {
          return string.length;
        }
        if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
          return string.byteLength;
        }
        if (typeof string !== "string") {
          throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
        }
        var len = string.length;
        var mustMatch = arguments.length > 2 && arguments[2] === true;
        if (!mustMatch && len === 0)
          return 0;
        var loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "ascii":
            case "latin1":
            case "binary":
              return len;
            case "utf8":
            case "utf-8":
              return utf8ToBytes(string).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return len * 2;
            case "hex":
              return len >>> 1;
            case "base64":
              return base64ToBytes(string).length;
            default:
              if (loweredCase) {
                return mustMatch ? -1 : utf8ToBytes(string).length;
              }
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer2.byteLength = byteLength;
      function slowToString(encoding, start, end) {
        var loweredCase = false;
        if (start === void 0 || start < 0) {
          start = 0;
        }
        if (start > this.length) {
          return "";
        }
        if (end === void 0 || end > this.length) {
          end = this.length;
        }
        if (end <= 0) {
          return "";
        }
        end >>>= 0;
        start >>>= 0;
        if (end <= start) {
          return "";
        }
        if (!encoding)
          encoding = "utf8";
        while (true) {
          switch (encoding) {
            case "hex":
              return hexSlice(this, start, end);
            case "utf8":
            case "utf-8":
              return utf8Slice(this, start, end);
            case "ascii":
              return asciiSlice(this, start, end);
            case "latin1":
            case "binary":
              return latin1Slice(this, start, end);
            case "base64":
              return base64Slice(this, start, end);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return utf16leSlice(this, start, end);
            default:
              if (loweredCase)
                throw new TypeError("Unknown encoding: " + encoding);
              encoding = (encoding + "").toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer2.prototype._isBuffer = true;
      function swap(b2, n2, m3) {
        var i3 = b2[n2];
        b2[n2] = b2[m3];
        b2[m3] = i3;
      }
      Buffer2.prototype.swap16 = function swap16() {
        var len = this.length;
        if (len % 2 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        }
        for (var i3 = 0; i3 < len; i3 += 2) {
          swap(this, i3, i3 + 1);
        }
        return this;
      };
      Buffer2.prototype.swap32 = function swap32() {
        var len = this.length;
        if (len % 4 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        }
        for (var i3 = 0; i3 < len; i3 += 4) {
          swap(this, i3, i3 + 3);
          swap(this, i3 + 1, i3 + 2);
        }
        return this;
      };
      Buffer2.prototype.swap64 = function swap64() {
        var len = this.length;
        if (len % 8 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        }
        for (var i3 = 0; i3 < len; i3 += 8) {
          swap(this, i3, i3 + 7);
          swap(this, i3 + 1, i3 + 6);
          swap(this, i3 + 2, i3 + 5);
          swap(this, i3 + 3, i3 + 4);
        }
        return this;
      };
      Buffer2.prototype.toString = function toString() {
        var length = this.length;
        if (length === 0)
          return "";
        if (arguments.length === 0)
          return utf8Slice(this, 0, length);
        return slowToString.apply(this, arguments);
      };
      Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
      Buffer2.prototype.equals = function equals(b2) {
        if (!Buffer2.isBuffer(b2))
          throw new TypeError("Argument must be a Buffer");
        if (this === b2)
          return true;
        return Buffer2.compare(this, b2) === 0;
      };
      Buffer2.prototype.inspect = function inspect4() {
        var str = "";
        var max = exports.INSPECT_MAX_BYTES;
        str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
        if (this.length > max)
          str += " ... ";
        return "<Buffer " + str + ">";
      };
      if (customInspectSymbol) {
        Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
      }
      Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
        if (isInstance(target, Uint8Array)) {
          target = Buffer2.from(target, target.offset, target.byteLength);
        }
        if (!Buffer2.isBuffer(target)) {
          throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
        }
        if (start === void 0) {
          start = 0;
        }
        if (end === void 0) {
          end = target ? target.length : 0;
        }
        if (thisStart === void 0) {
          thisStart = 0;
        }
        if (thisEnd === void 0) {
          thisEnd = this.length;
        }
        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
          throw new RangeError("out of range index");
        }
        if (thisStart >= thisEnd && start >= end) {
          return 0;
        }
        if (thisStart >= thisEnd) {
          return -1;
        }
        if (start >= end) {
          return 1;
        }
        start >>>= 0;
        end >>>= 0;
        thisStart >>>= 0;
        thisEnd >>>= 0;
        if (this === target)
          return 0;
        var x3 = thisEnd - thisStart;
        var y3 = end - start;
        var len = Math.min(x3, y3);
        var thisCopy = this.slice(thisStart, thisEnd);
        var targetCopy = target.slice(start, end);
        for (var i3 = 0; i3 < len; ++i3) {
          if (thisCopy[i3] !== targetCopy[i3]) {
            x3 = thisCopy[i3];
            y3 = targetCopy[i3];
            break;
          }
        }
        if (x3 < y3)
          return -1;
        if (y3 < x3)
          return 1;
        return 0;
      };
      function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
        if (buffer.length === 0)
          return -1;
        if (typeof byteOffset === "string") {
          encoding = byteOffset;
          byteOffset = 0;
        } else if (byteOffset > 2147483647) {
          byteOffset = 2147483647;
        } else if (byteOffset < -2147483648) {
          byteOffset = -2147483648;
        }
        byteOffset = +byteOffset;
        if (numberIsNaN(byteOffset)) {
          byteOffset = dir ? 0 : buffer.length - 1;
        }
        if (byteOffset < 0)
          byteOffset = buffer.length + byteOffset;
        if (byteOffset >= buffer.length) {
          if (dir)
            return -1;
          else
            byteOffset = buffer.length - 1;
        } else if (byteOffset < 0) {
          if (dir)
            byteOffset = 0;
          else
            return -1;
        }
        if (typeof val === "string") {
          val = Buffer2.from(val, encoding);
        }
        if (Buffer2.isBuffer(val)) {
          if (val.length === 0) {
            return -1;
          }
          return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
        } else if (typeof val === "number") {
          val = val & 255;
          if (typeof Uint8Array.prototype.indexOf === "function") {
            if (dir) {
              return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            } else {
              return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
            }
          }
          return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
        }
        throw new TypeError("val must be string, number or Buffer");
      }
      function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
        var indexSize = 1;
        var arrLength = arr.length;
        var valLength = val.length;
        if (encoding !== void 0) {
          encoding = String(encoding).toLowerCase();
          if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
            if (arr.length < 2 || val.length < 2) {
              return -1;
            }
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
          }
        }
        function read(buf, i4) {
          if (indexSize === 1) {
            return buf[i4];
          } else {
            return buf.readUInt16BE(i4 * indexSize);
          }
        }
        var i3;
        if (dir) {
          var foundIndex = -1;
          for (i3 = byteOffset; i3 < arrLength; i3++) {
            if (read(arr, i3) === read(val, foundIndex === -1 ? 0 : i3 - foundIndex)) {
              if (foundIndex === -1)
                foundIndex = i3;
              if (i3 - foundIndex + 1 === valLength)
                return foundIndex * indexSize;
            } else {
              if (foundIndex !== -1)
                i3 -= i3 - foundIndex;
              foundIndex = -1;
            }
          }
        } else {
          if (byteOffset + valLength > arrLength)
            byteOffset = arrLength - valLength;
          for (i3 = byteOffset; i3 >= 0; i3--) {
            var found = true;
            for (var j3 = 0; j3 < valLength; j3++) {
              if (read(arr, i3 + j3) !== read(val, j3)) {
                found = false;
                break;
              }
            }
            if (found)
              return i3;
          }
        }
        return -1;
      }
      Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
        return this.indexOf(val, byteOffset, encoding) !== -1;
      };
      Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
      };
      Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
      };
      function hexWrite(buf, string, offset, length) {
        offset = Number(offset) || 0;
        var remaining = buf.length - offset;
        if (!length) {
          length = remaining;
        } else {
          length = Number(length);
          if (length > remaining) {
            length = remaining;
          }
        }
        var strLen = string.length;
        if (length > strLen / 2) {
          length = strLen / 2;
        }
        for (var i3 = 0; i3 < length; ++i3) {
          var parsed = parseInt(string.substr(i3 * 2, 2), 16);
          if (numberIsNaN(parsed))
            return i3;
          buf[offset + i3] = parsed;
        }
        return i3;
      }
      function utf8Write(buf, string, offset, length) {
        return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
      }
      function asciiWrite(buf, string, offset, length) {
        return blitBuffer(asciiToBytes(string), buf, offset, length);
      }
      function base64Write(buf, string, offset, length) {
        return blitBuffer(base64ToBytes(string), buf, offset, length);
      }
      function ucs2Write(buf, string, offset, length) {
        return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
      }
      Buffer2.prototype.write = function write(string, offset, length, encoding) {
        if (offset === void 0) {
          encoding = "utf8";
          length = this.length;
          offset = 0;
        } else if (length === void 0 && typeof offset === "string") {
          encoding = offset;
          length = this.length;
          offset = 0;
        } else if (isFinite(offset)) {
          offset = offset >>> 0;
          if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === void 0)
              encoding = "utf8";
          } else {
            encoding = length;
            length = void 0;
          }
        } else {
          throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
        }
        var remaining = this.length - offset;
        if (length === void 0 || length > remaining)
          length = remaining;
        if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
          throw new RangeError("Attempt to write outside buffer bounds");
        }
        if (!encoding)
          encoding = "utf8";
        var loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "hex":
              return hexWrite(this, string, offset, length);
            case "utf8":
            case "utf-8":
              return utf8Write(this, string, offset, length);
            case "ascii":
            case "latin1":
            case "binary":
              return asciiWrite(this, string, offset, length);
            case "base64":
              return base64Write(this, string, offset, length);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return ucs2Write(this, string, offset, length);
            default:
              if (loweredCase)
                throw new TypeError("Unknown encoding: " + encoding);
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      };
      Buffer2.prototype.toJSON = function toJSON2() {
        return {
          type: "Buffer",
          data: Array.prototype.slice.call(this._arr || this, 0)
        };
      };
      function base64Slice(buf, start, end) {
        if (start === 0 && end === buf.length) {
          return base64.fromByteArray(buf);
        } else {
          return base64.fromByteArray(buf.slice(start, end));
        }
      }
      function utf8Slice(buf, start, end) {
        end = Math.min(buf.length, end);
        var res = [];
        var i3 = start;
        while (i3 < end) {
          var firstByte = buf[i3];
          var codePoint = null;
          var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
          if (i3 + bytesPerSequence <= end) {
            var secondByte, thirdByte, fourthByte, tempCodePoint;
            switch (bytesPerSequence) {
              case 1:
                if (firstByte < 128) {
                  codePoint = firstByte;
                }
                break;
              case 2:
                secondByte = buf[i3 + 1];
                if ((secondByte & 192) === 128) {
                  tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                  if (tempCodePoint > 127) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 3:
                secondByte = buf[i3 + 1];
                thirdByte = buf[i3 + 2];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                  if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 4:
                secondByte = buf[i3 + 1];
                thirdByte = buf[i3 + 2];
                fourthByte = buf[i3 + 3];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                  if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                    codePoint = tempCodePoint;
                  }
                }
            }
          }
          if (codePoint === null) {
            codePoint = 65533;
            bytesPerSequence = 1;
          } else if (codePoint > 65535) {
            codePoint -= 65536;
            res.push(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
          }
          res.push(codePoint);
          i3 += bytesPerSequence;
        }
        return decodeCodePointsArray(res);
      }
      var MAX_ARGUMENTS_LENGTH = 4096;
      function decodeCodePointsArray(codePoints) {
        var len = codePoints.length;
        if (len <= MAX_ARGUMENTS_LENGTH) {
          return String.fromCharCode.apply(String, codePoints);
        }
        var res = "";
        var i3 = 0;
        while (i3 < len) {
          res += String.fromCharCode.apply(String, codePoints.slice(i3, i3 += MAX_ARGUMENTS_LENGTH));
        }
        return res;
      }
      function asciiSlice(buf, start, end) {
        var ret = "";
        end = Math.min(buf.length, end);
        for (var i3 = start; i3 < end; ++i3) {
          ret += String.fromCharCode(buf[i3] & 127);
        }
        return ret;
      }
      function latin1Slice(buf, start, end) {
        var ret = "";
        end = Math.min(buf.length, end);
        for (var i3 = start; i3 < end; ++i3) {
          ret += String.fromCharCode(buf[i3]);
        }
        return ret;
      }
      function hexSlice(buf, start, end) {
        var len = buf.length;
        if (!start || start < 0)
          start = 0;
        if (!end || end < 0 || end > len)
          end = len;
        var out = "";
        for (var i3 = start; i3 < end; ++i3) {
          out += hexSliceLookupTable[buf[i3]];
        }
        return out;
      }
      function utf16leSlice(buf, start, end) {
        var bytes = buf.slice(start, end);
        var res = "";
        for (var i3 = 0; i3 < bytes.length - 1; i3 += 2) {
          res += String.fromCharCode(bytes[i3] + bytes[i3 + 1] * 256);
        }
        return res;
      }
      Buffer2.prototype.slice = function slice(start, end) {
        var len = this.length;
        start = ~~start;
        end = end === void 0 ? len : ~~end;
        if (start < 0) {
          start += len;
          if (start < 0)
            start = 0;
        } else if (start > len) {
          start = len;
        }
        if (end < 0) {
          end += len;
          if (end < 0)
            end = 0;
        } else if (end > len) {
          end = len;
        }
        if (end < start)
          end = start;
        var newBuf = this.subarray(start, end);
        Object.setPrototypeOf(newBuf, Buffer2.prototype);
        return newBuf;
      };
      function checkOffset(offset, ext, length) {
        if (offset % 1 !== 0 || offset < 0)
          throw new RangeError("offset is not uint");
        if (offset + ext > length)
          throw new RangeError("Trying to access beyond buffer length");
      }
      Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        var val = this[offset];
        var mul3 = 1;
        var i3 = 0;
        while (++i3 < byteLength2 && (mul3 *= 256)) {
          val += this[offset + i3] * mul3;
        }
        return val;
      };
      Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          checkOffset(offset, byteLength2, this.length);
        }
        var val = this[offset + --byteLength2];
        var mul3 = 1;
        while (byteLength2 > 0 && (mul3 *= 256)) {
          val += this[offset + --byteLength2] * mul3;
        }
        return val;
      };
      Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 1, this.length);
        return this[offset];
      };
      Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        return this[offset] | this[offset + 1] << 8;
      };
      Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        return this[offset] << 8 | this[offset + 1];
      };
      Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
      };
      Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
      };
      Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        var val = this[offset];
        var mul3 = 1;
        var i3 = 0;
        while (++i3 < byteLength2 && (mul3 *= 256)) {
          val += this[offset + i3] * mul3;
        }
        mul3 *= 128;
        if (val >= mul3)
          val -= Math.pow(2, 8 * byteLength2);
        return val;
      };
      Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        var i3 = byteLength2;
        var mul3 = 1;
        var val = this[offset + --i3];
        while (i3 > 0 && (mul3 *= 256)) {
          val += this[offset + --i3] * mul3;
        }
        mul3 *= 128;
        if (val >= mul3)
          val -= Math.pow(2, 8 * byteLength2);
        return val;
      };
      Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 1, this.length);
        if (!(this[offset] & 128))
          return this[offset];
        return (255 - this[offset] + 1) * -1;
      };
      Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        var val = this[offset] | this[offset + 1] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        var val = this[offset + 1] | this[offset] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
      };
      Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
      };
      Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return ieee754.read(this, offset, true, 23, 4);
      };
      Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return ieee754.read(this, offset, false, 23, 4);
      };
      Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 8, this.length);
        return ieee754.read(this, offset, true, 52, 8);
      };
      Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 8, this.length);
        return ieee754.read(this, offset, false, 52, 8);
      };
      function checkInt(buf, value, offset, ext, max, min) {
        if (!Buffer2.isBuffer(buf))
          throw new TypeError('"buffer" argument must be a Buffer instance');
        if (value > max || value < min)
          throw new RangeError('"value" argument is out of bounds');
        if (offset + ext > buf.length)
          throw new RangeError("Index out of range");
      }
      Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }
        var mul3 = 1;
        var i3 = 0;
        this[offset] = value & 255;
        while (++i3 < byteLength2 && (mul3 *= 256)) {
          this[offset + i3] = value / mul3 & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }
        var i3 = byteLength2 - 1;
        var mul3 = 1;
        this[offset + i3] = value & 255;
        while (--i3 >= 0 && (mul3 *= 256)) {
          this[offset + i3] = value / mul3 & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 1, 255, 0);
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };
      Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };
      Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset + 3] = value >>> 24;
        this[offset + 2] = value >>> 16;
        this[offset + 1] = value >>> 8;
        this[offset] = value & 255;
        return offset + 4;
      };
      Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };
      Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          var limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset, byteLength2, limit - 1, -limit);
        }
        var i3 = 0;
        var mul3 = 1;
        var sub = 0;
        this[offset] = value & 255;
        while (++i3 < byteLength2 && (mul3 *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i3 - 1] !== 0) {
            sub = 1;
          }
          this[offset + i3] = (value / mul3 >> 0) - sub & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          var limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset, byteLength2, limit - 1, -limit);
        }
        var i3 = byteLength2 - 1;
        var mul3 = 1;
        var sub = 0;
        this[offset + i3] = value & 255;
        while (--i3 >= 0 && (mul3 *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i3 + 1] !== 0) {
            sub = 1;
          }
          this[offset + i3] = (value / mul3 >> 0) - sub & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 1, 127, -128);
        if (value < 0)
          value = 255 + value + 1;
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };
      Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };
      Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 2147483647, -2147483648);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        this[offset + 2] = value >>> 16;
        this[offset + 3] = value >>> 24;
        return offset + 4;
      };
      Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 2147483647, -2147483648);
        if (value < 0)
          value = 4294967295 + value + 1;
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };
      function checkIEEE754(buf, value, offset, ext, max, min) {
        if (offset + ext > buf.length)
          throw new RangeError("Index out of range");
        if (offset < 0)
          throw new RangeError("Index out of range");
      }
      function writeFloat(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
        }
        ieee754.write(buf, value, offset, littleEndian, 23, 4);
        return offset + 4;
      }
      Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
        return writeFloat(this, value, offset, true, noAssert);
      };
      Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
        return writeFloat(this, value, offset, false, noAssert);
      };
      function writeDouble(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
        }
        ieee754.write(buf, value, offset, littleEndian, 52, 8);
        return offset + 8;
      }
      Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
        return writeDouble(this, value, offset, true, noAssert);
      };
      Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
        return writeDouble(this, value, offset, false, noAssert);
      };
      Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
        if (!Buffer2.isBuffer(target))
          throw new TypeError("argument should be a Buffer");
        if (!start)
          start = 0;
        if (!end && end !== 0)
          end = this.length;
        if (targetStart >= target.length)
          targetStart = target.length;
        if (!targetStart)
          targetStart = 0;
        if (end > 0 && end < start)
          end = start;
        if (end === start)
          return 0;
        if (target.length === 0 || this.length === 0)
          return 0;
        if (targetStart < 0) {
          throw new RangeError("targetStart out of bounds");
        }
        if (start < 0 || start >= this.length)
          throw new RangeError("Index out of range");
        if (end < 0)
          throw new RangeError("sourceEnd out of bounds");
        if (end > this.length)
          end = this.length;
        if (target.length - targetStart < end - start) {
          end = target.length - targetStart + start;
        }
        var len = end - start;
        if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
          this.copyWithin(targetStart, start, end);
        } else {
          Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
        }
        return len;
      };
      Buffer2.prototype.fill = function fill(val, start, end, encoding) {
        if (typeof val === "string") {
          if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
          } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
          }
          if (encoding !== void 0 && typeof encoding !== "string") {
            throw new TypeError("encoding must be a string");
          }
          if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
            throw new TypeError("Unknown encoding: " + encoding);
          }
          if (val.length === 1) {
            var code = val.charCodeAt(0);
            if (encoding === "utf8" && code < 128 || encoding === "latin1") {
              val = code;
            }
          }
        } else if (typeof val === "number") {
          val = val & 255;
        } else if (typeof val === "boolean") {
          val = Number(val);
        }
        if (start < 0 || this.length < start || this.length < end) {
          throw new RangeError("Out of range index");
        }
        if (end <= start) {
          return this;
        }
        start = start >>> 0;
        end = end === void 0 ? this.length : end >>> 0;
        if (!val)
          val = 0;
        var i3;
        if (typeof val === "number") {
          for (i3 = start; i3 < end; ++i3) {
            this[i3] = val;
          }
        } else {
          var bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
          var len = bytes.length;
          if (len === 0) {
            throw new TypeError('The value "' + val + '" is invalid for argument "value"');
          }
          for (i3 = 0; i3 < end - start; ++i3) {
            this[i3 + start] = bytes[i3 % len];
          }
        }
        return this;
      };
      var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
      function base64clean(str) {
        str = str.split("=")[0];
        str = str.trim().replace(INVALID_BASE64_RE, "");
        if (str.length < 2)
          return "";
        while (str.length % 4 !== 0) {
          str = str + "=";
        }
        return str;
      }
      function utf8ToBytes(string, units) {
        units = units || Infinity;
        var codePoint;
        var length = string.length;
        var leadSurrogate = null;
        var bytes = [];
        for (var i3 = 0; i3 < length; ++i3) {
          codePoint = string.charCodeAt(i3);
          if (codePoint > 55295 && codePoint < 57344) {
            if (!leadSurrogate) {
              if (codePoint > 56319) {
                if ((units -= 3) > -1)
                  bytes.push(239, 191, 189);
                continue;
              } else if (i3 + 1 === length) {
                if ((units -= 3) > -1)
                  bytes.push(239, 191, 189);
                continue;
              }
              leadSurrogate = codePoint;
              continue;
            }
            if (codePoint < 56320) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              leadSurrogate = codePoint;
              continue;
            }
            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
          } else if (leadSurrogate) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
          }
          leadSurrogate = null;
          if (codePoint < 128) {
            if ((units -= 1) < 0)
              break;
            bytes.push(codePoint);
          } else if (codePoint < 2048) {
            if ((units -= 2) < 0)
              break;
            bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
          } else if (codePoint < 65536) {
            if ((units -= 3) < 0)
              break;
            bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
          } else if (codePoint < 1114112) {
            if ((units -= 4) < 0)
              break;
            bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
          } else {
            throw new Error("Invalid code point");
          }
        }
        return bytes;
      }
      function asciiToBytes(str) {
        var byteArray = [];
        for (var i3 = 0; i3 < str.length; ++i3) {
          byteArray.push(str.charCodeAt(i3) & 255);
        }
        return byteArray;
      }
      function utf16leToBytes(str, units) {
        var c3, hi, lo;
        var byteArray = [];
        for (var i3 = 0; i3 < str.length; ++i3) {
          if ((units -= 2) < 0)
            break;
          c3 = str.charCodeAt(i3);
          hi = c3 >> 8;
          lo = c3 % 256;
          byteArray.push(lo);
          byteArray.push(hi);
        }
        return byteArray;
      }
      function base64ToBytes(str) {
        return base64.toByteArray(base64clean(str));
      }
      function blitBuffer(src, dst, offset, length) {
        for (var i3 = 0; i3 < length; ++i3) {
          if (i3 + offset >= dst.length || i3 >= src.length)
            break;
          dst[i3 + offset] = src[i3];
        }
        return i3;
      }
      function isInstance(obj, type) {
        return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
      }
      function numberIsNaN(obj) {
        return obj !== obj;
      }
      var hexSliceLookupTable = function() {
        var alphabet = "0123456789abcdef";
        var table = new Array(256);
        for (var i3 = 0; i3 < 16; ++i3) {
          var i16 = i3 * 16;
          for (var j3 = 0; j3 < 16; ++j3) {
            table[i16 + j3] = alphabet[i3] + alphabet[j3];
          }
        }
        return table;
      }();
    }
  });

  // node_modules/qrcode/lib/core/reed-solomon-encoder.js
  var require_reed_solomon_encoder = __commonJS({
    "node_modules/qrcode/lib/core/reed-solomon-encoder.js"(exports, module) {
      var BufferUtil = require_typedarray_buffer();
      var Polynomial = require_polynomial();
      var Buffer2 = require_buffer2().Buffer;
      function ReedSolomonEncoder(degree) {
        this.genPoly = void 0;
        this.degree = degree;
        if (this.degree)
          this.initialize(this.degree);
      }
      ReedSolomonEncoder.prototype.initialize = function initialize(degree) {
        this.degree = degree;
        this.genPoly = Polynomial.generateECPolynomial(this.degree);
      };
      ReedSolomonEncoder.prototype.encode = function encode4(data4) {
        if (!this.genPoly) {
          throw new Error("Encoder not initialized");
        }
        var pad = BufferUtil.alloc(this.degree);
        var paddedData = Buffer2.concat([data4, pad], data4.length + this.degree);
        var remainder = Polynomial.mod(paddedData, this.genPoly);
        var start = this.degree - remainder.length;
        if (start > 0) {
          var buff = BufferUtil.alloc(this.degree);
          remainder.copy(buff, start);
          return buff;
        }
        return remainder;
      };
      module.exports = ReedSolomonEncoder;
    }
  });

  // node_modules/qrcode/lib/core/version-check.js
  var require_version_check = __commonJS({
    "node_modules/qrcode/lib/core/version-check.js"(exports) {
      exports.isValid = function isValid(version26) {
        return !isNaN(version26) && version26 >= 1 && version26 <= 40;
      };
    }
  });

  // node_modules/qrcode/lib/core/regex.js
  var require_regex = __commonJS({
    "node_modules/qrcode/lib/core/regex.js"(exports) {
      var numeric = "[0-9]+";
      var alphanumeric = "[A-Z $%*+\\-./:]+";
      var kanji = "(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+";
      kanji = kanji.replace(/u/g, "\\u");
      var byte = "(?:(?![A-Z0-9 $%*+\\-./:]|" + kanji + ")(?:.|[\r\n]))+";
      exports.KANJI = new RegExp(kanji, "g");
      exports.BYTE_KANJI = new RegExp("[^A-Z0-9 $%*+\\-./:]+", "g");
      exports.BYTE = new RegExp(byte, "g");
      exports.NUMERIC = new RegExp(numeric, "g");
      exports.ALPHANUMERIC = new RegExp(alphanumeric, "g");
      var TEST_KANJI = new RegExp("^" + kanji + "$");
      var TEST_NUMERIC = new RegExp("^" + numeric + "$");
      var TEST_ALPHANUMERIC = new RegExp("^[A-Z0-9 $%*+\\-./:]+$");
      exports.testKanji = function testKanji(str) {
        return TEST_KANJI.test(str);
      };
      exports.testNumeric = function testNumeric(str) {
        return TEST_NUMERIC.test(str);
      };
      exports.testAlphanumeric = function testAlphanumeric(str) {
        return TEST_ALPHANUMERIC.test(str);
      };
    }
  });

  // node_modules/qrcode/lib/core/mode.js
  var require_mode = __commonJS({
    "node_modules/qrcode/lib/core/mode.js"(exports) {
      var VersionCheck = require_version_check();
      var Regex = require_regex();
      exports.NUMERIC = {
        id: "Numeric",
        bit: 1 << 0,
        ccBits: [10, 12, 14]
      };
      exports.ALPHANUMERIC = {
        id: "Alphanumeric",
        bit: 1 << 1,
        ccBits: [9, 11, 13]
      };
      exports.BYTE = {
        id: "Byte",
        bit: 1 << 2,
        ccBits: [8, 16, 16]
      };
      exports.KANJI = {
        id: "Kanji",
        bit: 1 << 3,
        ccBits: [8, 10, 12]
      };
      exports.MIXED = {
        bit: -1
      };
      exports.getCharCountIndicator = function getCharCountIndicator(mode, version26) {
        if (!mode.ccBits)
          throw new Error("Invalid mode: " + mode);
        if (!VersionCheck.isValid(version26)) {
          throw new Error("Invalid version: " + version26);
        }
        if (version26 >= 1 && version26 < 10)
          return mode.ccBits[0];
        else if (version26 < 27)
          return mode.ccBits[1];
        return mode.ccBits[2];
      };
      exports.getBestModeForData = function getBestModeForData(dataStr) {
        if (Regex.testNumeric(dataStr))
          return exports.NUMERIC;
        else if (Regex.testAlphanumeric(dataStr))
          return exports.ALPHANUMERIC;
        else if (Regex.testKanji(dataStr))
          return exports.KANJI;
        else
          return exports.BYTE;
      };
      exports.toString = function toString(mode) {
        if (mode && mode.id)
          return mode.id;
        throw new Error("Invalid mode");
      };
      exports.isValid = function isValid(mode) {
        return mode && mode.bit && mode.ccBits;
      };
      function fromString(string) {
        if (typeof string !== "string") {
          throw new Error("Param is not a string");
        }
        var lcStr = string.toLowerCase();
        switch (lcStr) {
          case "numeric":
            return exports.NUMERIC;
          case "alphanumeric":
            return exports.ALPHANUMERIC;
          case "kanji":
            return exports.KANJI;
          case "byte":
            return exports.BYTE;
          default:
            throw new Error("Unknown mode: " + string);
        }
      }
      exports.from = function from(value, defaultValue) {
        if (exports.isValid(value)) {
          return value;
        }
        try {
          return fromString(value);
        } catch (e3) {
          return defaultValue;
        }
      };
    }
  });

  // node_modules/qrcode/lib/core/version.js
  var require_version = __commonJS({
    "node_modules/qrcode/lib/core/version.js"(exports) {
      var Utils = require_utils2();
      var ECCode = require_error_correction_code();
      var ECLevel = require_error_correction_level();
      var Mode = require_mode();
      var VersionCheck = require_version_check();
      var isArray = require_isarray();
      var G18 = 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0;
      var G18_BCH = Utils.getBCHDigit(G18);
      function getBestVersionForDataLength(mode, length, errorCorrectionLevel) {
        for (var currentVersion = 1; currentVersion <= 40; currentVersion++) {
          if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, mode)) {
            return currentVersion;
          }
        }
        return void 0;
      }
      function getReservedBitsCount(mode, version26) {
        return Mode.getCharCountIndicator(mode, version26) + 4;
      }
      function getTotalBitsFromDataArray(segments, version26) {
        var totalBits = 0;
        segments.forEach(function(data4) {
          var reservedBits = getReservedBitsCount(data4.mode, version26);
          totalBits += reservedBits + data4.getBitsLength();
        });
        return totalBits;
      }
      function getBestVersionForMixedData(segments, errorCorrectionLevel) {
        for (var currentVersion = 1; currentVersion <= 40; currentVersion++) {
          var length = getTotalBitsFromDataArray(segments, currentVersion);
          if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, Mode.MIXED)) {
            return currentVersion;
          }
        }
        return void 0;
      }
      exports.from = function from(value, defaultValue) {
        if (VersionCheck.isValid(value)) {
          return parseInt(value, 10);
        }
        return defaultValue;
      };
      exports.getCapacity = function getCapacity(version26, errorCorrectionLevel, mode) {
        if (!VersionCheck.isValid(version26)) {
          throw new Error("Invalid QR Code version");
        }
        if (typeof mode === "undefined")
          mode = Mode.BYTE;
        var totalCodewords = Utils.getSymbolTotalCodewords(version26);
        var ecTotalCodewords = ECCode.getTotalCodewordsCount(version26, errorCorrectionLevel);
        var dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
        if (mode === Mode.MIXED)
          return dataTotalCodewordsBits;
        var usableBits = dataTotalCodewordsBits - getReservedBitsCount(mode, version26);
        switch (mode) {
          case Mode.NUMERIC:
            return Math.floor(usableBits / 10 * 3);
          case Mode.ALPHANUMERIC:
            return Math.floor(usableBits / 11 * 2);
          case Mode.KANJI:
            return Math.floor(usableBits / 13);
          case Mode.BYTE:
          default:
            return Math.floor(usableBits / 8);
        }
      };
      exports.getBestVersionForData = function getBestVersionForData(data4, errorCorrectionLevel) {
        var seg;
        var ecl = ECLevel.from(errorCorrectionLevel, ECLevel.M);
        if (isArray(data4)) {
          if (data4.length > 1) {
            return getBestVersionForMixedData(data4, ecl);
          }
          if (data4.length === 0) {
            return 1;
          }
          seg = data4[0];
        } else {
          seg = data4;
        }
        return getBestVersionForDataLength(seg.mode, seg.getLength(), ecl);
      };
      exports.getEncodedBits = function getEncodedBits(version26) {
        if (!VersionCheck.isValid(version26) || version26 < 7) {
          throw new Error("Invalid QR Code version");
        }
        var d3 = version26 << 12;
        while (Utils.getBCHDigit(d3) - G18_BCH >= 0) {
          d3 ^= G18 << Utils.getBCHDigit(d3) - G18_BCH;
        }
        return version26 << 12 | d3;
      };
    }
  });

  // node_modules/qrcode/lib/core/format-info.js
  var require_format_info = __commonJS({
    "node_modules/qrcode/lib/core/format-info.js"(exports) {
      var Utils = require_utils2();
      var G15 = 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0;
      var G15_MASK = 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1;
      var G15_BCH = Utils.getBCHDigit(G15);
      exports.getEncodedBits = function getEncodedBits(errorCorrectionLevel, mask) {
        var data4 = errorCorrectionLevel.bit << 3 | mask;
        var d3 = data4 << 10;
        while (Utils.getBCHDigit(d3) - G15_BCH >= 0) {
          d3 ^= G15 << Utils.getBCHDigit(d3) - G15_BCH;
        }
        return (data4 << 10 | d3) ^ G15_MASK;
      };
    }
  });

  // node_modules/qrcode/lib/core/numeric-data.js
  var require_numeric_data = __commonJS({
    "node_modules/qrcode/lib/core/numeric-data.js"(exports, module) {
      var Mode = require_mode();
      function NumericData(data4) {
        this.mode = Mode.NUMERIC;
        this.data = data4.toString();
      }
      NumericData.getBitsLength = function getBitsLength(length) {
        return 10 * Math.floor(length / 3) + (length % 3 ? length % 3 * 3 + 1 : 0);
      };
      NumericData.prototype.getLength = function getLength2() {
        return this.data.length;
      };
      NumericData.prototype.getBitsLength = function getBitsLength() {
        return NumericData.getBitsLength(this.data.length);
      };
      NumericData.prototype.write = function write(bitBuffer) {
        var i3, group, value;
        for (i3 = 0; i3 + 3 <= this.data.length; i3 += 3) {
          group = this.data.substr(i3, 3);
          value = parseInt(group, 10);
          bitBuffer.put(value, 10);
        }
        var remainingNum = this.data.length - i3;
        if (remainingNum > 0) {
          group = this.data.substr(i3);
          value = parseInt(group, 10);
          bitBuffer.put(value, remainingNum * 3 + 1);
        }
      };
      module.exports = NumericData;
    }
  });

  // node_modules/qrcode/lib/core/alphanumeric-data.js
  var require_alphanumeric_data = __commonJS({
    "node_modules/qrcode/lib/core/alphanumeric-data.js"(exports, module) {
      var Mode = require_mode();
      var ALPHA_NUM_CHARS = [
        "0",
        "1",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        "8",
        "9",
        "A",
        "B",
        "C",
        "D",
        "E",
        "F",
        "G",
        "H",
        "I",
        "J",
        "K",
        "L",
        "M",
        "N",
        "O",
        "P",
        "Q",
        "R",
        "S",
        "T",
        "U",
        "V",
        "W",
        "X",
        "Y",
        "Z",
        " ",
        "$",
        "%",
        "*",
        "+",
        "-",
        ".",
        "/",
        ":"
      ];
      function AlphanumericData(data4) {
        this.mode = Mode.ALPHANUMERIC;
        this.data = data4;
      }
      AlphanumericData.getBitsLength = function getBitsLength(length) {
        return 11 * Math.floor(length / 2) + 6 * (length % 2);
      };
      AlphanumericData.prototype.getLength = function getLength2() {
        return this.data.length;
      };
      AlphanumericData.prototype.getBitsLength = function getBitsLength() {
        return AlphanumericData.getBitsLength(this.data.length);
      };
      AlphanumericData.prototype.write = function write(bitBuffer) {
        var i3;
        for (i3 = 0; i3 + 2 <= this.data.length; i3 += 2) {
          var value = ALPHA_NUM_CHARS.indexOf(this.data[i3]) * 45;
          value += ALPHA_NUM_CHARS.indexOf(this.data[i3 + 1]);
          bitBuffer.put(value, 11);
        }
        if (this.data.length % 2) {
          bitBuffer.put(ALPHA_NUM_CHARS.indexOf(this.data[i3]), 6);
        }
      };
      module.exports = AlphanumericData;
    }
  });

  // node_modules/qrcode/lib/core/byte-data.js
  var require_byte_data = __commonJS({
    "node_modules/qrcode/lib/core/byte-data.js"(exports, module) {
      var BufferUtil = require_typedarray_buffer();
      var Mode = require_mode();
      function ByteData(data4) {
        this.mode = Mode.BYTE;
        this.data = BufferUtil.from(data4);
      }
      ByteData.getBitsLength = function getBitsLength(length) {
        return length * 8;
      };
      ByteData.prototype.getLength = function getLength2() {
        return this.data.length;
      };
      ByteData.prototype.getBitsLength = function getBitsLength() {
        return ByteData.getBitsLength(this.data.length);
      };
      ByteData.prototype.write = function(bitBuffer) {
        for (var i3 = 0, l3 = this.data.length; i3 < l3; i3++) {
          bitBuffer.put(this.data[i3], 8);
        }
      };
      module.exports = ByteData;
    }
  });

  // node_modules/qrcode/lib/core/kanji-data.js
  var require_kanji_data = __commonJS({
    "node_modules/qrcode/lib/core/kanji-data.js"(exports, module) {
      var Mode = require_mode();
      var Utils = require_utils2();
      function KanjiData(data4) {
        this.mode = Mode.KANJI;
        this.data = data4;
      }
      KanjiData.getBitsLength = function getBitsLength(length) {
        return length * 13;
      };
      KanjiData.prototype.getLength = function getLength2() {
        return this.data.length;
      };
      KanjiData.prototype.getBitsLength = function getBitsLength() {
        return KanjiData.getBitsLength(this.data.length);
      };
      KanjiData.prototype.write = function(bitBuffer) {
        var i3;
        for (i3 = 0; i3 < this.data.length; i3++) {
          var value = Utils.toSJIS(this.data[i3]);
          if (value >= 33088 && value <= 40956) {
            value -= 33088;
          } else if (value >= 57408 && value <= 60351) {
            value -= 49472;
          } else {
            throw new Error("Invalid SJIS character: " + this.data[i3] + "\nMake sure your charset is UTF-8");
          }
          value = (value >>> 8 & 255) * 192 + (value & 255);
          bitBuffer.put(value, 13);
        }
      };
      module.exports = KanjiData;
    }
  });

  // node_modules/dijkstrajs/dijkstra.js
  var require_dijkstra = __commonJS({
    "node_modules/dijkstrajs/dijkstra.js"(exports, module) {
      "use strict";
      var dijkstra = {
        single_source_shortest_paths: function(graph, s3, d3) {
          var predecessors = {};
          var costs = {};
          costs[s3] = 0;
          var open = dijkstra.PriorityQueue.make();
          open.push(s3, 0);
          var closest, u3, v3, cost_of_s_to_u, adjacent_nodes, cost_of_e, cost_of_s_to_u_plus_cost_of_e, cost_of_s_to_v, first_visit;
          while (!open.empty()) {
            closest = open.pop();
            u3 = closest.value;
            cost_of_s_to_u = closest.cost;
            adjacent_nodes = graph[u3] || {};
            for (v3 in adjacent_nodes) {
              if (adjacent_nodes.hasOwnProperty(v3)) {
                cost_of_e = adjacent_nodes[v3];
                cost_of_s_to_u_plus_cost_of_e = cost_of_s_to_u + cost_of_e;
                cost_of_s_to_v = costs[v3];
                first_visit = typeof costs[v3] === "undefined";
                if (first_visit || cost_of_s_to_v > cost_of_s_to_u_plus_cost_of_e) {
                  costs[v3] = cost_of_s_to_u_plus_cost_of_e;
                  open.push(v3, cost_of_s_to_u_plus_cost_of_e);
                  predecessors[v3] = u3;
                }
              }
            }
          }
          if (typeof d3 !== "undefined" && typeof costs[d3] === "undefined") {
            var msg = ["Could not find a path from ", s3, " to ", d3, "."].join("");
            throw new Error(msg);
          }
          return predecessors;
        },
        extract_shortest_path_from_predecessor_list: function(predecessors, d3) {
          var nodes = [];
          var u3 = d3;
          var predecessor;
          while (u3) {
            nodes.push(u3);
            predecessor = predecessors[u3];
            u3 = predecessors[u3];
          }
          nodes.reverse();
          return nodes;
        },
        find_path: function(graph, s3, d3) {
          var predecessors = dijkstra.single_source_shortest_paths(graph, s3, d3);
          return dijkstra.extract_shortest_path_from_predecessor_list(predecessors, d3);
        },
        PriorityQueue: {
          make: function(opts) {
            var T4 = dijkstra.PriorityQueue, t3 = {}, key2;
            opts = opts || {};
            for (key2 in T4) {
              if (T4.hasOwnProperty(key2)) {
                t3[key2] = T4[key2];
              }
            }
            t3.queue = [];
            t3.sorter = opts.sorter || T4.default_sorter;
            return t3;
          },
          default_sorter: function(a3, b2) {
            return a3.cost - b2.cost;
          },
          push: function(value, cost) {
            var item = { value, cost };
            this.queue.push(item);
            this.queue.sort(this.sorter);
          },
          pop: function() {
            return this.queue.shift();
          },
          empty: function() {
            return this.queue.length === 0;
          }
        }
      };
      if (typeof module !== "undefined") {
        module.exports = dijkstra;
      }
    }
  });

  // node_modules/qrcode/lib/core/segments.js
  var require_segments = __commonJS({
    "node_modules/qrcode/lib/core/segments.js"(exports) {
      var Mode = require_mode();
      var NumericData = require_numeric_data();
      var AlphanumericData = require_alphanumeric_data();
      var ByteData = require_byte_data();
      var KanjiData = require_kanji_data();
      var Regex = require_regex();
      var Utils = require_utils2();
      var dijkstra = require_dijkstra();
      function getStringByteLength(str) {
        return unescape(encodeURIComponent(str)).length;
      }
      function getSegments(regex, mode, str) {
        var segments = [];
        var result;
        while ((result = regex.exec(str)) !== null) {
          segments.push({
            data: result[0],
            index: result.index,
            mode,
            length: result[0].length
          });
        }
        return segments;
      }
      function getSegmentsFromString(dataStr) {
        var numSegs = getSegments(Regex.NUMERIC, Mode.NUMERIC, dataStr);
        var alphaNumSegs = getSegments(Regex.ALPHANUMERIC, Mode.ALPHANUMERIC, dataStr);
        var byteSegs;
        var kanjiSegs;
        if (Utils.isKanjiModeEnabled()) {
          byteSegs = getSegments(Regex.BYTE, Mode.BYTE, dataStr);
          kanjiSegs = getSegments(Regex.KANJI, Mode.KANJI, dataStr);
        } else {
          byteSegs = getSegments(Regex.BYTE_KANJI, Mode.BYTE, dataStr);
          kanjiSegs = [];
        }
        var segs = numSegs.concat(alphaNumSegs, byteSegs, kanjiSegs);
        return segs.sort(function(s1, s22) {
          return s1.index - s22.index;
        }).map(function(obj) {
          return {
            data: obj.data,
            mode: obj.mode,
            length: obj.length
          };
        });
      }
      function getSegmentBitsLength(length, mode) {
        switch (mode) {
          case Mode.NUMERIC:
            return NumericData.getBitsLength(length);
          case Mode.ALPHANUMERIC:
            return AlphanumericData.getBitsLength(length);
          case Mode.KANJI:
            return KanjiData.getBitsLength(length);
          case Mode.BYTE:
            return ByteData.getBitsLength(length);
        }
      }
      function mergeSegments(segs) {
        return segs.reduce(function(acc, curr) {
          var prevSeg = acc.length - 1 >= 0 ? acc[acc.length - 1] : null;
          if (prevSeg && prevSeg.mode === curr.mode) {
            acc[acc.length - 1].data += curr.data;
            return acc;
          }
          acc.push(curr);
          return acc;
        }, []);
      }
      function buildNodes(segs) {
        var nodes = [];
        for (var i3 = 0; i3 < segs.length; i3++) {
          var seg = segs[i3];
          switch (seg.mode) {
            case Mode.NUMERIC:
              nodes.push([
                seg,
                { data: seg.data, mode: Mode.ALPHANUMERIC, length: seg.length },
                { data: seg.data, mode: Mode.BYTE, length: seg.length }
              ]);
              break;
            case Mode.ALPHANUMERIC:
              nodes.push([
                seg,
                { data: seg.data, mode: Mode.BYTE, length: seg.length }
              ]);
              break;
            case Mode.KANJI:
              nodes.push([
                seg,
                { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }
              ]);
              break;
            case Mode.BYTE:
              nodes.push([
                { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }
              ]);
          }
        }
        return nodes;
      }
      function buildGraph(nodes, version26) {
        var table = {};
        var graph = { "start": {} };
        var prevNodeIds = ["start"];
        for (var i3 = 0; i3 < nodes.length; i3++) {
          var nodeGroup = nodes[i3];
          var currentNodeIds = [];
          for (var j3 = 0; j3 < nodeGroup.length; j3++) {
            var node = nodeGroup[j3];
            var key2 = "" + i3 + j3;
            currentNodeIds.push(key2);
            table[key2] = { node, lastCount: 0 };
            graph[key2] = {};
            for (var n2 = 0; n2 < prevNodeIds.length; n2++) {
              var prevNodeId = prevNodeIds[n2];
              if (table[prevNodeId] && table[prevNodeId].node.mode === node.mode) {
                graph[prevNodeId][key2] = getSegmentBitsLength(table[prevNodeId].lastCount + node.length, node.mode) - getSegmentBitsLength(table[prevNodeId].lastCount, node.mode);
                table[prevNodeId].lastCount += node.length;
              } else {
                if (table[prevNodeId])
                  table[prevNodeId].lastCount = node.length;
                graph[prevNodeId][key2] = getSegmentBitsLength(node.length, node.mode) + 4 + Mode.getCharCountIndicator(node.mode, version26);
              }
            }
          }
          prevNodeIds = currentNodeIds;
        }
        for (n2 = 0; n2 < prevNodeIds.length; n2++) {
          graph[prevNodeIds[n2]]["end"] = 0;
        }
        return { map: graph, table };
      }
      function buildSingleSegment(data4, modesHint) {
        var mode;
        var bestMode = Mode.getBestModeForData(data4);
        mode = Mode.from(modesHint, bestMode);
        if (mode !== Mode.BYTE && mode.bit < bestMode.bit) {
          throw new Error('"' + data4 + '" cannot be encoded with mode ' + Mode.toString(mode) + ".\n Suggested mode is: " + Mode.toString(bestMode));
        }
        if (mode === Mode.KANJI && !Utils.isKanjiModeEnabled()) {
          mode = Mode.BYTE;
        }
        switch (mode) {
          case Mode.NUMERIC:
            return new NumericData(data4);
          case Mode.ALPHANUMERIC:
            return new AlphanumericData(data4);
          case Mode.KANJI:
            return new KanjiData(data4);
          case Mode.BYTE:
            return new ByteData(data4);
        }
      }
      exports.fromArray = function fromArray(array) {
        return array.reduce(function(acc, seg) {
          if (typeof seg === "string") {
            acc.push(buildSingleSegment(seg, null));
          } else if (seg.data) {
            acc.push(buildSingleSegment(seg.data, seg.mode));
          }
          return acc;
        }, []);
      };
      exports.fromString = function fromString(data4, version26) {
        var segs = getSegmentsFromString(data4, Utils.isKanjiModeEnabled());
        var nodes = buildNodes(segs);
        var graph = buildGraph(nodes, version26);
        var path = dijkstra.find_path(graph.map, "start", "end");
        var optimizedSegs = [];
        for (var i3 = 1; i3 < path.length - 1; i3++) {
          optimizedSegs.push(graph.table[path[i3]].node);
        }
        return exports.fromArray(mergeSegments(optimizedSegs));
      };
      exports.rawSplit = function rawSplit(data4) {
        return exports.fromArray(getSegmentsFromString(data4, Utils.isKanjiModeEnabled()));
      };
    }
  });

  // node_modules/qrcode/lib/core/qrcode.js
  var require_qrcode = __commonJS({
    "node_modules/qrcode/lib/core/qrcode.js"(exports) {
      var BufferUtil = require_typedarray_buffer();
      var Utils = require_utils2();
      var ECLevel = require_error_correction_level();
      var BitBuffer = require_bit_buffer();
      var BitMatrix = require_bit_matrix();
      var AlignmentPattern = require_alignment_pattern();
      var FinderPattern = require_finder_pattern();
      var MaskPattern = require_mask_pattern();
      var ECCode = require_error_correction_code();
      var ReedSolomonEncoder = require_reed_solomon_encoder();
      var Version = require_version();
      var FormatInfo = require_format_info();
      var Mode = require_mode();
      var Segments = require_segments();
      var isArray = require_isarray();
      function setupFinderPattern(matrix, version26) {
        var size = matrix.size;
        var pos = FinderPattern.getPositions(version26);
        for (var i3 = 0; i3 < pos.length; i3++) {
          var row = pos[i3][0];
          var col = pos[i3][1];
          for (var r3 = -1; r3 <= 7; r3++) {
            if (row + r3 <= -1 || size <= row + r3)
              continue;
            for (var c3 = -1; c3 <= 7; c3++) {
              if (col + c3 <= -1 || size <= col + c3)
                continue;
              if (r3 >= 0 && r3 <= 6 && (c3 === 0 || c3 === 6) || c3 >= 0 && c3 <= 6 && (r3 === 0 || r3 === 6) || r3 >= 2 && r3 <= 4 && c3 >= 2 && c3 <= 4) {
                matrix.set(row + r3, col + c3, true, true);
              } else {
                matrix.set(row + r3, col + c3, false, true);
              }
            }
          }
        }
      }
      function setupTimingPattern(matrix) {
        var size = matrix.size;
        for (var r3 = 8; r3 < size - 8; r3++) {
          var value = r3 % 2 === 0;
          matrix.set(r3, 6, value, true);
          matrix.set(6, r3, value, true);
        }
      }
      function setupAlignmentPattern(matrix, version26) {
        var pos = AlignmentPattern.getPositions(version26);
        for (var i3 = 0; i3 < pos.length; i3++) {
          var row = pos[i3][0];
          var col = pos[i3][1];
          for (var r3 = -2; r3 <= 2; r3++) {
            for (var c3 = -2; c3 <= 2; c3++) {
              if (r3 === -2 || r3 === 2 || c3 === -2 || c3 === 2 || r3 === 0 && c3 === 0) {
                matrix.set(row + r3, col + c3, true, true);
              } else {
                matrix.set(row + r3, col + c3, false, true);
              }
            }
          }
        }
      }
      function setupVersionInfo(matrix, version26) {
        var size = matrix.size;
        var bits = Version.getEncodedBits(version26);
        var row, col, mod;
        for (var i3 = 0; i3 < 18; i3++) {
          row = Math.floor(i3 / 3);
          col = i3 % 3 + size - 8 - 3;
          mod = (bits >> i3 & 1) === 1;
          matrix.set(row, col, mod, true);
          matrix.set(col, row, mod, true);
        }
      }
      function setupFormatInfo(matrix, errorCorrectionLevel, maskPattern) {
        var size = matrix.size;
        var bits = FormatInfo.getEncodedBits(errorCorrectionLevel, maskPattern);
        var i3, mod;
        for (i3 = 0; i3 < 15; i3++) {
          mod = (bits >> i3 & 1) === 1;
          if (i3 < 6) {
            matrix.set(i3, 8, mod, true);
          } else if (i3 < 8) {
            matrix.set(i3 + 1, 8, mod, true);
          } else {
            matrix.set(size - 15 + i3, 8, mod, true);
          }
          if (i3 < 8) {
            matrix.set(8, size - i3 - 1, mod, true);
          } else if (i3 < 9) {
            matrix.set(8, 15 - i3 - 1 + 1, mod, true);
          } else {
            matrix.set(8, 15 - i3 - 1, mod, true);
          }
        }
        matrix.set(size - 8, 8, 1, true);
      }
      function setupData(matrix, data4) {
        var size = matrix.size;
        var inc = -1;
        var row = size - 1;
        var bitIndex = 7;
        var byteIndex = 0;
        for (var col = size - 1; col > 0; col -= 2) {
          if (col === 6)
            col--;
          while (true) {
            for (var c3 = 0; c3 < 2; c3++) {
              if (!matrix.isReserved(row, col - c3)) {
                var dark = false;
                if (byteIndex < data4.length) {
                  dark = (data4[byteIndex] >>> bitIndex & 1) === 1;
                }
                matrix.set(row, col - c3, dark);
                bitIndex--;
                if (bitIndex === -1) {
                  byteIndex++;
                  bitIndex = 7;
                }
              }
            }
            row += inc;
            if (row < 0 || size <= row) {
              row -= inc;
              inc = -inc;
              break;
            }
          }
        }
      }
      function createData(version26, errorCorrectionLevel, segments) {
        var buffer = new BitBuffer();
        segments.forEach(function(data4) {
          buffer.put(data4.mode.bit, 4);
          buffer.put(data4.getLength(), Mode.getCharCountIndicator(data4.mode, version26));
          data4.write(buffer);
        });
        var totalCodewords = Utils.getSymbolTotalCodewords(version26);
        var ecTotalCodewords = ECCode.getTotalCodewordsCount(version26, errorCorrectionLevel);
        var dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
        if (buffer.getLengthInBits() + 4 <= dataTotalCodewordsBits) {
          buffer.put(0, 4);
        }
        while (buffer.getLengthInBits() % 8 !== 0) {
          buffer.putBit(0);
        }
        var remainingByte = (dataTotalCodewordsBits - buffer.getLengthInBits()) / 8;
        for (var i3 = 0; i3 < remainingByte; i3++) {
          buffer.put(i3 % 2 ? 17 : 236, 8);
        }
        return createCodewords(buffer, version26, errorCorrectionLevel);
      }
      function createCodewords(bitBuffer, version26, errorCorrectionLevel) {
        var totalCodewords = Utils.getSymbolTotalCodewords(version26);
        var ecTotalCodewords = ECCode.getTotalCodewordsCount(version26, errorCorrectionLevel);
        var dataTotalCodewords = totalCodewords - ecTotalCodewords;
        var ecTotalBlocks = ECCode.getBlocksCount(version26, errorCorrectionLevel);
        var blocksInGroup2 = totalCodewords % ecTotalBlocks;
        var blocksInGroup1 = ecTotalBlocks - blocksInGroup2;
        var totalCodewordsInGroup1 = Math.floor(totalCodewords / ecTotalBlocks);
        var dataCodewordsInGroup1 = Math.floor(dataTotalCodewords / ecTotalBlocks);
        var dataCodewordsInGroup2 = dataCodewordsInGroup1 + 1;
        var ecCount = totalCodewordsInGroup1 - dataCodewordsInGroup1;
        var rs = new ReedSolomonEncoder(ecCount);
        var offset = 0;
        var dcData = new Array(ecTotalBlocks);
        var ecData = new Array(ecTotalBlocks);
        var maxDataSize = 0;
        var buffer = BufferUtil.from(bitBuffer.buffer);
        for (var b2 = 0; b2 < ecTotalBlocks; b2++) {
          var dataSize = b2 < blocksInGroup1 ? dataCodewordsInGroup1 : dataCodewordsInGroup2;
          dcData[b2] = buffer.slice(offset, offset + dataSize);
          ecData[b2] = rs.encode(dcData[b2]);
          offset += dataSize;
          maxDataSize = Math.max(maxDataSize, dataSize);
        }
        var data4 = BufferUtil.alloc(totalCodewords);
        var index = 0;
        var i3, r3;
        for (i3 = 0; i3 < maxDataSize; i3++) {
          for (r3 = 0; r3 < ecTotalBlocks; r3++) {
            if (i3 < dcData[r3].length) {
              data4[index++] = dcData[r3][i3];
            }
          }
        }
        for (i3 = 0; i3 < ecCount; i3++) {
          for (r3 = 0; r3 < ecTotalBlocks; r3++) {
            data4[index++] = ecData[r3][i3];
          }
        }
        return data4;
      }
      function createSymbol(data4, version26, errorCorrectionLevel, maskPattern) {
        var segments;
        if (isArray(data4)) {
          segments = Segments.fromArray(data4);
        } else if (typeof data4 === "string") {
          var estimatedVersion = version26;
          if (!estimatedVersion) {
            var rawSegments = Segments.rawSplit(data4);
            estimatedVersion = Version.getBestVersionForData(rawSegments, errorCorrectionLevel);
          }
          segments = Segments.fromString(data4, estimatedVersion || 40);
        } else {
          throw new Error("Invalid data");
        }
        var bestVersion = Version.getBestVersionForData(segments, errorCorrectionLevel);
        if (!bestVersion) {
          throw new Error("The amount of data is too big to be stored in a QR Code");
        }
        if (!version26) {
          version26 = bestVersion;
        } else if (version26 < bestVersion) {
          throw new Error("\nThe chosen QR Code version cannot contain this amount of data.\nMinimum version required to store current data is: " + bestVersion + ".\n");
        }
        var dataBits = createData(version26, errorCorrectionLevel, segments);
        var moduleCount = Utils.getSymbolSize(version26);
        var modules = new BitMatrix(moduleCount);
        setupFinderPattern(modules, version26);
        setupTimingPattern(modules);
        setupAlignmentPattern(modules, version26);
        setupFormatInfo(modules, errorCorrectionLevel, 0);
        if (version26 >= 7) {
          setupVersionInfo(modules, version26);
        }
        setupData(modules, dataBits);
        if (isNaN(maskPattern)) {
          maskPattern = MaskPattern.getBestMask(modules, setupFormatInfo.bind(null, modules, errorCorrectionLevel));
        }
        MaskPattern.applyMask(maskPattern, modules);
        setupFormatInfo(modules, errorCorrectionLevel, maskPattern);
        return {
          modules,
          version: version26,
          errorCorrectionLevel,
          maskPattern,
          segments
        };
      }
      exports.create = function create(data4, options) {
        if (typeof data4 === "undefined" || data4 === "") {
          throw new Error("No input text");
        }
        var errorCorrectionLevel = ECLevel.M;
        var version26;
        var mask;
        if (typeof options !== "undefined") {
          errorCorrectionLevel = ECLevel.from(options.errorCorrectionLevel, ECLevel.M);
          version26 = Version.from(options.version);
          mask = MaskPattern.from(options.maskPattern);
          if (options.toSJISFunc) {
            Utils.setToSJISFunction(options.toSJISFunc);
          }
        }
        return createSymbol(data4, version26, errorCorrectionLevel, mask);
      };
    }
  });

  // node_modules/qrcode/lib/renderer/utils.js
  var require_utils3 = __commonJS({
    "node_modules/qrcode/lib/renderer/utils.js"(exports) {
      function hex2rgba(hex2) {
        if (typeof hex2 === "number") {
          hex2 = hex2.toString();
        }
        if (typeof hex2 !== "string") {
          throw new Error("Color should be defined as hex string");
        }
        var hexCode = hex2.slice().replace("#", "").split("");
        if (hexCode.length < 3 || hexCode.length === 5 || hexCode.length > 8) {
          throw new Error("Invalid hex color: " + hex2);
        }
        if (hexCode.length === 3 || hexCode.length === 4) {
          hexCode = Array.prototype.concat.apply([], hexCode.map(function(c3) {
            return [c3, c3];
          }));
        }
        if (hexCode.length === 6)
          hexCode.push("F", "F");
        var hexValue2 = parseInt(hexCode.join(""), 16);
        return {
          r: hexValue2 >> 24 & 255,
          g: hexValue2 >> 16 & 255,
          b: hexValue2 >> 8 & 255,
          a: hexValue2 & 255,
          hex: "#" + hexCode.slice(0, 6).join("")
        };
      }
      exports.getOptions = function getOptions(options) {
        if (!options)
          options = {};
        if (!options.color)
          options.color = {};
        var margin = typeof options.margin === "undefined" || options.margin === null || options.margin < 0 ? 4 : options.margin;
        var width = options.width && options.width >= 21 ? options.width : void 0;
        var scale = options.scale || 4;
        return {
          width,
          scale: width ? 4 : scale,
          margin,
          color: {
            dark: hex2rgba(options.color.dark || "#000000ff"),
            light: hex2rgba(options.color.light || "#ffffffff")
          },
          type: options.type,
          rendererOpts: options.rendererOpts || {}
        };
      };
      exports.getScale = function getScale(qrSize, opts) {
        return opts.width && opts.width >= qrSize + opts.margin * 2 ? opts.width / (qrSize + opts.margin * 2) : opts.scale;
      };
      exports.getImageWidth = function getImageWidth(qrSize, opts) {
        var scale = exports.getScale(qrSize, opts);
        return Math.floor((qrSize + opts.margin * 2) * scale);
      };
      exports.qrToImageData = function qrToImageData(imgData, qr, opts) {
        var size = qr.modules.size;
        var data4 = qr.modules.data;
        var scale = exports.getScale(size, opts);
        var symbolSize = Math.floor((size + opts.margin * 2) * scale);
        var scaledMargin = opts.margin * scale;
        var palette = [opts.color.light, opts.color.dark];
        for (var i3 = 0; i3 < symbolSize; i3++) {
          for (var j3 = 0; j3 < symbolSize; j3++) {
            var posDst = (i3 * symbolSize + j3) * 4;
            var pxColor = opts.color.light;
            if (i3 >= scaledMargin && j3 >= scaledMargin && i3 < symbolSize - scaledMargin && j3 < symbolSize - scaledMargin) {
              var iSrc = Math.floor((i3 - scaledMargin) / scale);
              var jSrc = Math.floor((j3 - scaledMargin) / scale);
              pxColor = palette[data4[iSrc * size + jSrc] ? 1 : 0];
            }
            imgData[posDst++] = pxColor.r;
            imgData[posDst++] = pxColor.g;
            imgData[posDst++] = pxColor.b;
            imgData[posDst] = pxColor.a;
          }
        }
      };
    }
  });

  // node_modules/qrcode/lib/renderer/canvas.js
  var require_canvas = __commonJS({
    "node_modules/qrcode/lib/renderer/canvas.js"(exports) {
      var Utils = require_utils3();
      function clearCanvas(ctx, canvas, size) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        if (!canvas.style)
          canvas.style = {};
        canvas.height = size;
        canvas.width = size;
        canvas.style.height = size + "px";
        canvas.style.width = size + "px";
      }
      function getCanvasElement() {
        try {
          return document.createElement("canvas");
        } catch (e3) {
          throw new Error("You need to specify a canvas element");
        }
      }
      exports.render = function render(qrData, canvas, options) {
        var opts = options;
        var canvasEl = canvas;
        if (typeof opts === "undefined" && (!canvas || !canvas.getContext)) {
          opts = canvas;
          canvas = void 0;
        }
        if (!canvas) {
          canvasEl = getCanvasElement();
        }
        opts = Utils.getOptions(opts);
        var size = Utils.getImageWidth(qrData.modules.size, opts);
        var ctx = canvasEl.getContext("2d");
        var image = ctx.createImageData(size, size);
        Utils.qrToImageData(image.data, qrData, opts);
        clearCanvas(ctx, canvasEl, size);
        ctx.putImageData(image, 0, 0);
        return canvasEl;
      };
      exports.renderToDataURL = function renderToDataURL(qrData, canvas, options) {
        var opts = options;
        if (typeof opts === "undefined" && (!canvas || !canvas.getContext)) {
          opts = canvas;
          canvas = void 0;
        }
        if (!opts)
          opts = {};
        var canvasEl = exports.render(qrData, canvas, opts);
        var type = opts.type || "image/png";
        var rendererOpts = opts.rendererOpts || {};
        return canvasEl.toDataURL(type, rendererOpts.quality);
      };
    }
  });

  // node_modules/qrcode/lib/renderer/svg-tag.js
  var require_svg_tag = __commonJS({
    "node_modules/qrcode/lib/renderer/svg-tag.js"(exports) {
      var Utils = require_utils3();
      function getColorAttrib(color, attrib) {
        var alpha = color.a / 255;
        var str = attrib + '="' + color.hex + '"';
        return alpha < 1 ? str + " " + attrib + '-opacity="' + alpha.toFixed(2).slice(1) + '"' : str;
      }
      function svgCmd(cmd, x3, y3) {
        var str = cmd + x3;
        if (typeof y3 !== "undefined")
          str += " " + y3;
        return str;
      }
      function qrToPath(data4, size, margin) {
        var path = "";
        var moveBy = 0;
        var newRow = false;
        var lineLength = 0;
        for (var i3 = 0; i3 < data4.length; i3++) {
          var col = Math.floor(i3 % size);
          var row = Math.floor(i3 / size);
          if (!col && !newRow)
            newRow = true;
          if (data4[i3]) {
            lineLength++;
            if (!(i3 > 0 && col > 0 && data4[i3 - 1])) {
              path += newRow ? svgCmd("M", col + margin, 0.5 + row + margin) : svgCmd("m", moveBy, 0);
              moveBy = 0;
              newRow = false;
            }
            if (!(col + 1 < size && data4[i3 + 1])) {
              path += svgCmd("h", lineLength);
              lineLength = 0;
            }
          } else {
            moveBy++;
          }
        }
        return path;
      }
      exports.render = function render(qrData, options, cb) {
        var opts = Utils.getOptions(options);
        var size = qrData.modules.size;
        var data4 = qrData.modules.data;
        var qrcodesize = size + opts.margin * 2;
        var bg = !opts.color.light.a ? "" : "<path " + getColorAttrib(opts.color.light, "fill") + ' d="M0 0h' + qrcodesize + "v" + qrcodesize + 'H0z"/>';
        var path = "<path " + getColorAttrib(opts.color.dark, "stroke") + ' d="' + qrToPath(data4, size, opts.margin) + '"/>';
        var viewBox = 'viewBox="0 0 ' + qrcodesize + " " + qrcodesize + '"';
        var width = !opts.width ? "" : 'width="' + opts.width + '" height="' + opts.width + '" ';
        var svgTag = '<svg xmlns="http://www.w3.org/2000/svg" ' + width + viewBox + ' shape-rendering="crispEdges">' + bg + path + "</svg>\n";
        if (typeof cb === "function") {
          cb(null, svgTag);
        }
        return svgTag;
      };
    }
  });

  // node_modules/qrcode/lib/browser.js
  var require_browser2 = __commonJS({
    "node_modules/qrcode/lib/browser.js"(exports) {
      var canPromise = require_can_promise();
      var QRCode = require_qrcode();
      var CanvasRenderer = require_canvas();
      var SvgRenderer = require_svg_tag();
      function renderCanvas(renderFunc, canvas, text, opts, cb) {
        var args = [].slice.call(arguments, 1);
        var argsNum = args.length;
        var isLastArgCb = typeof args[argsNum - 1] === "function";
        if (!isLastArgCb && !canPromise()) {
          throw new Error("Callback required as last argument");
        }
        if (isLastArgCb) {
          if (argsNum < 2) {
            throw new Error("Too few arguments provided");
          }
          if (argsNum === 2) {
            cb = text;
            text = canvas;
            canvas = opts = void 0;
          } else if (argsNum === 3) {
            if (canvas.getContext && typeof cb === "undefined") {
              cb = opts;
              opts = void 0;
            } else {
              cb = opts;
              opts = text;
              text = canvas;
              canvas = void 0;
            }
          }
        } else {
          if (argsNum < 1) {
            throw new Error("Too few arguments provided");
          }
          if (argsNum === 1) {
            text = canvas;
            canvas = opts = void 0;
          } else if (argsNum === 2 && !canvas.getContext) {
            opts = text;
            text = canvas;
            canvas = void 0;
          }
          return new Promise(function(resolve, reject) {
            try {
              var data5 = QRCode.create(text, opts);
              resolve(renderFunc(data5, canvas, opts));
            } catch (e3) {
              reject(e3);
            }
          });
        }
        try {
          var data4 = QRCode.create(text, opts);
          cb(null, renderFunc(data4, canvas, opts));
        } catch (e3) {
          cb(e3);
        }
      }
      exports.create = QRCode.create;
      exports.toCanvas = renderCanvas.bind(null, CanvasRenderer.render);
      exports.toDataURL = renderCanvas.bind(null, CanvasRenderer.renderToDataURL);
      exports.toString = renderCanvas.bind(null, function(data4, _4, opts) {
        return SvgRenderer.render(data4, opts);
      });
    }
  });

  // node_modules/toggle-selection/index.js
  var require_toggle_selection = __commonJS({
    "node_modules/toggle-selection/index.js"(exports, module) {
      module.exports = function() {
        var selection = document.getSelection();
        if (!selection.rangeCount) {
          return function() {
          };
        }
        var active = document.activeElement;
        var ranges = [];
        for (var i3 = 0; i3 < selection.rangeCount; i3++) {
          ranges.push(selection.getRangeAt(i3));
        }
        switch (active.tagName.toUpperCase()) {
          case "INPUT":
          case "TEXTAREA":
            active.blur();
            break;
          default:
            active = null;
            break;
        }
        selection.removeAllRanges();
        return function() {
          selection.type === "Caret" && selection.removeAllRanges();
          if (!selection.rangeCount) {
            ranges.forEach(function(range) {
              selection.addRange(range);
            });
          }
          active && active.focus();
        };
      };
    }
  });

  // node_modules/copy-to-clipboard/index.js
  var require_copy_to_clipboard = __commonJS({
    "node_modules/copy-to-clipboard/index.js"(exports, module) {
      "use strict";
      var deselectCurrent = require_toggle_selection();
      var clipboardToIE11Formatting = {
        "text/plain": "Text",
        "text/html": "Url",
        "default": "Text"
      };
      var defaultMessage = "Copy to clipboard: #{key}, Enter";
      function format(message) {
        var copyKey = (/mac os x/i.test(navigator.userAgent) ? "\u2318" : "Ctrl") + "+C";
        return message.replace(/#{\s*key\s*}/g, copyKey);
      }
      function copy(text, options) {
        var debug, message, reselectPrevious, range, selection, mark, success = false;
        if (!options) {
          options = {};
        }
        debug = options.debug || false;
        try {
          reselectPrevious = deselectCurrent();
          range = document.createRange();
          selection = document.getSelection();
          mark = document.createElement("span");
          mark.textContent = text;
          mark.style.all = "unset";
          mark.style.position = "fixed";
          mark.style.top = 0;
          mark.style.clip = "rect(0, 0, 0, 0)";
          mark.style.whiteSpace = "pre";
          mark.style.webkitUserSelect = "text";
          mark.style.MozUserSelect = "text";
          mark.style.msUserSelect = "text";
          mark.style.userSelect = "text";
          mark.addEventListener("copy", function(e3) {
            e3.stopPropagation();
            if (options.format) {
              e3.preventDefault();
              if (typeof e3.clipboardData === "undefined") {
                debug && console.warn("unable to use e.clipboardData");
                debug && console.warn("trying IE specific stuff");
                window.clipboardData.clearData();
                var format2 = clipboardToIE11Formatting[options.format] || clipboardToIE11Formatting["default"];
                window.clipboardData.setData(format2, text);
              } else {
                e3.clipboardData.clearData();
                e3.clipboardData.setData(options.format, text);
              }
            }
            if (options.onCopy) {
              e3.preventDefault();
              options.onCopy(e3.clipboardData);
            }
          });
          document.body.appendChild(mark);
          range.selectNodeContents(mark);
          selection.addRange(range);
          var successful = document.execCommand("copy");
          if (!successful) {
            throw new Error("copy command was unsuccessful");
          }
          success = true;
        } catch (err) {
          debug && console.error("unable to copy using execCommand: ", err);
          debug && console.warn("trying IE specific stuff");
          try {
            window.clipboardData.setData(options.format || "text", text);
            options.onCopy && options.onCopy(window.clipboardData);
            success = true;
          } catch (err2) {
            debug && console.error("unable to copy using clipboardData: ", err2);
            debug && console.error("falling back to prompt");
            message = format("message" in options ? options.message : defaultMessage);
            window.prompt(message, text);
          }
        } finally {
          if (selection) {
            if (typeof selection.removeRange == "function") {
              selection.removeRange(range);
            } else {
              selection.removeAllRanges();
            }
          }
          if (mark) {
            document.body.removeChild(mark);
          }
          reselectPrevious();
        }
        return success;
      }
      module.exports = copy;
    }
  });

  // node_modules/preact/dist/preact.module.js
  function a(n2, l3) {
    for (var u3 in l3)
      n2[u3] = l3[u3];
    return n2;
  }
  function v(n2) {
    var l3 = n2.parentNode;
    l3 && l3.removeChild(n2);
  }
  function h(n2, l3, u3) {
    var i3, t3 = arguments, r3 = {};
    for (i3 in l3)
      i3 !== "key" && i3 !== "ref" && (r3[i3] = l3[i3]);
    if (arguments.length > 3)
      for (u3 = [u3], i3 = 3; i3 < arguments.length; i3++)
        u3.push(t3[i3]);
    if (u3 != null && (r3.children = u3), typeof n2 == "function" && n2.defaultProps != null)
      for (i3 in n2.defaultProps)
        r3[i3] === void 0 && (r3[i3] = n2.defaultProps[i3]);
    return p(n2, r3, l3 && l3.key, l3 && l3.ref, null);
  }
  function p(l3, u3, i3, t3, r3) {
    var o3 = { type: l3, props: u3, key: i3, ref: t3, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, constructor: void 0, __v: r3 };
    return r3 == null && (o3.__v = o3), n.vnode && n.vnode(o3), o3;
  }
  function y() {
    return {};
  }
  function d(n2) {
    return n2.children;
  }
  function m(n2, l3) {
    this.props = n2, this.context = l3;
  }
  function w(n2, l3) {
    if (l3 == null)
      return n2.__ ? w(n2.__, n2.__.__k.indexOf(n2) + 1) : null;
    for (var u3; l3 < n2.__k.length; l3++)
      if ((u3 = n2.__k[l3]) != null && u3.__e != null)
        return u3.__e;
    return typeof n2.type == "function" ? w(n2) : null;
  }
  function k(n2) {
    var l3, u3;
    if ((n2 = n2.__) != null && n2.__c != null) {
      for (n2.__e = n2.__c.base = null, l3 = 0; l3 < n2.__k.length; l3++)
        if ((u3 = n2.__k[l3]) != null && u3.__e != null) {
          n2.__e = n2.__c.base = u3.__e;
          break;
        }
      return k(n2);
    }
  }
  function g(l3) {
    (!l3.__d && (l3.__d = true) && u.push(l3) && !i++ || r !== n.debounceRendering) && ((r = n.debounceRendering) || t)(_);
  }
  function _() {
    for (var n2; i = u.length; )
      n2 = u.sort(function(n3, l3) {
        return n3.__v.__b - l3.__v.__b;
      }), u = [], n2.some(function(n3) {
        var l3, u3, i3, t3, r3, o3, f3;
        n3.__d && (o3 = (r3 = (l3 = n3).__v).__e, (f3 = l3.__P) && (u3 = [], (i3 = a({}, r3)).__v = i3, t3 = A(f3, r3, i3, l3.__n, f3.ownerSVGElement !== void 0, null, u3, o3 == null ? w(r3) : o3), T(u3, r3), t3 != o3 && k(r3)));
      });
  }
  function b(n2, l3, u3, i3, t3, r3, o3, f3, s3) {
    var a3, h3, p3, y3, d3, m3, k3, g3 = u3 && u3.__k || c, _4 = g3.length;
    if (f3 == e && (f3 = r3 != null ? r3[0] : _4 ? w(u3, 0) : null), a3 = 0, l3.__k = x(l3.__k, function(u4) {
      if (u4 != null) {
        if (u4.__ = l3, u4.__b = l3.__b + 1, (p3 = g3[a3]) === null || p3 && u4.key == p3.key && u4.type === p3.type)
          g3[a3] = void 0;
        else
          for (h3 = 0; h3 < _4; h3++) {
            if ((p3 = g3[h3]) && u4.key == p3.key && u4.type === p3.type) {
              g3[h3] = void 0;
              break;
            }
            p3 = null;
          }
        if (y3 = A(n2, u4, p3 = p3 || e, i3, t3, r3, o3, f3, s3), (h3 = u4.ref) && p3.ref != h3 && (k3 || (k3 = []), p3.ref && k3.push(p3.ref, null, u4), k3.push(h3, u4.__c || y3, u4)), y3 != null) {
          var c3;
          if (m3 == null && (m3 = y3), u4.__d !== void 0)
            c3 = u4.__d, u4.__d = void 0;
          else if (r3 == p3 || y3 != f3 || y3.parentNode == null) {
            n:
              if (f3 == null || f3.parentNode !== n2)
                n2.appendChild(y3), c3 = null;
              else {
                for (d3 = f3, h3 = 0; (d3 = d3.nextSibling) && h3 < _4; h3 += 2)
                  if (d3 == y3)
                    break n;
                n2.insertBefore(y3, f3), c3 = f3;
              }
            l3.type == "option" && (n2.value = "");
          }
          f3 = c3 !== void 0 ? c3 : y3.nextSibling, typeof l3.type == "function" && (l3.__d = f3);
        } else
          f3 && p3.__e == f3 && f3.parentNode != n2 && (f3 = w(p3));
      }
      return a3++, u4;
    }), l3.__e = m3, r3 != null && typeof l3.type != "function")
      for (a3 = r3.length; a3--; )
        r3[a3] != null && v(r3[a3]);
    for (a3 = _4; a3--; )
      g3[a3] != null && D(g3[a3], g3[a3]);
    if (k3)
      for (a3 = 0; a3 < k3.length; a3++)
        j(k3[a3], k3[++a3], k3[++a3]);
  }
  function x(n2, l3, u3) {
    if (u3 == null && (u3 = []), n2 == null || typeof n2 == "boolean")
      l3 && u3.push(l3(null));
    else if (Array.isArray(n2))
      for (var i3 = 0; i3 < n2.length; i3++)
        x(n2[i3], l3, u3);
    else
      u3.push(l3 ? l3(typeof n2 == "string" || typeof n2 == "number" ? p(null, n2, null, null, n2) : n2.__e != null || n2.__c != null ? p(n2.type, n2.props, n2.key, null, n2.__v) : n2) : n2);
    return u3;
  }
  function P(n2, l3, u3, i3, t3) {
    var r3;
    for (r3 in u3)
      r3 === "children" || r3 === "key" || r3 in l3 || N2(n2, r3, null, u3[r3], i3);
    for (r3 in l3)
      t3 && typeof l3[r3] != "function" || r3 === "children" || r3 === "key" || r3 === "value" || r3 === "checked" || u3[r3] === l3[r3] || N2(n2, r3, l3[r3], u3[r3], i3);
  }
  function C(n2, l3, u3) {
    l3[0] === "-" ? n2.setProperty(l3, u3) : n2[l3] = typeof u3 == "number" && s.test(l3) === false ? u3 + "px" : u3 == null ? "" : u3;
  }
  function N2(n2, l3, u3, i3, t3) {
    var r3, o3, f3, e3, c3;
    if (t3 ? l3 === "className" && (l3 = "class") : l3 === "class" && (l3 = "className"), l3 === "style")
      if (r3 = n2.style, typeof u3 == "string")
        r3.cssText = u3;
      else {
        if (typeof i3 == "string" && (r3.cssText = "", i3 = null), i3)
          for (e3 in i3)
            u3 && e3 in u3 || C(r3, e3, "");
        if (u3)
          for (c3 in u3)
            i3 && u3[c3] === i3[c3] || C(r3, c3, u3[c3]);
      }
    else
      l3[0] === "o" && l3[1] === "n" ? (o3 = l3 !== (l3 = l3.replace(/Capture$/, "")), f3 = l3.toLowerCase(), l3 = (f3 in n2 ? f3 : l3).slice(2), u3 ? (i3 || n2.addEventListener(l3, z, o3), (n2.l || (n2.l = {}))[l3] = u3) : n2.removeEventListener(l3, z, o3)) : l3 !== "list" && l3 !== "tagName" && l3 !== "form" && l3 !== "type" && l3 !== "size" && !t3 && l3 in n2 ? n2[l3] = u3 == null ? "" : u3 : typeof u3 != "function" && l3 !== "dangerouslySetInnerHTML" && (l3 !== (l3 = l3.replace(/^xlink:?/, "")) ? u3 == null || u3 === false ? n2.removeAttributeNS("http://www.w3.org/1999/xlink", l3.toLowerCase()) : n2.setAttributeNS("http://www.w3.org/1999/xlink", l3.toLowerCase(), u3) : u3 == null || u3 === false && !/^ar/.test(l3) ? n2.removeAttribute(l3) : n2.setAttribute(l3, u3));
  }
  function z(l3) {
    this.l[l3.type](n.event ? n.event(l3) : l3);
  }
  function A(l3, u3, i3, t3, r3, o3, f3, e3, c3) {
    var s3, v3, h3, p3, y3, w4, k3, g3, _4, x3, P3 = u3.type;
    if (u3.constructor !== void 0)
      return null;
    (s3 = n.__b) && s3(u3);
    try {
      n:
        if (typeof P3 == "function") {
          if (g3 = u3.props, _4 = (s3 = P3.contextType) && t3[s3.__c], x3 = s3 ? _4 ? _4.props.value : s3.__ : t3, i3.__c ? k3 = (v3 = u3.__c = i3.__c).__ = v3.__E : ("prototype" in P3 && P3.prototype.render ? u3.__c = v3 = new P3(g3, x3) : (u3.__c = v3 = new m(g3, x3), v3.constructor = P3, v3.render = E), _4 && _4.sub(v3), v3.props = g3, v3.state || (v3.state = {}), v3.context = x3, v3.__n = t3, h3 = v3.__d = true, v3.__h = []), v3.__s == null && (v3.__s = v3.state), P3.getDerivedStateFromProps != null && (v3.__s == v3.state && (v3.__s = a({}, v3.__s)), a(v3.__s, P3.getDerivedStateFromProps(g3, v3.__s))), p3 = v3.props, y3 = v3.state, h3)
            P3.getDerivedStateFromProps == null && v3.componentWillMount != null && v3.componentWillMount(), v3.componentDidMount != null && v3.__h.push(v3.componentDidMount);
          else {
            if (P3.getDerivedStateFromProps == null && g3 !== p3 && v3.componentWillReceiveProps != null && v3.componentWillReceiveProps(g3, x3), !v3.__e && v3.shouldComponentUpdate != null && v3.shouldComponentUpdate(g3, v3.__s, x3) === false || u3.__v === i3.__v && !v3.__) {
              for (v3.props = g3, v3.state = v3.__s, u3.__v !== i3.__v && (v3.__d = false), v3.__v = u3, u3.__e = i3.__e, u3.__k = i3.__k, v3.__h.length && f3.push(v3), s3 = 0; s3 < u3.__k.length; s3++)
                u3.__k[s3] && (u3.__k[s3].__ = u3);
              break n;
            }
            v3.componentWillUpdate != null && v3.componentWillUpdate(g3, v3.__s, x3), v3.componentDidUpdate != null && v3.__h.push(function() {
              v3.componentDidUpdate(p3, y3, w4);
            });
          }
          v3.context = x3, v3.props = g3, v3.state = v3.__s, (s3 = n.__r) && s3(u3), v3.__d = false, v3.__v = u3, v3.__P = l3, s3 = v3.render(v3.props, v3.state, v3.context), u3.__k = s3 != null && s3.type == d && s3.key == null ? s3.props.children : Array.isArray(s3) ? s3 : [s3], v3.getChildContext != null && (t3 = a(a({}, t3), v3.getChildContext())), h3 || v3.getSnapshotBeforeUpdate == null || (w4 = v3.getSnapshotBeforeUpdate(p3, y3)), b(l3, u3, i3, t3, r3, o3, f3, e3, c3), v3.base = u3.__e, v3.__h.length && f3.push(v3), k3 && (v3.__E = v3.__ = null), v3.__e = false;
        } else
          o3 == null && u3.__v === i3.__v ? (u3.__k = i3.__k, u3.__e = i3.__e) : u3.__e = $(i3.__e, u3, i3, t3, r3, o3, f3, c3);
      (s3 = n.diffed) && s3(u3);
    } catch (l4) {
      u3.__v = null, n.__e(l4, u3, i3);
    }
    return u3.__e;
  }
  function T(l3, u3) {
    n.__c && n.__c(u3, l3), l3.some(function(u4) {
      try {
        l3 = u4.__h, u4.__h = [], l3.some(function(n2) {
          n2.call(u4);
        });
      } catch (l4) {
        n.__e(l4, u4.__v);
      }
    });
  }
  function $(n2, l3, u3, i3, t3, r3, o3, f3) {
    var s3, a3, v3, h3, p3, y3 = u3.props, d3 = l3.props;
    if (t3 = l3.type === "svg" || t3, r3 != null) {
      for (s3 = 0; s3 < r3.length; s3++)
        if ((a3 = r3[s3]) != null && ((l3.type === null ? a3.nodeType === 3 : a3.localName === l3.type) || n2 == a3)) {
          n2 = a3, r3[s3] = null;
          break;
        }
    }
    if (n2 == null) {
      if (l3.type === null)
        return document.createTextNode(d3);
      n2 = t3 ? document.createElementNS("http://www.w3.org/2000/svg", l3.type) : document.createElement(l3.type, d3.is && { is: d3.is }), r3 = null, f3 = false;
    }
    if (l3.type === null)
      y3 !== d3 && n2.data != d3 && (n2.data = d3);
    else {
      if (r3 != null && (r3 = c.slice.call(n2.childNodes)), v3 = (y3 = u3.props || e).dangerouslySetInnerHTML, h3 = d3.dangerouslySetInnerHTML, !f3) {
        if (y3 === e)
          for (y3 = {}, p3 = 0; p3 < n2.attributes.length; p3++)
            y3[n2.attributes[p3].name] = n2.attributes[p3].value;
        (h3 || v3) && (h3 && v3 && h3.__html == v3.__html || (n2.innerHTML = h3 && h3.__html || ""));
      }
      P(n2, d3, y3, t3, f3), h3 ? l3.__k = [] : (l3.__k = l3.props.children, b(n2, l3, u3, i3, l3.type !== "foreignObject" && t3, r3, o3, e, f3)), f3 || ("value" in d3 && (s3 = d3.value) !== void 0 && s3 !== n2.value && N2(n2, "value", s3, y3.value, false), "checked" in d3 && (s3 = d3.checked) !== void 0 && s3 !== n2.checked && N2(n2, "checked", s3, y3.checked, false));
    }
    return n2;
  }
  function j(l3, u3, i3) {
    try {
      typeof l3 == "function" ? l3(u3) : l3.current = u3;
    } catch (l4) {
      n.__e(l4, i3);
    }
  }
  function D(l3, u3, i3) {
    var t3, r3, o3;
    if (n.unmount && n.unmount(l3), (t3 = l3.ref) && (t3.current && t3.current !== l3.__e || j(t3, null, u3)), i3 || typeof l3.type == "function" || (i3 = (r3 = l3.__e) != null), l3.__e = l3.__d = void 0, (t3 = l3.__c) != null) {
      if (t3.componentWillUnmount)
        try {
          t3.componentWillUnmount();
        } catch (l4) {
          n.__e(l4, u3);
        }
      t3.base = t3.__P = null;
    }
    if (t3 = l3.__k)
      for (o3 = 0; o3 < t3.length; o3++)
        t3[o3] && D(t3[o3], u3, i3);
    r3 != null && v(r3);
  }
  function E(n2, l3, u3) {
    return this.constructor(n2, u3);
  }
  function H(l3, u3, i3) {
    var t3, r3, f3;
    n.__ && n.__(l3, u3), r3 = (t3 = i3 === o) ? null : i3 && i3.__k || u3.__k, l3 = h(d, null, [l3]), f3 = [], A(u3, (t3 ? u3 : i3 || u3).__k = l3, r3 || e, e, u3.ownerSVGElement !== void 0, i3 && !t3 ? [i3] : r3 ? null : c.slice.call(u3.childNodes), f3, i3 || e, t3), T(f3, l3);
  }
  function I(n2, l3) {
    H(n2, l3, o);
  }
  function L(n2, l3) {
    var u3, i3;
    for (i3 in l3 = a(a({}, n2.props), l3), arguments.length > 2 && (l3.children = c.slice.call(arguments, 2)), u3 = {}, l3)
      i3 !== "key" && i3 !== "ref" && (u3[i3] = l3[i3]);
    return p(n2.type, u3, l3.key || n2.key, l3.ref || n2.ref, null);
  }
  function M(n2) {
    var l3 = {}, u3 = { __c: "__cC" + f++, __: n2, Consumer: function(n3, l4) {
      return n3.children(l4);
    }, Provider: function(n3) {
      var i3, t3 = this;
      return this.getChildContext || (i3 = [], this.getChildContext = function() {
        return l3[u3.__c] = t3, l3;
      }, this.shouldComponentUpdate = function(n4) {
        t3.props.value !== n4.value && i3.some(function(l4) {
          l4.context = n4.value, g(l4);
        });
      }, this.sub = function(n4) {
        i3.push(n4);
        var l4 = n4.componentWillUnmount;
        n4.componentWillUnmount = function() {
          i3.splice(i3.indexOf(n4), 1), l4 && l4.call(n4);
        };
      }), n3.children;
    } };
    return u3.Consumer.contextType = u3, u3.Provider.__ = u3, u3;
  }
  var n, l, u, i, t, r, o, f, e, c, s;
  var init_preact_module = __esm({
    "node_modules/preact/dist/preact.module.js"() {
      e = {};
      c = [];
      s = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord/i;
      n = { __e: function(n2, l3) {
        for (var u3, i3; l3 = l3.__; )
          if ((u3 = l3.__c) && !u3.__)
            try {
              if (u3.constructor && u3.constructor.getDerivedStateFromError != null && (i3 = true, u3.setState(u3.constructor.getDerivedStateFromError(n2))), u3.componentDidCatch != null && (i3 = true, u3.componentDidCatch(n2)), i3)
                return g(u3.__E = u3);
            } catch (l4) {
              n2 = l4;
            }
        throw n2;
      } }, l = function(n2) {
        return n2 != null && n2.constructor === void 0;
      }, m.prototype.setState = function(n2, l3) {
        var u3;
        u3 = this.__s !== this.state ? this.__s : this.__s = a({}, this.state), typeof n2 == "function" && (n2 = n2(u3, this.props)), n2 && a(u3, n2), n2 != null && this.__v && (l3 && this.__h.push(l3), g(this));
      }, m.prototype.forceUpdate = function(n2) {
        this.__v && (this.__e = true, n2 && this.__h.push(n2), g(this));
      }, m.prototype.render = d, u = [], i = 0, t = typeof Promise == "function" ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, o = e, f = 0;
    }
  });

  // node_modules/preact/hooks/dist/hooks.module.js
  function v2(t3, r3) {
    n.__h && n.__h(u2, t3, i2 || r3), i2 = 0;
    var o3 = u2.__H || (u2.__H = { __: [], __h: [] });
    return t3 >= o3.__.length && o3.__.push({}), o3.__[t3];
  }
  function m2(n2) {
    return i2 = 1, p2(E2, n2);
  }
  function p2(n2, r3, i3) {
    var o3 = v2(t2++, 2);
    return o3.__c || (o3.__c = u2, o3.__ = [i3 ? i3(r3) : E2(void 0, r3), function(t3) {
      var u3 = n2(o3.__[0], t3);
      o3.__[0] !== u3 && (o3.__[0] = u3, o3.__c.setState({}));
    }]), o3.__;
  }
  function l2(r3, i3) {
    var o3 = v2(t2++, 3);
    !n.__s && x2(o3.__H, i3) && (o3.__ = r3, o3.__H = i3, u2.__H.__h.push(o3));
  }
  function y2(r3, i3) {
    var o3 = v2(t2++, 4);
    !n.__s && x2(o3.__H, i3) && (o3.__ = r3, o3.__H = i3, u2.__h.push(o3));
  }
  function d2(n2) {
    return i2 = 5, h2(function() {
      return { current: n2 };
    }, []);
  }
  function s2(n2, t3, u3) {
    i2 = 6, y2(function() {
      typeof n2 == "function" ? n2(t3()) : n2 && (n2.current = t3());
    }, u3 == null ? u3 : u3.concat(n2));
  }
  function h2(n2, u3) {
    var r3 = v2(t2++, 7);
    return x2(r3.__H, u3) ? (r3.__H = u3, r3.__h = n2, r3.__ = n2()) : r3.__;
  }
  function T2(n2, t3) {
    return i2 = 8, h2(function() {
      return n2;
    }, t3);
  }
  function w2(n2) {
    var r3 = u2.context[n2.__c], i3 = v2(t2++, 9);
    return i3.__c = n2, r3 ? (i3.__ == null && (i3.__ = true, r3.sub(u2)), r3.props.value) : n2.__;
  }
  function A2(t3, u3) {
    n.useDebugValue && n.useDebugValue(u3 ? u3(t3) : t3);
  }
  function F(n2) {
    var r3 = v2(t2++, 10), i3 = m2();
    return r3.__ = n2, u2.componentDidCatch || (u2.componentDidCatch = function(n3) {
      r3.__ && r3.__(n3), i3[1](n3);
    }), [i3[0], function() {
      i3[1](void 0);
    }];
  }
  function _2() {
    o2.some(function(t3) {
      if (t3.__P)
        try {
          t3.__H.__h.forEach(g2), t3.__H.__h.forEach(q), t3.__H.__h = [];
        } catch (u3) {
          return t3.__H.__h = [], n.__e(u3, t3.__v), true;
        }
    }), o2 = [];
  }
  function g2(n2) {
    n2.t && n2.t();
  }
  function q(n2) {
    var t3 = n2.__();
    typeof t3 == "function" && (n2.t = t3);
  }
  function x2(n2, t3) {
    return !n2 || t3.some(function(t4, u3) {
      return t4 !== n2[u3];
    });
  }
  function E2(n2, t3) {
    return typeof t3 == "function" ? t3(n2) : t3;
  }
  var t2, u2, r2, i2, o2, c2, f2, e2, a2;
  var init_hooks_module = __esm({
    "node_modules/preact/hooks/dist/hooks.module.js"() {
      init_preact_module();
      i2 = 0;
      o2 = [];
      c2 = n.__r;
      f2 = n.diffed;
      e2 = n.__c;
      a2 = n.unmount;
      n.__r = function(n2) {
        c2 && c2(n2), t2 = 0, (u2 = n2.__c).__H && (u2.__H.__h.forEach(g2), u2.__H.__h.forEach(q), u2.__H.__h = []);
      }, n.diffed = function(t3) {
        f2 && f2(t3);
        var u3 = t3.__c;
        if (u3) {
          var i3 = u3.__H;
          i3 && i3.__h.length && (o2.push(u3) !== 1 && r2 === n.requestAnimationFrame || ((r2 = n.requestAnimationFrame) || function(n2) {
            var t4, u4 = function() {
              clearTimeout(r3), cancelAnimationFrame(t4), setTimeout(n2);
            }, r3 = setTimeout(u4, 100);
            typeof window != "undefined" && (t4 = requestAnimationFrame(u4));
          })(_2));
        }
      }, n.__c = function(t3, u3) {
        u3.some(function(t4) {
          try {
            t4.__h.forEach(g2), t4.__h = t4.__h.filter(function(n2) {
              return !n2.__ || q(n2);
            });
          } catch (r3) {
            u3.some(function(n2) {
              n2.__h && (n2.__h = []);
            }), u3 = [], n.__e(r3, t4.__v);
          }
        }), e2 && e2(t3, u3);
      }, n.unmount = function(t3) {
        a2 && a2(t3);
        var u3 = t3.__c;
        if (u3) {
          var r3 = u3.__H;
          if (r3)
            try {
              r3.__.forEach(function(n2) {
                return n2.t && n2.t();
              });
            } catch (t4) {
              n.__e(t4, u3.__v);
            }
        }
      };
    }
  });

  // node_modules/preact/compat/dist/compat.module.js
  var compat_module_exports = {};
  __export(compat_module_exports, {
    Children: () => R,
    Component: () => m,
    Fragment: () => d,
    PureComponent: () => C2,
    Suspense: () => U,
    SuspenseList: () => O,
    cloneElement: () => K,
    createContext: () => M,
    createElement: () => h,
    createFactory: () => G,
    createPortal: () => z2,
    createRef: () => y,
    default: () => compat_module_default,
    findDOMNode: () => X,
    forwardRef: () => S,
    hydrate: () => V,
    isValidElement: () => J,
    lazy: () => L2,
    memo: () => _3,
    render: () => T3,
    unmountComponentAtNode: () => Q,
    unstable_batchedUpdates: () => Y,
    useCallback: () => T2,
    useContext: () => w2,
    useDebugValue: () => A2,
    useEffect: () => l2,
    useErrorBoundary: () => F,
    useImperativeHandle: () => s2,
    useLayoutEffect: () => y2,
    useMemo: () => h2,
    useReducer: () => p2,
    useRef: () => d2,
    useState: () => m2,
    version: () => B
  });
  function E3(n2, t3) {
    for (var e3 in t3)
      n2[e3] = t3[e3];
    return n2;
  }
  function w3(n2, t3) {
    for (var e3 in n2)
      if (e3 !== "__source" && !(e3 in t3))
        return true;
    for (var r3 in t3)
      if (r3 !== "__source" && n2[r3] !== t3[r3])
        return true;
    return false;
  }
  function _3(n2, t3) {
    function e3(n3) {
      var e4 = this.props.ref, r4 = e4 == n3.ref;
      return !r4 && e4 && (e4.call ? e4(null) : e4.current = null), t3 ? !t3(this.props, n3) || !r4 : w3(this.props, n3);
    }
    function r3(t4) {
      return this.shouldComponentUpdate = e3, h(n2, E3({}, t4));
    }
    return r3.prototype.isReactComponent = true, r3.displayName = "Memo(" + (n2.displayName || n2.name) + ")", r3.t = true, r3;
  }
  function S(n2) {
    function t3(t4) {
      var e3 = E3({}, t4);
      return delete e3.ref, n2(e3, t4.ref);
    }
    return t3.prototype.isReactComponent = t3.t = true, t3.displayName = "ForwardRef(" + (n2.displayName || n2.name) + ")", t3;
  }
  function N3(n2) {
    return n2 && ((n2 = E3({}, n2)).__c = null, n2.__k = n2.__k && n2.__k.map(N3)), n2;
  }
  function U() {
    this.__u = 0, this.o = null, this.__b = null;
  }
  function M2(n2) {
    var t3 = n2.__.__c;
    return t3 && t3.u && t3.u(n2);
  }
  function L2(n2) {
    var t3, e3, r3;
    function o3(o4) {
      if (t3 || (t3 = n2()).then(function(n3) {
        e3 = n3.default || n3;
      }, function(n3) {
        r3 = n3;
      }), r3)
        throw r3;
      if (!e3)
        throw t3;
      return h(e3, o4);
    }
    return o3.displayName = "Lazy", o3.t = true, o3;
  }
  function O() {
    this.i = null, this.l = null;
  }
  function j2(n2) {
    var t3 = this, e3 = n2.container, r3 = h(W, { context: t3.context }, n2.vnode);
    return t3.s && t3.s !== e3 && (t3.v.parentNode && t3.s.removeChild(t3.v), D(t3.h), t3.p = false), n2.vnode ? t3.p ? (e3.__k = t3.__k, H(r3, e3), t3.__k = e3.__k) : (t3.v = document.createTextNode(""), I("", e3), e3.appendChild(t3.v), t3.p = true, t3.s = e3, H(r3, e3, t3.v), t3.__k = t3.v.__k) : t3.p && (t3.v.parentNode && t3.s.removeChild(t3.v), D(t3.h)), t3.h = r3, t3.componentWillUnmount = function() {
      t3.v.parentNode && t3.s.removeChild(t3.v), D(t3.h);
    }, null;
  }
  function z2(n2, t3) {
    return h(j2, { vnode: n2, container: t3 });
  }
  function T3(n2, t3, e3) {
    if (t3.__k == null)
      for (; t3.firstChild; )
        t3.removeChild(t3.firstChild);
    return H(n2, t3), typeof e3 == "function" && e3(), n2 ? n2.__c : null;
  }
  function V(n2, t3, e3) {
    return I(n2, t3), typeof e3 == "function" && e3(), n2 ? n2.__c : null;
  }
  function I2(n2, t3) {
    n2["UNSAFE_" + t3] && !n2[t3] && Object.defineProperty(n2, t3, { configurable: false, get: function() {
      return this["UNSAFE_" + t3];
    }, set: function(n3) {
      this["UNSAFE_" + t3] = n3;
    } });
  }
  function G(n2) {
    return h.bind(null, n2);
  }
  function J(n2) {
    return !!n2 && n2.$$typeof === H2;
  }
  function K(n2) {
    return J(n2) ? L.apply(null, arguments) : n2;
  }
  function Q(n2) {
    return !!n2.__k && (H(null, n2), true);
  }
  function X(n2) {
    return n2 && (n2.base || n2.nodeType === 1 && n2) || null;
  }
  var C2, A3, k2, R, F2, P2, W, D2, H2, Z, $2, q2, B, Y, compat_module_default;
  var init_compat_module = __esm({
    "node_modules/preact/compat/dist/compat.module.js"() {
      init_hooks_module();
      init_hooks_module();
      init_preact_module();
      init_preact_module();
      C2 = function(n2) {
        var t3, e3;
        function r3(t4) {
          var e4;
          return (e4 = n2.call(this, t4) || this).isPureReactComponent = true, e4;
        }
        return e3 = n2, (t3 = r3).prototype = Object.create(e3.prototype), t3.prototype.constructor = t3, t3.__proto__ = e3, r3.prototype.shouldComponentUpdate = function(n3, t4) {
          return w3(this.props, n3) || w3(this.state, t4);
        }, r3;
      }(m);
      A3 = n.__b;
      n.__b = function(n2) {
        n2.type && n2.type.t && n2.ref && (n2.props.ref = n2.ref, n2.ref = null), A3 && A3(n2);
      };
      k2 = function(n2, t3) {
        return n2 ? x(n2).reduce(function(n3, e3, r3) {
          return n3.concat(t3(e3, r3));
        }, []) : null;
      };
      R = { map: k2, forEach: k2, count: function(n2) {
        return n2 ? x(n2).length : 0;
      }, only: function(n2) {
        if ((n2 = x(n2)).length !== 1)
          throw new Error("Children.only() expects only one child.");
        return n2[0];
      }, toArray: x };
      F2 = n.__e;
      n.__e = function(n2, t3, e3) {
        if (n2.then) {
          for (var r3, o3 = t3; o3 = o3.__; )
            if ((r3 = o3.__c) && r3.__c)
              return r3.__c(n2, t3.__c);
        }
        F2(n2, t3, e3);
      }, (U.prototype = new m()).__c = function(n2, t3) {
        var e3 = this;
        e3.o == null && (e3.o = []), e3.o.push(t3);
        var r3 = M2(e3.__v), o3 = false, u3 = function() {
          o3 || (o3 = true, r3 ? r3(i3) : i3());
        };
        t3.__c = t3.componentWillUnmount, t3.componentWillUnmount = function() {
          u3(), t3.__c && t3.__c();
        };
        var i3 = function() {
          var n3;
          if (!--e3.__u)
            for (e3.__v.__k[0] = e3.state.u, e3.setState({ u: e3.__b = null }); n3 = e3.o.pop(); )
              n3.forceUpdate();
        };
        e3.__u++ || e3.setState({ u: e3.__b = e3.__v.__k[0] }), n2.then(u3, u3);
      }, U.prototype.render = function(n2, t3) {
        return this.__b && (this.__v.__k[0] = N3(this.__b), this.__b = null), [h(m, null, t3.u ? null : n2.children), t3.u && n2.fallback];
      };
      P2 = function(n2, t3, e3) {
        if (++e3[1] === e3[0] && n2.l.delete(t3), n2.props.revealOrder && (n2.props.revealOrder[0] !== "t" || !n2.l.size))
          for (e3 = n2.i; e3; ) {
            for (; e3.length > 3; )
              e3.pop()();
            if (e3[1] < e3[0])
              break;
            n2.i = e3 = e3[2];
          }
      };
      (O.prototype = new m()).u = function(n2) {
        var t3 = this, e3 = M2(t3.__v), r3 = t3.l.get(n2);
        return r3[0]++, function(o3) {
          var u3 = function() {
            t3.props.revealOrder ? (r3.push(o3), P2(t3, n2, r3)) : o3();
          };
          e3 ? e3(u3) : u3();
        };
      }, O.prototype.render = function(n2) {
        this.i = null, this.l = /* @__PURE__ */ new Map();
        var t3 = x(n2.children);
        n2.revealOrder && n2.revealOrder[0] === "b" && t3.reverse();
        for (var e3 = t3.length; e3--; )
          this.l.set(t3[e3], this.i = [1, 0, this.i]);
        return n2.children;
      }, O.prototype.componentDidUpdate = O.prototype.componentDidMount = function() {
        var n2 = this;
        n2.l.forEach(function(t3, e3) {
          P2(n2, e3, t3);
        });
      };
      W = function() {
        function n2() {
        }
        var t3 = n2.prototype;
        return t3.getChildContext = function() {
          return this.props.context;
        }, t3.render = function(n3) {
          return n3.children;
        }, n2;
      }();
      D2 = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|fill|flood|font|glyph(?!R)|horiz|marker(?!H|W|U)|overline|paint|stop|strikethrough|stroke|text(?!L)|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/;
      m.prototype.isReactComponent = {};
      H2 = typeof Symbol != "undefined" && Symbol.for && Symbol.for("react.element") || 60103;
      Z = n.event;
      n.event = function(n2) {
        Z && (n2 = Z(n2)), n2.persist = function() {
        };
        var t3 = false, e3 = false, r3 = n2.stopPropagation;
        n2.stopPropagation = function() {
          r3.call(n2), t3 = true;
        };
        var o3 = n2.preventDefault;
        return n2.preventDefault = function() {
          o3.call(n2), e3 = true;
        }, n2.isPropagationStopped = function() {
          return t3;
        }, n2.isDefaultPrevented = function() {
          return e3;
        }, n2.nativeEvent = n2;
      };
      $2 = { configurable: true, get: function() {
        return this.class;
      } };
      q2 = n.vnode;
      n.vnode = function(n2) {
        n2.$$typeof = H2;
        var t3 = n2.type, e3 = n2.props;
        if (t3) {
          if (e3.class != e3.className && ($2.enumerable = "className" in e3, e3.className != null && (e3.class = e3.className), Object.defineProperty(e3, "className", $2)), typeof t3 != "function") {
            var r3, o3, u3;
            for (u3 in e3.defaultValue && e3.value !== void 0 && (e3.value || e3.value === 0 || (e3.value = e3.defaultValue), delete e3.defaultValue), Array.isArray(e3.value) && e3.multiple && t3 === "select" && (x(e3.children).forEach(function(n3) {
              e3.value.indexOf(n3.props.value) != -1 && (n3.props.selected = true);
            }), delete e3.value), e3)
              if (r3 = D2.test(u3))
                break;
            if (r3)
              for (u3 in o3 = n2.props = {}, e3)
                o3[D2.test(u3) ? u3.replace(/[A-Z0-9]/, "-$&").toLowerCase() : u3] = e3[u3];
          }
          !function(t4) {
            var e4 = n2.type, r4 = n2.props;
            if (r4 && typeof e4 == "string") {
              var o4 = {};
              for (var u4 in r4)
                /^on(Ani|Tra|Tou)/.test(u4) && (r4[u4.toLowerCase()] = r4[u4], delete r4[u4]), o4[u4.toLowerCase()] = u4;
              if (o4.ondoubleclick && (r4.ondblclick = r4[o4.ondoubleclick], delete r4[o4.ondoubleclick]), o4.onbeforeinput && (r4.onbeforeinput = r4[o4.onbeforeinput], delete r4[o4.onbeforeinput]), o4.onchange && (e4 === "textarea" || e4.toLowerCase() === "input" && !/^fil|che|ra/i.test(r4.type))) {
                var i3 = o4.oninput || "oninput";
                r4[i3] || (r4[i3] = r4[o4.onchange], delete r4[o4.onchange]);
              }
            }
          }(), typeof t3 == "function" && !t3.m && t3.prototype && (I2(t3.prototype, "componentWillMount"), I2(t3.prototype, "componentWillReceiveProps"), I2(t3.prototype, "componentWillUpdate"), t3.m = true);
        }
        q2 && q2(n2);
      };
      B = "16.8.0";
      Y = function(n2, t3) {
        return n2(t3);
      };
      compat_module_default = { useState: m2, useReducer: p2, useEffect: l2, useLayoutEffect: y2, useRef: d2, useImperativeHandle: s2, useMemo: h2, useCallback: T2, useContext: w2, useDebugValue: A2, version: "16.8.0", Children: R, render: T3, hydrate: T3, unmountComponentAtNode: Q, createPortal: z2, createElement: h, createContext: M, createFactory: G, cloneElement: K, createRef: y, Fragment: d, isValidElement: J, findDOMNode: X, Component: m, PureComponent: C2, memo: _3, forwardRef: S, unstable_batchedUpdates: Y, Suspense: U, SuspenseList: O, lazy: L2 };
    }
  });

  // node_modules/@walletconnect/qrcode-modal/dist/cjs/index.js
  var require_cjs4 = __commonJS({
    "node_modules/@walletconnect/qrcode-modal/dist/cjs/index.js"(exports, module) {
      function _interopDefault(ex) {
        return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
      }
      var browserUtils = (init_esm2(), esm_exports3);
      var QRCode = _interopDefault(require_browser2());
      var copy = _interopDefault(require_copy_to_clipboard());
      var React = (init_compat_module(), compat_module_exports);
      function open(uri) {
        QRCode.toString(uri, {
          type: "terminal"
        }).then(console.log);
      }
      var WALLETCONNECT_STYLE_SHEET = ':root {\n  --animation-duration: 300ms;\n}\n\n@keyframes fadeIn {\n  from {\n    opacity: 0;\n  }\n  to {\n    opacity: 1;\n  }\n}\n\n@keyframes fadeOut {\n  from {\n    opacity: 1;\n  }\n  to {\n    opacity: 0;\n  }\n}\n\n.animated {\n  animation-duration: var(--animation-duration);\n  animation-fill-mode: both;\n}\n\n.fadeIn {\n  animation-name: fadeIn;\n}\n\n.fadeOut {\n  animation-name: fadeOut;\n}\n\n#walletconnect-wrapper {\n  -webkit-user-select: none;\n  align-items: center;\n  display: flex;\n  height: 100%;\n  justify-content: center;\n  left: 0;\n  pointer-events: none;\n  position: fixed;\n  top: 0;\n  user-select: none;\n  width: 100%;\n  z-index: 99999999999999;\n}\n\n.walletconnect-modal__headerLogo {\n  height: 21px;\n}\n\n.walletconnect-modal__header p {\n  color: #ffffff;\n  font-size: 20px;\n  font-weight: 600;\n  margin: 0;\n  align-items: flex-start;\n  display: flex;\n  flex: 1;\n  margin-left: 5px;\n}\n\n.walletconnect-modal__close__wrapper {\n  position: absolute;\n  top: 0px;\n  right: 0px;\n  z-index: 10000;\n  background: white;\n  border-radius: 26px;\n  padding: 6px;\n  box-sizing: border-box;\n  width: 26px;\n  height: 26px;\n  cursor: pointer;\n}\n\n.walletconnect-modal__close__icon {\n  position: relative;\n  top: 7px;\n  right: 0;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  transform: rotate(45deg);\n}\n\n.walletconnect-modal__close__line1 {\n  position: absolute;\n  width: 100%;\n  border: 1px solid rgb(48, 52, 59);\n}\n\n.walletconnect-modal__close__line2 {\n  position: absolute;\n  width: 100%;\n  border: 1px solid rgb(48, 52, 59);\n  transform: rotate(90deg);\n}\n\n.walletconnect-qrcode__base {\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n  background: rgba(37, 41, 46, 0.95);\n  height: 100%;\n  left: 0;\n  pointer-events: auto;\n  position: fixed;\n  top: 0;\n  transition: 0.4s cubic-bezier(0.19, 1, 0.22, 1);\n  width: 100%;\n  will-change: opacity;\n  padding: 40px;\n  box-sizing: border-box;\n}\n\n.walletconnect-qrcode__text {\n  color: rgba(60, 66, 82, 0.6);\n  font-size: 16px;\n  font-weight: 600;\n  letter-spacing: 0;\n  line-height: 1.1875em;\n  margin: 10px 0 20px 0;\n  text-align: center;\n  width: 100%;\n}\n\n@media only screen and (max-width: 768px) {\n  .walletconnect-qrcode__text {\n    font-size: 4vw;\n  }\n}\n\n@media only screen and (max-width: 320px) {\n  .walletconnect-qrcode__text {\n    font-size: 14px;\n  }\n}\n\n.walletconnect-qrcode__image {\n  width: calc(100% - 30px);\n  box-sizing: border-box;\n  cursor: none;\n  margin: 0 auto;\n}\n\n.walletconnect-qrcode__notification {\n  position: absolute;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  font-size: 16px;\n  padding: 16px 20px;\n  border-radius: 16px;\n  text-align: center;\n  transition: all 0.1s ease-in-out;\n  background: white;\n  color: black;\n  margin-bottom: -60px;\n  opacity: 0;\n}\n\n.walletconnect-qrcode__notification.notification__show {\n  opacity: 1;\n}\n\n@media only screen and (max-width: 768px) {\n  .walletconnect-modal__header {\n    height: 130px;\n  }\n  .walletconnect-modal__base {\n    overflow: auto;\n  }\n}\n\n@media only screen and (min-device-width: 415px) and (max-width: 768px) {\n  #content {\n    max-width: 768px;\n    box-sizing: border-box;\n  }\n}\n\n@media only screen and (min-width: 375px) and (max-width: 415px) {\n  #content {\n    max-width: 414px;\n    box-sizing: border-box;\n  }\n}\n\n@media only screen and (min-width: 320px) and (max-width: 375px) {\n  #content {\n    max-width: 375px;\n    box-sizing: border-box;\n  }\n}\n\n@media only screen and (max-width: 320px) {\n  #content {\n    max-width: 320px;\n    box-sizing: border-box;\n  }\n}\n\n.walletconnect-modal__base {\n  -webkit-font-smoothing: antialiased;\n  background: #ffffff;\n  border-radius: 24px;\n  box-shadow: 0 10px 50px 5px rgba(0, 0, 0, 0.4);\n  font-family: ui-rounded, "SF Pro Rounded", "SF Pro Text", medium-content-sans-serif-font,\n    -apple-system, BlinkMacSystemFont, ui-sans-serif, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell,\n    "Open Sans", "Helvetica Neue", sans-serif;\n  margin-top: 41px;\n  padding: 24px 24px 22px;\n  pointer-events: auto;\n  position: relative;\n  text-align: center;\n  transition: 0.4s cubic-bezier(0.19, 1, 0.22, 1);\n  will-change: transform;\n  overflow: visible;\n  transform: translateY(-50%);\n  top: 50%;\n  max-width: 500px;\n  margin: auto;\n}\n\n@media only screen and (max-width: 320px) {\n  .walletconnect-modal__base {\n    padding: 24px 12px;\n  }\n}\n\n.walletconnect-modal__base .hidden {\n  transform: translateY(150%);\n  transition: 0.125s cubic-bezier(0.4, 0, 1, 1);\n}\n\n.walletconnect-modal__header {\n  align-items: center;\n  display: flex;\n  height: 26px;\n  left: 0;\n  justify-content: space-between;\n  position: absolute;\n  top: -42px;\n  width: 100%;\n}\n\n.walletconnect-modal__base .wc-logo {\n  align-items: center;\n  display: flex;\n  height: 26px;\n  margin-top: 15px;\n  padding-bottom: 15px;\n  pointer-events: auto;\n}\n\n.walletconnect-modal__base .wc-logo div {\n  background-color: #3399ff;\n  height: 21px;\n  margin-right: 5px;\n  mask-image: url("images/wc-logo.svg") center no-repeat;\n  width: 32px;\n}\n\n.walletconnect-modal__base .wc-logo p {\n  color: #ffffff;\n  font-size: 20px;\n  font-weight: 600;\n  margin: 0;\n}\n\n.walletconnect-modal__base h2 {\n  color: rgba(60, 66, 82, 0.6);\n  font-size: 16px;\n  font-weight: 600;\n  letter-spacing: 0;\n  line-height: 1.1875em;\n  margin: 0 0 19px 0;\n  text-align: center;\n  width: 100%;\n}\n\n.walletconnect-modal__base__row {\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n  align-items: center;\n  border-radius: 20px;\n  cursor: pointer;\n  display: flex;\n  height: 56px;\n  justify-content: space-between;\n  padding: 0 15px;\n  position: relative;\n  margin: 0px 0px 8px;\n  text-align: left;\n  transition: 0.15s cubic-bezier(0.25, 0.46, 0.45, 0.94);\n  will-change: transform;\n  text-decoration: none;\n}\n\n.walletconnect-modal__base__row:hover {\n  background: rgba(60, 66, 82, 0.06);\n}\n\n.walletconnect-modal__base__row:active {\n  background: rgba(60, 66, 82, 0.06);\n  transform: scale(0.975);\n  transition: 0.1s cubic-bezier(0.25, 0.46, 0.45, 0.94);\n}\n\n.walletconnect-modal__base__row__h3 {\n  color: #25292e;\n  font-size: 20px;\n  font-weight: 700;\n  margin: 0;\n  padding-bottom: 3px;\n}\n\n.walletconnect-modal__base__row__right {\n  align-items: center;\n  display: flex;\n  justify-content: center;\n}\n\n.walletconnect-modal__base__row__right__app-icon {\n  border-radius: 8px;\n  height: 34px;\n  margin: 0 11px 2px 0;\n  width: 34px;\n  background-size: 100%;\n  box-shadow: 0 4px 12px 0 rgba(37, 41, 46, 0.25);\n}\n\n.walletconnect-modal__base__row__right__caret {\n  height: 18px;\n  opacity: 0.3;\n  transition: 0.1s cubic-bezier(0.25, 0.46, 0.45, 0.94);\n  width: 8px;\n  will-change: opacity;\n}\n\n.walletconnect-modal__base__row:hover .caret,\n.walletconnect-modal__base__row:active .caret {\n  opacity: 0.6;\n}\n\n.walletconnect-modal__mobile__toggle {\n  width: 80%;\n  display: flex;\n  margin: 0 auto;\n  position: relative;\n  overflow: hidden;\n  border-radius: 8px;\n  margin-bottom: 18px;\n  background: #d4d5d9;\n}\n\n.walletconnect-modal__single_wallet {\n  display: flex;\n  justify-content: center;\n  margin-top: 7px;\n  margin-bottom: 18px;\n}\n\n.walletconnect-modal__single_wallet a {\n  cursor: pointer;\n  color: rgb(64, 153, 255);\n  font-size: 21px;\n  font-weight: 800;\n  text-decoration: none !important;\n  margin: 0 auto;\n}\n\n.walletconnect-modal__mobile__toggle_selector {\n  width: calc(50% - 8px);\n  background: white;\n  position: absolute;\n  border-radius: 5px;\n  height: calc(100% - 8px);\n  top: 4px;\n  transition: all 0.2s ease-in-out;\n  transform: translate3d(4px, 0, 0);\n}\n\n.walletconnect-modal__mobile__toggle.right__selected .walletconnect-modal__mobile__toggle_selector {\n  transform: translate3d(calc(100% + 12px), 0, 0);\n}\n\n.walletconnect-modal__mobile__toggle a {\n  font-size: 12px;\n  width: 50%;\n  text-align: center;\n  padding: 8px;\n  margin: 0;\n  font-weight: 600;\n  z-index: 1;\n}\n\n.walletconnect-modal__footer {\n  display: flex;\n  justify-content: center;\n  margin-top: 20px;\n}\n\n@media only screen and (max-width: 768px) {\n  .walletconnect-modal__footer {\n    margin-top: 5vw;\n  }\n}\n\n.walletconnect-modal__footer a {\n  cursor: pointer;\n  color: #898d97;\n  font-size: 15px;\n  margin: 0 auto;\n}\n\n@media only screen and (max-width: 320px) {\n  .walletconnect-modal__footer a {\n    font-size: 14px;\n  }\n}\n\n.walletconnect-connect__buttons__wrapper {\n  max-height: 44vh;\n}\n\n.walletconnect-connect__buttons__wrapper__android {\n  margin: 50% 0;\n}\n\n.walletconnect-connect__buttons__wrapper__wrap {\n  display: grid;\n  grid-template-columns: repeat(4, 1fr);\n  margin: 10px 0;\n}\n\n@media only screen and (min-width: 768px) {\n  .walletconnect-connect__buttons__wrapper__wrap {\n    margin-top: 40px;\n  }\n}\n\n.walletconnect-connect__button {\n  background-color: rgb(64, 153, 255);\n  padding: 12px;\n  border-radius: 8px;\n  text-decoration: none;\n  color: rgb(255, 255, 255);\n  font-weight: 500;\n}\n\n.walletconnect-connect__button__icon_anchor {\n  cursor: pointer;\n  display: flex;\n  justify-content: flex-start;\n  align-items: center;\n  margin: 8px;\n  width: 42px;\n  justify-self: center;\n  flex-direction: column;\n  text-decoration: none !important;\n}\n\n@media only screen and (max-width: 320px) {\n  .walletconnect-connect__button__icon_anchor {\n    margin: 4px;\n  }\n}\n\n.walletconnect-connect__button__icon {\n  border-radius: 10px;\n  height: 42px;\n  margin: 0;\n  width: 42px;\n  background-size: cover !important;\n  box-shadow: 0 4px 12px 0 rgba(37, 41, 46, 0.25);\n}\n\n.walletconnect-connect__button__text {\n  color: #424952;\n  font-size: 2.7vw;\n  text-decoration: none !important;\n  padding: 0;\n  margin-top: 1.8vw;\n  font-weight: 600;\n}\n\n@media only screen and (min-width: 768px) {\n  .walletconnect-connect__button__text {\n    font-size: 16px;\n    margin-top: 12px;\n  }\n}\n\n.walletconnect-search__input {\n  border: none;\n  background: #d4d5d9;\n  border-style: none;\n  padding: 8px 16px;\n  outline: none;\n  font-style: normal;\n  font-stretch: normal;\n  font-size: 16px;\n  font-style: normal;\n  font-stretch: normal;\n  line-height: normal;\n  letter-spacing: normal;\n  text-align: left;\n  border-radius: 8px;\n  width: calc(100% - 16px);\n  margin: 0;\n  margin-bottom: 8px;\n}\n';
      var _iteratorSymbol = typeof Symbol !== "undefined" ? Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator")) : "@@iterator";
      var _asyncIteratorSymbol = typeof Symbol !== "undefined" ? Symbol.asyncIterator || (Symbol.asyncIterator = Symbol("Symbol.asyncIterator")) : "@@asyncIterator";
      function _catch(body, recover) {
        try {
          var result = body();
        } catch (e3) {
          return recover(e3);
        }
        if (result && result.then) {
          return result.then(void 0, recover);
        }
        return result;
      }
      var WALLETCONNECT_LOGO_SVG_URL = "data:image/svg+xml,%3Csvg height='185' viewBox='0 0 300 185' width='300' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='m61.4385429 36.2562612c48.9112241-47.8881663 128.2119871-47.8881663 177.1232091 0l5.886545 5.7634174c2.445561 2.3944081 2.445561 6.2765112 0 8.6709204l-20.136695 19.715503c-1.222781 1.1972051-3.2053 1.1972051-4.428081 0l-8.100584-7.9311479c-34.121692-33.4079817-89.443886-33.4079817-123.5655788 0l-8.6750562 8.4936051c-1.2227816 1.1972041-3.205301 1.1972041-4.4280806 0l-20.1366949-19.7155031c-2.4455612-2.3944092-2.4455612-6.2765122 0-8.6709204zm218.7677961 40.7737449 17.921697 17.546897c2.445549 2.3943969 2.445563 6.2764769.000031 8.6708899l-80.810171 79.121134c-2.445544 2.394426-6.410582 2.394453-8.85616.000062-.00001-.00001-.000022-.000022-.000032-.000032l-57.354143-56.154572c-.61139-.598602-1.60265-.598602-2.21404 0-.000004.000004-.000007.000008-.000011.000011l-57.3529212 56.154531c-2.4455368 2.394432-6.4105755 2.394472-8.8561612.000087-.0000143-.000014-.0000296-.000028-.0000449-.000044l-80.81241943-79.122185c-2.44556021-2.394408-2.44556021-6.2765115 0-8.6709197l17.92172963-17.5468673c2.4455602-2.3944082 6.4105989-2.3944082 8.8561602 0l57.3549775 56.155357c.6113908.598602 1.602649.598602 2.2140398 0 .0000092-.000009.0000174-.000017.0000265-.000024l57.3521031-56.155333c2.445505-2.3944633 6.410544-2.3945531 8.856161-.0002.000034.0000336.000068.0000673.000101.000101l57.354902 56.155432c.61139.598601 1.60265.598601 2.21404 0l57.353975-56.1543249c2.445561-2.3944092 6.410599-2.3944092 8.85616 0z' fill='%233b99fc'/%3E%3C/svg%3E";
      var WALLETCONNECT_HEADER_TEXT = "WalletConnect";
      var ANIMATION_DURATION = 300;
      var DEFAULT_BUTTON_COLOR = "rgb(64, 153, 255)";
      var WALLETCONNECT_WRAPPER_ID = "walletconnect-wrapper";
      var WALLETCONNECT_STYLE_ID = "walletconnect-style-sheet";
      var WALLETCONNECT_MODAL_ID = "walletconnect-qrcode-modal";
      var WALLETCONNECT_CLOSE_BUTTON_ID = "walletconnect-qrcode-close";
      var WALLETCONNECT_CTA_TEXT_ID = "walletconnect-qrcode-text";
      var WALLETCONNECT_CONNECT_BUTTON_ID = "walletconnect-connect-button";
      function Header(props) {
        return React.createElement("div", {
          className: "walletconnect-modal__header"
        }, React.createElement("img", {
          src: WALLETCONNECT_LOGO_SVG_URL,
          className: "walletconnect-modal__headerLogo"
        }), React.createElement("p", null, WALLETCONNECT_HEADER_TEXT), React.createElement("div", {
          className: "walletconnect-modal__close__wrapper",
          onClick: props.onClose
        }, React.createElement("div", {
          id: WALLETCONNECT_CLOSE_BUTTON_ID,
          className: "walletconnect-modal__close__icon"
        }, React.createElement("div", {
          className: "walletconnect-modal__close__line1"
        }), React.createElement("div", {
          className: "walletconnect-modal__close__line2"
        }))));
      }
      function ConnectButton(props) {
        return React.createElement("a", {
          className: "walletconnect-connect__button",
          href: props.href,
          id: WALLETCONNECT_CONNECT_BUTTON_ID + "-" + props.name,
          onClick: props.onClick,
          rel: "noopener noreferrer",
          style: {
            backgroundColor: props.color
          },
          target: "_blank"
        }, props.name);
      }
      var CARET_SVG_URL = "data:image/svg+xml,%3Csvg fill='none' height='18' viewBox='0 0 8 18' width='8' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath clip-rule='evenodd' d='m.586301.213898c-.435947.33907-.5144813.967342-.175411 1.403292l4.87831 6.27212c.28087.36111.28087.86677 0 1.22788l-4.878311 6.27211c-.33907.436-.260536 1.0642.175412 1.4033.435949.3391 1.064219.2605 1.403289-.1754l4.87832-6.2721c.84259-1.08336.84259-2.60034 0-3.68367l-4.87832-6.27212c-.33907-.4359474-.96734-.514482-1.403289-.175412z' fill='%233c4252' fill-rule='evenodd'/%3E%3C/svg%3E";
      function WalletButton(props) {
        var color = props.color;
        var href = props.href;
        var name2 = props.name;
        var logo = props.logo;
        var onClick = props.onClick;
        return React.createElement("a", {
          className: "walletconnect-modal__base__row",
          href,
          onClick,
          rel: "noopener noreferrer",
          target: "_blank"
        }, React.createElement("h3", {
          className: "walletconnect-modal__base__row__h3"
        }, name2), React.createElement("div", {
          className: "walletconnect-modal__base__row__right"
        }, React.createElement("div", {
          className: "walletconnect-modal__base__row__right__app-icon",
          style: {
            background: "url('" + logo + "') " + color,
            backgroundSize: "100%"
          }
        }), React.createElement("img", {
          src: CARET_SVG_URL,
          className: "walletconnect-modal__base__row__right__caret"
        })));
      }
      function WalletIcon(props) {
        var color = props.color;
        var href = props.href;
        var name2 = props.name;
        var logo = props.logo;
        var onClick = props.onClick;
        var fontSize = window.innerWidth < 768 ? (name2.length > 8 ? 2.5 : 2.7) + "vw" : "inherit";
        return React.createElement("a", {
          className: "walletconnect-connect__button__icon_anchor",
          href,
          onClick,
          rel: "noopener noreferrer",
          target: "_blank"
        }, React.createElement("div", {
          className: "walletconnect-connect__button__icon",
          style: {
            background: "url('" + logo + "') " + color,
            backgroundSize: "100%"
          }
        }), React.createElement("div", {
          style: {
            fontSize
          },
          className: "walletconnect-connect__button__text"
        }, name2));
      }
      var GRID_MIN_COUNT = 5;
      var LINKS_PER_PAGE = 12;
      function LinkDisplay(props) {
        var android = browserUtils.isAndroid();
        var ref = React.useState("");
        var input = ref[0];
        var setInput = ref[1];
        var ref$1 = React.useState("");
        var filter = ref$1[0];
        var setFilter = ref$1[1];
        var ref$2 = React.useState(1);
        var page = ref$2[0];
        var setPage = ref$2[1];
        var links = filter ? props.links.filter(function(link) {
          return link.name.toLowerCase().includes(filter.toLowerCase());
        }) : props.links;
        var errorMessage = props.errorMessage;
        var grid = filter || links.length > GRID_MIN_COUNT;
        var pages = Math.ceil(links.length / LINKS_PER_PAGE);
        var range = [(page - 1) * LINKS_PER_PAGE + 1, page * LINKS_PER_PAGE];
        var pageLinks = links.length ? links.filter(function(_4, index2) {
          return index2 + 1 >= range[0] && index2 + 1 <= range[1];
        }) : [];
        var hasPaging = !!(!android && pages > 1);
        var filterTimeout = void 0;
        function handleInput(e3) {
          setInput(e3.target.value);
          clearTimeout(filterTimeout);
          if (e3.target.value) {
            filterTimeout = setTimeout(function() {
              setFilter(e3.target.value);
              setPage(1);
            }, 1e3);
          } else {
            setInput("");
            setFilter("");
            setPage(1);
          }
        }
        return React.createElement("div", null, React.createElement("p", {
          id: WALLETCONNECT_CTA_TEXT_ID,
          className: "walletconnect-qrcode__text"
        }, android ? props.text.connect_mobile_wallet : props.text.choose_preferred_wallet), !android && React.createElement("input", {
          className: "walletconnect-search__input",
          placeholder: "Search",
          value: input,
          onChange: handleInput
        }), React.createElement("div", {
          className: "walletconnect-connect__buttons__wrapper" + (android ? "__android" : grid && links.length ? "__wrap" : "")
        }, !android ? pageLinks.length ? pageLinks.map(function(entry) {
          var color = entry.color;
          var name2 = entry.name;
          var shortName = entry.shortName;
          var logo = entry.logo;
          var href = browserUtils.formatIOSMobile(props.uri, entry);
          var handleClickIOS = React.useCallback(function() {
            browserUtils.saveMobileLinkInfo({
              name: name2,
              href
            });
          }, [pageLinks]);
          return !grid ? React.createElement(WalletButton, {
            color,
            href,
            name: name2,
            logo,
            onClick: handleClickIOS
          }) : React.createElement(WalletIcon, {
            color,
            href,
            name: shortName || name2,
            logo,
            onClick: handleClickIOS
          });
        }) : React.createElement(React.Fragment, null, React.createElement("p", null, errorMessage.length ? props.errorMessage : !!props.links.length && !links.length ? props.text.no_wallets_found : props.text.loading)) : React.createElement(ConnectButton, {
          name: props.text.connect,
          color: DEFAULT_BUTTON_COLOR,
          href: props.uri,
          onClick: React.useCallback(function() {
            browserUtils.saveMobileLinkInfo({
              name: "Unknown",
              href: props.uri
            });
          }, [])
        })), hasPaging && React.createElement("div", {
          className: "walletconnect-modal__footer"
        }, Array(pages).fill(0).map(function(_4, index2) {
          var pageNumber = index2 + 1;
          var selected = page === pageNumber;
          return React.createElement("a", {
            style: {
              margin: "auto 10px",
              fontWeight: selected ? "bold" : "normal"
            },
            onClick: function() {
              return setPage(pageNumber);
            }
          }, pageNumber);
        })));
      }
      function Notification(props) {
        var show = !!props.message.trim();
        return React.createElement("div", {
          className: "walletconnect-qrcode__notification" + (show ? " notification__show" : "")
        }, props.message);
      }
      var formatQRCodeImage = function(data4) {
        try {
          var result = "";
          return Promise.resolve(QRCode.toString(data4, {
            margin: 0,
            type: "svg"
          })).then(function(dataString) {
            if (typeof dataString === "string") {
              result = dataString.replace("<svg", '<svg class="walletconnect-qrcode__image"');
            }
            return result;
          });
        } catch (e3) {
          return Promise.reject(e3);
        }
      };
      function QRCodeDisplay(props) {
        var ref = React.useState("");
        var notification = ref[0];
        var setNotification = ref[1];
        var ref$1 = React.useState("");
        var svg = ref$1[0];
        var setSvg = ref$1[1];
        React.useEffect(function() {
          try {
            return Promise.resolve(formatQRCodeImage(props.uri)).then(function(_formatQRCodeImage) {
              setSvg(_formatQRCodeImage);
            });
          } catch (e3) {
            Promise.reject(e3);
          }
        }, []);
        var copyToClipboard = function() {
          var success = copy(props.uri);
          if (success) {
            setNotification(props.text.copied_to_clipboard);
            setInterval(function() {
              return setNotification("");
            }, 1200);
          } else {
            setNotification("Error");
            setInterval(function() {
              return setNotification("");
            }, 1200);
          }
        };
        return React.createElement("div", null, React.createElement("p", {
          id: WALLETCONNECT_CTA_TEXT_ID,
          className: "walletconnect-qrcode__text"
        }, props.text.scan_qrcode_with_wallet), React.createElement("div", {
          dangerouslySetInnerHTML: {
            __html: svg
          }
        }), React.createElement("div", {
          className: "walletconnect-modal__footer"
        }, React.createElement("a", {
          onClick: copyToClipboard
        }, props.text.copy_to_clipboard)), React.createElement(Notification, {
          message: notification
        }));
      }
      function Modal(props) {
        var android = browserUtils.isAndroid();
        var mobile = browserUtils.isMobile();
        var whitelist = mobile ? props.qrcodeModalOptions && props.qrcodeModalOptions.mobileLinks ? props.qrcodeModalOptions.mobileLinks : void 0 : props.qrcodeModalOptions && props.qrcodeModalOptions.desktopLinks ? props.qrcodeModalOptions.desktopLinks : void 0;
        var ref = React.useState(false);
        var loading = ref[0];
        var setLoading = ref[1];
        var ref$1 = React.useState(false);
        var fetched = ref$1[0];
        var setFetched = ref$1[1];
        var ref$2 = React.useState(!mobile);
        var displayQRCode = ref$2[0];
        var setDisplayQRCode = ref$2[1];
        var displayProps = {
          mobile,
          text: props.text,
          uri: props.uri,
          qrcodeModalOptions: props.qrcodeModalOptions
        };
        var ref$3 = React.useState("");
        var singleLinkHref = ref$3[0];
        var setSingleLinkHref = ref$3[1];
        var ref$4 = React.useState(false);
        var hasSingleLink = ref$4[0];
        var setHasSingleLink = ref$4[1];
        var ref$5 = React.useState([]);
        var links = ref$5[0];
        var setLinks = ref$5[1];
        var ref$6 = React.useState("");
        var errorMessage = ref$6[0];
        var setErrorMessage = ref$6[1];
        var getLinksIfNeeded = function() {
          if (fetched || loading || whitelist && !whitelist.length || links.length > 0) {
            return;
          }
          React.useEffect(function() {
            var initLinks = function() {
              try {
                if (android) {
                  return Promise.resolve();
                }
                setLoading(true);
                var _temp = _catch(function() {
                  var url = props.qrcodeModalOptions && props.qrcodeModalOptions.registryUrl ? props.qrcodeModalOptions.registryUrl : browserUtils.getWalletRegistryUrl();
                  return Promise.resolve(fetch(url)).then(function(registryResponse) {
                    return Promise.resolve(registryResponse.json()).then(function(_registryResponse$jso) {
                      var registry = _registryResponse$jso.listings;
                      var platform = mobile ? "mobile" : "desktop";
                      var _links = browserUtils.getMobileLinkRegistry(browserUtils.formatMobileRegistry(registry, platform), whitelist);
                      setLoading(false);
                      setFetched(true);
                      setErrorMessage(!_links.length ? props.text.no_supported_wallets : "");
                      setLinks(_links);
                      var hasSingleLink2 = _links.length === 1;
                      if (hasSingleLink2) {
                        setSingleLinkHref(browserUtils.formatIOSMobile(props.uri, _links[0]));
                        setDisplayQRCode(true);
                      }
                      setHasSingleLink(hasSingleLink2);
                    });
                  });
                }, function(e3) {
                  setLoading(false);
                  setFetched(true);
                  setErrorMessage(props.text.something_went_wrong);
                  console.error(e3);
                });
                return Promise.resolve(_temp && _temp.then ? _temp.then(function() {
                }) : void 0);
              } catch (e3) {
                return Promise.reject(e3);
              }
            };
            initLinks();
          });
        };
        getLinksIfNeeded();
        var rightSelected = mobile ? displayQRCode : !displayQRCode;
        return React.createElement("div", {
          id: WALLETCONNECT_MODAL_ID,
          className: "walletconnect-qrcode__base animated fadeIn"
        }, React.createElement("div", {
          className: "walletconnect-modal__base"
        }, React.createElement(Header, {
          onClose: props.onClose
        }), hasSingleLink && displayQRCode ? React.createElement("div", {
          className: "walletconnect-modal__single_wallet"
        }, React.createElement("a", {
          onClick: function() {
            return browserUtils.saveMobileLinkInfo({
              name: links[0].name,
              href: singleLinkHref
            });
          },
          href: singleLinkHref,
          rel: "noopener noreferrer",
          target: "_blank"
        }, props.text.connect_with + " " + (hasSingleLink ? links[0].name : "") + " \u203A")) : android || loading || !loading && links.length ? React.createElement("div", {
          className: "walletconnect-modal__mobile__toggle" + (rightSelected ? " right__selected" : "")
        }, React.createElement("div", {
          className: "walletconnect-modal__mobile__toggle_selector"
        }), mobile ? React.createElement(React.Fragment, null, React.createElement("a", {
          onClick: function() {
            return setDisplayQRCode(false), getLinksIfNeeded();
          }
        }, props.text.mobile), React.createElement("a", {
          onClick: function() {
            return setDisplayQRCode(true);
          }
        }, props.text.qrcode)) : React.createElement(React.Fragment, null, React.createElement("a", {
          onClick: function() {
            return setDisplayQRCode(true);
          }
        }, props.text.qrcode), React.createElement("a", {
          onClick: function() {
            return setDisplayQRCode(false), getLinksIfNeeded();
          }
        }, props.text.desktop))) : null, React.createElement("div", null, displayQRCode || !android && !loading && !links.length ? React.createElement(QRCodeDisplay, Object.assign({}, displayProps)) : React.createElement(LinkDisplay, Object.assign({}, displayProps, {
          links,
          errorMessage
        })))));
      }
      var de = {
        choose_preferred_wallet: "W\xE4hle bevorzugte Wallet",
        connect_mobile_wallet: "Verbinde mit Mobile Wallet",
        scan_qrcode_with_wallet: "Scanne den QR-code mit einer WalletConnect kompatiblen Wallet",
        connect: "Verbinden",
        qrcode: "QR-Code",
        mobile: "Mobile",
        desktop: "Desktop",
        copy_to_clipboard: "In die Zwischenablage kopieren",
        copied_to_clipboard: "In die Zwischenablage kopiert!",
        connect_with: "Verbinden mit Hilfe von",
        loading: "Laden...",
        something_went_wrong: "Etwas ist schief gelaufen",
        no_supported_wallets: "Es gibt noch keine unterst\xFCtzten Wallet",
        no_wallets_found: "keine Wallet gefunden"
      };
      var en = {
        choose_preferred_wallet: "Choose your preferred wallet",
        connect_mobile_wallet: "Connect to Mobile Wallet",
        scan_qrcode_with_wallet: "Scan QR code with a WalletConnect-compatible wallet",
        connect: "Connect",
        qrcode: "QR Code",
        mobile: "Mobile",
        desktop: "Desktop",
        copy_to_clipboard: "Copy to clipboard",
        copied_to_clipboard: "Copied to clipboard!",
        connect_with: "Connect with",
        loading: "Loading...",
        something_went_wrong: "Something went wrong",
        no_supported_wallets: "There are no supported wallets yet",
        no_wallets_found: "No wallets found"
      };
      var es = {
        choose_preferred_wallet: "Elige tu billetera preferida",
        connect_mobile_wallet: "Conectar a billetera m\xF3vil",
        scan_qrcode_with_wallet: "Escanea el c\xF3digo QR con una billetera compatible con WalletConnect",
        connect: "Conectar",
        qrcode: "C\xF3digo QR",
        mobile: "M\xF3vil",
        desktop: "Desktop",
        copy_to_clipboard: "Copiar",
        copied_to_clipboard: "Copiado!",
        connect_with: "Conectar mediante",
        loading: "Cargando...",
        something_went_wrong: "Algo sali\xF3 mal",
        no_supported_wallets: "Todav\xEDa no hay billeteras compatibles",
        no_wallets_found: "No se encontraron billeteras"
      };
      var fr = {
        choose_preferred_wallet: "Choisissez votre portefeuille pr\xE9f\xE9r\xE9",
        connect_mobile_wallet: "Se connecter au portefeuille mobile",
        scan_qrcode_with_wallet: "Scannez le QR code avec un portefeuille compatible WalletConnect",
        connect: "Se connecter",
        qrcode: "QR Code",
        mobile: "Mobile",
        desktop: "Desktop",
        copy_to_clipboard: "Copier",
        copied_to_clipboard: "Copi\xE9!",
        connect_with: "Connectez-vous \xE0 l'aide de",
        loading: "Chargement...",
        something_went_wrong: "Quelque chose a mal tourn\xE9",
        no_supported_wallets: "Il n'y a pas encore de portefeuilles pris en charge",
        no_wallets_found: "Aucun portefeuille trouv\xE9"
      };
      var ko = {
        choose_preferred_wallet: "\uC6D0\uD558\uB294 \uC9C0\uAC11\uC744 \uC120\uD0DD\uD558\uC138\uC694",
        connect_mobile_wallet: "\uBAA8\uBC14\uC77C \uC9C0\uAC11\uACFC \uC5F0\uACB0",
        scan_qrcode_with_wallet: "WalletConnect \uC9C0\uC6D0 \uC9C0\uAC11\uC5D0\uC11C QR\uCF54\uB4DC\uB97C \uC2A4\uCE94\uD558\uC138\uC694",
        connect: "\uC5F0\uACB0",
        qrcode: "QR \uCF54\uB4DC",
        mobile: "\uBAA8\uBC14\uC77C",
        desktop: "\uB370\uC2A4\uD06C\uD0D1",
        copy_to_clipboard: "\uD074\uB9BD\uBCF4\uB4DC\uC5D0 \uBCF5\uC0AC",
        copied_to_clipboard: "\uD074\uB9BD\uBCF4\uB4DC\uC5D0 \uBCF5\uC0AC\uB418\uC5C8\uC2B5\uB2C8\uB2E4!",
        connect_with: "\uC640 \uC5F0\uACB0\uD558\uB2E4",
        loading: "\uB85C\uB4DC \uC911...",
        something_went_wrong: "\uBB38\uC81C\uAC00 \uBC1C\uC0DD\uD588\uC2B5\uB2C8\uB2E4.",
        no_supported_wallets: "\uC544\uC9C1 \uC9C0\uC6D0\uB418\uB294 \uC9C0\uAC11\uC774 \uC5C6\uC2B5\uB2C8\uB2E4",
        no_wallets_found: "\uC9C0\uAC11\uC744 \uCC3E\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4"
      };
      var pt = {
        choose_preferred_wallet: "Escolha sua carteira preferida",
        connect_mobile_wallet: "Conectar-se \xE0 carteira m\xF3vel",
        scan_qrcode_with_wallet: "Ler o c\xF3digo QR com uma carteira compat\xEDvel com WalletConnect",
        connect: "Conectar",
        qrcode: "C\xF3digo QR",
        mobile: "M\xF3vel",
        desktop: "Desktop",
        copy_to_clipboard: "Copiar",
        copied_to_clipboard: "Copiado!",
        connect_with: "Ligar por meio de",
        loading: "Carregamento...",
        something_went_wrong: "Algo correu mal",
        no_supported_wallets: "Ainda n\xE3o h\xE1 carteiras suportadas",
        no_wallets_found: "Nenhuma carteira encontrada"
      };
      var zh = {
        choose_preferred_wallet: "\u9009\u62E9\u4F60\u7684\u94B1\u5305",
        connect_mobile_wallet: "\u8FDE\u63A5\u81F3\u79FB\u52A8\u7AEF\u94B1\u5305",
        scan_qrcode_with_wallet: "\u4F7F\u7528\u517C\u5BB9 WalletConnect \u7684\u94B1\u5305\u626B\u63CF\u4E8C\u7EF4\u7801",
        connect: "\u8FDE\u63A5",
        qrcode: "\u4E8C\u7EF4\u7801",
        mobile: "\u79FB\u52A8",
        desktop: "\u684C\u9762",
        copy_to_clipboard: "\u590D\u5236\u5230\u526A\u8D34\u677F",
        copied_to_clipboard: "\u590D\u5236\u5230\u526A\u8D34\u677F\u6210\u529F\uFF01",
        connect_with: "\u901A\u8FC7\u4EE5\u4E0B\u65B9\u5F0F\u8FDE\u63A5",
        loading: "\u6B63\u5728\u52A0\u8F7D...",
        something_went_wrong: "\u51FA\u4E86\u95EE\u9898",
        no_supported_wallets: "\u76EE\u524D\u8FD8\u6CA1\u6709\u652F\u6301\u7684\u94B1\u5305",
        no_wallets_found: "\u6CA1\u6709\u627E\u5230\u94B1\u5305"
      };
      var fa = {
        choose_preferred_wallet: "\u06A9\u06CC\u0641 \u067E\u0648\u0644 \u0645\u0648\u0631\u062F \u0646\u0638\u0631 \u062E\u0648\u062F \u0631\u0627 \u0627\u0646\u062A\u062E\u0627\u0628 \u06A9\u0646\u06CC\u062F",
        connect_mobile_wallet: "\u0628\u0647 \u06A9\u06CC\u0641 \u067E\u0648\u0644 \u0645\u0648\u0628\u0627\u06CC\u0644 \u0648\u0635\u0644 \u0634\u0648\u06CC\u062F",
        scan_qrcode_with_wallet: "\u06A9\u062F QR \u0631\u0627 \u0628\u0627 \u06CC\u06A9 \u06A9\u06CC\u0641 \u067E\u0648\u0644 \u0633\u0627\u0632\u06AF\u0627\u0631 \u0628\u0627 WalletConnect \u0627\u0633\u06A9\u0646 \u06A9\u0646\u06CC\u062F",
        connect: "\u0627\u062A\u0635\u0627\u0644",
        qrcode: "\u06A9\u062F QR",
        mobile: "\u0633\u06CC\u0627\u0631",
        desktop: "\u062F\u0633\u06A9\u062A\u0627\u067E",
        copy_to_clipboard: "\u06A9\u067E\u06CC \u0628\u0647 \u06A9\u0644\u06CC\u067E \u0628\u0648\u0631\u062F",
        copied_to_clipboard: "\u062F\u0631 \u06A9\u0644\u06CC\u067E \u0628\u0648\u0631\u062F \u06A9\u067E\u06CC \u0634\u062F!",
        connect_with: "\u0627\u0631\u062A\u0628\u0627\u0637 \u0628\u0627",
        loading: "...\u0628\u0627\u0631\u06AF\u0630\u0627\u0631\u06CC",
        something_went_wrong: "\u0645\u0634\u06A9\u0644\u06CC \u067E\u06CC\u0634 \u0622\u0645\u062F",
        no_supported_wallets: "\u0647\u0646\u0648\u0632 \u0647\u06CC\u0686 \u06A9\u06CC\u0641 \u067E\u0648\u0644 \u067E\u0634\u062A\u06CC\u0628\u0627\u0646\u06CC \u0634\u062F\u0647 \u0627\u06CC \u0648\u062C\u0648\u062F \u0646\u062F\u0627\u0631\u062F",
        no_wallets_found: "\u0647\u06CC\u0686 \u06A9\u06CC\u0641 \u067E\u0648\u0644\u06CC \u067E\u06CC\u062F\u0627 \u0646\u0634\u062F"
      };
      var languages = {
        de,
        en,
        es,
        fr,
        ko,
        pt,
        zh,
        fa
      };
      function injectStyleSheet() {
        var doc = browserUtils.getDocumentOrThrow();
        var prev = doc.getElementById(WALLETCONNECT_STYLE_ID);
        if (prev) {
          doc.head.removeChild(prev);
        }
        var style2 = doc.createElement("style");
        style2.setAttribute("id", WALLETCONNECT_STYLE_ID);
        style2.innerText = WALLETCONNECT_STYLE_SHEET;
        doc.head.appendChild(style2);
      }
      function renderWrapper() {
        var doc = browserUtils.getDocumentOrThrow();
        var wrapper = doc.createElement("div");
        wrapper.setAttribute("id", WALLETCONNECT_WRAPPER_ID);
        doc.body.appendChild(wrapper);
        return wrapper;
      }
      function triggerCloseAnimation() {
        var doc = browserUtils.getDocumentOrThrow();
        var modal = doc.getElementById(WALLETCONNECT_MODAL_ID);
        if (modal) {
          modal.className = modal.className.replace("fadeIn", "fadeOut");
          setTimeout(function() {
            var wrapper = doc.getElementById(WALLETCONNECT_WRAPPER_ID);
            if (wrapper) {
              doc.body.removeChild(wrapper);
            }
          }, ANIMATION_DURATION);
        }
      }
      function getWrappedCallback(cb) {
        return function() {
          triggerCloseAnimation();
          if (cb) {
            cb();
          }
        };
      }
      function getText() {
        var lang = browserUtils.getNavigatorOrThrow().language.split("-")[0] || "en";
        return languages[lang] || languages["en"];
      }
      function open$1(uri, cb, qrcodeModalOptions) {
        injectStyleSheet();
        var wrapper = renderWrapper();
        React.render(React.createElement(Modal, {
          text: getText(),
          uri,
          onClose: getWrappedCallback(cb),
          qrcodeModalOptions
        }), wrapper);
      }
      function close$1() {
        triggerCloseAnimation();
      }
      var isNode3 = function() {
        return typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.node !== "undefined";
      };
      function open$2(uri, cb, qrcodeModalOptions) {
        console.log(uri);
        if (isNode3()) {
          open(uri);
        } else {
          open$1(uri, cb, qrcodeModalOptions);
        }
      }
      function close$2() {
        if (isNode3())
          ;
        else {
          close$1();
        }
      }
      var index = {
        open: open$2,
        close: close$2
      };
      module.exports = index;
    }
  });

  // src/index.ts
  var src_exports = {};
  __export(src_exports, {
    Handler: () => Handler,
    Transaction: () => Transaction,
    default: () => src_default
  });

  // src/domain/handler/findBlock.ts
  var import_luxon = __toModule(require_luxon());
  function findBlock(_0, _1) {
    return __async(this, arguments, function* (provider, { date, timezone = "UTC", blocksPerMinute = 4 }) {
      const MIN = 60;
      const dateInSecs = import_luxon.DateTime.fromISO(date, {
        zone: timezone
      }).toSeconds();
      const calcSecs = (blockTimeStamp, timestamp) => Math.abs(blockTimeStamp - timestamp);
      const convertSecsToMin = (sec) => sec / MIN;
      const countBlock = (min) => Math.floor(min * blocksPerMinute);
      const latestBlock = yield provider.getBlock("latest");
      const afterLatestBlock = dateInSecs > latestBlock.timestamp;
      const countedBlock = countBlock(convertSecsToMin(calcSecs(latestBlock.timestamp, dateInSecs)));
      if (afterLatestBlock)
        return {
          timestamp: dateInSecs,
          block: latestBlock.number + countedBlock
        };
      const firstBlock = yield provider.getBlock(1);
      const beforeFirstBlock = dateInSecs < firstBlock.timestamp;
      if (beforeFirstBlock)
        return {
          timestamp: firstBlock.timestamp,
          block: firstBlock.number
        };
      const approximatedNumber = latestBlock.number - countedBlock;
      const approximatedBlock = yield provider.getBlock(approximatedNumber);
      return {
        timestamp: approximatedBlock.timestamp,
        block: approximatedBlock.number
      };
    });
  }

  // src/domain/transaction/transaction.ts
  var hasEvents = (item) => !!(item.events && Array.isArray(item.events));
  var Transaction = class {
    constructor(hash3, tx) {
      this.hash = hash3;
      this.rawTransaction = tx;
    }
    wait() {
      return __async(this, null, function* () {
        const receipt = yield this.rawTransaction.wait();
        let events;
        if (hasEvents(receipt)) {
          events = receipt.events.map((elm) => {
            if (!elm.event)
              return null;
            const args = Array.isArray(elm.args) ? elm.args.map((arg) => arg.toString()) : [];
            return {
              name: elm.event,
              signature: elm.eventSignature,
              args
            };
          }).filter((elm) => !!elm);
        } else {
          events = [];
        }
        return {
          blockNumber: receipt.blockNumber,
          blockHash: receipt.blockHash,
          transactionHash: receipt.transactionHash,
          success: Boolean(receipt.status),
          events,
          rawReceipt: receipt
        };
      });
    }
  };

  // node_modules/ethers/lib.esm/ethers.js
  var ethers_exports = {};
  __export(ethers_exports, {
    BaseContract: () => BaseContract,
    BigNumber: () => BigNumber,
    Contract: () => Contract,
    ContractFactory: () => ContractFactory,
    FixedNumber: () => FixedNumber,
    Signer: () => Signer,
    VoidSigner: () => VoidSigner,
    Wallet: () => Wallet,
    Wordlist: () => Wordlist,
    constants: () => lib_exports2,
    errors: () => ErrorCode,
    getDefaultProvider: () => getDefaultProvider,
    logger: () => logger44,
    providers: () => lib_exports4,
    utils: () => utils_exports,
    version: () => version25,
    wordlists: () => wordlists
  });

  // node_modules/@ethersproject/bignumber/lib.esm/bignumber.js
  var import_bn = __toModule(require_bn());

  // node_modules/@ethersproject/logger/lib.esm/_version.js
  var version = "logger/5.4.0";

  // node_modules/@ethersproject/logger/lib.esm/index.js
  "use strict";
  var _permanentCensorErrors = false;
  var _censorErrors = false;
  var LogLevels = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
  var _logLevel = LogLevels["default"];
  var _globalLogger = null;
  function _checkNormalize() {
    try {
      const missing = [];
      ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
        try {
          if ("test".normalize(form) !== "test") {
            throw new Error("bad normalize");
          }
          ;
        } catch (error) {
          missing.push(form);
        }
      });
      if (missing.length) {
        throw new Error("missing " + missing.join(", "));
      }
      if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
        throw new Error("broken implementation");
      }
    } catch (error) {
      return error.message;
    }
    return null;
  }
  var _normalizeError = _checkNormalize();
  var LogLevel;
  (function(LogLevel2) {
    LogLevel2["DEBUG"] = "DEBUG";
    LogLevel2["INFO"] = "INFO";
    LogLevel2["WARNING"] = "WARNING";
    LogLevel2["ERROR"] = "ERROR";
    LogLevel2["OFF"] = "OFF";
  })(LogLevel || (LogLevel = {}));
  var ErrorCode;
  (function(ErrorCode2) {
    ErrorCode2["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
    ErrorCode2["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
    ErrorCode2["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
    ErrorCode2["NETWORK_ERROR"] = "NETWORK_ERROR";
    ErrorCode2["SERVER_ERROR"] = "SERVER_ERROR";
    ErrorCode2["TIMEOUT"] = "TIMEOUT";
    ErrorCode2["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
    ErrorCode2["NUMERIC_FAULT"] = "NUMERIC_FAULT";
    ErrorCode2["MISSING_NEW"] = "MISSING_NEW";
    ErrorCode2["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
    ErrorCode2["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
    ErrorCode2["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
    ErrorCode2["CALL_EXCEPTION"] = "CALL_EXCEPTION";
    ErrorCode2["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
    ErrorCode2["NONCE_EXPIRED"] = "NONCE_EXPIRED";
    ErrorCode2["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
    ErrorCode2["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
    ErrorCode2["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
  })(ErrorCode || (ErrorCode = {}));
  var Logger = class {
    constructor(version26) {
      Object.defineProperty(this, "version", {
        enumerable: true,
        value: version26,
        writable: false
      });
    }
    _log(logLevel, args) {
      const level = logLevel.toLowerCase();
      if (LogLevels[level] == null) {
        this.throwArgumentError("invalid log level name", "logLevel", logLevel);
      }
      if (_logLevel > LogLevels[level]) {
        return;
      }
      console.log.apply(console, args);
    }
    debug(...args) {
      this._log(Logger.levels.DEBUG, args);
    }
    info(...args) {
      this._log(Logger.levels.INFO, args);
    }
    warn(...args) {
      this._log(Logger.levels.WARNING, args);
    }
    makeError(message, code, params) {
      if (_censorErrors) {
        return this.makeError("censored error", code, {});
      }
      if (!code) {
        code = Logger.errors.UNKNOWN_ERROR;
      }
      if (!params) {
        params = {};
      }
      const messageDetails = [];
      Object.keys(params).forEach((key2) => {
        try {
          messageDetails.push(key2 + "=" + JSON.stringify(params[key2]));
        } catch (error2) {
          messageDetails.push(key2 + "=" + JSON.stringify(params[key2].toString()));
        }
      });
      messageDetails.push(`code=${code}`);
      messageDetails.push(`version=${this.version}`);
      const reason = message;
      if (messageDetails.length) {
        message += " (" + messageDetails.join(", ") + ")";
      }
      const error = new Error(message);
      error.reason = reason;
      error.code = code;
      Object.keys(params).forEach(function(key2) {
        error[key2] = params[key2];
      });
      return error;
    }
    throwError(message, code, params) {
      throw this.makeError(message, code, params);
    }
    throwArgumentError(message, name2, value) {
      return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {
        argument: name2,
        value
      });
    }
    assert(condition, message, code, params) {
      if (!!condition) {
        return;
      }
      this.throwError(message, code, params);
    }
    assertArgument(condition, message, name2, value) {
      if (!!condition) {
        return;
      }
      this.throwArgumentError(message, name2, value);
    }
    checkNormalize(message) {
      if (message == null) {
        message = "platform missing String.prototype.normalize";
      }
      if (_normalizeError) {
        this.throwError("platform missing String.prototype.normalize", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "String.prototype.normalize",
          form: _normalizeError
        });
      }
    }
    checkSafeUint53(value, message) {
      if (typeof value !== "number") {
        return;
      }
      if (message == null) {
        message = "value not safe";
      }
      if (value < 0 || value >= 9007199254740991) {
        this.throwError(message, Logger.errors.NUMERIC_FAULT, {
          operation: "checkSafeInteger",
          fault: "out-of-safe-range",
          value
        });
      }
      if (value % 1) {
        this.throwError(message, Logger.errors.NUMERIC_FAULT, {
          operation: "checkSafeInteger",
          fault: "non-integer",
          value
        });
      }
    }
    checkArgumentCount(count, expectedCount, message) {
      if (message) {
        message = ": " + message;
      } else {
        message = "";
      }
      if (count < expectedCount) {
        this.throwError("missing argument" + message, Logger.errors.MISSING_ARGUMENT, {
          count,
          expectedCount
        });
      }
      if (count > expectedCount) {
        this.throwError("too many arguments" + message, Logger.errors.UNEXPECTED_ARGUMENT, {
          count,
          expectedCount
        });
      }
    }
    checkNew(target, kind) {
      if (target === Object || target == null) {
        this.throwError("missing new", Logger.errors.MISSING_NEW, { name: kind.name });
      }
    }
    checkAbstract(target, kind) {
      if (target === kind) {
        this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
      } else if (target === Object || target == null) {
        this.throwError("missing new", Logger.errors.MISSING_NEW, { name: kind.name });
      }
    }
    static globalLogger() {
      if (!_globalLogger) {
        _globalLogger = new Logger(version);
      }
      return _globalLogger;
    }
    static setCensorship(censorship, permanent) {
      if (!censorship && permanent) {
        this.globalLogger().throwError("cannot permanently disable censorship", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "setCensorship"
        });
      }
      if (_permanentCensorErrors) {
        if (!censorship) {
          return;
        }
        this.globalLogger().throwError("error censorship permanent", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "setCensorship"
        });
      }
      _censorErrors = !!censorship;
      _permanentCensorErrors = !!permanent;
    }
    static setLogLevel(logLevel) {
      const level = LogLevels[logLevel.toLowerCase()];
      if (level == null) {
        Logger.globalLogger().warn("invalid log level - " + logLevel);
        return;
      }
      _logLevel = level;
    }
    static from(version26) {
      return new Logger(version26);
    }
  };
  Logger.errors = ErrorCode;
  Logger.levels = LogLevel;

  // node_modules/@ethersproject/bytes/lib.esm/_version.js
  var version2 = "bytes/5.4.0";

  // node_modules/@ethersproject/bytes/lib.esm/index.js
  "use strict";
  var logger = new Logger(version2);
  function isHexable(value) {
    return !!value.toHexString;
  }
  function addSlice(array) {
    if (array.slice) {
      return array;
    }
    array.slice = function() {
      const args = Array.prototype.slice.call(arguments);
      return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));
    };
    return array;
  }
  function isBytesLike(value) {
    return isHexString(value) && !(value.length % 2) || isBytes(value);
  }
  function isBytes(value) {
    if (value == null) {
      return false;
    }
    if (value.constructor === Uint8Array) {
      return true;
    }
    if (typeof value === "string") {
      return false;
    }
    if (value.length == null) {
      return false;
    }
    for (let i3 = 0; i3 < value.length; i3++) {
      const v3 = value[i3];
      if (typeof v3 !== "number" || v3 < 0 || v3 >= 256 || v3 % 1) {
        return false;
      }
    }
    return true;
  }
  function arrayify(value, options) {
    if (!options) {
      options = {};
    }
    if (typeof value === "number") {
      logger.checkSafeUint53(value, "invalid arrayify value");
      const result = [];
      while (value) {
        result.unshift(value & 255);
        value = parseInt(String(value / 256));
      }
      if (result.length === 0) {
        result.push(0);
      }
      return addSlice(new Uint8Array(result));
    }
    if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
      value = "0x" + value;
    }
    if (isHexable(value)) {
      value = value.toHexString();
    }
    if (isHexString(value)) {
      let hex2 = value.substring(2);
      if (hex2.length % 2) {
        if (options.hexPad === "left") {
          hex2 = "0x0" + hex2.substring(2);
        } else if (options.hexPad === "right") {
          hex2 += "0";
        } else {
          logger.throwArgumentError("hex data is odd-length", "value", value);
        }
      }
      const result = [];
      for (let i3 = 0; i3 < hex2.length; i3 += 2) {
        result.push(parseInt(hex2.substring(i3, i3 + 2), 16));
      }
      return addSlice(new Uint8Array(result));
    }
    if (isBytes(value)) {
      return addSlice(new Uint8Array(value));
    }
    return logger.throwArgumentError("invalid arrayify value", "value", value);
  }
  function concat(items) {
    const objects = items.map((item) => arrayify(item));
    const length = objects.reduce((accum, item) => accum + item.length, 0);
    const result = new Uint8Array(length);
    objects.reduce((offset, object) => {
      result.set(object, offset);
      return offset + object.length;
    }, 0);
    return addSlice(result);
  }
  function stripZeros(value) {
    let result = arrayify(value);
    if (result.length === 0) {
      return result;
    }
    let start = 0;
    while (start < result.length && result[start] === 0) {
      start++;
    }
    if (start) {
      result = result.slice(start);
    }
    return result;
  }
  function zeroPad(value, length) {
    value = arrayify(value);
    if (value.length > length) {
      logger.throwArgumentError("value out of range", "value", arguments[0]);
    }
    const result = new Uint8Array(length);
    result.set(value, length - value.length);
    return addSlice(result);
  }
  function isHexString(value, length) {
    if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
      return false;
    }
    if (length && value.length !== 2 + 2 * length) {
      return false;
    }
    return true;
  }
  var HexCharacters = "0123456789abcdef";
  function hexlify(value, options) {
    if (!options) {
      options = {};
    }
    if (typeof value === "number") {
      logger.checkSafeUint53(value, "invalid hexlify value");
      let hex2 = "";
      while (value) {
        hex2 = HexCharacters[value & 15] + hex2;
        value = Math.floor(value / 16);
      }
      if (hex2.length) {
        if (hex2.length % 2) {
          hex2 = "0" + hex2;
        }
        return "0x" + hex2;
      }
      return "0x00";
    }
    if (typeof value === "bigint") {
      value = value.toString(16);
      if (value.length % 2) {
        return "0x0" + value;
      }
      return "0x" + value;
    }
    if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
      value = "0x" + value;
    }
    if (isHexable(value)) {
      return value.toHexString();
    }
    if (isHexString(value)) {
      if (value.length % 2) {
        if (options.hexPad === "left") {
          value = "0x0" + value.substring(2);
        } else if (options.hexPad === "right") {
          value += "0";
        } else {
          logger.throwArgumentError("hex data is odd-length", "value", value);
        }
      }
      return value.toLowerCase();
    }
    if (isBytes(value)) {
      let result = "0x";
      for (let i3 = 0; i3 < value.length; i3++) {
        let v3 = value[i3];
        result += HexCharacters[(v3 & 240) >> 4] + HexCharacters[v3 & 15];
      }
      return result;
    }
    return logger.throwArgumentError("invalid hexlify value", "value", value);
  }
  function hexDataLength(data4) {
    if (typeof data4 !== "string") {
      data4 = hexlify(data4);
    } else if (!isHexString(data4) || data4.length % 2) {
      return null;
    }
    return (data4.length - 2) / 2;
  }
  function hexDataSlice(data4, offset, endOffset) {
    if (typeof data4 !== "string") {
      data4 = hexlify(data4);
    } else if (!isHexString(data4) || data4.length % 2) {
      logger.throwArgumentError("invalid hexData", "value", data4);
    }
    offset = 2 + 2 * offset;
    if (endOffset != null) {
      return "0x" + data4.substring(offset, 2 + 2 * endOffset);
    }
    return "0x" + data4.substring(offset);
  }
  function hexConcat(items) {
    let result = "0x";
    items.forEach((item) => {
      result += hexlify(item).substring(2);
    });
    return result;
  }
  function hexValue(value) {
    const trimmed = hexStripZeros(hexlify(value, { hexPad: "left" }));
    if (trimmed === "0x") {
      return "0x0";
    }
    return trimmed;
  }
  function hexStripZeros(value) {
    if (typeof value !== "string") {
      value = hexlify(value);
    }
    if (!isHexString(value)) {
      logger.throwArgumentError("invalid hex string", "value", value);
    }
    value = value.substring(2);
    let offset = 0;
    while (offset < value.length && value[offset] === "0") {
      offset++;
    }
    return "0x" + value.substring(offset);
  }
  function hexZeroPad(value, length) {
    if (typeof value !== "string") {
      value = hexlify(value);
    } else if (!isHexString(value)) {
      logger.throwArgumentError("invalid hex string", "value", value);
    }
    if (value.length > 2 * length + 2) {
      logger.throwArgumentError("value out of range", "value", arguments[1]);
    }
    while (value.length < 2 * length + 2) {
      value = "0x0" + value.substring(2);
    }
    return value;
  }
  function splitSignature(signature2) {
    const result = {
      r: "0x",
      s: "0x",
      _vs: "0x",
      recoveryParam: 0,
      v: 0
    };
    if (isBytesLike(signature2)) {
      const bytes = arrayify(signature2);
      if (bytes.length !== 65) {
        logger.throwArgumentError("invalid signature string; must be 65 bytes", "signature", signature2);
      }
      result.r = hexlify(bytes.slice(0, 32));
      result.s = hexlify(bytes.slice(32, 64));
      result.v = bytes[64];
      if (result.v < 27) {
        if (result.v === 0 || result.v === 1) {
          result.v += 27;
        } else {
          logger.throwArgumentError("signature invalid v byte", "signature", signature2);
        }
      }
      result.recoveryParam = 1 - result.v % 2;
      if (result.recoveryParam) {
        bytes[32] |= 128;
      }
      result._vs = hexlify(bytes.slice(32, 64));
    } else {
      result.r = signature2.r;
      result.s = signature2.s;
      result.v = signature2.v;
      result.recoveryParam = signature2.recoveryParam;
      result._vs = signature2._vs;
      if (result._vs != null) {
        const vs2 = zeroPad(arrayify(result._vs), 32);
        result._vs = hexlify(vs2);
        const recoveryParam = vs2[0] >= 128 ? 1 : 0;
        if (result.recoveryParam == null) {
          result.recoveryParam = recoveryParam;
        } else if (result.recoveryParam !== recoveryParam) {
          logger.throwArgumentError("signature recoveryParam mismatch _vs", "signature", signature2);
        }
        vs2[0] &= 127;
        const s3 = hexlify(vs2);
        if (result.s == null) {
          result.s = s3;
        } else if (result.s !== s3) {
          logger.throwArgumentError("signature v mismatch _vs", "signature", signature2);
        }
      }
      if (result.recoveryParam == null) {
        if (result.v == null) {
          logger.throwArgumentError("signature missing v and recoveryParam", "signature", signature2);
        } else if (result.v === 0 || result.v === 1) {
          result.recoveryParam = result.v;
        } else {
          result.recoveryParam = 1 - result.v % 2;
        }
      } else {
        if (result.v == null) {
          result.v = 27 + result.recoveryParam;
        } else if (result.recoveryParam !== 1 - result.v % 2) {
          logger.throwArgumentError("signature recoveryParam mismatch v", "signature", signature2);
        }
      }
      if (result.r == null || !isHexString(result.r)) {
        logger.throwArgumentError("signature missing or invalid r", "signature", signature2);
      } else {
        result.r = hexZeroPad(result.r, 32);
      }
      if (result.s == null || !isHexString(result.s)) {
        logger.throwArgumentError("signature missing or invalid s", "signature", signature2);
      } else {
        result.s = hexZeroPad(result.s, 32);
      }
      const vs = arrayify(result.s);
      if (vs[0] >= 128) {
        logger.throwArgumentError("signature s out of range", "signature", signature2);
      }
      if (result.recoveryParam) {
        vs[0] |= 128;
      }
      const _vs = hexlify(vs);
      if (result._vs) {
        if (!isHexString(result._vs)) {
          logger.throwArgumentError("signature invalid _vs", "signature", signature2);
        }
        result._vs = hexZeroPad(result._vs, 32);
      }
      if (result._vs == null) {
        result._vs = _vs;
      } else if (result._vs !== _vs) {
        logger.throwArgumentError("signature _vs mismatch v and s", "signature", signature2);
      }
    }
    return result;
  }
  function joinSignature(signature2) {
    signature2 = splitSignature(signature2);
    return hexlify(concat([
      signature2.r,
      signature2.s,
      signature2.recoveryParam ? "0x1c" : "0x1b"
    ]));
  }

  // node_modules/@ethersproject/bignumber/lib.esm/_version.js
  var version3 = "bignumber/5.4.1";

  // node_modules/@ethersproject/bignumber/lib.esm/bignumber.js
  "use strict";
  var BN = import_bn.default.BN;
  var logger2 = new Logger(version3);
  var _constructorGuard = {};
  var MAX_SAFE = 9007199254740991;
  function isBigNumberish(value) {
    return value != null && (BigNumber.isBigNumber(value) || typeof value === "number" && value % 1 === 0 || typeof value === "string" && !!value.match(/^-?[0-9]+$/) || isHexString(value) || typeof value === "bigint" || isBytes(value));
  }
  var _warnedToStringRadix = false;
  var BigNumber = class {
    constructor(constructorGuard, hex2) {
      logger2.checkNew(new.target, BigNumber);
      if (constructorGuard !== _constructorGuard) {
        logger2.throwError("cannot call constructor directly; use BigNumber.from", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "new (BigNumber)"
        });
      }
      this._hex = hex2;
      this._isBigNumber = true;
      Object.freeze(this);
    }
    fromTwos(value) {
      return toBigNumber(toBN(this).fromTwos(value));
    }
    toTwos(value) {
      return toBigNumber(toBN(this).toTwos(value));
    }
    abs() {
      if (this._hex[0] === "-") {
        return BigNumber.from(this._hex.substring(1));
      }
      return this;
    }
    add(other) {
      return toBigNumber(toBN(this).add(toBN(other)));
    }
    sub(other) {
      return toBigNumber(toBN(this).sub(toBN(other)));
    }
    div(other) {
      const o3 = BigNumber.from(other);
      if (o3.isZero()) {
        throwFault("division by zero", "div");
      }
      return toBigNumber(toBN(this).div(toBN(other)));
    }
    mul(other) {
      return toBigNumber(toBN(this).mul(toBN(other)));
    }
    mod(other) {
      const value = toBN(other);
      if (value.isNeg()) {
        throwFault("cannot modulo negative values", "mod");
      }
      return toBigNumber(toBN(this).umod(value));
    }
    pow(other) {
      const value = toBN(other);
      if (value.isNeg()) {
        throwFault("cannot raise to negative values", "pow");
      }
      return toBigNumber(toBN(this).pow(value));
    }
    and(other) {
      const value = toBN(other);
      if (this.isNegative() || value.isNeg()) {
        throwFault("cannot 'and' negative values", "and");
      }
      return toBigNumber(toBN(this).and(value));
    }
    or(other) {
      const value = toBN(other);
      if (this.isNegative() || value.isNeg()) {
        throwFault("cannot 'or' negative values", "or");
      }
      return toBigNumber(toBN(this).or(value));
    }
    xor(other) {
      const value = toBN(other);
      if (this.isNegative() || value.isNeg()) {
        throwFault("cannot 'xor' negative values", "xor");
      }
      return toBigNumber(toBN(this).xor(value));
    }
    mask(value) {
      if (this.isNegative() || value < 0) {
        throwFault("cannot mask negative values", "mask");
      }
      return toBigNumber(toBN(this).maskn(value));
    }
    shl(value) {
      if (this.isNegative() || value < 0) {
        throwFault("cannot shift negative values", "shl");
      }
      return toBigNumber(toBN(this).shln(value));
    }
    shr(value) {
      if (this.isNegative() || value < 0) {
        throwFault("cannot shift negative values", "shr");
      }
      return toBigNumber(toBN(this).shrn(value));
    }
    eq(other) {
      return toBN(this).eq(toBN(other));
    }
    lt(other) {
      return toBN(this).lt(toBN(other));
    }
    lte(other) {
      return toBN(this).lte(toBN(other));
    }
    gt(other) {
      return toBN(this).gt(toBN(other));
    }
    gte(other) {
      return toBN(this).gte(toBN(other));
    }
    isNegative() {
      return this._hex[0] === "-";
    }
    isZero() {
      return toBN(this).isZero();
    }
    toNumber() {
      try {
        return toBN(this).toNumber();
      } catch (error) {
        throwFault("overflow", "toNumber", this.toString());
      }
      return null;
    }
    toBigInt() {
      try {
        return BigInt(this.toString());
      } catch (e3) {
      }
      return logger2.throwError("this platform does not support BigInt", Logger.errors.UNSUPPORTED_OPERATION, {
        value: this.toString()
      });
    }
    toString() {
      if (arguments.length > 0) {
        if (arguments[0] === 10) {
          if (!_warnedToStringRadix) {
            _warnedToStringRadix = true;
            logger2.warn("BigNumber.toString does not accept any parameters; base-10 is assumed");
          }
        } else if (arguments[0] === 16) {
          logger2.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", Logger.errors.UNEXPECTED_ARGUMENT, {});
        } else {
          logger2.throwError("BigNumber.toString does not accept parameters", Logger.errors.UNEXPECTED_ARGUMENT, {});
        }
      }
      return toBN(this).toString(10);
    }
    toHexString() {
      return this._hex;
    }
    toJSON(key2) {
      return { type: "BigNumber", hex: this.toHexString() };
    }
    static from(value) {
      if (value instanceof BigNumber) {
        return value;
      }
      if (typeof value === "string") {
        if (value.match(/^-?0x[0-9a-f]+$/i)) {
          return new BigNumber(_constructorGuard, toHex(value));
        }
        if (value.match(/^-?[0-9]+$/)) {
          return new BigNumber(_constructorGuard, toHex(new BN(value)));
        }
        return logger2.throwArgumentError("invalid BigNumber string", "value", value);
      }
      if (typeof value === "number") {
        if (value % 1) {
          throwFault("underflow", "BigNumber.from", value);
        }
        if (value >= MAX_SAFE || value <= -MAX_SAFE) {
          throwFault("overflow", "BigNumber.from", value);
        }
        return BigNumber.from(String(value));
      }
      const anyValue = value;
      if (typeof anyValue === "bigint") {
        return BigNumber.from(anyValue.toString());
      }
      if (isBytes(anyValue)) {
        return BigNumber.from(hexlify(anyValue));
      }
      if (anyValue) {
        if (anyValue.toHexString) {
          const hex2 = anyValue.toHexString();
          if (typeof hex2 === "string") {
            return BigNumber.from(hex2);
          }
        } else {
          let hex2 = anyValue._hex;
          if (hex2 == null && anyValue.type === "BigNumber") {
            hex2 = anyValue.hex;
          }
          if (typeof hex2 === "string") {
            if (isHexString(hex2) || hex2[0] === "-" && isHexString(hex2.substring(1))) {
              return BigNumber.from(hex2);
            }
          }
        }
      }
      return logger2.throwArgumentError("invalid BigNumber value", "value", value);
    }
    static isBigNumber(value) {
      return !!(value && value._isBigNumber);
    }
  };
  function toHex(value) {
    if (typeof value !== "string") {
      return toHex(value.toString(16));
    }
    if (value[0] === "-") {
      value = value.substring(1);
      if (value[0] === "-") {
        logger2.throwArgumentError("invalid hex", "value", value);
      }
      value = toHex(value);
      if (value === "0x00") {
        return value;
      }
      return "-" + value;
    }
    if (value.substring(0, 2) !== "0x") {
      value = "0x" + value;
    }
    if (value === "0x") {
      return "0x00";
    }
    if (value.length % 2) {
      value = "0x0" + value.substring(2);
    }
    while (value.length > 4 && value.substring(0, 4) === "0x00") {
      value = "0x" + value.substring(4);
    }
    return value;
  }
  function toBigNumber(value) {
    return BigNumber.from(toHex(value));
  }
  function toBN(value) {
    const hex2 = BigNumber.from(value).toHexString();
    if (hex2[0] === "-") {
      return new BN("-" + hex2.substring(3), 16);
    }
    return new BN(hex2.substring(2), 16);
  }
  function throwFault(fault, operation, value) {
    const params = { fault, operation };
    if (value != null) {
      params.value = value;
    }
    return logger2.throwError(fault, Logger.errors.NUMERIC_FAULT, params);
  }
  function _base36To16(value) {
    return new BN(value, 36).toString(16);
  }
  function _base16To36(value) {
    return new BN(value, 16).toString(36);
  }

  // node_modules/@ethersproject/bignumber/lib.esm/fixednumber.js
  "use strict";
  var logger3 = new Logger(version3);
  var _constructorGuard2 = {};
  var Zero = BigNumber.from(0);
  var NegativeOne = BigNumber.from(-1);
  function throwFault2(message, fault, operation, value) {
    const params = { fault, operation };
    if (value !== void 0) {
      params.value = value;
    }
    return logger3.throwError(message, Logger.errors.NUMERIC_FAULT, params);
  }
  var zeros = "0";
  while (zeros.length < 256) {
    zeros += zeros;
  }
  function getMultiplier(decimals) {
    if (typeof decimals !== "number") {
      try {
        decimals = BigNumber.from(decimals).toNumber();
      } catch (e3) {
      }
    }
    if (typeof decimals === "number" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {
      return "1" + zeros.substring(0, decimals);
    }
    return logger3.throwArgumentError("invalid decimal size", "decimals", decimals);
  }
  function formatFixed(value, decimals) {
    if (decimals == null) {
      decimals = 0;
    }
    const multiplier = getMultiplier(decimals);
    value = BigNumber.from(value);
    const negative = value.lt(Zero);
    if (negative) {
      value = value.mul(NegativeOne);
    }
    let fraction = value.mod(multiplier).toString();
    while (fraction.length < multiplier.length - 1) {
      fraction = "0" + fraction;
    }
    fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];
    const whole = value.div(multiplier).toString();
    if (multiplier.length === 1) {
      value = whole;
    } else {
      value = whole + "." + fraction;
    }
    if (negative) {
      value = "-" + value;
    }
    return value;
  }
  function parseFixed(value, decimals) {
    if (decimals == null) {
      decimals = 0;
    }
    const multiplier = getMultiplier(decimals);
    if (typeof value !== "string" || !value.match(/^-?[0-9.,]+$/)) {
      logger3.throwArgumentError("invalid decimal value", "value", value);
    }
    const negative = value.substring(0, 1) === "-";
    if (negative) {
      value = value.substring(1);
    }
    if (value === ".") {
      logger3.throwArgumentError("missing value", "value", value);
    }
    const comps = value.split(".");
    if (comps.length > 2) {
      logger3.throwArgumentError("too many decimal points", "value", value);
    }
    let whole = comps[0], fraction = comps[1];
    if (!whole) {
      whole = "0";
    }
    if (!fraction) {
      fraction = "0";
    }
    {
      const sigFraction = fraction.replace(/^([0-9]*?)(0*)$/, (all, sig, zeros2) => sig);
      if (sigFraction.length > multiplier.length - 1) {
        throwFault2("fractional component exceeds decimals", "underflow", "parseFixed");
      }
    }
    while (fraction.length < multiplier.length - 1) {
      fraction += "0";
    }
    const wholeValue = BigNumber.from(whole);
    const fractionValue = BigNumber.from(fraction);
    let wei = wholeValue.mul(multiplier).add(fractionValue);
    if (negative) {
      wei = wei.mul(NegativeOne);
    }
    return wei;
  }
  var FixedFormat = class {
    constructor(constructorGuard, signed, width, decimals) {
      if (constructorGuard !== _constructorGuard2) {
        logger3.throwError("cannot use FixedFormat constructor; use FixedFormat.from", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "new FixedFormat"
        });
      }
      this.signed = signed;
      this.width = width;
      this.decimals = decimals;
      this.name = (signed ? "" : "u") + "fixed" + String(width) + "x" + String(decimals);
      this._multiplier = getMultiplier(decimals);
      Object.freeze(this);
    }
    static from(value) {
      if (value instanceof FixedFormat) {
        return value;
      }
      if (typeof value === "number") {
        value = `fixed128x${value}`;
      }
      let signed = true;
      let width = 128;
      let decimals = 18;
      if (typeof value === "string") {
        if (value === "fixed") {
        } else if (value === "ufixed") {
          signed = false;
        } else {
          const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
          if (!match) {
            logger3.throwArgumentError("invalid fixed format", "format", value);
          }
          signed = match[1] !== "u";
          width = parseInt(match[2]);
          decimals = parseInt(match[3]);
        }
      } else if (value) {
        const check = (key2, type, defaultValue) => {
          if (value[key2] == null) {
            return defaultValue;
          }
          if (typeof value[key2] !== type) {
            logger3.throwArgumentError("invalid fixed format (" + key2 + " not " + type + ")", "format." + key2, value[key2]);
          }
          return value[key2];
        };
        signed = check("signed", "boolean", signed);
        width = check("width", "number", width);
        decimals = check("decimals", "number", decimals);
      }
      if (width % 8) {
        logger3.throwArgumentError("invalid fixed format width (not byte aligned)", "format.width", width);
      }
      if (decimals > 80) {
        logger3.throwArgumentError("invalid fixed format (decimals too large)", "format.decimals", decimals);
      }
      return new FixedFormat(_constructorGuard2, signed, width, decimals);
    }
  };
  var FixedNumber = class {
    constructor(constructorGuard, hex2, value, format) {
      logger3.checkNew(new.target, FixedNumber);
      if (constructorGuard !== _constructorGuard2) {
        logger3.throwError("cannot use FixedNumber constructor; use FixedNumber.from", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "new FixedFormat"
        });
      }
      this.format = format;
      this._hex = hex2;
      this._value = value;
      this._isFixedNumber = true;
      Object.freeze(this);
    }
    _checkFormat(other) {
      if (this.format.name !== other.format.name) {
        logger3.throwArgumentError("incompatible format; use fixedNumber.toFormat", "other", other);
      }
    }
    addUnsafe(other) {
      this._checkFormat(other);
      const a3 = parseFixed(this._value, this.format.decimals);
      const b2 = parseFixed(other._value, other.format.decimals);
      return FixedNumber.fromValue(a3.add(b2), this.format.decimals, this.format);
    }
    subUnsafe(other) {
      this._checkFormat(other);
      const a3 = parseFixed(this._value, this.format.decimals);
      const b2 = parseFixed(other._value, other.format.decimals);
      return FixedNumber.fromValue(a3.sub(b2), this.format.decimals, this.format);
    }
    mulUnsafe(other) {
      this._checkFormat(other);
      const a3 = parseFixed(this._value, this.format.decimals);
      const b2 = parseFixed(other._value, other.format.decimals);
      return FixedNumber.fromValue(a3.mul(b2).div(this.format._multiplier), this.format.decimals, this.format);
    }
    divUnsafe(other) {
      this._checkFormat(other);
      const a3 = parseFixed(this._value, this.format.decimals);
      const b2 = parseFixed(other._value, other.format.decimals);
      return FixedNumber.fromValue(a3.mul(this.format._multiplier).div(b2), this.format.decimals, this.format);
    }
    floor() {
      const comps = this.toString().split(".");
      if (comps.length === 1) {
        comps.push("0");
      }
      let result = FixedNumber.from(comps[0], this.format);
      const hasFraction = !comps[1].match(/^(0*)$/);
      if (this.isNegative() && hasFraction) {
        result = result.subUnsafe(ONE.toFormat(result.format));
      }
      return result;
    }
    ceiling() {
      const comps = this.toString().split(".");
      if (comps.length === 1) {
        comps.push("0");
      }
      let result = FixedNumber.from(comps[0], this.format);
      const hasFraction = !comps[1].match(/^(0*)$/);
      if (!this.isNegative() && hasFraction) {
        result = result.addUnsafe(ONE.toFormat(result.format));
      }
      return result;
    }
    round(decimals) {
      if (decimals == null) {
        decimals = 0;
      }
      const comps = this.toString().split(".");
      if (comps.length === 1) {
        comps.push("0");
      }
      if (decimals < 0 || decimals > 80 || decimals % 1) {
        logger3.throwArgumentError("invalid decimal count", "decimals", decimals);
      }
      if (comps[1].length <= decimals) {
        return this;
      }
      const factor = FixedNumber.from("1" + zeros.substring(0, decimals), this.format);
      const bump = BUMP.toFormat(this.format);
      return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);
    }
    isZero() {
      return this._value === "0.0" || this._value === "0";
    }
    isNegative() {
      return this._value[0] === "-";
    }
    toString() {
      return this._value;
    }
    toHexString(width) {
      if (width == null) {
        return this._hex;
      }
      if (width % 8) {
        logger3.throwArgumentError("invalid byte width", "width", width);
      }
      const hex2 = BigNumber.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();
      return hexZeroPad(hex2, width / 8);
    }
    toUnsafeFloat() {
      return parseFloat(this.toString());
    }
    toFormat(format) {
      return FixedNumber.fromString(this._value, format);
    }
    static fromValue(value, decimals, format) {
      if (format == null && decimals != null && !isBigNumberish(decimals)) {
        format = decimals;
        decimals = null;
      }
      if (decimals == null) {
        decimals = 0;
      }
      if (format == null) {
        format = "fixed";
      }
      return FixedNumber.fromString(formatFixed(value, decimals), FixedFormat.from(format));
    }
    static fromString(value, format) {
      if (format == null) {
        format = "fixed";
      }
      const fixedFormat = FixedFormat.from(format);
      const numeric = parseFixed(value, fixedFormat.decimals);
      if (!fixedFormat.signed && numeric.lt(Zero)) {
        throwFault2("unsigned value cannot be negative", "overflow", "value", value);
      }
      let hex2 = null;
      if (fixedFormat.signed) {
        hex2 = numeric.toTwos(fixedFormat.width).toHexString();
      } else {
        hex2 = numeric.toHexString();
        hex2 = hexZeroPad(hex2, fixedFormat.width / 8);
      }
      const decimal = formatFixed(numeric, fixedFormat.decimals);
      return new FixedNumber(_constructorGuard2, hex2, decimal, fixedFormat);
    }
    static fromBytes(value, format) {
      if (format == null) {
        format = "fixed";
      }
      const fixedFormat = FixedFormat.from(format);
      if (arrayify(value).length > fixedFormat.width / 8) {
        throw new Error("overflow");
      }
      let numeric = BigNumber.from(value);
      if (fixedFormat.signed) {
        numeric = numeric.fromTwos(fixedFormat.width);
      }
      const hex2 = numeric.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();
      const decimal = formatFixed(numeric, fixedFormat.decimals);
      return new FixedNumber(_constructorGuard2, hex2, decimal, fixedFormat);
    }
    static from(value, format) {
      if (typeof value === "string") {
        return FixedNumber.fromString(value, format);
      }
      if (isBytes(value)) {
        return FixedNumber.fromBytes(value, format);
      }
      try {
        return FixedNumber.fromValue(value, 0, format);
      } catch (error) {
        if (error.code !== Logger.errors.INVALID_ARGUMENT) {
          throw error;
        }
      }
      return logger3.throwArgumentError("invalid FixedNumber value", "value", value);
    }
    static isFixedNumber(value) {
      return !!(value && value._isFixedNumber);
    }
  };
  var ONE = FixedNumber.from(1);
  var BUMP = FixedNumber.from("0.5");

  // node_modules/@ethersproject/properties/lib.esm/_version.js
  var version4 = "properties/5.4.0";

  // node_modules/@ethersproject/properties/lib.esm/index.js
  "use strict";
  var __awaiter = function(thisArg, _arguments, P3, generator) {
    function adopt(value) {
      return value instanceof P3 ? value : new P3(function(resolve) {
        resolve(value);
      });
    }
    return new (P3 || (P3 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e3) {
          reject(e3);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e3) {
          reject(e3);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var logger4 = new Logger(version4);
  function defineReadOnly(object, name2, value) {
    Object.defineProperty(object, name2, {
      enumerable: true,
      value,
      writable: false
    });
  }
  function getStatic(ctor, key2) {
    for (let i3 = 0; i3 < 32; i3++) {
      if (ctor[key2]) {
        return ctor[key2];
      }
      if (!ctor.prototype || typeof ctor.prototype !== "object") {
        break;
      }
      ctor = Object.getPrototypeOf(ctor.prototype).constructor;
    }
    return null;
  }
  function resolveProperties(object) {
    return __awaiter(this, void 0, void 0, function* () {
      const promises = Object.keys(object).map((key2) => {
        const value = object[key2];
        return Promise.resolve(value).then((v3) => ({ key: key2, value: v3 }));
      });
      const results = yield Promise.all(promises);
      return results.reduce((accum, result) => {
        accum[result.key] = result.value;
        return accum;
      }, {});
    });
  }
  function checkProperties(object, properties) {
    if (!object || typeof object !== "object") {
      logger4.throwArgumentError("invalid object", "object", object);
    }
    Object.keys(object).forEach((key2) => {
      if (!properties[key2]) {
        logger4.throwArgumentError("invalid object key - " + key2, "transaction:" + key2, object);
      }
    });
  }
  function shallowCopy(object) {
    const result = {};
    for (const key2 in object) {
      result[key2] = object[key2];
    }
    return result;
  }
  var opaque = { bigint: true, boolean: true, "function": true, number: true, string: true };
  function _isFrozen(object) {
    if (object === void 0 || object === null || opaque[typeof object]) {
      return true;
    }
    if (Array.isArray(object) || typeof object === "object") {
      if (!Object.isFrozen(object)) {
        return false;
      }
      const keys = Object.keys(object);
      for (let i3 = 0; i3 < keys.length; i3++) {
        if (!_isFrozen(object[keys[i3]])) {
          return false;
        }
      }
      return true;
    }
    return logger4.throwArgumentError(`Cannot deepCopy ${typeof object}`, "object", object);
  }
  function _deepCopy(object) {
    if (_isFrozen(object)) {
      return object;
    }
    if (Array.isArray(object)) {
      return Object.freeze(object.map((item) => deepCopy(item)));
    }
    if (typeof object === "object") {
      const result = {};
      for (const key2 in object) {
        const value = object[key2];
        if (value === void 0) {
          continue;
        }
        defineReadOnly(result, key2, deepCopy(value));
      }
      return result;
    }
    return logger4.throwArgumentError(`Cannot deepCopy ${typeof object}`, "object", object);
  }
  function deepCopy(object) {
    return _deepCopy(object);
  }
  var Description = class {
    constructor(info) {
      for (const key2 in info) {
        this[key2] = deepCopy(info[key2]);
      }
    }
  };

  // node_modules/@ethersproject/abi/lib.esm/_version.js
  var version5 = "abi/5.4.0";

  // node_modules/@ethersproject/abi/lib.esm/fragments.js
  "use strict";
  var logger5 = new Logger(version5);
  var _constructorGuard3 = {};
  var ModifiersBytes = { calldata: true, memory: true, storage: true };
  var ModifiersNest = { calldata: true, memory: true };
  function checkModifier(type, name2) {
    if (type === "bytes" || type === "string") {
      if (ModifiersBytes[name2]) {
        return true;
      }
    } else if (type === "address") {
      if (name2 === "payable") {
        return true;
      }
    } else if (type.indexOf("[") >= 0 || type === "tuple") {
      if (ModifiersNest[name2]) {
        return true;
      }
    }
    if (ModifiersBytes[name2] || name2 === "payable") {
      logger5.throwArgumentError("invalid modifier", "name", name2);
    }
    return false;
  }
  function parseParamType(param, allowIndexed) {
    let originalParam = param;
    function throwError(i3) {
      logger5.throwArgumentError(`unexpected character at position ${i3}`, "param", param);
    }
    param = param.replace(/\s/g, " ");
    function newNode(parent2) {
      let node2 = { type: "", name: "", parent: parent2, state: { allowType: true } };
      if (allowIndexed) {
        node2.indexed = false;
      }
      return node2;
    }
    let parent = { type: "", name: "", state: { allowType: true } };
    let node = parent;
    for (let i3 = 0; i3 < param.length; i3++) {
      let c3 = param[i3];
      switch (c3) {
        case "(":
          if (node.state.allowType && node.type === "") {
            node.type = "tuple";
          } else if (!node.state.allowParams) {
            throwError(i3);
          }
          node.state.allowType = false;
          node.type = verifyType(node.type);
          node.components = [newNode(node)];
          node = node.components[0];
          break;
        case ")":
          delete node.state;
          if (node.name === "indexed") {
            if (!allowIndexed) {
              throwError(i3);
            }
            node.indexed = true;
            node.name = "";
          }
          if (checkModifier(node.type, node.name)) {
            node.name = "";
          }
          node.type = verifyType(node.type);
          let child = node;
          node = node.parent;
          if (!node) {
            throwError(i3);
          }
          delete child.parent;
          node.state.allowParams = false;
          node.state.allowName = true;
          node.state.allowArray = true;
          break;
        case ",":
          delete node.state;
          if (node.name === "indexed") {
            if (!allowIndexed) {
              throwError(i3);
            }
            node.indexed = true;
            node.name = "";
          }
          if (checkModifier(node.type, node.name)) {
            node.name = "";
          }
          node.type = verifyType(node.type);
          let sibling = newNode(node.parent);
          node.parent.components.push(sibling);
          delete node.parent;
          node = sibling;
          break;
        case " ":
          if (node.state.allowType) {
            if (node.type !== "") {
              node.type = verifyType(node.type);
              delete node.state.allowType;
              node.state.allowName = true;
              node.state.allowParams = true;
            }
          }
          if (node.state.allowName) {
            if (node.name !== "") {
              if (node.name === "indexed") {
                if (!allowIndexed) {
                  throwError(i3);
                }
                if (node.indexed) {
                  throwError(i3);
                }
                node.indexed = true;
                node.name = "";
              } else if (checkModifier(node.type, node.name)) {
                node.name = "";
              } else {
                node.state.allowName = false;
              }
            }
          }
          break;
        case "[":
          if (!node.state.allowArray) {
            throwError(i3);
          }
          node.type += c3;
          node.state.allowArray = false;
          node.state.allowName = false;
          node.state.readArray = true;
          break;
        case "]":
          if (!node.state.readArray) {
            throwError(i3);
          }
          node.type += c3;
          node.state.readArray = false;
          node.state.allowArray = true;
          node.state.allowName = true;
          break;
        default:
          if (node.state.allowType) {
            node.type += c3;
            node.state.allowParams = true;
            node.state.allowArray = true;
          } else if (node.state.allowName) {
            node.name += c3;
            delete node.state.allowArray;
          } else if (node.state.readArray) {
            node.type += c3;
          } else {
            throwError(i3);
          }
      }
    }
    if (node.parent) {
      logger5.throwArgumentError("unexpected eof", "param", param);
    }
    delete parent.state;
    if (node.name === "indexed") {
      if (!allowIndexed) {
        throwError(originalParam.length - 7);
      }
      if (node.indexed) {
        throwError(originalParam.length - 7);
      }
      node.indexed = true;
      node.name = "";
    } else if (checkModifier(node.type, node.name)) {
      node.name = "";
    }
    parent.type = verifyType(parent.type);
    return parent;
  }
  function populate(object, params) {
    for (let key2 in params) {
      defineReadOnly(object, key2, params[key2]);
    }
  }
  var FormatTypes = Object.freeze({
    sighash: "sighash",
    minimal: "minimal",
    full: "full",
    json: "json"
  });
  var paramTypeArray = new RegExp(/^(.*)\[([0-9]*)\]$/);
  var ParamType = class {
    constructor(constructorGuard, params) {
      if (constructorGuard !== _constructorGuard3) {
        logger5.throwError("use fromString", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "new ParamType()"
        });
      }
      populate(this, params);
      let match = this.type.match(paramTypeArray);
      if (match) {
        populate(this, {
          arrayLength: parseInt(match[2] || "-1"),
          arrayChildren: ParamType.fromObject({
            type: match[1],
            components: this.components
          }),
          baseType: "array"
        });
      } else {
        populate(this, {
          arrayLength: null,
          arrayChildren: null,
          baseType: this.components != null ? "tuple" : this.type
        });
      }
      this._isParamType = true;
      Object.freeze(this);
    }
    format(format) {
      if (!format) {
        format = FormatTypes.sighash;
      }
      if (!FormatTypes[format]) {
        logger5.throwArgumentError("invalid format type", "format", format);
      }
      if (format === FormatTypes.json) {
        let result2 = {
          type: this.baseType === "tuple" ? "tuple" : this.type,
          name: this.name || void 0
        };
        if (typeof this.indexed === "boolean") {
          result2.indexed = this.indexed;
        }
        if (this.components) {
          result2.components = this.components.map((comp) => JSON.parse(comp.format(format)));
        }
        return JSON.stringify(result2);
      }
      let result = "";
      if (this.baseType === "array") {
        result += this.arrayChildren.format(format);
        result += "[" + (this.arrayLength < 0 ? "" : String(this.arrayLength)) + "]";
      } else {
        if (this.baseType === "tuple") {
          if (format !== FormatTypes.sighash) {
            result += this.type;
          }
          result += "(" + this.components.map((comp) => comp.format(format)).join(format === FormatTypes.full ? ", " : ",") + ")";
        } else {
          result += this.type;
        }
      }
      if (format !== FormatTypes.sighash) {
        if (this.indexed === true) {
          result += " indexed";
        }
        if (format === FormatTypes.full && this.name) {
          result += " " + this.name;
        }
      }
      return result;
    }
    static from(value, allowIndexed) {
      if (typeof value === "string") {
        return ParamType.fromString(value, allowIndexed);
      }
      return ParamType.fromObject(value);
    }
    static fromObject(value) {
      if (ParamType.isParamType(value)) {
        return value;
      }
      return new ParamType(_constructorGuard3, {
        name: value.name || null,
        type: verifyType(value.type),
        indexed: value.indexed == null ? null : !!value.indexed,
        components: value.components ? value.components.map(ParamType.fromObject) : null
      });
    }
    static fromString(value, allowIndexed) {
      function ParamTypify(node) {
        return ParamType.fromObject({
          name: node.name,
          type: node.type,
          indexed: node.indexed,
          components: node.components
        });
      }
      return ParamTypify(parseParamType(value, !!allowIndexed));
    }
    static isParamType(value) {
      return !!(value != null && value._isParamType);
    }
  };
  function parseParams(value, allowIndex) {
    return splitNesting(value).map((param) => ParamType.fromString(param, allowIndex));
  }
  var Fragment = class {
    constructor(constructorGuard, params) {
      if (constructorGuard !== _constructorGuard3) {
        logger5.throwError("use a static from method", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "new Fragment()"
        });
      }
      populate(this, params);
      this._isFragment = true;
      Object.freeze(this);
    }
    static from(value) {
      if (Fragment.isFragment(value)) {
        return value;
      }
      if (typeof value === "string") {
        return Fragment.fromString(value);
      }
      return Fragment.fromObject(value);
    }
    static fromObject(value) {
      if (Fragment.isFragment(value)) {
        return value;
      }
      switch (value.type) {
        case "function":
          return FunctionFragment.fromObject(value);
        case "event":
          return EventFragment.fromObject(value);
        case "constructor":
          return ConstructorFragment.fromObject(value);
        case "error":
          return ErrorFragment.fromObject(value);
        case "fallback":
        case "receive":
          return null;
      }
      return logger5.throwArgumentError("invalid fragment object", "value", value);
    }
    static fromString(value) {
      value = value.replace(/\s/g, " ");
      value = value.replace(/\(/g, " (").replace(/\)/g, ") ").replace(/\s+/g, " ");
      value = value.trim();
      if (value.split(" ")[0] === "event") {
        return EventFragment.fromString(value.substring(5).trim());
      } else if (value.split(" ")[0] === "function") {
        return FunctionFragment.fromString(value.substring(8).trim());
      } else if (value.split("(")[0].trim() === "constructor") {
        return ConstructorFragment.fromString(value.trim());
      } else if (value.split(" ")[0] === "error") {
        return ErrorFragment.fromString(value.substring(5).trim());
      }
      return logger5.throwArgumentError("unsupported fragment", "value", value);
    }
    static isFragment(value) {
      return !!(value && value._isFragment);
    }
  };
  var EventFragment = class extends Fragment {
    format(format) {
      if (!format) {
        format = FormatTypes.sighash;
      }
      if (!FormatTypes[format]) {
        logger5.throwArgumentError("invalid format type", "format", format);
      }
      if (format === FormatTypes.json) {
        return JSON.stringify({
          type: "event",
          anonymous: this.anonymous,
          name: this.name,
          inputs: this.inputs.map((input) => JSON.parse(input.format(format)))
        });
      }
      let result = "";
      if (format !== FormatTypes.sighash) {
        result += "event ";
      }
      result += this.name + "(" + this.inputs.map((input) => input.format(format)).join(format === FormatTypes.full ? ", " : ",") + ") ";
      if (format !== FormatTypes.sighash) {
        if (this.anonymous) {
          result += "anonymous ";
        }
      }
      return result.trim();
    }
    static from(value) {
      if (typeof value === "string") {
        return EventFragment.fromString(value);
      }
      return EventFragment.fromObject(value);
    }
    static fromObject(value) {
      if (EventFragment.isEventFragment(value)) {
        return value;
      }
      if (value.type !== "event") {
        logger5.throwArgumentError("invalid event object", "value", value);
      }
      const params = {
        name: verifyIdentifier(value.name),
        anonymous: value.anonymous,
        inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],
        type: "event"
      };
      return new EventFragment(_constructorGuard3, params);
    }
    static fromString(value) {
      let match = value.match(regexParen);
      if (!match) {
        logger5.throwArgumentError("invalid event string", "value", value);
      }
      let anonymous = false;
      match[3].split(" ").forEach((modifier) => {
        switch (modifier.trim()) {
          case "anonymous":
            anonymous = true;
            break;
          case "":
            break;
          default:
            logger5.warn("unknown modifier: " + modifier);
        }
      });
      return EventFragment.fromObject({
        name: match[1].trim(),
        anonymous,
        inputs: parseParams(match[2], true),
        type: "event"
      });
    }
    static isEventFragment(value) {
      return value && value._isFragment && value.type === "event";
    }
  };
  function parseGas(value, params) {
    params.gas = null;
    let comps = value.split("@");
    if (comps.length !== 1) {
      if (comps.length > 2) {
        logger5.throwArgumentError("invalid human-readable ABI signature", "value", value);
      }
      if (!comps[1].match(/^[0-9]+$/)) {
        logger5.throwArgumentError("invalid human-readable ABI signature gas", "value", value);
      }
      params.gas = BigNumber.from(comps[1]);
      return comps[0];
    }
    return value;
  }
  function parseModifiers(value, params) {
    params.constant = false;
    params.payable = false;
    params.stateMutability = "nonpayable";
    value.split(" ").forEach((modifier) => {
      switch (modifier.trim()) {
        case "constant":
          params.constant = true;
          break;
        case "payable":
          params.payable = true;
          params.stateMutability = "payable";
          break;
        case "nonpayable":
          params.payable = false;
          params.stateMutability = "nonpayable";
          break;
        case "pure":
          params.constant = true;
          params.stateMutability = "pure";
          break;
        case "view":
          params.constant = true;
          params.stateMutability = "view";
          break;
        case "external":
        case "public":
        case "":
          break;
        default:
          console.log("unknown modifier: " + modifier);
      }
    });
  }
  function verifyState(value) {
    let result = {
      constant: false,
      payable: true,
      stateMutability: "payable"
    };
    if (value.stateMutability != null) {
      result.stateMutability = value.stateMutability;
      result.constant = result.stateMutability === "view" || result.stateMutability === "pure";
      if (value.constant != null) {
        if (!!value.constant !== result.constant) {
          logger5.throwArgumentError("cannot have constant function with mutability " + result.stateMutability, "value", value);
        }
      }
      result.payable = result.stateMutability === "payable";
      if (value.payable != null) {
        if (!!value.payable !== result.payable) {
          logger5.throwArgumentError("cannot have payable function with mutability " + result.stateMutability, "value", value);
        }
      }
    } else if (value.payable != null) {
      result.payable = !!value.payable;
      if (value.constant == null && !result.payable && value.type !== "constructor") {
        logger5.throwArgumentError("unable to determine stateMutability", "value", value);
      }
      result.constant = !!value.constant;
      if (result.constant) {
        result.stateMutability = "view";
      } else {
        result.stateMutability = result.payable ? "payable" : "nonpayable";
      }
      if (result.payable && result.constant) {
        logger5.throwArgumentError("cannot have constant payable function", "value", value);
      }
    } else if (value.constant != null) {
      result.constant = !!value.constant;
      result.payable = !result.constant;
      result.stateMutability = result.constant ? "view" : "payable";
    } else if (value.type !== "constructor") {
      logger5.throwArgumentError("unable to determine stateMutability", "value", value);
    }
    return result;
  }
  var ConstructorFragment = class extends Fragment {
    format(format) {
      if (!format) {
        format = FormatTypes.sighash;
      }
      if (!FormatTypes[format]) {
        logger5.throwArgumentError("invalid format type", "format", format);
      }
      if (format === FormatTypes.json) {
        return JSON.stringify({
          type: "constructor",
          stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
          payable: this.payable,
          gas: this.gas ? this.gas.toNumber() : void 0,
          inputs: this.inputs.map((input) => JSON.parse(input.format(format)))
        });
      }
      if (format === FormatTypes.sighash) {
        logger5.throwError("cannot format a constructor for sighash", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "format(sighash)"
        });
      }
      let result = "constructor(" + this.inputs.map((input) => input.format(format)).join(format === FormatTypes.full ? ", " : ",") + ") ";
      if (this.stateMutability && this.stateMutability !== "nonpayable") {
        result += this.stateMutability + " ";
      }
      return result.trim();
    }
    static from(value) {
      if (typeof value === "string") {
        return ConstructorFragment.fromString(value);
      }
      return ConstructorFragment.fromObject(value);
    }
    static fromObject(value) {
      if (ConstructorFragment.isConstructorFragment(value)) {
        return value;
      }
      if (value.type !== "constructor") {
        logger5.throwArgumentError("invalid constructor object", "value", value);
      }
      let state = verifyState(value);
      if (state.constant) {
        logger5.throwArgumentError("constructor cannot be constant", "value", value);
      }
      const params = {
        name: null,
        type: value.type,
        inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],
        payable: state.payable,
        stateMutability: state.stateMutability,
        gas: value.gas ? BigNumber.from(value.gas) : null
      };
      return new ConstructorFragment(_constructorGuard3, params);
    }
    static fromString(value) {
      let params = { type: "constructor" };
      value = parseGas(value, params);
      let parens = value.match(regexParen);
      if (!parens || parens[1].trim() !== "constructor") {
        logger5.throwArgumentError("invalid constructor string", "value", value);
      }
      params.inputs = parseParams(parens[2].trim(), false);
      parseModifiers(parens[3].trim(), params);
      return ConstructorFragment.fromObject(params);
    }
    static isConstructorFragment(value) {
      return value && value._isFragment && value.type === "constructor";
    }
  };
  var FunctionFragment = class extends ConstructorFragment {
    format(format) {
      if (!format) {
        format = FormatTypes.sighash;
      }
      if (!FormatTypes[format]) {
        logger5.throwArgumentError("invalid format type", "format", format);
      }
      if (format === FormatTypes.json) {
        return JSON.stringify({
          type: "function",
          name: this.name,
          constant: this.constant,
          stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
          payable: this.payable,
          gas: this.gas ? this.gas.toNumber() : void 0,
          inputs: this.inputs.map((input) => JSON.parse(input.format(format))),
          outputs: this.outputs.map((output) => JSON.parse(output.format(format)))
        });
      }
      let result = "";
      if (format !== FormatTypes.sighash) {
        result += "function ";
      }
      result += this.name + "(" + this.inputs.map((input) => input.format(format)).join(format === FormatTypes.full ? ", " : ",") + ") ";
      if (format !== FormatTypes.sighash) {
        if (this.stateMutability) {
          if (this.stateMutability !== "nonpayable") {
            result += this.stateMutability + " ";
          }
        } else if (this.constant) {
          result += "view ";
        }
        if (this.outputs && this.outputs.length) {
          result += "returns (" + this.outputs.map((output) => output.format(format)).join(", ") + ") ";
        }
        if (this.gas != null) {
          result += "@" + this.gas.toString() + " ";
        }
      }
      return result.trim();
    }
    static from(value) {
      if (typeof value === "string") {
        return FunctionFragment.fromString(value);
      }
      return FunctionFragment.fromObject(value);
    }
    static fromObject(value) {
      if (FunctionFragment.isFunctionFragment(value)) {
        return value;
      }
      if (value.type !== "function") {
        logger5.throwArgumentError("invalid function object", "value", value);
      }
      let state = verifyState(value);
      const params = {
        type: value.type,
        name: verifyIdentifier(value.name),
        constant: state.constant,
        inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],
        outputs: value.outputs ? value.outputs.map(ParamType.fromObject) : [],
        payable: state.payable,
        stateMutability: state.stateMutability,
        gas: value.gas ? BigNumber.from(value.gas) : null
      };
      return new FunctionFragment(_constructorGuard3, params);
    }
    static fromString(value) {
      let params = { type: "function" };
      value = parseGas(value, params);
      let comps = value.split(" returns ");
      if (comps.length > 2) {
        logger5.throwArgumentError("invalid function string", "value", value);
      }
      let parens = comps[0].match(regexParen);
      if (!parens) {
        logger5.throwArgumentError("invalid function signature", "value", value);
      }
      params.name = parens[1].trim();
      if (params.name) {
        verifyIdentifier(params.name);
      }
      params.inputs = parseParams(parens[2], false);
      parseModifiers(parens[3].trim(), params);
      if (comps.length > 1) {
        let returns = comps[1].match(regexParen);
        if (returns[1].trim() != "" || returns[3].trim() != "") {
          logger5.throwArgumentError("unexpected tokens", "value", value);
        }
        params.outputs = parseParams(returns[2], false);
      } else {
        params.outputs = [];
      }
      return FunctionFragment.fromObject(params);
    }
    static isFunctionFragment(value) {
      return value && value._isFragment && value.type === "function";
    }
  };
  function checkForbidden(fragment) {
    const sig = fragment.format();
    if (sig === "Error(string)" || sig === "Panic(uint256)") {
      logger5.throwArgumentError(`cannot specify user defined ${sig} error`, "fragment", fragment);
    }
    return fragment;
  }
  var ErrorFragment = class extends Fragment {
    format(format) {
      if (!format) {
        format = FormatTypes.sighash;
      }
      if (!FormatTypes[format]) {
        logger5.throwArgumentError("invalid format type", "format", format);
      }
      if (format === FormatTypes.json) {
        return JSON.stringify({
          type: "error",
          name: this.name,
          inputs: this.inputs.map((input) => JSON.parse(input.format(format)))
        });
      }
      let result = "";
      if (format !== FormatTypes.sighash) {
        result += "error ";
      }
      result += this.name + "(" + this.inputs.map((input) => input.format(format)).join(format === FormatTypes.full ? ", " : ",") + ") ";
      return result.trim();
    }
    static from(value) {
      if (typeof value === "string") {
        return ErrorFragment.fromString(value);
      }
      return ErrorFragment.fromObject(value);
    }
    static fromObject(value) {
      if (ErrorFragment.isErrorFragment(value)) {
        return value;
      }
      if (value.type !== "error") {
        logger5.throwArgumentError("invalid error object", "value", value);
      }
      const params = {
        type: value.type,
        name: verifyIdentifier(value.name),
        inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : []
      };
      return checkForbidden(new ErrorFragment(_constructorGuard3, params));
    }
    static fromString(value) {
      let params = { type: "error" };
      let parens = value.match(regexParen);
      if (!parens) {
        logger5.throwArgumentError("invalid error signature", "value", value);
      }
      params.name = parens[1].trim();
      if (params.name) {
        verifyIdentifier(params.name);
      }
      params.inputs = parseParams(parens[2], false);
      return checkForbidden(ErrorFragment.fromObject(params));
    }
    static isErrorFragment(value) {
      return value && value._isFragment && value.type === "error";
    }
  };
  function verifyType(type) {
    if (type.match(/^uint($|[^1-9])/)) {
      type = "uint256" + type.substring(4);
    } else if (type.match(/^int($|[^1-9])/)) {
      type = "int256" + type.substring(3);
    }
    return type;
  }
  var regexIdentifier = new RegExp("^[a-zA-Z$_][a-zA-Z0-9$_]*$");
  function verifyIdentifier(value) {
    if (!value || !value.match(regexIdentifier)) {
      logger5.throwArgumentError(`invalid identifier "${value}"`, "value", value);
    }
    return value;
  }
  var regexParen = new RegExp("^([^)(]*)\\((.*)\\)([^)(]*)$");
  function splitNesting(value) {
    value = value.trim();
    let result = [];
    let accum = "";
    let depth = 0;
    for (let offset = 0; offset < value.length; offset++) {
      let c3 = value[offset];
      if (c3 === "," && depth === 0) {
        result.push(accum);
        accum = "";
      } else {
        accum += c3;
        if (c3 === "(") {
          depth++;
        } else if (c3 === ")") {
          depth--;
          if (depth === -1) {
            logger5.throwArgumentError("unbalanced parenthesis", "value", value);
          }
        }
      }
    }
    if (accum) {
      result.push(accum);
    }
    return result;
  }

  // node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js
  "use strict";
  var logger6 = new Logger(version5);
  function checkResultErrors(result) {
    const errors = [];
    const checkErrors = function(path, object) {
      if (!Array.isArray(object)) {
        return;
      }
      for (let key2 in object) {
        const childPath = path.slice();
        childPath.push(key2);
        try {
          checkErrors(childPath, object[key2]);
        } catch (error) {
          errors.push({ path: childPath, error });
        }
      }
    };
    checkErrors([], result);
    return errors;
  }
  var Coder = class {
    constructor(name2, type, localName, dynamic) {
      this.name = name2;
      this.type = type;
      this.localName = localName;
      this.dynamic = dynamic;
    }
    _throwError(message, value) {
      logger6.throwArgumentError(message, this.localName, value);
    }
  };
  var Writer = class {
    constructor(wordSize) {
      defineReadOnly(this, "wordSize", wordSize || 32);
      this._data = [];
      this._dataLength = 0;
      this._padding = new Uint8Array(wordSize);
    }
    get data() {
      return hexConcat(this._data);
    }
    get length() {
      return this._dataLength;
    }
    _writeData(data4) {
      this._data.push(data4);
      this._dataLength += data4.length;
      return data4.length;
    }
    appendWriter(writer) {
      return this._writeData(concat(writer._data));
    }
    writeBytes(value) {
      let bytes = arrayify(value);
      const paddingOffset = bytes.length % this.wordSize;
      if (paddingOffset) {
        bytes = concat([bytes, this._padding.slice(paddingOffset)]);
      }
      return this._writeData(bytes);
    }
    _getValue(value) {
      let bytes = arrayify(BigNumber.from(value));
      if (bytes.length > this.wordSize) {
        logger6.throwError("value out-of-bounds", Logger.errors.BUFFER_OVERRUN, {
          length: this.wordSize,
          offset: bytes.length
        });
      }
      if (bytes.length % this.wordSize) {
        bytes = concat([this._padding.slice(bytes.length % this.wordSize), bytes]);
      }
      return bytes;
    }
    writeValue(value) {
      return this._writeData(this._getValue(value));
    }
    writeUpdatableValue() {
      const offset = this._data.length;
      this._data.push(this._padding);
      this._dataLength += this.wordSize;
      return (value) => {
        this._data[offset] = this._getValue(value);
      };
    }
  };
  var Reader = class {
    constructor(data4, wordSize, coerceFunc, allowLoose) {
      defineReadOnly(this, "_data", arrayify(data4));
      defineReadOnly(this, "wordSize", wordSize || 32);
      defineReadOnly(this, "_coerceFunc", coerceFunc);
      defineReadOnly(this, "allowLoose", allowLoose);
      this._offset = 0;
    }
    get data() {
      return hexlify(this._data);
    }
    get consumed() {
      return this._offset;
    }
    static coerce(name2, value) {
      let match = name2.match("^u?int([0-9]+)$");
      if (match && parseInt(match[1]) <= 48) {
        value = value.toNumber();
      }
      return value;
    }
    coerce(name2, value) {
      if (this._coerceFunc) {
        return this._coerceFunc(name2, value);
      }
      return Reader.coerce(name2, value);
    }
    _peekBytes(offset, length, loose) {
      let alignedLength = Math.ceil(length / this.wordSize) * this.wordSize;
      if (this._offset + alignedLength > this._data.length) {
        if (this.allowLoose && loose && this._offset + length <= this._data.length) {
          alignedLength = length;
        } else {
          logger6.throwError("data out-of-bounds", Logger.errors.BUFFER_OVERRUN, {
            length: this._data.length,
            offset: this._offset + alignedLength
          });
        }
      }
      return this._data.slice(this._offset, this._offset + alignedLength);
    }
    subReader(offset) {
      return new Reader(this._data.slice(this._offset + offset), this.wordSize, this._coerceFunc, this.allowLoose);
    }
    readBytes(length, loose) {
      let bytes = this._peekBytes(0, length, !!loose);
      this._offset += bytes.length;
      return bytes.slice(0, length);
    }
    readValue() {
      return BigNumber.from(this.readBytes(this.wordSize));
    }
  };

  // node_modules/@ethersproject/keccak256/lib.esm/index.js
  var import_js_sha3 = __toModule(require_sha3());
  "use strict";
  function keccak256(data4) {
    return "0x" + import_js_sha3.default.keccak_256(arrayify(data4));
  }

  // node_modules/@ethersproject/rlp/lib.esm/index.js
  var lib_exports = {};
  __export(lib_exports, {
    decode: () => decode,
    encode: () => encode
  });

  // node_modules/@ethersproject/rlp/lib.esm/_version.js
  var version6 = "rlp/5.4.0";

  // node_modules/@ethersproject/rlp/lib.esm/index.js
  "use strict";
  var logger7 = new Logger(version6);
  function arrayifyInteger(value) {
    const result = [];
    while (value) {
      result.unshift(value & 255);
      value >>= 8;
    }
    return result;
  }
  function unarrayifyInteger(data4, offset, length) {
    let result = 0;
    for (let i3 = 0; i3 < length; i3++) {
      result = result * 256 + data4[offset + i3];
    }
    return result;
  }
  function _encode(object) {
    if (Array.isArray(object)) {
      let payload = [];
      object.forEach(function(child) {
        payload = payload.concat(_encode(child));
      });
      if (payload.length <= 55) {
        payload.unshift(192 + payload.length);
        return payload;
      }
      const length2 = arrayifyInteger(payload.length);
      length2.unshift(247 + length2.length);
      return length2.concat(payload);
    }
    if (!isBytesLike(object)) {
      logger7.throwArgumentError("RLP object must be BytesLike", "object", object);
    }
    const data4 = Array.prototype.slice.call(arrayify(object));
    if (data4.length === 1 && data4[0] <= 127) {
      return data4;
    } else if (data4.length <= 55) {
      data4.unshift(128 + data4.length);
      return data4;
    }
    const length = arrayifyInteger(data4.length);
    length.unshift(183 + length.length);
    return length.concat(data4);
  }
  function encode(object) {
    return hexlify(_encode(object));
  }
  function _decodeChildren(data4, offset, childOffset, length) {
    const result = [];
    while (childOffset < offset + 1 + length) {
      const decoded = _decode(data4, childOffset);
      result.push(decoded.result);
      childOffset += decoded.consumed;
      if (childOffset > offset + 1 + length) {
        logger7.throwError("child data too short", Logger.errors.BUFFER_OVERRUN, {});
      }
    }
    return { consumed: 1 + length, result };
  }
  function _decode(data4, offset) {
    if (data4.length === 0) {
      logger7.throwError("data too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    if (data4[offset] >= 248) {
      const lengthLength = data4[offset] - 247;
      if (offset + 1 + lengthLength > data4.length) {
        logger7.throwError("data short segment too short", Logger.errors.BUFFER_OVERRUN, {});
      }
      const length = unarrayifyInteger(data4, offset + 1, lengthLength);
      if (offset + 1 + lengthLength + length > data4.length) {
        logger7.throwError("data long segment too short", Logger.errors.BUFFER_OVERRUN, {});
      }
      return _decodeChildren(data4, offset, offset + 1 + lengthLength, lengthLength + length);
    } else if (data4[offset] >= 192) {
      const length = data4[offset] - 192;
      if (offset + 1 + length > data4.length) {
        logger7.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {});
      }
      return _decodeChildren(data4, offset, offset + 1, length);
    } else if (data4[offset] >= 184) {
      const lengthLength = data4[offset] - 183;
      if (offset + 1 + lengthLength > data4.length) {
        logger7.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {});
      }
      const length = unarrayifyInteger(data4, offset + 1, lengthLength);
      if (offset + 1 + lengthLength + length > data4.length) {
        logger7.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {});
      }
      const result = hexlify(data4.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));
      return { consumed: 1 + lengthLength + length, result };
    } else if (data4[offset] >= 128) {
      const length = data4[offset] - 128;
      if (offset + 1 + length > data4.length) {
        logger7.throwError("data too short", Logger.errors.BUFFER_OVERRUN, {});
      }
      const result = hexlify(data4.slice(offset + 1, offset + 1 + length));
      return { consumed: 1 + length, result };
    }
    return { consumed: 1, result: hexlify(data4[offset]) };
  }
  function decode(data4) {
    const bytes = arrayify(data4);
    const decoded = _decode(bytes, 0);
    if (decoded.consumed !== bytes.length) {
      logger7.throwArgumentError("invalid rlp data", "data", data4);
    }
    return decoded.result;
  }

  // node_modules/@ethersproject/address/lib.esm/_version.js
  var version7 = "address/5.4.0";

  // node_modules/@ethersproject/address/lib.esm/index.js
  "use strict";
  var logger8 = new Logger(version7);
  function getChecksumAddress(address) {
    if (!isHexString(address, 20)) {
      logger8.throwArgumentError("invalid address", "address", address);
    }
    address = address.toLowerCase();
    const chars = address.substring(2).split("");
    const expanded = new Uint8Array(40);
    for (let i3 = 0; i3 < 40; i3++) {
      expanded[i3] = chars[i3].charCodeAt(0);
    }
    const hashed = arrayify(keccak256(expanded));
    for (let i3 = 0; i3 < 40; i3 += 2) {
      if (hashed[i3 >> 1] >> 4 >= 8) {
        chars[i3] = chars[i3].toUpperCase();
      }
      if ((hashed[i3 >> 1] & 15) >= 8) {
        chars[i3 + 1] = chars[i3 + 1].toUpperCase();
      }
    }
    return "0x" + chars.join("");
  }
  var MAX_SAFE_INTEGER = 9007199254740991;
  function log10(x3) {
    if (Math.log10) {
      return Math.log10(x3);
    }
    return Math.log(x3) / Math.LN10;
  }
  var ibanLookup = {};
  for (let i3 = 0; i3 < 10; i3++) {
    ibanLookup[String(i3)] = String(i3);
  }
  for (let i3 = 0; i3 < 26; i3++) {
    ibanLookup[String.fromCharCode(65 + i3)] = String(10 + i3);
  }
  var safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));
  function ibanChecksum(address) {
    address = address.toUpperCase();
    address = address.substring(4) + address.substring(0, 2) + "00";
    let expanded = address.split("").map((c3) => {
      return ibanLookup[c3];
    }).join("");
    while (expanded.length >= safeDigits) {
      let block = expanded.substring(0, safeDigits);
      expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
    }
    let checksum = String(98 - parseInt(expanded, 10) % 97);
    while (checksum.length < 2) {
      checksum = "0" + checksum;
    }
    return checksum;
  }
  function getAddress(address) {
    let result = null;
    if (typeof address !== "string") {
      logger8.throwArgumentError("invalid address", "address", address);
    }
    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
      if (address.substring(0, 2) !== "0x") {
        address = "0x" + address;
      }
      result = getChecksumAddress(address);
      if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {
        logger8.throwArgumentError("bad address checksum", "address", address);
      }
    } else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
      if (address.substring(2, 4) !== ibanChecksum(address)) {
        logger8.throwArgumentError("bad icap checksum", "address", address);
      }
      result = _base36To16(address.substring(4));
      while (result.length < 40) {
        result = "0" + result;
      }
      result = getChecksumAddress("0x" + result);
    } else {
      logger8.throwArgumentError("invalid address", "address", address);
    }
    return result;
  }
  function isAddress(address) {
    try {
      getAddress(address);
      return true;
    } catch (error) {
    }
    return false;
  }
  function getIcapAddress(address) {
    let base36 = _base16To36(getAddress(address).substring(2)).toUpperCase();
    while (base36.length < 30) {
      base36 = "0" + base36;
    }
    return "XE" + ibanChecksum("XE00" + base36) + base36;
  }
  function getContractAddress(transaction) {
    let from = null;
    try {
      from = getAddress(transaction.from);
    } catch (error) {
      logger8.throwArgumentError("missing from address", "transaction", transaction);
    }
    const nonce = stripZeros(arrayify(BigNumber.from(transaction.nonce).toHexString()));
    return getAddress(hexDataSlice(keccak256(encode([from, nonce])), 12));
  }
  function getCreate2Address(from, salt, initCodeHash) {
    if (hexDataLength(salt) !== 32) {
      logger8.throwArgumentError("salt must be 32 bytes", "salt", salt);
    }
    if (hexDataLength(initCodeHash) !== 32) {
      logger8.throwArgumentError("initCodeHash must be 32 bytes", "initCodeHash", initCodeHash);
    }
    return getAddress(hexDataSlice(keccak256(concat(["0xff", getAddress(from), salt, initCodeHash])), 12));
  }

  // node_modules/@ethersproject/abi/lib.esm/coders/address.js
  "use strict";
  var AddressCoder = class extends Coder {
    constructor(localName) {
      super("address", "address", localName, false);
    }
    defaultValue() {
      return "0x0000000000000000000000000000000000000000";
    }
    encode(writer, value) {
      try {
        getAddress(value);
      } catch (error) {
        this._throwError(error.message, value);
      }
      return writer.writeValue(value);
    }
    decode(reader) {
      return getAddress(hexZeroPad(reader.readValue().toHexString(), 20));
    }
  };

  // node_modules/@ethersproject/abi/lib.esm/coders/anonymous.js
  "use strict";
  var AnonymousCoder = class extends Coder {
    constructor(coder) {
      super(coder.name, coder.type, void 0, coder.dynamic);
      this.coder = coder;
    }
    defaultValue() {
      return this.coder.defaultValue();
    }
    encode(writer, value) {
      return this.coder.encode(writer, value);
    }
    decode(reader) {
      return this.coder.decode(reader);
    }
  };

  // node_modules/@ethersproject/abi/lib.esm/coders/array.js
  "use strict";
  var logger9 = new Logger(version5);
  function pack(writer, coders, values) {
    let arrayValues = null;
    if (Array.isArray(values)) {
      arrayValues = values;
    } else if (values && typeof values === "object") {
      let unique = {};
      arrayValues = coders.map((coder) => {
        const name2 = coder.localName;
        if (!name2) {
          logger9.throwError("cannot encode object for signature with missing names", Logger.errors.INVALID_ARGUMENT, {
            argument: "values",
            coder,
            value: values
          });
        }
        if (unique[name2]) {
          logger9.throwError("cannot encode object for signature with duplicate names", Logger.errors.INVALID_ARGUMENT, {
            argument: "values",
            coder,
            value: values
          });
        }
        unique[name2] = true;
        return values[name2];
      });
    } else {
      logger9.throwArgumentError("invalid tuple value", "tuple", values);
    }
    if (coders.length !== arrayValues.length) {
      logger9.throwArgumentError("types/value length mismatch", "tuple", values);
    }
    let staticWriter = new Writer(writer.wordSize);
    let dynamicWriter = new Writer(writer.wordSize);
    let updateFuncs = [];
    coders.forEach((coder, index) => {
      let value = arrayValues[index];
      if (coder.dynamic) {
        let dynamicOffset = dynamicWriter.length;
        coder.encode(dynamicWriter, value);
        let updateFunc = staticWriter.writeUpdatableValue();
        updateFuncs.push((baseOffset) => {
          updateFunc(baseOffset + dynamicOffset);
        });
      } else {
        coder.encode(staticWriter, value);
      }
    });
    updateFuncs.forEach((func) => {
      func(staticWriter.length);
    });
    let length = writer.appendWriter(staticWriter);
    length += writer.appendWriter(dynamicWriter);
    return length;
  }
  function unpack(reader, coders) {
    let values = [];
    let baseReader = reader.subReader(0);
    coders.forEach((coder) => {
      let value = null;
      if (coder.dynamic) {
        let offset = reader.readValue();
        let offsetReader = baseReader.subReader(offset.toNumber());
        try {
          value = coder.decode(offsetReader);
        } catch (error) {
          if (error.code === Logger.errors.BUFFER_OVERRUN) {
            throw error;
          }
          value = error;
          value.baseType = coder.name;
          value.name = coder.localName;
          value.type = coder.type;
        }
      } else {
        try {
          value = coder.decode(reader);
        } catch (error) {
          if (error.code === Logger.errors.BUFFER_OVERRUN) {
            throw error;
          }
          value = error;
          value.baseType = coder.name;
          value.name = coder.localName;
          value.type = coder.type;
        }
      }
      if (value != void 0) {
        values.push(value);
      }
    });
    const uniqueNames = coders.reduce((accum, coder) => {
      const name2 = coder.localName;
      if (name2) {
        if (!accum[name2]) {
          accum[name2] = 0;
        }
        accum[name2]++;
      }
      return accum;
    }, {});
    coders.forEach((coder, index) => {
      let name2 = coder.localName;
      if (!name2 || uniqueNames[name2] !== 1) {
        return;
      }
      if (name2 === "length") {
        name2 = "_length";
      }
      if (values[name2] != null) {
        return;
      }
      const value = values[index];
      if (value instanceof Error) {
        Object.defineProperty(values, name2, {
          get: () => {
            throw value;
          }
        });
      } else {
        values[name2] = value;
      }
    });
    for (let i3 = 0; i3 < values.length; i3++) {
      const value = values[i3];
      if (value instanceof Error) {
        Object.defineProperty(values, i3, {
          get: () => {
            throw value;
          }
        });
      }
    }
    return Object.freeze(values);
  }
  var ArrayCoder = class extends Coder {
    constructor(coder, length, localName) {
      const type = coder.type + "[" + (length >= 0 ? length : "") + "]";
      const dynamic = length === -1 || coder.dynamic;
      super("array", type, localName, dynamic);
      this.coder = coder;
      this.length = length;
    }
    defaultValue() {
      const defaultChild = this.coder.defaultValue();
      const result = [];
      for (let i3 = 0; i3 < this.length; i3++) {
        result.push(defaultChild);
      }
      return result;
    }
    encode(writer, value) {
      if (!Array.isArray(value)) {
        this._throwError("expected array value", value);
      }
      let count = this.length;
      if (count === -1) {
        count = value.length;
        writer.writeValue(value.length);
      }
      logger9.checkArgumentCount(value.length, count, "coder array" + (this.localName ? " " + this.localName : ""));
      let coders = [];
      for (let i3 = 0; i3 < value.length; i3++) {
        coders.push(this.coder);
      }
      return pack(writer, coders, value);
    }
    decode(reader) {
      let count = this.length;
      if (count === -1) {
        count = reader.readValue().toNumber();
        if (count * 32 > reader._data.length) {
          logger9.throwError("insufficient data length", Logger.errors.BUFFER_OVERRUN, {
            length: reader._data.length,
            count
          });
        }
      }
      let coders = [];
      for (let i3 = 0; i3 < count; i3++) {
        coders.push(new AnonymousCoder(this.coder));
      }
      return reader.coerce(this.name, unpack(reader, coders));
    }
  };

  // node_modules/@ethersproject/abi/lib.esm/coders/boolean.js
  "use strict";
  var BooleanCoder = class extends Coder {
    constructor(localName) {
      super("bool", "bool", localName, false);
    }
    defaultValue() {
      return false;
    }
    encode(writer, value) {
      return writer.writeValue(value ? 1 : 0);
    }
    decode(reader) {
      return reader.coerce(this.type, !reader.readValue().isZero());
    }
  };

  // node_modules/@ethersproject/abi/lib.esm/coders/bytes.js
  "use strict";
  var DynamicBytesCoder = class extends Coder {
    constructor(type, localName) {
      super(type, type, localName, true);
    }
    defaultValue() {
      return "0x";
    }
    encode(writer, value) {
      value = arrayify(value);
      let length = writer.writeValue(value.length);
      length += writer.writeBytes(value);
      return length;
    }
    decode(reader) {
      return reader.readBytes(reader.readValue().toNumber(), true);
    }
  };
  var BytesCoder = class extends DynamicBytesCoder {
    constructor(localName) {
      super("bytes", localName);
    }
    decode(reader) {
      return reader.coerce(this.name, hexlify(super.decode(reader)));
    }
  };

  // node_modules/@ethersproject/abi/lib.esm/coders/fixed-bytes.js
  "use strict";
  var FixedBytesCoder = class extends Coder {
    constructor(size, localName) {
      let name2 = "bytes" + String(size);
      super(name2, name2, localName, false);
      this.size = size;
    }
    defaultValue() {
      return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2);
    }
    encode(writer, value) {
      let data4 = arrayify(value);
      if (data4.length !== this.size) {
        this._throwError("incorrect data length", value);
      }
      return writer.writeBytes(data4);
    }
    decode(reader) {
      return reader.coerce(this.name, hexlify(reader.readBytes(this.size)));
    }
  };

  // node_modules/@ethersproject/abi/lib.esm/coders/null.js
  "use strict";
  var NullCoder = class extends Coder {
    constructor(localName) {
      super("null", "", localName, false);
    }
    defaultValue() {
      return null;
    }
    encode(writer, value) {
      if (value != null) {
        this._throwError("not null", value);
      }
      return writer.writeBytes([]);
    }
    decode(reader) {
      reader.readBytes(0);
      return reader.coerce(this.name, null);
    }
  };

  // node_modules/@ethersproject/constants/lib.esm/index.js
  var lib_exports2 = {};
  __export(lib_exports2, {
    AddressZero: () => AddressZero,
    EtherSymbol: () => EtherSymbol,
    HashZero: () => HashZero,
    MaxInt256: () => MaxInt256,
    MaxUint256: () => MaxUint256,
    MinInt256: () => MinInt256,
    NegativeOne: () => NegativeOne2,
    One: () => One,
    Two: () => Two,
    WeiPerEther: () => WeiPerEther,
    Zero: () => Zero2
  });

  // node_modules/@ethersproject/constants/lib.esm/addresses.js
  var AddressZero = "0x0000000000000000000000000000000000000000";

  // node_modules/@ethersproject/constants/lib.esm/bignumbers.js
  var NegativeOne2 = /* @__PURE__ */ BigNumber.from(-1);
  var Zero2 = /* @__PURE__ */ BigNumber.from(0);
  var One = /* @__PURE__ */ BigNumber.from(1);
  var Two = /* @__PURE__ */ BigNumber.from(2);
  var WeiPerEther = /* @__PURE__ */ BigNumber.from("1000000000000000000");
  var MaxUint256 = /* @__PURE__ */ BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
  var MinInt256 = /* @__PURE__ */ BigNumber.from("-0x8000000000000000000000000000000000000000000000000000000000000000");
  var MaxInt256 = /* @__PURE__ */ BigNumber.from("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");

  // node_modules/@ethersproject/constants/lib.esm/hashes.js
  var HashZero = "0x0000000000000000000000000000000000000000000000000000000000000000";

  // node_modules/@ethersproject/constants/lib.esm/strings.js
  var EtherSymbol = "\u039E";

  // node_modules/@ethersproject/constants/lib.esm/index.js
  "use strict";

  // node_modules/@ethersproject/abi/lib.esm/coders/number.js
  "use strict";
  var NumberCoder = class extends Coder {
    constructor(size, signed, localName) {
      const name2 = (signed ? "int" : "uint") + size * 8;
      super(name2, name2, localName, false);
      this.size = size;
      this.signed = signed;
    }
    defaultValue() {
      return 0;
    }
    encode(writer, value) {
      let v3 = BigNumber.from(value);
      let maxUintValue = MaxUint256.mask(writer.wordSize * 8);
      if (this.signed) {
        let bounds = maxUintValue.mask(this.size * 8 - 1);
        if (v3.gt(bounds) || v3.lt(bounds.add(One).mul(NegativeOne2))) {
          this._throwError("value out-of-bounds", value);
        }
      } else if (v3.lt(Zero2) || v3.gt(maxUintValue.mask(this.size * 8))) {
        this._throwError("value out-of-bounds", value);
      }
      v3 = v3.toTwos(this.size * 8).mask(this.size * 8);
      if (this.signed) {
        v3 = v3.fromTwos(this.size * 8).toTwos(8 * writer.wordSize);
      }
      return writer.writeValue(v3);
    }
    decode(reader) {
      let value = reader.readValue().mask(this.size * 8);
      if (this.signed) {
        value = value.fromTwos(this.size * 8);
      }
      return reader.coerce(this.name, value);
    }
  };

  // node_modules/@ethersproject/strings/lib.esm/_version.js
  var version8 = "strings/5.4.0";

  // node_modules/@ethersproject/strings/lib.esm/utf8.js
  "use strict";
  var logger10 = new Logger(version8);
  var UnicodeNormalizationForm;
  (function(UnicodeNormalizationForm2) {
    UnicodeNormalizationForm2["current"] = "";
    UnicodeNormalizationForm2["NFC"] = "NFC";
    UnicodeNormalizationForm2["NFD"] = "NFD";
    UnicodeNormalizationForm2["NFKC"] = "NFKC";
    UnicodeNormalizationForm2["NFKD"] = "NFKD";
  })(UnicodeNormalizationForm || (UnicodeNormalizationForm = {}));
  var Utf8ErrorReason;
  (function(Utf8ErrorReason2) {
    Utf8ErrorReason2["UNEXPECTED_CONTINUE"] = "unexpected continuation byte";
    Utf8ErrorReason2["BAD_PREFIX"] = "bad codepoint prefix";
    Utf8ErrorReason2["OVERRUN"] = "string overrun";
    Utf8ErrorReason2["MISSING_CONTINUE"] = "missing continuation byte";
    Utf8ErrorReason2["OUT_OF_RANGE"] = "out of UTF-8 range";
    Utf8ErrorReason2["UTF16_SURROGATE"] = "UTF-16 surrogate";
    Utf8ErrorReason2["OVERLONG"] = "overlong representation";
  })(Utf8ErrorReason || (Utf8ErrorReason = {}));
  function errorFunc(reason, offset, bytes, output, badCodepoint) {
    return logger10.throwArgumentError(`invalid codepoint at offset ${offset}; ${reason}`, "bytes", bytes);
  }
  function ignoreFunc(reason, offset, bytes, output, badCodepoint) {
    if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {
      let i3 = 0;
      for (let o3 = offset + 1; o3 < bytes.length; o3++) {
        if (bytes[o3] >> 6 !== 2) {
          break;
        }
        i3++;
      }
      return i3;
    }
    if (reason === Utf8ErrorReason.OVERRUN) {
      return bytes.length - offset - 1;
    }
    return 0;
  }
  function replaceFunc(reason, offset, bytes, output, badCodepoint) {
    if (reason === Utf8ErrorReason.OVERLONG) {
      output.push(badCodepoint);
      return 0;
    }
    output.push(65533);
    return ignoreFunc(reason, offset, bytes, output, badCodepoint);
  }
  var Utf8ErrorFuncs = Object.freeze({
    error: errorFunc,
    ignore: ignoreFunc,
    replace: replaceFunc
  });
  function getUtf8CodePoints(bytes, onError) {
    if (onError == null) {
      onError = Utf8ErrorFuncs.error;
    }
    bytes = arrayify(bytes);
    const result = [];
    let i3 = 0;
    while (i3 < bytes.length) {
      const c3 = bytes[i3++];
      if (c3 >> 7 === 0) {
        result.push(c3);
        continue;
      }
      let extraLength = null;
      let overlongMask = null;
      if ((c3 & 224) === 192) {
        extraLength = 1;
        overlongMask = 127;
      } else if ((c3 & 240) === 224) {
        extraLength = 2;
        overlongMask = 2047;
      } else if ((c3 & 248) === 240) {
        extraLength = 3;
        overlongMask = 65535;
      } else {
        if ((c3 & 192) === 128) {
          i3 += onError(Utf8ErrorReason.UNEXPECTED_CONTINUE, i3 - 1, bytes, result);
        } else {
          i3 += onError(Utf8ErrorReason.BAD_PREFIX, i3 - 1, bytes, result);
        }
        continue;
      }
      if (i3 - 1 + extraLength >= bytes.length) {
        i3 += onError(Utf8ErrorReason.OVERRUN, i3 - 1, bytes, result);
        continue;
      }
      let res = c3 & (1 << 8 - extraLength - 1) - 1;
      for (let j3 = 0; j3 < extraLength; j3++) {
        let nextChar = bytes[i3];
        if ((nextChar & 192) != 128) {
          i3 += onError(Utf8ErrorReason.MISSING_CONTINUE, i3, bytes, result);
          res = null;
          break;
        }
        ;
        res = res << 6 | nextChar & 63;
        i3++;
      }
      if (res === null) {
        continue;
      }
      if (res > 1114111) {
        i3 += onError(Utf8ErrorReason.OUT_OF_RANGE, i3 - 1 - extraLength, bytes, result, res);
        continue;
      }
      if (res >= 55296 && res <= 57343) {
        i3 += onError(Utf8ErrorReason.UTF16_SURROGATE, i3 - 1 - extraLength, bytes, result, res);
        continue;
      }
      if (res <= overlongMask) {
        i3 += onError(Utf8ErrorReason.OVERLONG, i3 - 1 - extraLength, bytes, result, res);
        continue;
      }
      result.push(res);
    }
    return result;
  }
  function toUtf8Bytes(str, form = UnicodeNormalizationForm.current) {
    if (form != UnicodeNormalizationForm.current) {
      logger10.checkNormalize();
      str = str.normalize(form);
    }
    let result = [];
    for (let i3 = 0; i3 < str.length; i3++) {
      const c3 = str.charCodeAt(i3);
      if (c3 < 128) {
        result.push(c3);
      } else if (c3 < 2048) {
        result.push(c3 >> 6 | 192);
        result.push(c3 & 63 | 128);
      } else if ((c3 & 64512) == 55296) {
        i3++;
        const c22 = str.charCodeAt(i3);
        if (i3 >= str.length || (c22 & 64512) !== 56320) {
          throw new Error("invalid utf-8 string");
        }
        const pair = 65536 + ((c3 & 1023) << 10) + (c22 & 1023);
        result.push(pair >> 18 | 240);
        result.push(pair >> 12 & 63 | 128);
        result.push(pair >> 6 & 63 | 128);
        result.push(pair & 63 | 128);
      } else {
        result.push(c3 >> 12 | 224);
        result.push(c3 >> 6 & 63 | 128);
        result.push(c3 & 63 | 128);
      }
    }
    return arrayify(result);
  }
  function escapeChar(value) {
    const hex2 = "0000" + value.toString(16);
    return "\\u" + hex2.substring(hex2.length - 4);
  }
  function _toEscapedUtf8String(bytes, onError) {
    return '"' + getUtf8CodePoints(bytes, onError).map((codePoint) => {
      if (codePoint < 256) {
        switch (codePoint) {
          case 8:
            return "\\b";
          case 9:
            return "\\t";
          case 10:
            return "\\n";
          case 13:
            return "\\r";
          case 34:
            return '\\"';
          case 92:
            return "\\\\";
        }
        if (codePoint >= 32 && codePoint < 127) {
          return String.fromCharCode(codePoint);
        }
      }
      if (codePoint <= 65535) {
        return escapeChar(codePoint);
      }
      codePoint -= 65536;
      return escapeChar((codePoint >> 10 & 1023) + 55296) + escapeChar((codePoint & 1023) + 56320);
    }).join("") + '"';
  }
  function _toUtf8String(codePoints) {
    return codePoints.map((codePoint) => {
      if (codePoint <= 65535) {
        return String.fromCharCode(codePoint);
      }
      codePoint -= 65536;
      return String.fromCharCode((codePoint >> 10 & 1023) + 55296, (codePoint & 1023) + 56320);
    }).join("");
  }
  function toUtf8String(bytes, onError) {
    return _toUtf8String(getUtf8CodePoints(bytes, onError));
  }
  function toUtf8CodePoints(str, form = UnicodeNormalizationForm.current) {
    return getUtf8CodePoints(toUtf8Bytes(str, form));
  }

  // node_modules/@ethersproject/strings/lib.esm/bytes32.js
  "use strict";
  function formatBytes32String(text) {
    const bytes = toUtf8Bytes(text);
    if (bytes.length > 31) {
      throw new Error("bytes32 string must be less than 32 bytes");
    }
    return hexlify(concat([bytes, HashZero]).slice(0, 32));
  }
  function parseBytes32String(bytes) {
    const data4 = arrayify(bytes);
    if (data4.length !== 32) {
      throw new Error("invalid bytes32 - not 32 bytes long");
    }
    if (data4[31] !== 0) {
      throw new Error("invalid bytes32 string - no null terminator");
    }
    let length = 31;
    while (data4[length - 1] === 0) {
      length--;
    }
    return toUtf8String(data4.slice(0, length));
  }

  // node_modules/@ethersproject/strings/lib.esm/idna.js
  "use strict";
  function bytes2(data4) {
    if (data4.length % 4 !== 0) {
      throw new Error("bad data");
    }
    let result = [];
    for (let i3 = 0; i3 < data4.length; i3 += 4) {
      result.push(parseInt(data4.substring(i3, i3 + 4), 16));
    }
    return result;
  }
  function createTable(data4, func) {
    if (!func) {
      func = function(value) {
        return [parseInt(value, 16)];
      };
    }
    let lo = 0;
    let result = {};
    data4.split(",").forEach((pair) => {
      let comps = pair.split(":");
      lo += parseInt(comps[0], 16);
      result[lo] = func(comps[1]);
    });
    return result;
  }
  function createRangeTable(data4) {
    let hi = 0;
    return data4.split(",").map((v3) => {
      let comps = v3.split("-");
      if (comps.length === 1) {
        comps[1] = "0";
      } else if (comps[1] === "") {
        comps[1] = "1";
      }
      let lo = hi + parseInt(comps[0], 16);
      hi = parseInt(comps[1], 16);
      return { l: lo, h: hi };
    });
  }
  function matchMap(value, ranges) {
    let lo = 0;
    for (let i3 = 0; i3 < ranges.length; i3++) {
      let range = ranges[i3];
      lo += range.l;
      if (value >= lo && value <= lo + range.h && (value - lo) % (range.d || 1) === 0) {
        if (range.e && range.e.indexOf(value - lo) !== -1) {
          continue;
        }
        return range;
      }
    }
    return null;
  }
  var Table_A_1_ranges = createRangeTable("221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d");
  var Table_B_1_flags = "ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff".split(",").map((v3) => parseInt(v3, 16));
  var Table_B_2_ranges = [
    { h: 25, s: 32, l: 65 },
    { h: 30, s: 32, e: [23], l: 127 },
    { h: 54, s: 1, e: [48], l: 64, d: 2 },
    { h: 14, s: 1, l: 57, d: 2 },
    { h: 44, s: 1, l: 17, d: 2 },
    { h: 10, s: 1, e: [2, 6, 8], l: 61, d: 2 },
    { h: 16, s: 1, l: 68, d: 2 },
    { h: 84, s: 1, e: [18, 24, 66], l: 19, d: 2 },
    { h: 26, s: 32, e: [17], l: 435 },
    { h: 22, s: 1, l: 71, d: 2 },
    { h: 15, s: 80, l: 40 },
    { h: 31, s: 32, l: 16 },
    { h: 32, s: 1, l: 80, d: 2 },
    { h: 52, s: 1, l: 42, d: 2 },
    { h: 12, s: 1, l: 55, d: 2 },
    { h: 40, s: 1, e: [38], l: 15, d: 2 },
    { h: 14, s: 1, l: 48, d: 2 },
    { h: 37, s: 48, l: 49 },
    { h: 148, s: 1, l: 6351, d: 2 },
    { h: 88, s: 1, l: 160, d: 2 },
    { h: 15, s: 16, l: 704 },
    { h: 25, s: 26, l: 854 },
    { h: 25, s: 32, l: 55915 },
    { h: 37, s: 40, l: 1247 },
    { h: 25, s: -119711, l: 53248 },
    { h: 25, s: -119763, l: 52 },
    { h: 25, s: -119815, l: 52 },
    { h: 25, s: -119867, e: [1, 4, 5, 7, 8, 11, 12, 17], l: 52 },
    { h: 25, s: -119919, l: 52 },
    { h: 24, s: -119971, e: [2, 7, 8, 17], l: 52 },
    { h: 24, s: -120023, e: [2, 7, 13, 15, 16, 17], l: 52 },
    { h: 25, s: -120075, l: 52 },
    { h: 25, s: -120127, l: 52 },
    { h: 25, s: -120179, l: 52 },
    { h: 25, s: -120231, l: 52 },
    { h: 25, s: -120283, l: 52 },
    { h: 25, s: -120335, l: 52 },
    { h: 24, s: -119543, e: [17], l: 56 },
    { h: 24, s: -119601, e: [17], l: 58 },
    { h: 24, s: -119659, e: [17], l: 58 },
    { h: 24, s: -119717, e: [17], l: 58 },
    { h: 24, s: -119775, e: [17], l: 58 }
  ];
  var Table_B_2_lut_abs = createTable("b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3");
  var Table_B_2_lut_rel = createTable("179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7");
  var Table_B_2_complex = createTable("df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D", bytes2);
  var Table_C_ranges = createRangeTable("80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001");
  function flatten(values) {
    return values.reduce((accum, value) => {
      value.forEach((value2) => {
        accum.push(value2);
      });
      return accum;
    }, []);
  }
  function _nameprepTableA1(codepoint) {
    return !!matchMap(codepoint, Table_A_1_ranges);
  }
  function _nameprepTableB2(codepoint) {
    let range = matchMap(codepoint, Table_B_2_ranges);
    if (range) {
      return [codepoint + range.s];
    }
    let codes3 = Table_B_2_lut_abs[codepoint];
    if (codes3) {
      return codes3;
    }
    let shift = Table_B_2_lut_rel[codepoint];
    if (shift) {
      return [codepoint + shift[0]];
    }
    let complex = Table_B_2_complex[codepoint];
    if (complex) {
      return complex;
    }
    return null;
  }
  function _nameprepTableC(codepoint) {
    return !!matchMap(codepoint, Table_C_ranges);
  }
  function nameprep(value) {
    if (value.match(/^[a-z0-9-]*$/i) && value.length <= 59) {
      return value.toLowerCase();
    }
    let codes3 = toUtf8CodePoints(value);
    codes3 = flatten(codes3.map((code) => {
      if (Table_B_1_flags.indexOf(code) >= 0) {
        return [];
      }
      if (code >= 65024 && code <= 65039) {
        return [];
      }
      let codesTableB2 = _nameprepTableB2(code);
      if (codesTableB2) {
        return codesTableB2;
      }
      return [code];
    }));
    codes3 = toUtf8CodePoints(_toUtf8String(codes3), UnicodeNormalizationForm.NFKC);
    codes3.forEach((code) => {
      if (_nameprepTableC(code)) {
        throw new Error("STRINGPREP_CONTAINS_PROHIBITED");
      }
    });
    codes3.forEach((code) => {
      if (_nameprepTableA1(code)) {
        throw new Error("STRINGPREP_CONTAINS_UNASSIGNED");
      }
    });
    let name2 = _toUtf8String(codes3);
    if (name2.substring(0, 1) === "-" || name2.substring(2, 4) === "--" || name2.substring(name2.length - 1) === "-") {
      throw new Error("invalid hyphen");
    }
    if (name2.length > 63) {
      throw new Error("too long");
    }
    return name2;
  }

  // node_modules/@ethersproject/strings/lib.esm/index.js
  "use strict";

  // node_modules/@ethersproject/abi/lib.esm/coders/string.js
  "use strict";
  var StringCoder = class extends DynamicBytesCoder {
    constructor(localName) {
      super("string", localName);
    }
    defaultValue() {
      return "";
    }
    encode(writer, value) {
      return super.encode(writer, toUtf8Bytes(value));
    }
    decode(reader) {
      return toUtf8String(super.decode(reader));
    }
  };

  // node_modules/@ethersproject/abi/lib.esm/coders/tuple.js
  "use strict";
  var TupleCoder = class extends Coder {
    constructor(coders, localName) {
      let dynamic = false;
      const types = [];
      coders.forEach((coder) => {
        if (coder.dynamic) {
          dynamic = true;
        }
        types.push(coder.type);
      });
      const type = "tuple(" + types.join(",") + ")";
      super("tuple", type, localName, dynamic);
      this.coders = coders;
    }
    defaultValue() {
      const values = [];
      this.coders.forEach((coder) => {
        values.push(coder.defaultValue());
      });
      const uniqueNames = this.coders.reduce((accum, coder) => {
        const name2 = coder.localName;
        if (name2) {
          if (!accum[name2]) {
            accum[name2] = 0;
          }
          accum[name2]++;
        }
        return accum;
      }, {});
      this.coders.forEach((coder, index) => {
        let name2 = coder.localName;
        if (!name2 || uniqueNames[name2] !== 1) {
          return;
        }
        if (name2 === "length") {
          name2 = "_length";
        }
        if (values[name2] != null) {
          return;
        }
        values[name2] = values[index];
      });
      return Object.freeze(values);
    }
    encode(writer, value) {
      return pack(writer, this.coders, value);
    }
    decode(reader) {
      return reader.coerce(this.name, unpack(reader, this.coders));
    }
  };

  // node_modules/@ethersproject/abi/lib.esm/abi-coder.js
  "use strict";
  var logger11 = new Logger(version5);
  var paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);
  var paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);
  var AbiCoder = class {
    constructor(coerceFunc) {
      logger11.checkNew(new.target, AbiCoder);
      defineReadOnly(this, "coerceFunc", coerceFunc || null);
    }
    _getCoder(param) {
      switch (param.baseType) {
        case "address":
          return new AddressCoder(param.name);
        case "bool":
          return new BooleanCoder(param.name);
        case "string":
          return new StringCoder(param.name);
        case "bytes":
          return new BytesCoder(param.name);
        case "array":
          return new ArrayCoder(this._getCoder(param.arrayChildren), param.arrayLength, param.name);
        case "tuple":
          return new TupleCoder((param.components || []).map((component) => {
            return this._getCoder(component);
          }), param.name);
        case "":
          return new NullCoder(param.name);
      }
      let match = param.type.match(paramTypeNumber);
      if (match) {
        let size = parseInt(match[2] || "256");
        if (size === 0 || size > 256 || size % 8 !== 0) {
          logger11.throwArgumentError("invalid " + match[1] + " bit length", "param", param);
        }
        return new NumberCoder(size / 8, match[1] === "int", param.name);
      }
      match = param.type.match(paramTypeBytes);
      if (match) {
        let size = parseInt(match[1]);
        if (size === 0 || size > 32) {
          logger11.throwArgumentError("invalid bytes length", "param", param);
        }
        return new FixedBytesCoder(size, param.name);
      }
      return logger11.throwArgumentError("invalid type", "type", param.type);
    }
    _getWordSize() {
      return 32;
    }
    _getReader(data4, allowLoose) {
      return new Reader(data4, this._getWordSize(), this.coerceFunc, allowLoose);
    }
    _getWriter() {
      return new Writer(this._getWordSize());
    }
    getDefaultValue(types) {
      const coders = types.map((type) => this._getCoder(ParamType.from(type)));
      const coder = new TupleCoder(coders, "_");
      return coder.defaultValue();
    }
    encode(types, values) {
      if (types.length !== values.length) {
        logger11.throwError("types/values length mismatch", Logger.errors.INVALID_ARGUMENT, {
          count: { types: types.length, values: values.length },
          value: { types, values }
        });
      }
      const coders = types.map((type) => this._getCoder(ParamType.from(type)));
      const coder = new TupleCoder(coders, "_");
      const writer = this._getWriter();
      coder.encode(writer, values);
      return writer.data;
    }
    decode(types, data4, loose) {
      const coders = types.map((type) => this._getCoder(ParamType.from(type)));
      const coder = new TupleCoder(coders, "_");
      return coder.decode(this._getReader(arrayify(data4), loose));
    }
  };
  var defaultAbiCoder = new AbiCoder();

  // node_modules/@ethersproject/hash/lib.esm/id.js
  function id(text) {
    return keccak256(toUtf8Bytes(text));
  }

  // node_modules/@ethersproject/hash/lib.esm/_version.js
  var version9 = "hash/5.4.0";

  // node_modules/@ethersproject/hash/lib.esm/namehash.js
  var logger12 = new Logger(version9);
  var Zeros = new Uint8Array(32);
  Zeros.fill(0);
  var Partition = new RegExp("^((.*)\\.)?([^.]+)$");
  function isValidName(name2) {
    try {
      const comps = name2.split(".");
      for (let i3 = 0; i3 < comps.length; i3++) {
        if (nameprep(comps[i3]).length === 0) {
          throw new Error("empty");
        }
      }
      return true;
    } catch (error) {
    }
    return false;
  }
  function namehash(name2) {
    if (typeof name2 !== "string") {
      logger12.throwArgumentError("invalid ENS name; not a string", "name", name2);
    }
    let current = name2;
    let result = Zeros;
    while (current.length) {
      const partition = current.match(Partition);
      if (partition == null || partition[2] === "") {
        logger12.throwArgumentError("invalid ENS address; missing component", "name", name2);
      }
      const label = toUtf8Bytes(nameprep(partition[3]));
      result = keccak256(concat([result, keccak256(label)]));
      current = partition[2] || "";
    }
    return hexlify(result);
  }

  // node_modules/@ethersproject/hash/lib.esm/message.js
  var messagePrefix = "Ethereum Signed Message:\n";
  function hashMessage(message) {
    if (typeof message === "string") {
      message = toUtf8Bytes(message);
    }
    return keccak256(concat([
      toUtf8Bytes(messagePrefix),
      toUtf8Bytes(String(message.length)),
      message
    ]));
  }

  // node_modules/@ethersproject/hash/lib.esm/typed-data.js
  var __awaiter2 = function(thisArg, _arguments, P3, generator) {
    function adopt(value) {
      return value instanceof P3 ? value : new P3(function(resolve) {
        resolve(value);
      });
    }
    return new (P3 || (P3 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e3) {
          reject(e3);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e3) {
          reject(e3);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var logger13 = new Logger(version9);
  var padding = new Uint8Array(32);
  padding.fill(0);
  var NegativeOne3 = BigNumber.from(-1);
  var Zero3 = BigNumber.from(0);
  var One2 = BigNumber.from(1);
  var MaxUint2562 = BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
  function hexPadRight(value) {
    const bytes = arrayify(value);
    const padOffset = bytes.length % 32;
    if (padOffset) {
      return hexConcat([bytes, padding.slice(padOffset)]);
    }
    return hexlify(bytes);
  }
  var hexTrue = hexZeroPad(One2.toHexString(), 32);
  var hexFalse = hexZeroPad(Zero3.toHexString(), 32);
  var domainFieldTypes = {
    name: "string",
    version: "string",
    chainId: "uint256",
    verifyingContract: "address",
    salt: "bytes32"
  };
  var domainFieldNames = [
    "name",
    "version",
    "chainId",
    "verifyingContract",
    "salt"
  ];
  function checkString(key2) {
    return function(value) {
      if (typeof value !== "string") {
        logger13.throwArgumentError(`invalid domain value for ${JSON.stringify(key2)}`, `domain.${key2}`, value);
      }
      return value;
    };
  }
  var domainChecks = {
    name: checkString("name"),
    version: checkString("version"),
    chainId: function(value) {
      try {
        return BigNumber.from(value).toString();
      } catch (error) {
      }
      return logger13.throwArgumentError(`invalid domain value for "chainId"`, "domain.chainId", value);
    },
    verifyingContract: function(value) {
      try {
        return getAddress(value).toLowerCase();
      } catch (error) {
      }
      return logger13.throwArgumentError(`invalid domain value "verifyingContract"`, "domain.verifyingContract", value);
    },
    salt: function(value) {
      try {
        const bytes = arrayify(value);
        if (bytes.length !== 32) {
          throw new Error("bad length");
        }
        return hexlify(bytes);
      } catch (error) {
      }
      return logger13.throwArgumentError(`invalid domain value "salt"`, "domain.salt", value);
    }
  };
  function getBaseEncoder(type) {
    {
      const match = type.match(/^(u?)int(\d*)$/);
      if (match) {
        const signed = match[1] === "";
        const width = parseInt(match[2] || "256");
        if (width % 8 !== 0 || width > 256 || match[2] && match[2] !== String(width)) {
          logger13.throwArgumentError("invalid numeric width", "type", type);
        }
        const boundsUpper = MaxUint2562.mask(signed ? width - 1 : width);
        const boundsLower = signed ? boundsUpper.add(One2).mul(NegativeOne3) : Zero3;
        return function(value) {
          const v3 = BigNumber.from(value);
          if (v3.lt(boundsLower) || v3.gt(boundsUpper)) {
            logger13.throwArgumentError(`value out-of-bounds for ${type}`, "value", value);
          }
          return hexZeroPad(v3.toTwos(256).toHexString(), 32);
        };
      }
    }
    {
      const match = type.match(/^bytes(\d+)$/);
      if (match) {
        const width = parseInt(match[1]);
        if (width === 0 || width > 32 || match[1] !== String(width)) {
          logger13.throwArgumentError("invalid bytes width", "type", type);
        }
        return function(value) {
          const bytes = arrayify(value);
          if (bytes.length !== width) {
            logger13.throwArgumentError(`invalid length for ${type}`, "value", value);
          }
          return hexPadRight(value);
        };
      }
    }
    switch (type) {
      case "address":
        return function(value) {
          return hexZeroPad(getAddress(value), 32);
        };
      case "bool":
        return function(value) {
          return !value ? hexFalse : hexTrue;
        };
      case "bytes":
        return function(value) {
          return keccak256(value);
        };
      case "string":
        return function(value) {
          return id(value);
        };
    }
    return null;
  }
  function encodeType(name2, fields) {
    return `${name2}(${fields.map(({ name: name3, type }) => type + " " + name3).join(",")})`;
  }
  var TypedDataEncoder = class {
    constructor(types) {
      defineReadOnly(this, "types", Object.freeze(deepCopy(types)));
      defineReadOnly(this, "_encoderCache", {});
      defineReadOnly(this, "_types", {});
      const links = {};
      const parents = {};
      const subtypes = {};
      Object.keys(types).forEach((type) => {
        links[type] = {};
        parents[type] = [];
        subtypes[type] = {};
      });
      for (const name2 in types) {
        const uniqueNames = {};
        types[name2].forEach((field) => {
          if (uniqueNames[field.name]) {
            logger13.throwArgumentError(`duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name2)}`, "types", types);
          }
          uniqueNames[field.name] = true;
          const baseType = field.type.match(/^([^\x5b]*)(\x5b|$)/)[1];
          if (baseType === name2) {
            logger13.throwArgumentError(`circular type reference to ${JSON.stringify(baseType)}`, "types", types);
          }
          const encoder = getBaseEncoder(baseType);
          if (encoder) {
            return;
          }
          if (!parents[baseType]) {
            logger13.throwArgumentError(`unknown type ${JSON.stringify(baseType)}`, "types", types);
          }
          parents[baseType].push(name2);
          links[name2][baseType] = true;
        });
      }
      const primaryTypes = Object.keys(parents).filter((n2) => parents[n2].length === 0);
      if (primaryTypes.length === 0) {
        logger13.throwArgumentError("missing primary type", "types", types);
      } else if (primaryTypes.length > 1) {
        logger13.throwArgumentError(`ambiguous primary types or unused types: ${primaryTypes.map((t3) => JSON.stringify(t3)).join(", ")}`, "types", types);
      }
      defineReadOnly(this, "primaryType", primaryTypes[0]);
      function checkCircular(type, found) {
        if (found[type]) {
          logger13.throwArgumentError(`circular type reference to ${JSON.stringify(type)}`, "types", types);
        }
        found[type] = true;
        Object.keys(links[type]).forEach((child) => {
          if (!parents[child]) {
            return;
          }
          checkCircular(child, found);
          Object.keys(found).forEach((subtype) => {
            subtypes[subtype][child] = true;
          });
        });
        delete found[type];
      }
      checkCircular(this.primaryType, {});
      for (const name2 in subtypes) {
        const st = Object.keys(subtypes[name2]);
        st.sort();
        this._types[name2] = encodeType(name2, types[name2]) + st.map((t3) => encodeType(t3, types[t3])).join("");
      }
    }
    getEncoder(type) {
      let encoder = this._encoderCache[type];
      if (!encoder) {
        encoder = this._encoderCache[type] = this._getEncoder(type);
      }
      return encoder;
    }
    _getEncoder(type) {
      {
        const encoder = getBaseEncoder(type);
        if (encoder) {
          return encoder;
        }
      }
      const match = type.match(/^(.*)(\x5b(\d*)\x5d)$/);
      if (match) {
        const subtype = match[1];
        const subEncoder = this.getEncoder(subtype);
        const length = parseInt(match[3]);
        return (value) => {
          if (length >= 0 && value.length !== length) {
            logger13.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", value);
          }
          let result = value.map(subEncoder);
          if (this._types[subtype]) {
            result = result.map(keccak256);
          }
          return keccak256(hexConcat(result));
        };
      }
      const fields = this.types[type];
      if (fields) {
        const encodedType = id(this._types[type]);
        return (value) => {
          const values = fields.map(({ name: name2, type: type2 }) => {
            const result = this.getEncoder(type2)(value[name2]);
            if (this._types[type2]) {
              return keccak256(result);
            }
            return result;
          });
          values.unshift(encodedType);
          return hexConcat(values);
        };
      }
      return logger13.throwArgumentError(`unknown type: ${type}`, "type", type);
    }
    encodeType(name2) {
      const result = this._types[name2];
      if (!result) {
        logger13.throwArgumentError(`unknown type: ${JSON.stringify(name2)}`, "name", name2);
      }
      return result;
    }
    encodeData(type, value) {
      return this.getEncoder(type)(value);
    }
    hashStruct(name2, value) {
      return keccak256(this.encodeData(name2, value));
    }
    encode(value) {
      return this.encodeData(this.primaryType, value);
    }
    hash(value) {
      return this.hashStruct(this.primaryType, value);
    }
    _visit(type, value, callback) {
      {
        const encoder = getBaseEncoder(type);
        if (encoder) {
          return callback(type, value);
        }
      }
      const match = type.match(/^(.*)(\x5b(\d*)\x5d)$/);
      if (match) {
        const subtype = match[1];
        const length = parseInt(match[3]);
        if (length >= 0 && value.length !== length) {
          logger13.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", value);
        }
        return value.map((v3) => this._visit(subtype, v3, callback));
      }
      const fields = this.types[type];
      if (fields) {
        return fields.reduce((accum, { name: name2, type: type2 }) => {
          accum[name2] = this._visit(type2, value[name2], callback);
          return accum;
        }, {});
      }
      return logger13.throwArgumentError(`unknown type: ${type}`, "type", type);
    }
    visit(value, callback) {
      return this._visit(this.primaryType, value, callback);
    }
    static from(types) {
      return new TypedDataEncoder(types);
    }
    static getPrimaryType(types) {
      return TypedDataEncoder.from(types).primaryType;
    }
    static hashStruct(name2, types, value) {
      return TypedDataEncoder.from(types).hashStruct(name2, value);
    }
    static hashDomain(domain2) {
      const domainFields = [];
      for (const name2 in domain2) {
        const type = domainFieldTypes[name2];
        if (!type) {
          logger13.throwArgumentError(`invalid typed-data domain key: ${JSON.stringify(name2)}`, "domain", domain2);
        }
        domainFields.push({ name: name2, type });
      }
      domainFields.sort((a3, b2) => {
        return domainFieldNames.indexOf(a3.name) - domainFieldNames.indexOf(b2.name);
      });
      return TypedDataEncoder.hashStruct("EIP712Domain", { EIP712Domain: domainFields }, domain2);
    }
    static encode(domain2, types, value) {
      return hexConcat([
        "0x1901",
        TypedDataEncoder.hashDomain(domain2),
        TypedDataEncoder.from(types).hash(value)
      ]);
    }
    static hash(domain2, types, value) {
      return keccak256(TypedDataEncoder.encode(domain2, types, value));
    }
    static resolveNames(domain2, types, value, resolveName2) {
      return __awaiter2(this, void 0, void 0, function* () {
        domain2 = shallowCopy(domain2);
        const ensCache = {};
        if (domain2.verifyingContract && !isHexString(domain2.verifyingContract, 20)) {
          ensCache[domain2.verifyingContract] = "0x";
        }
        const encoder = TypedDataEncoder.from(types);
        encoder.visit(value, (type, value2) => {
          if (type === "address" && !isHexString(value2, 20)) {
            ensCache[value2] = "0x";
          }
          return value2;
        });
        for (const name2 in ensCache) {
          ensCache[name2] = yield resolveName2(name2);
        }
        if (domain2.verifyingContract && ensCache[domain2.verifyingContract]) {
          domain2.verifyingContract = ensCache[domain2.verifyingContract];
        }
        value = encoder.visit(value, (type, value2) => {
          if (type === "address" && ensCache[value2]) {
            return ensCache[value2];
          }
          return value2;
        });
        return { domain: domain2, value };
      });
    }
    static getPayload(domain2, types, value) {
      TypedDataEncoder.hashDomain(domain2);
      const domainValues = {};
      const domainTypes = [];
      domainFieldNames.forEach((name2) => {
        const value2 = domain2[name2];
        if (value2 == null) {
          return;
        }
        domainValues[name2] = domainChecks[name2](value2);
        domainTypes.push({ name: name2, type: domainFieldTypes[name2] });
      });
      const encoder = TypedDataEncoder.from(types);
      const typesWithDomain = shallowCopy(types);
      if (typesWithDomain.EIP712Domain) {
        logger13.throwArgumentError("types must not contain EIP712Domain type", "types.EIP712Domain", types);
      } else {
        typesWithDomain.EIP712Domain = domainTypes;
      }
      encoder.encode(value);
      return {
        types: typesWithDomain,
        domain: domainValues,
        primaryType: encoder.primaryType,
        message: encoder.visit(value, (type, value2) => {
          if (type.match(/^bytes(\d*)/)) {
            return hexlify(arrayify(value2));
          }
          if (type.match(/^u?int/)) {
            return BigNumber.from(value2).toString();
          }
          switch (type) {
            case "address":
              return value2.toLowerCase();
            case "bool":
              return !!value2;
            case "string":
              if (typeof value2 !== "string") {
                logger13.throwArgumentError(`invalid string`, "value", value2);
              }
              return value2;
          }
          return logger13.throwArgumentError("unsupported type", "type", type);
        })
      };
    }
  };

  // node_modules/@ethersproject/hash/lib.esm/index.js
  "use strict";

  // node_modules/@ethersproject/abi/lib.esm/interface.js
  "use strict";
  var logger14 = new Logger(version5);
  var LogDescription = class extends Description {
  };
  var TransactionDescription = class extends Description {
  };
  var ErrorDescription = class extends Description {
  };
  var Indexed = class extends Description {
    static isIndexed(value) {
      return !!(value && value._isIndexed);
    }
  };
  var BuiltinErrors = {
    "0x08c379a0": { signature: "Error(string)", name: "Error", inputs: ["string"], reason: true },
    "0x4e487b71": { signature: "Panic(uint256)", name: "Panic", inputs: ["uint256"] }
  };
  function wrapAccessError(property, error) {
    const wrap = new Error(`deferred error during ABI decoding triggered accessing ${property}`);
    wrap.error = error;
    return wrap;
  }
  var Interface = class {
    constructor(fragments) {
      logger14.checkNew(new.target, Interface);
      let abi = [];
      if (typeof fragments === "string") {
        abi = JSON.parse(fragments);
      } else {
        abi = fragments;
      }
      defineReadOnly(this, "fragments", abi.map((fragment) => {
        return Fragment.from(fragment);
      }).filter((fragment) => fragment != null));
      defineReadOnly(this, "_abiCoder", getStatic(new.target, "getAbiCoder")());
      defineReadOnly(this, "functions", {});
      defineReadOnly(this, "errors", {});
      defineReadOnly(this, "events", {});
      defineReadOnly(this, "structs", {});
      this.fragments.forEach((fragment) => {
        let bucket = null;
        switch (fragment.type) {
          case "constructor":
            if (this.deploy) {
              logger14.warn("duplicate definition - constructor");
              return;
            }
            defineReadOnly(this, "deploy", fragment);
            return;
          case "function":
            bucket = this.functions;
            break;
          case "event":
            bucket = this.events;
            break;
          case "error":
            bucket = this.errors;
            break;
          default:
            return;
        }
        let signature2 = fragment.format();
        if (bucket[signature2]) {
          logger14.warn("duplicate definition - " + signature2);
          return;
        }
        bucket[signature2] = fragment;
      });
      if (!this.deploy) {
        defineReadOnly(this, "deploy", ConstructorFragment.from({
          payable: false,
          type: "constructor"
        }));
      }
      defineReadOnly(this, "_isInterface", true);
    }
    format(format) {
      if (!format) {
        format = FormatTypes.full;
      }
      if (format === FormatTypes.sighash) {
        logger14.throwArgumentError("interface does not support formatting sighash", "format", format);
      }
      const abi = this.fragments.map((fragment) => fragment.format(format));
      if (format === FormatTypes.json) {
        return JSON.stringify(abi.map((j3) => JSON.parse(j3)));
      }
      return abi;
    }
    static getAbiCoder() {
      return defaultAbiCoder;
    }
    static getAddress(address) {
      return getAddress(address);
    }
    static getSighash(fragment) {
      return hexDataSlice(id(fragment.format()), 0, 4);
    }
    static getEventTopic(eventFragment) {
      return id(eventFragment.format());
    }
    getFunction(nameOrSignatureOrSighash) {
      if (isHexString(nameOrSignatureOrSighash)) {
        for (const name2 in this.functions) {
          if (nameOrSignatureOrSighash === this.getSighash(name2)) {
            return this.functions[name2];
          }
        }
        logger14.throwArgumentError("no matching function", "sighash", nameOrSignatureOrSighash);
      }
      if (nameOrSignatureOrSighash.indexOf("(") === -1) {
        const name2 = nameOrSignatureOrSighash.trim();
        const matching = Object.keys(this.functions).filter((f3) => f3.split("(")[0] === name2);
        if (matching.length === 0) {
          logger14.throwArgumentError("no matching function", "name", name2);
        } else if (matching.length > 1) {
          logger14.throwArgumentError("multiple matching functions", "name", name2);
        }
        return this.functions[matching[0]];
      }
      const result = this.functions[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];
      if (!result) {
        logger14.throwArgumentError("no matching function", "signature", nameOrSignatureOrSighash);
      }
      return result;
    }
    getEvent(nameOrSignatureOrTopic) {
      if (isHexString(nameOrSignatureOrTopic)) {
        const topichash = nameOrSignatureOrTopic.toLowerCase();
        for (const name2 in this.events) {
          if (topichash === this.getEventTopic(name2)) {
            return this.events[name2];
          }
        }
        logger14.throwArgumentError("no matching event", "topichash", topichash);
      }
      if (nameOrSignatureOrTopic.indexOf("(") === -1) {
        const name2 = nameOrSignatureOrTopic.trim();
        const matching = Object.keys(this.events).filter((f3) => f3.split("(")[0] === name2);
        if (matching.length === 0) {
          logger14.throwArgumentError("no matching event", "name", name2);
        } else if (matching.length > 1) {
          logger14.throwArgumentError("multiple matching events", "name", name2);
        }
        return this.events[matching[0]];
      }
      const result = this.events[EventFragment.fromString(nameOrSignatureOrTopic).format()];
      if (!result) {
        logger14.throwArgumentError("no matching event", "signature", nameOrSignatureOrTopic);
      }
      return result;
    }
    getError(nameOrSignatureOrSighash) {
      if (isHexString(nameOrSignatureOrSighash)) {
        const getSighash = getStatic(this.constructor, "getSighash");
        for (const name2 in this.errors) {
          const error = this.errors[name2];
          if (nameOrSignatureOrSighash === getSighash(error)) {
            return this.errors[name2];
          }
        }
        logger14.throwArgumentError("no matching error", "sighash", nameOrSignatureOrSighash);
      }
      if (nameOrSignatureOrSighash.indexOf("(") === -1) {
        const name2 = nameOrSignatureOrSighash.trim();
        const matching = Object.keys(this.errors).filter((f3) => f3.split("(")[0] === name2);
        if (matching.length === 0) {
          logger14.throwArgumentError("no matching error", "name", name2);
        } else if (matching.length > 1) {
          logger14.throwArgumentError("multiple matching errors", "name", name2);
        }
        return this.errors[matching[0]];
      }
      const result = this.errors[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];
      if (!result) {
        logger14.throwArgumentError("no matching error", "signature", nameOrSignatureOrSighash);
      }
      return result;
    }
    getSighash(fragment) {
      if (typeof fragment === "string") {
        try {
          fragment = this.getFunction(fragment);
        } catch (error) {
          try {
            fragment = this.getError(fragment);
          } catch (_4) {
            throw error;
          }
        }
      }
      return getStatic(this.constructor, "getSighash")(fragment);
    }
    getEventTopic(eventFragment) {
      if (typeof eventFragment === "string") {
        eventFragment = this.getEvent(eventFragment);
      }
      return getStatic(this.constructor, "getEventTopic")(eventFragment);
    }
    _decodeParams(params, data4) {
      return this._abiCoder.decode(params, data4);
    }
    _encodeParams(params, values) {
      return this._abiCoder.encode(params, values);
    }
    encodeDeploy(values) {
      return this._encodeParams(this.deploy.inputs, values || []);
    }
    decodeErrorResult(fragment, data4) {
      if (typeof fragment === "string") {
        fragment = this.getError(fragment);
      }
      const bytes = arrayify(data4);
      if (hexlify(bytes.slice(0, 4)) !== this.getSighash(fragment)) {
        logger14.throwArgumentError(`data signature does not match error ${fragment.name}.`, "data", hexlify(bytes));
      }
      return this._decodeParams(fragment.inputs, bytes.slice(4));
    }
    encodeErrorResult(fragment, values) {
      if (typeof fragment === "string") {
        fragment = this.getError(fragment);
      }
      return hexlify(concat([
        this.getSighash(fragment),
        this._encodeParams(fragment.inputs, values || [])
      ]));
    }
    decodeFunctionData(functionFragment, data4) {
      if (typeof functionFragment === "string") {
        functionFragment = this.getFunction(functionFragment);
      }
      const bytes = arrayify(data4);
      if (hexlify(bytes.slice(0, 4)) !== this.getSighash(functionFragment)) {
        logger14.throwArgumentError(`data signature does not match function ${functionFragment.name}.`, "data", hexlify(bytes));
      }
      return this._decodeParams(functionFragment.inputs, bytes.slice(4));
    }
    encodeFunctionData(functionFragment, values) {
      if (typeof functionFragment === "string") {
        functionFragment = this.getFunction(functionFragment);
      }
      return hexlify(concat([
        this.getSighash(functionFragment),
        this._encodeParams(functionFragment.inputs, values || [])
      ]));
    }
    decodeFunctionResult(functionFragment, data4) {
      if (typeof functionFragment === "string") {
        functionFragment = this.getFunction(functionFragment);
      }
      let bytes = arrayify(data4);
      let reason = null;
      let errorArgs = null;
      let errorName = null;
      let errorSignature = null;
      switch (bytes.length % this._abiCoder._getWordSize()) {
        case 0:
          try {
            return this._abiCoder.decode(functionFragment.outputs, bytes);
          } catch (error) {
          }
          break;
        case 4: {
          const selector = hexlify(bytes.slice(0, 4));
          const builtin = BuiltinErrors[selector];
          if (builtin) {
            errorArgs = this._abiCoder.decode(builtin.inputs, bytes.slice(4));
            errorName = builtin.name;
            errorSignature = builtin.signature;
            if (builtin.reason) {
              reason = errorArgs[0];
            }
          } else {
            try {
              const error = this.getError(selector);
              errorArgs = this._abiCoder.decode(error.inputs, bytes.slice(4));
              errorName = error.name;
              errorSignature = error.format();
            } catch (error) {
              console.log(error);
            }
          }
          break;
        }
      }
      return logger14.throwError("call revert exception", Logger.errors.CALL_EXCEPTION, {
        method: functionFragment.format(),
        errorArgs,
        errorName,
        errorSignature,
        reason
      });
    }
    encodeFunctionResult(functionFragment, values) {
      if (typeof functionFragment === "string") {
        functionFragment = this.getFunction(functionFragment);
      }
      return hexlify(this._abiCoder.encode(functionFragment.outputs, values || []));
    }
    encodeFilterTopics(eventFragment, values) {
      if (typeof eventFragment === "string") {
        eventFragment = this.getEvent(eventFragment);
      }
      if (values.length > eventFragment.inputs.length) {
        logger14.throwError("too many arguments for " + eventFragment.format(), Logger.errors.UNEXPECTED_ARGUMENT, {
          argument: "values",
          value: values
        });
      }
      let topics = [];
      if (!eventFragment.anonymous) {
        topics.push(this.getEventTopic(eventFragment));
      }
      const encodeTopic = (param, value) => {
        if (param.type === "string") {
          return id(value);
        } else if (param.type === "bytes") {
          return keccak256(hexlify(value));
        }
        if (param.type === "address") {
          this._abiCoder.encode(["address"], [value]);
        }
        return hexZeroPad(hexlify(value), 32);
      };
      values.forEach((value, index) => {
        let param = eventFragment.inputs[index];
        if (!param.indexed) {
          if (value != null) {
            logger14.throwArgumentError("cannot filter non-indexed parameters; must be null", "contract." + param.name, value);
          }
          return;
        }
        if (value == null) {
          topics.push(null);
        } else if (param.baseType === "array" || param.baseType === "tuple") {
          logger14.throwArgumentError("filtering with tuples or arrays not supported", "contract." + param.name, value);
        } else if (Array.isArray(value)) {
          topics.push(value.map((value2) => encodeTopic(param, value2)));
        } else {
          topics.push(encodeTopic(param, value));
        }
      });
      while (topics.length && topics[topics.length - 1] === null) {
        topics.pop();
      }
      return topics;
    }
    encodeEventLog(eventFragment, values) {
      if (typeof eventFragment === "string") {
        eventFragment = this.getEvent(eventFragment);
      }
      const topics = [];
      const dataTypes = [];
      const dataValues = [];
      if (!eventFragment.anonymous) {
        topics.push(this.getEventTopic(eventFragment));
      }
      if (values.length !== eventFragment.inputs.length) {
        logger14.throwArgumentError("event arguments/values mismatch", "values", values);
      }
      eventFragment.inputs.forEach((param, index) => {
        const value = values[index];
        if (param.indexed) {
          if (param.type === "string") {
            topics.push(id(value));
          } else if (param.type === "bytes") {
            topics.push(keccak256(value));
          } else if (param.baseType === "tuple" || param.baseType === "array") {
            throw new Error("not implemented");
          } else {
            topics.push(this._abiCoder.encode([param.type], [value]));
          }
        } else {
          dataTypes.push(param);
          dataValues.push(value);
        }
      });
      return {
        data: this._abiCoder.encode(dataTypes, dataValues),
        topics
      };
    }
    decodeEventLog(eventFragment, data4, topics) {
      if (typeof eventFragment === "string") {
        eventFragment = this.getEvent(eventFragment);
      }
      if (topics != null && !eventFragment.anonymous) {
        let topicHash = this.getEventTopic(eventFragment);
        if (!isHexString(topics[0], 32) || topics[0].toLowerCase() !== topicHash) {
          logger14.throwError("fragment/topic mismatch", Logger.errors.INVALID_ARGUMENT, { argument: "topics[0]", expected: topicHash, value: topics[0] });
        }
        topics = topics.slice(1);
      }
      let indexed = [];
      let nonIndexed = [];
      let dynamic = [];
      eventFragment.inputs.forEach((param, index) => {
        if (param.indexed) {
          if (param.type === "string" || param.type === "bytes" || param.baseType === "tuple" || param.baseType === "array") {
            indexed.push(ParamType.fromObject({ type: "bytes32", name: param.name }));
            dynamic.push(true);
          } else {
            indexed.push(param);
            dynamic.push(false);
          }
        } else {
          nonIndexed.push(param);
          dynamic.push(false);
        }
      });
      let resultIndexed = topics != null ? this._abiCoder.decode(indexed, concat(topics)) : null;
      let resultNonIndexed = this._abiCoder.decode(nonIndexed, data4, true);
      let result = [];
      let nonIndexedIndex = 0, indexedIndex = 0;
      eventFragment.inputs.forEach((param, index) => {
        if (param.indexed) {
          if (resultIndexed == null) {
            result[index] = new Indexed({ _isIndexed: true, hash: null });
          } else if (dynamic[index]) {
            result[index] = new Indexed({ _isIndexed: true, hash: resultIndexed[indexedIndex++] });
          } else {
            try {
              result[index] = resultIndexed[indexedIndex++];
            } catch (error) {
              result[index] = error;
            }
          }
        } else {
          try {
            result[index] = resultNonIndexed[nonIndexedIndex++];
          } catch (error) {
            result[index] = error;
          }
        }
        if (param.name && result[param.name] == null) {
          const value = result[index];
          if (value instanceof Error) {
            Object.defineProperty(result, param.name, {
              get: () => {
                throw wrapAccessError(`property ${JSON.stringify(param.name)}`, value);
              }
            });
          } else {
            result[param.name] = value;
          }
        }
      });
      for (let i3 = 0; i3 < result.length; i3++) {
        const value = result[i3];
        if (value instanceof Error) {
          Object.defineProperty(result, i3, {
            get: () => {
              throw wrapAccessError(`index ${i3}`, value);
            }
          });
        }
      }
      return Object.freeze(result);
    }
    parseTransaction(tx) {
      let fragment = this.getFunction(tx.data.substring(0, 10).toLowerCase());
      if (!fragment) {
        return null;
      }
      return new TransactionDescription({
        args: this._abiCoder.decode(fragment.inputs, "0x" + tx.data.substring(10)),
        functionFragment: fragment,
        name: fragment.name,
        signature: fragment.format(),
        sighash: this.getSighash(fragment),
        value: BigNumber.from(tx.value || "0")
      });
    }
    parseLog(log) {
      let fragment = this.getEvent(log.topics[0]);
      if (!fragment || fragment.anonymous) {
        return null;
      }
      return new LogDescription({
        eventFragment: fragment,
        name: fragment.name,
        signature: fragment.format(),
        topic: this.getEventTopic(fragment),
        args: this.decodeEventLog(fragment, log.data, log.topics)
      });
    }
    parseError(data4) {
      const hexData = hexlify(data4);
      let fragment = this.getError(hexData.substring(0, 10).toLowerCase());
      if (!fragment) {
        return null;
      }
      return new ErrorDescription({
        args: this._abiCoder.decode(fragment.inputs, "0x" + hexData.substring(10)),
        errorFragment: fragment,
        name: fragment.name,
        signature: fragment.format(),
        sighash: this.getSighash(fragment)
      });
    }
    static isInterface(value) {
      return !!(value && value._isInterface);
    }
  };

  // node_modules/@ethersproject/abi/lib.esm/index.js
  "use strict";

  // node_modules/@ethersproject/abstract-provider/lib.esm/_version.js
  var version10 = "abstract-provider/5.4.1";

  // node_modules/@ethersproject/abstract-provider/lib.esm/index.js
  "use strict";
  var __awaiter3 = function(thisArg, _arguments, P3, generator) {
    function adopt(value) {
      return value instanceof P3 ? value : new P3(function(resolve) {
        resolve(value);
      });
    }
    return new (P3 || (P3 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e3) {
          reject(e3);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e3) {
          reject(e3);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var logger15 = new Logger(version10);
  var ForkEvent = class extends Description {
    static isForkEvent(value) {
      return !!(value && value._isForkEvent);
    }
  };
  var Provider = class {
    constructor() {
      logger15.checkAbstract(new.target, Provider);
      defineReadOnly(this, "_isProvider", true);
    }
    getFeeData() {
      return __awaiter3(this, void 0, void 0, function* () {
        const { block, gasPrice } = yield resolveProperties({
          block: this.getBlock("latest"),
          gasPrice: this.getGasPrice().catch((error) => {
            return null;
          })
        });
        let maxFeePerGas = null, maxPriorityFeePerGas = null;
        if (block && block.baseFeePerGas) {
          maxPriorityFeePerGas = BigNumber.from("2500000000");
          maxFeePerGas = block.baseFeePerGas.mul(2).add(maxPriorityFeePerGas);
        }
        return { maxFeePerGas, maxPriorityFeePerGas, gasPrice };
      });
    }
    addListener(eventName, listener) {
      return this.on(eventName, listener);
    }
    removeListener(eventName, listener) {
      return this.off(eventName, listener);
    }
    static isProvider(value) {
      return !!(value && value._isProvider);
    }
  };

  // node_modules/@ethersproject/abstract-signer/lib.esm/_version.js
  var version11 = "abstract-signer/5.4.1";

  // node_modules/@ethersproject/abstract-signer/lib.esm/index.js
  "use strict";
  var __awaiter4 = function(thisArg, _arguments, P3, generator) {
    function adopt(value) {
      return value instanceof P3 ? value : new P3(function(resolve) {
        resolve(value);
      });
    }
    return new (P3 || (P3 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e3) {
          reject(e3);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e3) {
          reject(e3);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var logger16 = new Logger(version11);
  var allowedTransactionKeys = [
    "accessList",
    "chainId",
    "data",
    "from",
    "gasLimit",
    "gasPrice",
    "maxFeePerGas",
    "maxPriorityFeePerGas",
    "nonce",
    "to",
    "type",
    "value"
  ];
  var forwardErrors = [
    Logger.errors.INSUFFICIENT_FUNDS,
    Logger.errors.NONCE_EXPIRED,
    Logger.errors.REPLACEMENT_UNDERPRICED
  ];
  var Signer = class {
    constructor() {
      logger16.checkAbstract(new.target, Signer);
      defineReadOnly(this, "_isSigner", true);
    }
    getBalance(blockTag) {
      return __awaiter4(this, void 0, void 0, function* () {
        this._checkProvider("getBalance");
        return yield this.provider.getBalance(this.getAddress(), blockTag);
      });
    }
    getTransactionCount(blockTag) {
      return __awaiter4(this, void 0, void 0, function* () {
        this._checkProvider("getTransactionCount");
        return yield this.provider.getTransactionCount(this.getAddress(), blockTag);
      });
    }
    estimateGas(transaction) {
      return __awaiter4(this, void 0, void 0, function* () {
        this._checkProvider("estimateGas");
        const tx = yield resolveProperties(this.checkTransaction(transaction));
        return yield this.provider.estimateGas(tx);
      });
    }
    call(transaction, blockTag) {
      return __awaiter4(this, void 0, void 0, function* () {
        this._checkProvider("call");
        const tx = yield resolveProperties(this.checkTransaction(transaction));
        return yield this.provider.call(tx, blockTag);
      });
    }
    sendTransaction(transaction) {
      return __awaiter4(this, void 0, void 0, function* () {
        this._checkProvider("sendTransaction");
        const tx = yield this.populateTransaction(transaction);
        const signedTx = yield this.signTransaction(tx);
        return yield this.provider.sendTransaction(signedTx);
      });
    }
    getChainId() {
      return __awaiter4(this, void 0, void 0, function* () {
        this._checkProvider("getChainId");
        const network = yield this.provider.getNetwork();
        return network.chainId;
      });
    }
    getGasPrice() {
      return __awaiter4(this, void 0, void 0, function* () {
        this._checkProvider("getGasPrice");
        return yield this.provider.getGasPrice();
      });
    }
    getFeeData() {
      return __awaiter4(this, void 0, void 0, function* () {
        this._checkProvider("getFeeData");
        return yield this.provider.getFeeData();
      });
    }
    resolveName(name2) {
      return __awaiter4(this, void 0, void 0, function* () {
        this._checkProvider("resolveName");
        return yield this.provider.resolveName(name2);
      });
    }
    checkTransaction(transaction) {
      for (const key2 in transaction) {
        if (allowedTransactionKeys.indexOf(key2) === -1) {
          logger16.throwArgumentError("invalid transaction key: " + key2, "transaction", transaction);
        }
      }
      const tx = shallowCopy(transaction);
      if (tx.from == null) {
        tx.from = this.getAddress();
      } else {
        tx.from = Promise.all([
          Promise.resolve(tx.from),
          this.getAddress()
        ]).then((result) => {
          if (result[0].toLowerCase() !== result[1].toLowerCase()) {
            logger16.throwArgumentError("from address mismatch", "transaction", transaction);
          }
          return result[0];
        });
      }
      return tx;
    }
    populateTransaction(transaction) {
      return __awaiter4(this, void 0, void 0, function* () {
        const tx = yield resolveProperties(this.checkTransaction(transaction));
        if (tx.to != null) {
          tx.to = Promise.resolve(tx.to).then((to) => __awaiter4(this, void 0, void 0, function* () {
            if (to == null) {
              return null;
            }
            const address = yield this.resolveName(to);
            if (address == null) {
              logger16.throwArgumentError("provided ENS name resolves to null", "tx.to", to);
            }
            return address;
          }));
          tx.to.catch((error) => {
          });
        }
        const hasEip1559 = tx.maxFeePerGas != null || tx.maxPriorityFeePerGas != null;
        if (tx.gasPrice != null && (tx.type === 2 || hasEip1559)) {
          logger16.throwArgumentError("eip-1559 transaction do not support gasPrice", "transaction", transaction);
        } else if ((tx.type === 0 || tx.type === 1) && hasEip1559) {
          logger16.throwArgumentError("pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "transaction", transaction);
        }
        if ((tx.type === 2 || tx.type == null) && (tx.maxFeePerGas != null && tx.maxPriorityFeePerGas != null)) {
          tx.type = 2;
        } else if (tx.type === 0 || tx.type === 1) {
          if (tx.gasPrice == null) {
            tx.gasPrice = this.getGasPrice();
          }
        } else {
          const feeData = yield this.getFeeData();
          if (tx.type == null) {
            if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {
              tx.type = 2;
              if (tx.gasPrice != null) {
                const gasPrice = tx.gasPrice;
                delete tx.gasPrice;
                tx.maxFeePerGas = gasPrice;
                tx.maxPriorityFeePerGas = gasPrice;
              } else {
                if (tx.maxFeePerGas == null) {
                  tx.maxFeePerGas = feeData.maxFeePerGas;
                }
                if (tx.maxPriorityFeePerGas == null) {
                  tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
                }
              }
            } else if (feeData.gasPrice != null) {
              if (hasEip1559) {
                logger16.throwError("network does not support EIP-1559", Logger.errors.UNSUPPORTED_OPERATION, {
                  operation: "populateTransaction"
                });
              }
              if (tx.gasPrice == null) {
                tx.gasPrice = feeData.gasPrice;
              }
              tx.type = 0;
            } else {
              logger16.throwError("failed to get consistent fee data", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "signer.getFeeData"
              });
            }
          } else if (tx.type === 2) {
            if (tx.maxFeePerGas == null) {
              tx.maxFeePerGas = feeData.maxFeePerGas;
            }
            if (tx.maxPriorityFeePerGas == null) {
              tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
            }
          }
        }
        if (tx.nonce == null) {
          tx.nonce = this.getTransactionCount("pending");
        }
        if (tx.gasLimit == null) {
          tx.gasLimit = this.estimateGas(tx).catch((error) => {
            if (forwardErrors.indexOf(error.code) >= 0) {
              throw error;
            }
            return logger16.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
              error,
              tx
            });
          });
        }
        if (tx.chainId == null) {
          tx.chainId = this.getChainId();
        } else {
          tx.chainId = Promise.all([
            Promise.resolve(tx.chainId),
            this.getChainId()
          ]).then((results) => {
            if (results[1] !== 0 && results[0] !== results[1]) {
              logger16.throwArgumentError("chainId address mismatch", "transaction", transaction);
            }
            return results[0];
          });
        }
        return yield resolveProperties(tx);
      });
    }
    _checkProvider(operation) {
      if (!this.provider) {
        logger16.throwError("missing provider", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: operation || "_checkProvider"
        });
      }
    }
    static isSigner(value) {
      return !!(value && value._isSigner);
    }
  };
  var VoidSigner = class extends Signer {
    constructor(address, provider) {
      logger16.checkNew(new.target, VoidSigner);
      super();
      defineReadOnly(this, "address", address);
      defineReadOnly(this, "provider", provider || null);
    }
    getAddress() {
      return Promise.resolve(this.address);
    }
    _fail(message, operation) {
      return Promise.resolve().then(() => {
        logger16.throwError(message, Logger.errors.UNSUPPORTED_OPERATION, { operation });
      });
    }
    signMessage(message) {
      return this._fail("VoidSigner cannot sign messages", "signMessage");
    }
    signTransaction(transaction) {
      return this._fail("VoidSigner cannot sign transactions", "signTransaction");
    }
    _signTypedData(domain2, types, value) {
      return this._fail("VoidSigner cannot sign typed data", "signTypedData");
    }
    connect(provider) {
      return new VoidSigner(this.address, provider);
    }
  };

  // node_modules/@ethersproject/signing-key/lib.esm/elliptic.js
  var import_bn2 = __toModule(require_bn());
  var import_hash2 = __toModule(require_hash());
  function createCommonjsModule(fn, basedir, module) {
    return module = {
      path: basedir,
      exports: {},
      require: function(path, base2) {
        return commonjsRequire(path, base2 === void 0 || base2 === null ? module.path : base2);
      }
    }, fn(module, module.exports), module.exports;
  }
  function commonjsRequire() {
    throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
  }
  var minimalisticAssert = assert;
  function assert(val, msg) {
    if (!val)
      throw new Error(msg || "Assertion failed");
  }
  assert.equal = function assertEqual(l3, r3, msg) {
    if (l3 != r3)
      throw new Error(msg || "Assertion failed: " + l3 + " != " + r3);
  };
  var utils_1 = createCommonjsModule(function(module, exports) {
    "use strict";
    var utils = exports;
    function toArray(msg, enc) {
      if (Array.isArray(msg))
        return msg.slice();
      if (!msg)
        return [];
      var res = [];
      if (typeof msg !== "string") {
        for (var i3 = 0; i3 < msg.length; i3++)
          res[i3] = msg[i3] | 0;
        return res;
      }
      if (enc === "hex") {
        msg = msg.replace(/[^a-z0-9]+/ig, "");
        if (msg.length % 2 !== 0)
          msg = "0" + msg;
        for (var i3 = 0; i3 < msg.length; i3 += 2)
          res.push(parseInt(msg[i3] + msg[i3 + 1], 16));
      } else {
        for (var i3 = 0; i3 < msg.length; i3++) {
          var c3 = msg.charCodeAt(i3);
          var hi = c3 >> 8;
          var lo = c3 & 255;
          if (hi)
            res.push(hi, lo);
          else
            res.push(lo);
        }
      }
      return res;
    }
    utils.toArray = toArray;
    function zero2(word) {
      if (word.length === 1)
        return "0" + word;
      else
        return word;
    }
    utils.zero2 = zero2;
    function toHex2(msg) {
      var res = "";
      for (var i3 = 0; i3 < msg.length; i3++)
        res += zero2(msg[i3].toString(16));
      return res;
    }
    utils.toHex = toHex2;
    utils.encode = function encode4(arr, enc) {
      if (enc === "hex")
        return toHex2(arr);
      else
        return arr;
    };
  });
  var utils_1$1 = createCommonjsModule(function(module, exports) {
    "use strict";
    var utils = exports;
    utils.assert = minimalisticAssert;
    utils.toArray = utils_1.toArray;
    utils.zero2 = utils_1.zero2;
    utils.toHex = utils_1.toHex;
    utils.encode = utils_1.encode;
    function getNAF2(num, w4, bits) {
      var naf = new Array(Math.max(num.bitLength(), bits) + 1);
      naf.fill(0);
      var ws = 1 << w4 + 1;
      var k3 = num.clone();
      for (var i3 = 0; i3 < naf.length; i3++) {
        var z3;
        var mod = k3.andln(ws - 1);
        if (k3.isOdd()) {
          if (mod > (ws >> 1) - 1)
            z3 = (ws >> 1) - mod;
          else
            z3 = mod;
          k3.isubn(z3);
        } else {
          z3 = 0;
        }
        naf[i3] = z3;
        k3.iushrn(1);
      }
      return naf;
    }
    utils.getNAF = getNAF2;
    function getJSF2(k1, k22) {
      var jsf = [
        [],
        []
      ];
      k1 = k1.clone();
      k22 = k22.clone();
      var d1 = 0;
      var d22 = 0;
      var m8;
      while (k1.cmpn(-d1) > 0 || k22.cmpn(-d22) > 0) {
        var m14 = k1.andln(3) + d1 & 3;
        var m24 = k22.andln(3) + d22 & 3;
        if (m14 === 3)
          m14 = -1;
        if (m24 === 3)
          m24 = -1;
        var u1;
        if ((m14 & 1) === 0) {
          u1 = 0;
        } else {
          m8 = k1.andln(7) + d1 & 7;
          if ((m8 === 3 || m8 === 5) && m24 === 2)
            u1 = -m14;
          else
            u1 = m14;
        }
        jsf[0].push(u1);
        var u22;
        if ((m24 & 1) === 0) {
          u22 = 0;
        } else {
          m8 = k22.andln(7) + d22 & 7;
          if ((m8 === 3 || m8 === 5) && m14 === 2)
            u22 = -m24;
          else
            u22 = m24;
        }
        jsf[1].push(u22);
        if (2 * d1 === u1 + 1)
          d1 = 1 - d1;
        if (2 * d22 === u22 + 1)
          d22 = 1 - d22;
        k1.iushrn(1);
        k22.iushrn(1);
      }
      return jsf;
    }
    utils.getJSF = getJSF2;
    function cachedProperty(obj, name2, computer) {
      var key2 = "_" + name2;
      obj.prototype[name2] = function cachedProperty2() {
        return this[key2] !== void 0 ? this[key2] : this[key2] = computer.call(this);
      };
    }
    utils.cachedProperty = cachedProperty;
    function parseBytes(bytes) {
      return typeof bytes === "string" ? utils.toArray(bytes, "hex") : bytes;
    }
    utils.parseBytes = parseBytes;
    function intFromLE(bytes) {
      return new import_bn2.default(bytes, "hex", "le");
    }
    utils.intFromLE = intFromLE;
  });
  var getNAF = utils_1$1.getNAF;
  var getJSF = utils_1$1.getJSF;
  var assert$1 = utils_1$1.assert;
  function BaseCurve(type, conf) {
    this.type = type;
    this.p = new import_bn2.default(conf.p, 16);
    this.red = conf.prime ? import_bn2.default.red(conf.prime) : import_bn2.default.mont(this.p);
    this.zero = new import_bn2.default(0).toRed(this.red);
    this.one = new import_bn2.default(1).toRed(this.red);
    this.two = new import_bn2.default(2).toRed(this.red);
    this.n = conf.n && new import_bn2.default(conf.n, 16);
    this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
    this._wnafT1 = new Array(4);
    this._wnafT2 = new Array(4);
    this._wnafT3 = new Array(4);
    this._wnafT4 = new Array(4);
    this._bitLength = this.n ? this.n.bitLength() : 0;
    var adjustCount = this.n && this.p.div(this.n);
    if (!adjustCount || adjustCount.cmpn(100) > 0) {
      this.redN = null;
    } else {
      this._maxwellTrick = true;
      this.redN = this.n.toRed(this.red);
    }
  }
  var base = BaseCurve;
  BaseCurve.prototype.point = function point() {
    throw new Error("Not implemented");
  };
  BaseCurve.prototype.validate = function validate() {
    throw new Error("Not implemented");
  };
  BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p3, k3) {
    assert$1(p3.precomputed);
    var doubles = p3._getDoubles();
    var naf = getNAF(k3, 1, this._bitLength);
    var I3 = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
    I3 /= 3;
    var repr = [];
    var j3;
    var nafW;
    for (j3 = 0; j3 < naf.length; j3 += doubles.step) {
      nafW = 0;
      for (var l3 = j3 + doubles.step - 1; l3 >= j3; l3--)
        nafW = (nafW << 1) + naf[l3];
      repr.push(nafW);
    }
    var a3 = this.jpoint(null, null, null);
    var b2 = this.jpoint(null, null, null);
    for (var i3 = I3; i3 > 0; i3--) {
      for (j3 = 0; j3 < repr.length; j3++) {
        nafW = repr[j3];
        if (nafW === i3)
          b2 = b2.mixedAdd(doubles.points[j3]);
        else if (nafW === -i3)
          b2 = b2.mixedAdd(doubles.points[j3].neg());
      }
      a3 = a3.add(b2);
    }
    return a3.toP();
  };
  BaseCurve.prototype._wnafMul = function _wnafMul(p3, k3) {
    var w4 = 4;
    var nafPoints = p3._getNAFPoints(w4);
    w4 = nafPoints.wnd;
    var wnd = nafPoints.points;
    var naf = getNAF(k3, w4, this._bitLength);
    var acc = this.jpoint(null, null, null);
    for (var i3 = naf.length - 1; i3 >= 0; i3--) {
      for (var l3 = 0; i3 >= 0 && naf[i3] === 0; i3--)
        l3++;
      if (i3 >= 0)
        l3++;
      acc = acc.dblp(l3);
      if (i3 < 0)
        break;
      var z3 = naf[i3];
      assert$1(z3 !== 0);
      if (p3.type === "affine") {
        if (z3 > 0)
          acc = acc.mixedAdd(wnd[z3 - 1 >> 1]);
        else
          acc = acc.mixedAdd(wnd[-z3 - 1 >> 1].neg());
      } else {
        if (z3 > 0)
          acc = acc.add(wnd[z3 - 1 >> 1]);
        else
          acc = acc.add(wnd[-z3 - 1 >> 1].neg());
      }
    }
    return p3.type === "affine" ? acc.toP() : acc;
  };
  BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len, jacobianResult) {
    var wndWidth = this._wnafT1;
    var wnd = this._wnafT2;
    var naf = this._wnafT3;
    var max = 0;
    var i3;
    var j3;
    var p3;
    for (i3 = 0; i3 < len; i3++) {
      p3 = points[i3];
      var nafPoints = p3._getNAFPoints(defW);
      wndWidth[i3] = nafPoints.wnd;
      wnd[i3] = nafPoints.points;
    }
    for (i3 = len - 1; i3 >= 1; i3 -= 2) {
      var a3 = i3 - 1;
      var b2 = i3;
      if (wndWidth[a3] !== 1 || wndWidth[b2] !== 1) {
        naf[a3] = getNAF(coeffs[a3], wndWidth[a3], this._bitLength);
        naf[b2] = getNAF(coeffs[b2], wndWidth[b2], this._bitLength);
        max = Math.max(naf[a3].length, max);
        max = Math.max(naf[b2].length, max);
        continue;
      }
      var comb = [
        points[a3],
        null,
        null,
        points[b2]
      ];
      if (points[a3].y.cmp(points[b2].y) === 0) {
        comb[1] = points[a3].add(points[b2]);
        comb[2] = points[a3].toJ().mixedAdd(points[b2].neg());
      } else if (points[a3].y.cmp(points[b2].y.redNeg()) === 0) {
        comb[1] = points[a3].toJ().mixedAdd(points[b2]);
        comb[2] = points[a3].add(points[b2].neg());
      } else {
        comb[1] = points[a3].toJ().mixedAdd(points[b2]);
        comb[2] = points[a3].toJ().mixedAdd(points[b2].neg());
      }
      var index = [
        -3,
        -1,
        -5,
        -7,
        0,
        7,
        5,
        1,
        3
      ];
      var jsf = getJSF(coeffs[a3], coeffs[b2]);
      max = Math.max(jsf[0].length, max);
      naf[a3] = new Array(max);
      naf[b2] = new Array(max);
      for (j3 = 0; j3 < max; j3++) {
        var ja = jsf[0][j3] | 0;
        var jb = jsf[1][j3] | 0;
        naf[a3][j3] = index[(ja + 1) * 3 + (jb + 1)];
        naf[b2][j3] = 0;
        wnd[a3] = comb;
      }
    }
    var acc = this.jpoint(null, null, null);
    var tmp = this._wnafT4;
    for (i3 = max; i3 >= 0; i3--) {
      var k3 = 0;
      while (i3 >= 0) {
        var zero = true;
        for (j3 = 0; j3 < len; j3++) {
          tmp[j3] = naf[j3][i3] | 0;
          if (tmp[j3] !== 0)
            zero = false;
        }
        if (!zero)
          break;
        k3++;
        i3--;
      }
      if (i3 >= 0)
        k3++;
      acc = acc.dblp(k3);
      if (i3 < 0)
        break;
      for (j3 = 0; j3 < len; j3++) {
        var z3 = tmp[j3];
        p3;
        if (z3 === 0)
          continue;
        else if (z3 > 0)
          p3 = wnd[j3][z3 - 1 >> 1];
        else if (z3 < 0)
          p3 = wnd[j3][-z3 - 1 >> 1].neg();
        if (p3.type === "affine")
          acc = acc.mixedAdd(p3);
        else
          acc = acc.add(p3);
      }
    }
    for (i3 = 0; i3 < len; i3++)
      wnd[i3] = null;
    if (jacobianResult)
      return acc;
    else
      return acc.toP();
  };
  function BasePoint(curve, type) {
    this.curve = curve;
    this.type = type;
    this.precomputed = null;
  }
  BaseCurve.BasePoint = BasePoint;
  BasePoint.prototype.eq = function eq() {
    throw new Error("Not implemented");
  };
  BasePoint.prototype.validate = function validate2() {
    return this.curve.validate(this);
  };
  BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
    bytes = utils_1$1.toArray(bytes, enc);
    var len = this.p.byteLength();
    if ((bytes[0] === 4 || bytes[0] === 6 || bytes[0] === 7) && bytes.length - 1 === 2 * len) {
      if (bytes[0] === 6)
        assert$1(bytes[bytes.length - 1] % 2 === 0);
      else if (bytes[0] === 7)
        assert$1(bytes[bytes.length - 1] % 2 === 1);
      var res = this.point(bytes.slice(1, 1 + len), bytes.slice(1 + len, 1 + 2 * len));
      return res;
    } else if ((bytes[0] === 2 || bytes[0] === 3) && bytes.length - 1 === len) {
      return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 3);
    }
    throw new Error("Unknown point format");
  };
  BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
    return this.encode(enc, true);
  };
  BasePoint.prototype._encode = function _encode2(compact) {
    var len = this.curve.p.byteLength();
    var x3 = this.getX().toArray("be", len);
    if (compact)
      return [this.getY().isEven() ? 2 : 3].concat(x3);
    return [4].concat(x3, this.getY().toArray("be", len));
  };
  BasePoint.prototype.encode = function encode2(enc, compact) {
    return utils_1$1.encode(this._encode(compact), enc);
  };
  BasePoint.prototype.precompute = function precompute(power) {
    if (this.precomputed)
      return this;
    var precomputed = {
      doubles: null,
      naf: null,
      beta: null
    };
    precomputed.naf = this._getNAFPoints(8);
    precomputed.doubles = this._getDoubles(4, power);
    precomputed.beta = this._getBeta();
    this.precomputed = precomputed;
    return this;
  };
  BasePoint.prototype._hasDoubles = function _hasDoubles(k3) {
    if (!this.precomputed)
      return false;
    var doubles = this.precomputed.doubles;
    if (!doubles)
      return false;
    return doubles.points.length >= Math.ceil((k3.bitLength() + 1) / doubles.step);
  };
  BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
    if (this.precomputed && this.precomputed.doubles)
      return this.precomputed.doubles;
    var doubles = [this];
    var acc = this;
    for (var i3 = 0; i3 < power; i3 += step) {
      for (var j3 = 0; j3 < step; j3++)
        acc = acc.dbl();
      doubles.push(acc);
    }
    return {
      step,
      points: doubles
    };
  };
  BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
    if (this.precomputed && this.precomputed.naf)
      return this.precomputed.naf;
    var res = [this];
    var max = (1 << wnd) - 1;
    var dbl3 = max === 1 ? null : this.dbl();
    for (var i3 = 1; i3 < max; i3++)
      res[i3] = res[i3 - 1].add(dbl3);
    return {
      wnd,
      points: res
    };
  };
  BasePoint.prototype._getBeta = function _getBeta() {
    return null;
  };
  BasePoint.prototype.dblp = function dblp(k3) {
    var r3 = this;
    for (var i3 = 0; i3 < k3; i3++)
      r3 = r3.dbl();
    return r3;
  };
  var inherits_browser = createCommonjsModule(function(module) {
    if (typeof Object.create === "function") {
      module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  });
  var assert$2 = utils_1$1.assert;
  function ShortCurve(conf) {
    base.call(this, "short", conf);
    this.a = new import_bn2.default(conf.a, 16).toRed(this.red);
    this.b = new import_bn2.default(conf.b, 16).toRed(this.red);
    this.tinv = this.two.redInvm();
    this.zeroA = this.a.fromRed().cmpn(0) === 0;
    this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
    this.endo = this._getEndomorphism(conf);
    this._endoWnafT1 = new Array(4);
    this._endoWnafT2 = new Array(4);
  }
  inherits_browser(ShortCurve, base);
  var short_1 = ShortCurve;
  ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
    if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
      return;
    var beta;
    var lambda;
    if (conf.beta) {
      beta = new import_bn2.default(conf.beta, 16).toRed(this.red);
    } else {
      var betas = this._getEndoRoots(this.p);
      beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
      beta = beta.toRed(this.red);
    }
    if (conf.lambda) {
      lambda = new import_bn2.default(conf.lambda, 16);
    } else {
      var lambdas = this._getEndoRoots(this.n);
      if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
        lambda = lambdas[0];
      } else {
        lambda = lambdas[1];
        assert$2(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
      }
    }
    var basis;
    if (conf.basis) {
      basis = conf.basis.map(function(vec) {
        return {
          a: new import_bn2.default(vec.a, 16),
          b: new import_bn2.default(vec.b, 16)
        };
      });
    } else {
      basis = this._getEndoBasis(lambda);
    }
    return {
      beta,
      lambda,
      basis
    };
  };
  ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
    var red = num === this.p ? this.red : import_bn2.default.mont(num);
    var tinv = new import_bn2.default(2).toRed(red).redInvm();
    var ntinv = tinv.redNeg();
    var s3 = new import_bn2.default(3).toRed(red).redNeg().redSqrt().redMul(tinv);
    var l1 = ntinv.redAdd(s3).fromRed();
    var l22 = ntinv.redSub(s3).fromRed();
    return [l1, l22];
  };
  ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
    var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
    var u3 = lambda;
    var v3 = this.n.clone();
    var x1 = new import_bn2.default(1);
    var y1 = new import_bn2.default(0);
    var x22 = new import_bn2.default(0);
    var y22 = new import_bn2.default(1);
    var a0;
    var b0;
    var a1;
    var b1;
    var a22;
    var b2;
    var prevR;
    var i3 = 0;
    var r3;
    var x3;
    while (u3.cmpn(0) !== 0) {
      var q3 = v3.div(u3);
      r3 = v3.sub(q3.mul(u3));
      x3 = x22.sub(q3.mul(x1));
      var y3 = y22.sub(q3.mul(y1));
      if (!a1 && r3.cmp(aprxSqrt) < 0) {
        a0 = prevR.neg();
        b0 = x1;
        a1 = r3.neg();
        b1 = x3;
      } else if (a1 && ++i3 === 2) {
        break;
      }
      prevR = r3;
      v3 = u3;
      u3 = r3;
      x22 = x1;
      x1 = x3;
      y22 = y1;
      y1 = y3;
    }
    a22 = r3.neg();
    b2 = x3;
    var len1 = a1.sqr().add(b1.sqr());
    var len2 = a22.sqr().add(b2.sqr());
    if (len2.cmp(len1) >= 0) {
      a22 = a0;
      b2 = b0;
    }
    if (a1.negative) {
      a1 = a1.neg();
      b1 = b1.neg();
    }
    if (a22.negative) {
      a22 = a22.neg();
      b2 = b2.neg();
    }
    return [
      { a: a1, b: b1 },
      { a: a22, b: b2 }
    ];
  };
  ShortCurve.prototype._endoSplit = function _endoSplit(k3) {
    var basis = this.endo.basis;
    var v1 = basis[0];
    var v22 = basis[1];
    var c1 = v22.b.mul(k3).divRound(this.n);
    var c22 = v1.b.neg().mul(k3).divRound(this.n);
    var p1 = c1.mul(v1.a);
    var p22 = c22.mul(v22.a);
    var q1 = c1.mul(v1.b);
    var q22 = c22.mul(v22.b);
    var k1 = k3.sub(p1).sub(p22);
    var k22 = q1.add(q22).neg();
    return { k1, k2: k22 };
  };
  ShortCurve.prototype.pointFromX = function pointFromX(x3, odd) {
    x3 = new import_bn2.default(x3, 16);
    if (!x3.red)
      x3 = x3.toRed(this.red);
    var y22 = x3.redSqr().redMul(x3).redIAdd(x3.redMul(this.a)).redIAdd(this.b);
    var y3 = y22.redSqrt();
    if (y3.redSqr().redSub(y22).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    var isOdd = y3.fromRed().isOdd();
    if (odd && !isOdd || !odd && isOdd)
      y3 = y3.redNeg();
    return this.point(x3, y3);
  };
  ShortCurve.prototype.validate = function validate3(point3) {
    if (point3.inf)
      return true;
    var x3 = point3.x;
    var y3 = point3.y;
    var ax = this.a.redMul(x3);
    var rhs = x3.redSqr().redMul(x3).redIAdd(ax).redIAdd(this.b);
    return y3.redSqr().redISub(rhs).cmpn(0) === 0;
  };
  ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
    var npoints = this._endoWnafT1;
    var ncoeffs = this._endoWnafT2;
    for (var i3 = 0; i3 < points.length; i3++) {
      var split = this._endoSplit(coeffs[i3]);
      var p3 = points[i3];
      var beta = p3._getBeta();
      if (split.k1.negative) {
        split.k1.ineg();
        p3 = p3.neg(true);
      }
      if (split.k2.negative) {
        split.k2.ineg();
        beta = beta.neg(true);
      }
      npoints[i3 * 2] = p3;
      npoints[i3 * 2 + 1] = beta;
      ncoeffs[i3 * 2] = split.k1;
      ncoeffs[i3 * 2 + 1] = split.k2;
    }
    var res = this._wnafMulAdd(1, npoints, ncoeffs, i3 * 2, jacobianResult);
    for (var j3 = 0; j3 < i3 * 2; j3++) {
      npoints[j3] = null;
      ncoeffs[j3] = null;
    }
    return res;
  };
  function Point(curve, x3, y3, isRed) {
    base.BasePoint.call(this, curve, "affine");
    if (x3 === null && y3 === null) {
      this.x = null;
      this.y = null;
      this.inf = true;
    } else {
      this.x = new import_bn2.default(x3, 16);
      this.y = new import_bn2.default(y3, 16);
      if (isRed) {
        this.x.forceRed(this.curve.red);
        this.y.forceRed(this.curve.red);
      }
      if (!this.x.red)
        this.x = this.x.toRed(this.curve.red);
      if (!this.y.red)
        this.y = this.y.toRed(this.curve.red);
      this.inf = false;
    }
  }
  inherits_browser(Point, base.BasePoint);
  ShortCurve.prototype.point = function point2(x3, y3, isRed) {
    return new Point(this, x3, y3, isRed);
  };
  ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
    return Point.fromJSON(this, obj, red);
  };
  Point.prototype._getBeta = function _getBeta2() {
    if (!this.curve.endo)
      return;
    var pre = this.precomputed;
    if (pre && pre.beta)
      return pre.beta;
    var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
    if (pre) {
      var curve = this.curve;
      var endoMul = function(p3) {
        return curve.point(p3.x.redMul(curve.endo.beta), p3.y);
      };
      pre.beta = beta;
      beta.precomputed = {
        beta: null,
        naf: pre.naf && {
          wnd: pre.naf.wnd,
          points: pre.naf.points.map(endoMul)
        },
        doubles: pre.doubles && {
          step: pre.doubles.step,
          points: pre.doubles.points.map(endoMul)
        }
      };
    }
    return beta;
  };
  Point.prototype.toJSON = function toJSON() {
    if (!this.precomputed)
      return [this.x, this.y];
    return [this.x, this.y, this.precomputed && {
      doubles: this.precomputed.doubles && {
        step: this.precomputed.doubles.step,
        points: this.precomputed.doubles.points.slice(1)
      },
      naf: this.precomputed.naf && {
        wnd: this.precomputed.naf.wnd,
        points: this.precomputed.naf.points.slice(1)
      }
    }];
  };
  Point.fromJSON = function fromJSON(curve, obj, red) {
    if (typeof obj === "string")
      obj = JSON.parse(obj);
    var res = curve.point(obj[0], obj[1], red);
    if (!obj[2])
      return res;
    function obj2point(obj2) {
      return curve.point(obj2[0], obj2[1], red);
    }
    var pre = obj[2];
    res.precomputed = {
      beta: null,
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: [res].concat(pre.doubles.points.map(obj2point))
      },
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: [res].concat(pre.naf.points.map(obj2point))
      }
    };
    return res;
  };
  Point.prototype.inspect = function inspect() {
    if (this.isInfinity())
      return "<EC Point Infinity>";
    return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
  };
  Point.prototype.isInfinity = function isInfinity() {
    return this.inf;
  };
  Point.prototype.add = function add(p3) {
    if (this.inf)
      return p3;
    if (p3.inf)
      return this;
    if (this.eq(p3))
      return this.dbl();
    if (this.neg().eq(p3))
      return this.curve.point(null, null);
    if (this.x.cmp(p3.x) === 0)
      return this.curve.point(null, null);
    var c3 = this.y.redSub(p3.y);
    if (c3.cmpn(0) !== 0)
      c3 = c3.redMul(this.x.redSub(p3.x).redInvm());
    var nx = c3.redSqr().redISub(this.x).redISub(p3.x);
    var ny = c3.redMul(this.x.redSub(nx)).redISub(this.y);
    return this.curve.point(nx, ny);
  };
  Point.prototype.dbl = function dbl() {
    if (this.inf)
      return this;
    var ys1 = this.y.redAdd(this.y);
    if (ys1.cmpn(0) === 0)
      return this.curve.point(null, null);
    var a3 = this.curve.a;
    var x22 = this.x.redSqr();
    var dyinv = ys1.redInvm();
    var c3 = x22.redAdd(x22).redIAdd(x22).redIAdd(a3).redMul(dyinv);
    var nx = c3.redSqr().redISub(this.x.redAdd(this.x));
    var ny = c3.redMul(this.x.redSub(nx)).redISub(this.y);
    return this.curve.point(nx, ny);
  };
  Point.prototype.getX = function getX() {
    return this.x.fromRed();
  };
  Point.prototype.getY = function getY() {
    return this.y.fromRed();
  };
  Point.prototype.mul = function mul(k3) {
    k3 = new import_bn2.default(k3, 16);
    if (this.isInfinity())
      return this;
    else if (this._hasDoubles(k3))
      return this.curve._fixedNafMul(this, k3);
    else if (this.curve.endo)
      return this.curve._endoWnafMulAdd([this], [k3]);
    else
      return this.curve._wnafMul(this, k3);
  };
  Point.prototype.mulAdd = function mulAdd(k1, p22, k22) {
    var points = [this, p22];
    var coeffs = [k1, k22];
    if (this.curve.endo)
      return this.curve._endoWnafMulAdd(points, coeffs);
    else
      return this.curve._wnafMulAdd(1, points, coeffs, 2);
  };
  Point.prototype.jmulAdd = function jmulAdd(k1, p22, k22) {
    var points = [this, p22];
    var coeffs = [k1, k22];
    if (this.curve.endo)
      return this.curve._endoWnafMulAdd(points, coeffs, true);
    else
      return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
  };
  Point.prototype.eq = function eq2(p3) {
    return this === p3 || this.inf === p3.inf && (this.inf || this.x.cmp(p3.x) === 0 && this.y.cmp(p3.y) === 0);
  };
  Point.prototype.neg = function neg(_precompute) {
    if (this.inf)
      return this;
    var res = this.curve.point(this.x, this.y.redNeg());
    if (_precompute && this.precomputed) {
      var pre = this.precomputed;
      var negate = function(p3) {
        return p3.neg();
      };
      res.precomputed = {
        naf: pre.naf && {
          wnd: pre.naf.wnd,
          points: pre.naf.points.map(negate)
        },
        doubles: pre.doubles && {
          step: pre.doubles.step,
          points: pre.doubles.points.map(negate)
        }
      };
    }
    return res;
  };
  Point.prototype.toJ = function toJ() {
    if (this.inf)
      return this.curve.jpoint(null, null, null);
    var res = this.curve.jpoint(this.x, this.y, this.curve.one);
    return res;
  };
  function JPoint(curve, x3, y3, z3) {
    base.BasePoint.call(this, curve, "jacobian");
    if (x3 === null && y3 === null && z3 === null) {
      this.x = this.curve.one;
      this.y = this.curve.one;
      this.z = new import_bn2.default(0);
    } else {
      this.x = new import_bn2.default(x3, 16);
      this.y = new import_bn2.default(y3, 16);
      this.z = new import_bn2.default(z3, 16);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
    this.zOne = this.z === this.curve.one;
  }
  inherits_browser(JPoint, base.BasePoint);
  ShortCurve.prototype.jpoint = function jpoint(x3, y3, z3) {
    return new JPoint(this, x3, y3, z3);
  };
  JPoint.prototype.toP = function toP() {
    if (this.isInfinity())
      return this.curve.point(null, null);
    var zinv = this.z.redInvm();
    var zinv2 = zinv.redSqr();
    var ax = this.x.redMul(zinv2);
    var ay = this.y.redMul(zinv2).redMul(zinv);
    return this.curve.point(ax, ay);
  };
  JPoint.prototype.neg = function neg2() {
    return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
  };
  JPoint.prototype.add = function add2(p3) {
    if (this.isInfinity())
      return p3;
    if (p3.isInfinity())
      return this;
    var pz2 = p3.z.redSqr();
    var z22 = this.z.redSqr();
    var u1 = this.x.redMul(pz2);
    var u22 = p3.x.redMul(z22);
    var s1 = this.y.redMul(pz2.redMul(p3.z));
    var s22 = p3.y.redMul(z22.redMul(this.z));
    var h3 = u1.redSub(u22);
    var r3 = s1.redSub(s22);
    if (h3.cmpn(0) === 0) {
      if (r3.cmpn(0) !== 0)
        return this.curve.jpoint(null, null, null);
      else
        return this.dbl();
    }
    var h22 = h3.redSqr();
    var h32 = h22.redMul(h3);
    var v3 = u1.redMul(h22);
    var nx = r3.redSqr().redIAdd(h32).redISub(v3).redISub(v3);
    var ny = r3.redMul(v3.redISub(nx)).redISub(s1.redMul(h32));
    var nz = this.z.redMul(p3.z).redMul(h3);
    return this.curve.jpoint(nx, ny, nz);
  };
  JPoint.prototype.mixedAdd = function mixedAdd(p3) {
    if (this.isInfinity())
      return p3.toJ();
    if (p3.isInfinity())
      return this;
    var z22 = this.z.redSqr();
    var u1 = this.x;
    var u22 = p3.x.redMul(z22);
    var s1 = this.y;
    var s22 = p3.y.redMul(z22).redMul(this.z);
    var h3 = u1.redSub(u22);
    var r3 = s1.redSub(s22);
    if (h3.cmpn(0) === 0) {
      if (r3.cmpn(0) !== 0)
        return this.curve.jpoint(null, null, null);
      else
        return this.dbl();
    }
    var h22 = h3.redSqr();
    var h32 = h22.redMul(h3);
    var v3 = u1.redMul(h22);
    var nx = r3.redSqr().redIAdd(h32).redISub(v3).redISub(v3);
    var ny = r3.redMul(v3.redISub(nx)).redISub(s1.redMul(h32));
    var nz = this.z.redMul(h3);
    return this.curve.jpoint(nx, ny, nz);
  };
  JPoint.prototype.dblp = function dblp2(pow) {
    if (pow === 0)
      return this;
    if (this.isInfinity())
      return this;
    if (!pow)
      return this.dbl();
    var i3;
    if (this.curve.zeroA || this.curve.threeA) {
      var r3 = this;
      for (i3 = 0; i3 < pow; i3++)
        r3 = r3.dbl();
      return r3;
    }
    var a3 = this.curve.a;
    var tinv = this.curve.tinv;
    var jx = this.x;
    var jy = this.y;
    var jz = this.z;
    var jz4 = jz.redSqr().redSqr();
    var jyd = jy.redAdd(jy);
    for (i3 = 0; i3 < pow; i3++) {
      var jx2 = jx.redSqr();
      var jyd2 = jyd.redSqr();
      var jyd4 = jyd2.redSqr();
      var c3 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a3.redMul(jz4));
      var t1 = jx.redMul(jyd2);
      var nx = c3.redSqr().redISub(t1.redAdd(t1));
      var t22 = t1.redISub(nx);
      var dny = c3.redMul(t22);
      dny = dny.redIAdd(dny).redISub(jyd4);
      var nz = jyd.redMul(jz);
      if (i3 + 1 < pow)
        jz4 = jz4.redMul(jyd4);
      jx = nx;
      jz = nz;
      jyd = dny;
    }
    return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
  };
  JPoint.prototype.dbl = function dbl2() {
    if (this.isInfinity())
      return this;
    if (this.curve.zeroA)
      return this._zeroDbl();
    else if (this.curve.threeA)
      return this._threeDbl();
    else
      return this._dbl();
  };
  JPoint.prototype._zeroDbl = function _zeroDbl() {
    var nx;
    var ny;
    var nz;
    if (this.zOne) {
      var xx = this.x.redSqr();
      var yy = this.y.redSqr();
      var yyyy = yy.redSqr();
      var s3 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
      s3 = s3.redIAdd(s3);
      var m3 = xx.redAdd(xx).redIAdd(xx);
      var t3 = m3.redSqr().redISub(s3).redISub(s3);
      var yyyy8 = yyyy.redIAdd(yyyy);
      yyyy8 = yyyy8.redIAdd(yyyy8);
      yyyy8 = yyyy8.redIAdd(yyyy8);
      nx = t3;
      ny = m3.redMul(s3.redISub(t3)).redISub(yyyy8);
      nz = this.y.redAdd(this.y);
    } else {
      var a3 = this.x.redSqr();
      var b2 = this.y.redSqr();
      var c3 = b2.redSqr();
      var d3 = this.x.redAdd(b2).redSqr().redISub(a3).redISub(c3);
      d3 = d3.redIAdd(d3);
      var e3 = a3.redAdd(a3).redIAdd(a3);
      var f3 = e3.redSqr();
      var c8 = c3.redIAdd(c3);
      c8 = c8.redIAdd(c8);
      c8 = c8.redIAdd(c8);
      nx = f3.redISub(d3).redISub(d3);
      ny = e3.redMul(d3.redISub(nx)).redISub(c8);
      nz = this.y.redMul(this.z);
      nz = nz.redIAdd(nz);
    }
    return this.curve.jpoint(nx, ny, nz);
  };
  JPoint.prototype._threeDbl = function _threeDbl() {
    var nx;
    var ny;
    var nz;
    if (this.zOne) {
      var xx = this.x.redSqr();
      var yy = this.y.redSqr();
      var yyyy = yy.redSqr();
      var s3 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
      s3 = s3.redIAdd(s3);
      var m3 = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
      var t3 = m3.redSqr().redISub(s3).redISub(s3);
      nx = t3;
      var yyyy8 = yyyy.redIAdd(yyyy);
      yyyy8 = yyyy8.redIAdd(yyyy8);
      yyyy8 = yyyy8.redIAdd(yyyy8);
      ny = m3.redMul(s3.redISub(t3)).redISub(yyyy8);
      nz = this.y.redAdd(this.y);
    } else {
      var delta = this.z.redSqr();
      var gamma = this.y.redSqr();
      var beta = this.x.redMul(gamma);
      var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
      alpha = alpha.redAdd(alpha).redIAdd(alpha);
      var beta4 = beta.redIAdd(beta);
      beta4 = beta4.redIAdd(beta4);
      var beta8 = beta4.redAdd(beta4);
      nx = alpha.redSqr().redISub(beta8);
      nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
      var ggamma8 = gamma.redSqr();
      ggamma8 = ggamma8.redIAdd(ggamma8);
      ggamma8 = ggamma8.redIAdd(ggamma8);
      ggamma8 = ggamma8.redIAdd(ggamma8);
      ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
    }
    return this.curve.jpoint(nx, ny, nz);
  };
  JPoint.prototype._dbl = function _dbl() {
    var a3 = this.curve.a;
    var jx = this.x;
    var jy = this.y;
    var jz = this.z;
    var jz4 = jz.redSqr().redSqr();
    var jx2 = jx.redSqr();
    var jy2 = jy.redSqr();
    var c3 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a3.redMul(jz4));
    var jxd4 = jx.redAdd(jx);
    jxd4 = jxd4.redIAdd(jxd4);
    var t1 = jxd4.redMul(jy2);
    var nx = c3.redSqr().redISub(t1.redAdd(t1));
    var t22 = t1.redISub(nx);
    var jyd8 = jy2.redSqr();
    jyd8 = jyd8.redIAdd(jyd8);
    jyd8 = jyd8.redIAdd(jyd8);
    jyd8 = jyd8.redIAdd(jyd8);
    var ny = c3.redMul(t22).redISub(jyd8);
    var nz = jy.redAdd(jy).redMul(jz);
    return this.curve.jpoint(nx, ny, nz);
  };
  JPoint.prototype.trpl = function trpl() {
    if (!this.curve.zeroA)
      return this.dbl().add(this);
    var xx = this.x.redSqr();
    var yy = this.y.redSqr();
    var zz = this.z.redSqr();
    var yyyy = yy.redSqr();
    var m3 = xx.redAdd(xx).redIAdd(xx);
    var mm = m3.redSqr();
    var e3 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    e3 = e3.redIAdd(e3);
    e3 = e3.redAdd(e3).redIAdd(e3);
    e3 = e3.redISub(mm);
    var ee = e3.redSqr();
    var t3 = yyyy.redIAdd(yyyy);
    t3 = t3.redIAdd(t3);
    t3 = t3.redIAdd(t3);
    t3 = t3.redIAdd(t3);
    var u3 = m3.redIAdd(e3).redSqr().redISub(mm).redISub(ee).redISub(t3);
    var yyu4 = yy.redMul(u3);
    yyu4 = yyu4.redIAdd(yyu4);
    yyu4 = yyu4.redIAdd(yyu4);
    var nx = this.x.redMul(ee).redISub(yyu4);
    nx = nx.redIAdd(nx);
    nx = nx.redIAdd(nx);
    var ny = this.y.redMul(u3.redMul(t3.redISub(u3)).redISub(e3.redMul(ee)));
    ny = ny.redIAdd(ny);
    ny = ny.redIAdd(ny);
    ny = ny.redIAdd(ny);
    var nz = this.z.redAdd(e3).redSqr().redISub(zz).redISub(ee);
    return this.curve.jpoint(nx, ny, nz);
  };
  JPoint.prototype.mul = function mul2(k3, kbase) {
    k3 = new import_bn2.default(k3, kbase);
    return this.curve._wnafMul(this, k3);
  };
  JPoint.prototype.eq = function eq3(p3) {
    if (p3.type === "affine")
      return this.eq(p3.toJ());
    if (this === p3)
      return true;
    var z22 = this.z.redSqr();
    var pz2 = p3.z.redSqr();
    if (this.x.redMul(pz2).redISub(p3.x.redMul(z22)).cmpn(0) !== 0)
      return false;
    var z3 = z22.redMul(this.z);
    var pz3 = pz2.redMul(p3.z);
    return this.y.redMul(pz3).redISub(p3.y.redMul(z3)).cmpn(0) === 0;
  };
  JPoint.prototype.eqXToP = function eqXToP(x3) {
    var zs = this.z.redSqr();
    var rx = x3.toRed(this.curve.red).redMul(zs);
    if (this.x.cmp(rx) === 0)
      return true;
    var xc = x3.clone();
    var t3 = this.curve.redN.redMul(zs);
    for (; ; ) {
      xc.iadd(this.curve.n);
      if (xc.cmp(this.curve.p) >= 0)
        return false;
      rx.redIAdd(t3);
      if (this.x.cmp(rx) === 0)
        return true;
    }
  };
  JPoint.prototype.inspect = function inspect2() {
    if (this.isInfinity())
      return "<EC JPoint Infinity>";
    return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
  };
  JPoint.prototype.isInfinity = function isInfinity2() {
    return this.z.cmpn(0) === 0;
  };
  var curve_1 = createCommonjsModule(function(module, exports) {
    "use strict";
    var curve = exports;
    curve.base = base;
    curve.short = short_1;
    curve.mont = null;
    curve.edwards = null;
  });
  var curves_1 = createCommonjsModule(function(module, exports) {
    "use strict";
    var curves = exports;
    var assert3 = utils_1$1.assert;
    function PresetCurve(options) {
      if (options.type === "short")
        this.curve = new curve_1.short(options);
      else if (options.type === "edwards")
        this.curve = new curve_1.edwards(options);
      else
        this.curve = new curve_1.mont(options);
      this.g = this.curve.g;
      this.n = this.curve.n;
      this.hash = options.hash;
      assert3(this.g.validate(), "Invalid curve");
      assert3(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
    }
    curves.PresetCurve = PresetCurve;
    function defineCurve(name2, options) {
      Object.defineProperty(curves, name2, {
        configurable: true,
        enumerable: true,
        get: function() {
          var curve = new PresetCurve(options);
          Object.defineProperty(curves, name2, {
            configurable: true,
            enumerable: true,
            value: curve
          });
          return curve;
        }
      });
    }
    defineCurve("p192", {
      type: "short",
      prime: "p192",
      p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
      b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
      n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
      hash: import_hash2.default.sha256,
      gRed: false,
      g: [
        "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
        "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
      ]
    });
    defineCurve("p224", {
      type: "short",
      prime: "p224",
      p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
      b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
      n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
      hash: import_hash2.default.sha256,
      gRed: false,
      g: [
        "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
        "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
      ]
    });
    defineCurve("p256", {
      type: "short",
      prime: null,
      p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
      a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
      b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
      n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
      hash: import_hash2.default.sha256,
      gRed: false,
      g: [
        "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
        "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
      ]
    });
    defineCurve("p384", {
      type: "short",
      prime: null,
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
      a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
      b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
      n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
      hash: import_hash2.default.sha384,
      gRed: false,
      g: [
        "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
        "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
      ]
    });
    defineCurve("p521", {
      type: "short",
      prime: null,
      p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
      a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
      b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
      n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
      hash: import_hash2.default.sha512,
      gRed: false,
      g: [
        "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
        "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
      ]
    });
    defineCurve("curve25519", {
      type: "mont",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "76d06",
      b: "1",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: import_hash2.default.sha256,
      gRed: false,
      g: [
        "9"
      ]
    });
    defineCurve("ed25519", {
      type: "edwards",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "-1",
      c: "1",
      d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: import_hash2.default.sha256,
      gRed: false,
      g: [
        "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
        "6666666666666666666666666666666666666666666666666666666666666658"
      ]
    });
    var pre;
    try {
      pre = null.crash();
    } catch (e3) {
      pre = void 0;
    }
    defineCurve("secp256k1", {
      type: "short",
      prime: "k256",
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
      a: "0",
      b: "7",
      n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
      h: "1",
      hash: import_hash2.default.sha256,
      beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
      lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
      basis: [
        {
          a: "3086d221a7d46bcde86c90e49284eb15",
          b: "-e4437ed6010e88286f547fa90abfe4c3"
        },
        {
          a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
          b: "3086d221a7d46bcde86c90e49284eb15"
        }
      ],
      gRed: false,
      g: [
        "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
        "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
        pre
      ]
    });
  });
  function HmacDRBG(options) {
    if (!(this instanceof HmacDRBG))
      return new HmacDRBG(options);
    this.hash = options.hash;
    this.predResist = !!options.predResist;
    this.outLen = this.hash.outSize;
    this.minEntropy = options.minEntropy || this.hash.hmacStrength;
    this._reseed = null;
    this.reseedInterval = null;
    this.K = null;
    this.V = null;
    var entropy = utils_1.toArray(options.entropy, options.entropyEnc || "hex");
    var nonce = utils_1.toArray(options.nonce, options.nonceEnc || "hex");
    var pers = utils_1.toArray(options.pers, options.persEnc || "hex");
    minimalisticAssert(entropy.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits");
    this._init(entropy, nonce, pers);
  }
  var hmacDrbg = HmacDRBG;
  HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
    var seed = entropy.concat(nonce).concat(pers);
    this.K = new Array(this.outLen / 8);
    this.V = new Array(this.outLen / 8);
    for (var i3 = 0; i3 < this.V.length; i3++) {
      this.K[i3] = 0;
      this.V[i3] = 1;
    }
    this._update(seed);
    this._reseed = 1;
    this.reseedInterval = 281474976710656;
  };
  HmacDRBG.prototype._hmac = function hmac() {
    return new import_hash2.default.hmac(this.hash, this.K);
  };
  HmacDRBG.prototype._update = function update(seed) {
    var kmac = this._hmac().update(this.V).update([0]);
    if (seed)
      kmac = kmac.update(seed);
    this.K = kmac.digest();
    this.V = this._hmac().update(this.V).digest();
    if (!seed)
      return;
    this.K = this._hmac().update(this.V).update([1]).update(seed).digest();
    this.V = this._hmac().update(this.V).digest();
  };
  HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add3, addEnc) {
    if (typeof entropyEnc !== "string") {
      addEnc = add3;
      add3 = entropyEnc;
      entropyEnc = null;
    }
    entropy = utils_1.toArray(entropy, entropyEnc);
    add3 = utils_1.toArray(add3, addEnc);
    minimalisticAssert(entropy.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits");
    this._update(entropy.concat(add3 || []));
    this._reseed = 1;
  };
  HmacDRBG.prototype.generate = function generate(len, enc, add3, addEnc) {
    if (this._reseed > this.reseedInterval)
      throw new Error("Reseed is required");
    if (typeof enc !== "string") {
      addEnc = add3;
      add3 = enc;
      enc = null;
    }
    if (add3) {
      add3 = utils_1.toArray(add3, addEnc || "hex");
      this._update(add3);
    }
    var temp = [];
    while (temp.length < len) {
      this.V = this._hmac().update(this.V).digest();
      temp = temp.concat(this.V);
    }
    var res = temp.slice(0, len);
    this._update(add3);
    this._reseed++;
    return utils_1.encode(res, enc);
  };
  var assert$3 = utils_1$1.assert;
  function KeyPair(ec2, options) {
    this.ec = ec2;
    this.priv = null;
    this.pub = null;
    if (options.priv)
      this._importPrivate(options.priv, options.privEnc);
    if (options.pub)
      this._importPublic(options.pub, options.pubEnc);
  }
  var key = KeyPair;
  KeyPair.fromPublic = function fromPublic(ec2, pub, enc) {
    if (pub instanceof KeyPair)
      return pub;
    return new KeyPair(ec2, {
      pub,
      pubEnc: enc
    });
  };
  KeyPair.fromPrivate = function fromPrivate(ec2, priv, enc) {
    if (priv instanceof KeyPair)
      return priv;
    return new KeyPair(ec2, {
      priv,
      privEnc: enc
    });
  };
  KeyPair.prototype.validate = function validate4() {
    var pub = this.getPublic();
    if (pub.isInfinity())
      return { result: false, reason: "Invalid public key" };
    if (!pub.validate())
      return { result: false, reason: "Public key is not a point" };
    if (!pub.mul(this.ec.curve.n).isInfinity())
      return { result: false, reason: "Public key * N != O" };
    return { result: true, reason: null };
  };
  KeyPair.prototype.getPublic = function getPublic(compact, enc) {
    if (typeof compact === "string") {
      enc = compact;
      compact = null;
    }
    if (!this.pub)
      this.pub = this.ec.g.mul(this.priv);
    if (!enc)
      return this.pub;
    return this.pub.encode(enc, compact);
  };
  KeyPair.prototype.getPrivate = function getPrivate(enc) {
    if (enc === "hex")
      return this.priv.toString(16, 2);
    else
      return this.priv;
  };
  KeyPair.prototype._importPrivate = function _importPrivate(key2, enc) {
    this.priv = new import_bn2.default(key2, enc || 16);
    this.priv = this.priv.umod(this.ec.curve.n);
  };
  KeyPair.prototype._importPublic = function _importPublic(key2, enc) {
    if (key2.x || key2.y) {
      if (this.ec.curve.type === "mont") {
        assert$3(key2.x, "Need x coordinate");
      } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
        assert$3(key2.x && key2.y, "Need both x and y coordinate");
      }
      this.pub = this.ec.curve.point(key2.x, key2.y);
      return;
    }
    this.pub = this.ec.curve.decodePoint(key2, enc);
  };
  KeyPair.prototype.derive = function derive(pub) {
    if (!pub.validate()) {
      assert$3(pub.validate(), "public point not validated");
    }
    return pub.mul(this.priv).getX();
  };
  KeyPair.prototype.sign = function sign(msg, enc, options) {
    return this.ec.sign(msg, this, enc, options);
  };
  KeyPair.prototype.verify = function verify(msg, signature2) {
    return this.ec.verify(msg, signature2, this);
  };
  KeyPair.prototype.inspect = function inspect3() {
    return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
  };
  var assert$4 = utils_1$1.assert;
  function Signature(options, enc) {
    if (options instanceof Signature)
      return options;
    if (this._importDER(options, enc))
      return;
    assert$4(options.r && options.s, "Signature without r or s");
    this.r = new import_bn2.default(options.r, 16);
    this.s = new import_bn2.default(options.s, 16);
    if (options.recoveryParam === void 0)
      this.recoveryParam = null;
    else
      this.recoveryParam = options.recoveryParam;
  }
  var signature = Signature;
  function Position() {
    this.place = 0;
  }
  function getLength(buf, p3) {
    var initial = buf[p3.place++];
    if (!(initial & 128)) {
      return initial;
    }
    var octetLen = initial & 15;
    if (octetLen === 0 || octetLen > 4) {
      return false;
    }
    var val = 0;
    for (var i3 = 0, off = p3.place; i3 < octetLen; i3++, off++) {
      val <<= 8;
      val |= buf[off];
      val >>>= 0;
    }
    if (val <= 127) {
      return false;
    }
    p3.place = off;
    return val;
  }
  function rmPadding(buf) {
    var i3 = 0;
    var len = buf.length - 1;
    while (!buf[i3] && !(buf[i3 + 1] & 128) && i3 < len) {
      i3++;
    }
    if (i3 === 0) {
      return buf;
    }
    return buf.slice(i3);
  }
  Signature.prototype._importDER = function _importDER(data4, enc) {
    data4 = utils_1$1.toArray(data4, enc);
    var p3 = new Position();
    if (data4[p3.place++] !== 48) {
      return false;
    }
    var len = getLength(data4, p3);
    if (len === false) {
      return false;
    }
    if (len + p3.place !== data4.length) {
      return false;
    }
    if (data4[p3.place++] !== 2) {
      return false;
    }
    var rlen = getLength(data4, p3);
    if (rlen === false) {
      return false;
    }
    var r3 = data4.slice(p3.place, rlen + p3.place);
    p3.place += rlen;
    if (data4[p3.place++] !== 2) {
      return false;
    }
    var slen = getLength(data4, p3);
    if (slen === false) {
      return false;
    }
    if (data4.length !== slen + p3.place) {
      return false;
    }
    var s3 = data4.slice(p3.place, slen + p3.place);
    if (r3[0] === 0) {
      if (r3[1] & 128) {
        r3 = r3.slice(1);
      } else {
        return false;
      }
    }
    if (s3[0] === 0) {
      if (s3[1] & 128) {
        s3 = s3.slice(1);
      } else {
        return false;
      }
    }
    this.r = new import_bn2.default(r3);
    this.s = new import_bn2.default(s3);
    this.recoveryParam = null;
    return true;
  };
  function constructLength(arr, len) {
    if (len < 128) {
      arr.push(len);
      return;
    }
    var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
    arr.push(octets | 128);
    while (--octets) {
      arr.push(len >>> (octets << 3) & 255);
    }
    arr.push(len);
  }
  Signature.prototype.toDER = function toDER(enc) {
    var r3 = this.r.toArray();
    var s3 = this.s.toArray();
    if (r3[0] & 128)
      r3 = [0].concat(r3);
    if (s3[0] & 128)
      s3 = [0].concat(s3);
    r3 = rmPadding(r3);
    s3 = rmPadding(s3);
    while (!s3[0] && !(s3[1] & 128)) {
      s3 = s3.slice(1);
    }
    var arr = [2];
    constructLength(arr, r3.length);
    arr = arr.concat(r3);
    arr.push(2);
    constructLength(arr, s3.length);
    var backHalf = arr.concat(s3);
    var res = [48];
    constructLength(res, backHalf.length);
    res = res.concat(backHalf);
    return utils_1$1.encode(res, enc);
  };
  var rand = function() {
    throw new Error("unsupported");
  };
  var assert$5 = utils_1$1.assert;
  function EC(options) {
    if (!(this instanceof EC))
      return new EC(options);
    if (typeof options === "string") {
      assert$5(Object.prototype.hasOwnProperty.call(curves_1, options), "Unknown curve " + options);
      options = curves_1[options];
    }
    if (options instanceof curves_1.PresetCurve)
      options = { curve: options };
    this.curve = options.curve.curve;
    this.n = this.curve.n;
    this.nh = this.n.ushrn(1);
    this.g = this.curve.g;
    this.g = options.curve.g;
    this.g.precompute(options.curve.n.bitLength() + 1);
    this.hash = options.hash || options.curve.hash;
  }
  var ec = EC;
  EC.prototype.keyPair = function keyPair(options) {
    return new key(this, options);
  };
  EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
    return key.fromPrivate(this, priv, enc);
  };
  EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
    return key.fromPublic(this, pub, enc);
  };
  EC.prototype.genKeyPair = function genKeyPair(options) {
    if (!options)
      options = {};
    var drbg = new hmacDrbg({
      hash: this.hash,
      pers: options.pers,
      persEnc: options.persEnc || "utf8",
      entropy: options.entropy || rand(this.hash.hmacStrength),
      entropyEnc: options.entropy && options.entropyEnc || "utf8",
      nonce: this.n.toArray()
    });
    var bytes = this.n.byteLength();
    var ns2 = this.n.sub(new import_bn2.default(2));
    for (; ; ) {
      var priv = new import_bn2.default(drbg.generate(bytes));
      if (priv.cmp(ns2) > 0)
        continue;
      priv.iaddn(1);
      return this.keyFromPrivate(priv);
    }
  };
  EC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
    var delta = msg.byteLength() * 8 - this.n.bitLength();
    if (delta > 0)
      msg = msg.ushrn(delta);
    if (!truncOnly && msg.cmp(this.n) >= 0)
      return msg.sub(this.n);
    else
      return msg;
  };
  EC.prototype.sign = function sign2(msg, key2, enc, options) {
    if (typeof enc === "object") {
      options = enc;
      enc = null;
    }
    if (!options)
      options = {};
    key2 = this.keyFromPrivate(key2, enc);
    msg = this._truncateToN(new import_bn2.default(msg, 16));
    var bytes = this.n.byteLength();
    var bkey = key2.getPrivate().toArray("be", bytes);
    var nonce = msg.toArray("be", bytes);
    var drbg = new hmacDrbg({
      hash: this.hash,
      entropy: bkey,
      nonce,
      pers: options.pers,
      persEnc: options.persEnc || "utf8"
    });
    var ns1 = this.n.sub(new import_bn2.default(1));
    for (var iter = 0; ; iter++) {
      var k3 = options.k ? options.k(iter) : new import_bn2.default(drbg.generate(this.n.byteLength()));
      k3 = this._truncateToN(k3, true);
      if (k3.cmpn(1) <= 0 || k3.cmp(ns1) >= 0)
        continue;
      var kp = this.g.mul(k3);
      if (kp.isInfinity())
        continue;
      var kpX = kp.getX();
      var r3 = kpX.umod(this.n);
      if (r3.cmpn(0) === 0)
        continue;
      var s3 = k3.invm(this.n).mul(r3.mul(key2.getPrivate()).iadd(msg));
      s3 = s3.umod(this.n);
      if (s3.cmpn(0) === 0)
        continue;
      var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r3) !== 0 ? 2 : 0);
      if (options.canonical && s3.cmp(this.nh) > 0) {
        s3 = this.n.sub(s3);
        recoveryParam ^= 1;
      }
      return new signature({ r: r3, s: s3, recoveryParam });
    }
  };
  EC.prototype.verify = function verify2(msg, signature$1, key2, enc) {
    msg = this._truncateToN(new import_bn2.default(msg, 16));
    key2 = this.keyFromPublic(key2, enc);
    signature$1 = new signature(signature$1, "hex");
    var r3 = signature$1.r;
    var s3 = signature$1.s;
    if (r3.cmpn(1) < 0 || r3.cmp(this.n) >= 0)
      return false;
    if (s3.cmpn(1) < 0 || s3.cmp(this.n) >= 0)
      return false;
    var sinv = s3.invm(this.n);
    var u1 = sinv.mul(msg).umod(this.n);
    var u22 = sinv.mul(r3).umod(this.n);
    var p3;
    if (!this.curve._maxwellTrick) {
      p3 = this.g.mulAdd(u1, key2.getPublic(), u22);
      if (p3.isInfinity())
        return false;
      return p3.getX().umod(this.n).cmp(r3) === 0;
    }
    p3 = this.g.jmulAdd(u1, key2.getPublic(), u22);
    if (p3.isInfinity())
      return false;
    return p3.eqXToP(r3);
  };
  EC.prototype.recoverPubKey = function(msg, signature$1, j3, enc) {
    assert$5((3 & j3) === j3, "The recovery param is more than two bits");
    signature$1 = new signature(signature$1, enc);
    var n2 = this.n;
    var e3 = new import_bn2.default(msg);
    var r3 = signature$1.r;
    var s3 = signature$1.s;
    var isYOdd = j3 & 1;
    var isSecondKey = j3 >> 1;
    if (r3.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
      throw new Error("Unable to find sencond key candinate");
    if (isSecondKey)
      r3 = this.curve.pointFromX(r3.add(this.curve.n), isYOdd);
    else
      r3 = this.curve.pointFromX(r3, isYOdd);
    var rInv = signature$1.r.invm(n2);
    var s1 = n2.sub(e3).mul(rInv).umod(n2);
    var s22 = s3.mul(rInv).umod(n2);
    return this.g.mulAdd(s1, r3, s22);
  };
  EC.prototype.getKeyRecoveryParam = function(e3, signature$1, Q2, enc) {
    signature$1 = new signature(signature$1, enc);
    if (signature$1.recoveryParam !== null)
      return signature$1.recoveryParam;
    for (var i3 = 0; i3 < 4; i3++) {
      var Qprime;
      try {
        Qprime = this.recoverPubKey(e3, signature$1, i3);
      } catch (e4) {
        continue;
      }
      if (Qprime.eq(Q2))
        return i3;
    }
    throw new Error("Unable to find valid recovery factor");
  };
  var elliptic_1 = createCommonjsModule(function(module, exports) {
    "use strict";
    var elliptic = exports;
    elliptic.version = { version: "6.5.4" }.version;
    elliptic.utils = utils_1$1;
    elliptic.rand = function() {
      throw new Error("unsupported");
    };
    elliptic.curve = curve_1;
    elliptic.curves = curves_1;
    elliptic.ec = ec;
    elliptic.eddsa = null;
  });
  var EC$1 = elliptic_1.ec;

  // node_modules/@ethersproject/signing-key/lib.esm/_version.js
  var version12 = "signing-key/5.4.0";

  // node_modules/@ethersproject/signing-key/lib.esm/index.js
  "use strict";
  var logger17 = new Logger(version12);
  var _curve = null;
  function getCurve() {
    if (!_curve) {
      _curve = new EC$1("secp256k1");
    }
    return _curve;
  }
  var SigningKey = class {
    constructor(privateKey) {
      defineReadOnly(this, "curve", "secp256k1");
      defineReadOnly(this, "privateKey", hexlify(privateKey));
      const keyPair2 = getCurve().keyFromPrivate(arrayify(this.privateKey));
      defineReadOnly(this, "publicKey", "0x" + keyPair2.getPublic(false, "hex"));
      defineReadOnly(this, "compressedPublicKey", "0x" + keyPair2.getPublic(true, "hex"));
      defineReadOnly(this, "_isSigningKey", true);
    }
    _addPoint(other) {
      const p0 = getCurve().keyFromPublic(arrayify(this.publicKey));
      const p1 = getCurve().keyFromPublic(arrayify(other));
      return "0x" + p0.pub.add(p1.pub).encodeCompressed("hex");
    }
    signDigest(digest) {
      const keyPair2 = getCurve().keyFromPrivate(arrayify(this.privateKey));
      const digestBytes = arrayify(digest);
      if (digestBytes.length !== 32) {
        logger17.throwArgumentError("bad digest length", "digest", digest);
      }
      const signature2 = keyPair2.sign(digestBytes, { canonical: true });
      return splitSignature({
        recoveryParam: signature2.recoveryParam,
        r: hexZeroPad("0x" + signature2.r.toString(16), 32),
        s: hexZeroPad("0x" + signature2.s.toString(16), 32)
      });
    }
    computeSharedSecret(otherKey) {
      const keyPair2 = getCurve().keyFromPrivate(arrayify(this.privateKey));
      const otherKeyPair = getCurve().keyFromPublic(arrayify(computePublicKey(otherKey)));
      return hexZeroPad("0x" + keyPair2.derive(otherKeyPair.getPublic()).toString(16), 32);
    }
    static isSigningKey(value) {
      return !!(value && value._isSigningKey);
    }
  };
  function recoverPublicKey(digest, signature2) {
    const sig = splitSignature(signature2);
    const rs = { r: arrayify(sig.r), s: arrayify(sig.s) };
    return "0x" + getCurve().recoverPubKey(arrayify(digest), rs, sig.recoveryParam).encode("hex", false);
  }
  function computePublicKey(key2, compressed) {
    const bytes = arrayify(key2);
    if (bytes.length === 32) {
      const signingKey = new SigningKey(bytes);
      if (compressed) {
        return "0x" + getCurve().keyFromPrivate(bytes).getPublic(true, "hex");
      }
      return signingKey.publicKey;
    } else if (bytes.length === 33) {
      if (compressed) {
        return hexlify(bytes);
      }
      return "0x" + getCurve().keyFromPublic(bytes).getPublic(false, "hex");
    } else if (bytes.length === 65) {
      if (!compressed) {
        return hexlify(bytes);
      }
      return "0x" + getCurve().keyFromPublic(bytes).getPublic(true, "hex");
    }
    return logger17.throwArgumentError("invalid public or private key", "key", "[REDACTED]");
  }

  // node_modules/@ethersproject/transactions/lib.esm/_version.js
  var version13 = "transactions/5.4.0";

  // node_modules/@ethersproject/transactions/lib.esm/index.js
  "use strict";
  var logger18 = new Logger(version13);
  var TransactionTypes;
  (function(TransactionTypes2) {
    TransactionTypes2[TransactionTypes2["legacy"] = 0] = "legacy";
    TransactionTypes2[TransactionTypes2["eip2930"] = 1] = "eip2930";
    TransactionTypes2[TransactionTypes2["eip1559"] = 2] = "eip1559";
  })(TransactionTypes || (TransactionTypes = {}));
  function handleAddress(value) {
    if (value === "0x") {
      return null;
    }
    return getAddress(value);
  }
  function handleNumber(value) {
    if (value === "0x") {
      return Zero2;
    }
    return BigNumber.from(value);
  }
  var transactionFields = [
    { name: "nonce", maxLength: 32, numeric: true },
    { name: "gasPrice", maxLength: 32, numeric: true },
    { name: "gasLimit", maxLength: 32, numeric: true },
    { name: "to", length: 20 },
    { name: "value", maxLength: 32, numeric: true },
    { name: "data" }
  ];
  var allowedTransactionKeys2 = {
    chainId: true,
    data: true,
    gasLimit: true,
    gasPrice: true,
    nonce: true,
    to: true,
    type: true,
    value: true
  };
  function computeAddress(key2) {
    const publicKey = computePublicKey(key2);
    return getAddress(hexDataSlice(keccak256(hexDataSlice(publicKey, 1)), 12));
  }
  function recoverAddress(digest, signature2) {
    return computeAddress(recoverPublicKey(arrayify(digest), signature2));
  }
  function formatNumber(value, name2) {
    const result = stripZeros(BigNumber.from(value).toHexString());
    if (result.length > 32) {
      logger18.throwArgumentError("invalid length for " + name2, "transaction:" + name2, value);
    }
    return result;
  }
  function accessSetify(addr, storageKeys) {
    return {
      address: getAddress(addr),
      storageKeys: (storageKeys || []).map((storageKey, index) => {
        if (hexDataLength(storageKey) !== 32) {
          logger18.throwArgumentError("invalid access list storageKey", `accessList[${addr}:${index}]`, storageKey);
        }
        return storageKey.toLowerCase();
      })
    };
  }
  function accessListify(value) {
    if (Array.isArray(value)) {
      return value.map((set, index) => {
        if (Array.isArray(set)) {
          if (set.length > 2) {
            logger18.throwArgumentError("access list expected to be [ address, storageKeys[] ]", `value[${index}]`, set);
          }
          return accessSetify(set[0], set[1]);
        }
        return accessSetify(set.address, set.storageKeys);
      });
    }
    const result = Object.keys(value).map((addr) => {
      const storageKeys = value[addr].reduce((accum, storageKey) => {
        accum[storageKey] = true;
        return accum;
      }, {});
      return accessSetify(addr, Object.keys(storageKeys).sort());
    });
    result.sort((a3, b2) => a3.address.localeCompare(b2.address));
    return result;
  }
  function formatAccessList(value) {
    return accessListify(value).map((set) => [set.address, set.storageKeys]);
  }
  function _serializeEip1559(transaction, signature2) {
    if (transaction.gasPrice != null) {
      const gasPrice = BigNumber.from(transaction.gasPrice);
      const maxFeePerGas = BigNumber.from(transaction.maxFeePerGas || 0);
      if (!gasPrice.eq(maxFeePerGas)) {
        logger18.throwArgumentError("mismatch EIP-1559 gasPrice != maxFeePerGas", "tx", {
          gasPrice,
          maxFeePerGas
        });
      }
    }
    const fields = [
      formatNumber(transaction.chainId || 0, "chainId"),
      formatNumber(transaction.nonce || 0, "nonce"),
      formatNumber(transaction.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
      formatNumber(transaction.maxFeePerGas || 0, "maxFeePerGas"),
      formatNumber(transaction.gasLimit || 0, "gasLimit"),
      transaction.to != null ? getAddress(transaction.to) : "0x",
      formatNumber(transaction.value || 0, "value"),
      transaction.data || "0x",
      formatAccessList(transaction.accessList || [])
    ];
    if (signature2) {
      const sig = splitSignature(signature2);
      fields.push(formatNumber(sig.recoveryParam, "recoveryParam"));
      fields.push(stripZeros(sig.r));
      fields.push(stripZeros(sig.s));
    }
    return hexConcat(["0x02", encode(fields)]);
  }
  function _serializeEip2930(transaction, signature2) {
    const fields = [
      formatNumber(transaction.chainId || 0, "chainId"),
      formatNumber(transaction.nonce || 0, "nonce"),
      formatNumber(transaction.gasPrice || 0, "gasPrice"),
      formatNumber(transaction.gasLimit || 0, "gasLimit"),
      transaction.to != null ? getAddress(transaction.to) : "0x",
      formatNumber(transaction.value || 0, "value"),
      transaction.data || "0x",
      formatAccessList(transaction.accessList || [])
    ];
    if (signature2) {
      const sig = splitSignature(signature2);
      fields.push(formatNumber(sig.recoveryParam, "recoveryParam"));
      fields.push(stripZeros(sig.r));
      fields.push(stripZeros(sig.s));
    }
    return hexConcat(["0x01", encode(fields)]);
  }
  function _serialize(transaction, signature2) {
    checkProperties(transaction, allowedTransactionKeys2);
    const raw = [];
    transactionFields.forEach(function(fieldInfo) {
      let value = transaction[fieldInfo.name] || [];
      const options = {};
      if (fieldInfo.numeric) {
        options.hexPad = "left";
      }
      value = arrayify(hexlify(value, options));
      if (fieldInfo.length && value.length !== fieldInfo.length && value.length > 0) {
        logger18.throwArgumentError("invalid length for " + fieldInfo.name, "transaction:" + fieldInfo.name, value);
      }
      if (fieldInfo.maxLength) {
        value = stripZeros(value);
        if (value.length > fieldInfo.maxLength) {
          logger18.throwArgumentError("invalid length for " + fieldInfo.name, "transaction:" + fieldInfo.name, value);
        }
      }
      raw.push(hexlify(value));
    });
    let chainId = 0;
    if (transaction.chainId != null) {
      chainId = transaction.chainId;
      if (typeof chainId !== "number") {
        logger18.throwArgumentError("invalid transaction.chainId", "transaction", transaction);
      }
    } else if (signature2 && !isBytesLike(signature2) && signature2.v > 28) {
      chainId = Math.floor((signature2.v - 35) / 2);
    }
    if (chainId !== 0) {
      raw.push(hexlify(chainId));
      raw.push("0x");
      raw.push("0x");
    }
    if (!signature2) {
      return encode(raw);
    }
    const sig = splitSignature(signature2);
    let v3 = 27 + sig.recoveryParam;
    if (chainId !== 0) {
      raw.pop();
      raw.pop();
      raw.pop();
      v3 += chainId * 2 + 8;
      if (sig.v > 28 && sig.v !== v3) {
        logger18.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", signature2);
      }
    } else if (sig.v !== v3) {
      logger18.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", signature2);
    }
    raw.push(hexlify(v3));
    raw.push(stripZeros(arrayify(sig.r)));
    raw.push(stripZeros(arrayify(sig.s)));
    return encode(raw);
  }
  function serialize(transaction, signature2) {
    if (transaction.type == null || transaction.type === 0) {
      if (transaction.accessList != null) {
        logger18.throwArgumentError("untyped transactions do not support accessList; include type: 1", "transaction", transaction);
      }
      return _serialize(transaction, signature2);
    }
    switch (transaction.type) {
      case 1:
        return _serializeEip2930(transaction, signature2);
      case 2:
        return _serializeEip1559(transaction, signature2);
      default:
        break;
    }
    return logger18.throwError(`unsupported transaction type: ${transaction.type}`, Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "serializeTransaction",
      transactionType: transaction.type
    });
  }
  function _parseEipSignature(tx, fields, serialize3) {
    try {
      const recid = handleNumber(fields[0]).toNumber();
      if (recid !== 0 && recid !== 1) {
        throw new Error("bad recid");
      }
      tx.v = recid;
    } catch (error) {
      logger18.throwArgumentError("invalid v for transaction type: 1", "v", fields[0]);
    }
    tx.r = hexZeroPad(fields[1], 32);
    tx.s = hexZeroPad(fields[2], 32);
    try {
      const digest = keccak256(serialize3(tx));
      tx.from = recoverAddress(digest, { r: tx.r, s: tx.s, recoveryParam: tx.v });
    } catch (error) {
      console.log(error);
    }
  }
  function _parseEip1559(payload) {
    const transaction = decode(payload.slice(1));
    if (transaction.length !== 9 && transaction.length !== 12) {
      logger18.throwArgumentError("invalid component count for transaction type: 2", "payload", hexlify(payload));
    }
    const maxPriorityFeePerGas = handleNumber(transaction[2]);
    const maxFeePerGas = handleNumber(transaction[3]);
    const tx = {
      type: 2,
      chainId: handleNumber(transaction[0]).toNumber(),
      nonce: handleNumber(transaction[1]).toNumber(),
      maxPriorityFeePerGas,
      maxFeePerGas,
      gasPrice: null,
      gasLimit: handleNumber(transaction[4]),
      to: handleAddress(transaction[5]),
      value: handleNumber(transaction[6]),
      data: transaction[7],
      accessList: accessListify(transaction[8])
    };
    if (transaction.length === 9) {
      return tx;
    }
    tx.hash = keccak256(payload);
    _parseEipSignature(tx, transaction.slice(9), _serializeEip1559);
    return tx;
  }
  function _parseEip2930(payload) {
    const transaction = decode(payload.slice(1));
    if (transaction.length !== 8 && transaction.length !== 11) {
      logger18.throwArgumentError("invalid component count for transaction type: 1", "payload", hexlify(payload));
    }
    const tx = {
      type: 1,
      chainId: handleNumber(transaction[0]).toNumber(),
      nonce: handleNumber(transaction[1]).toNumber(),
      gasPrice: handleNumber(transaction[2]),
      gasLimit: handleNumber(transaction[3]),
      to: handleAddress(transaction[4]),
      value: handleNumber(transaction[5]),
      data: transaction[6],
      accessList: accessListify(transaction[7])
    };
    if (transaction.length === 8) {
      return tx;
    }
    tx.hash = keccak256(payload);
    _parseEipSignature(tx, transaction.slice(8), _serializeEip2930);
    return tx;
  }
  function _parse(rawTransaction) {
    const transaction = decode(rawTransaction);
    if (transaction.length !== 9 && transaction.length !== 6) {
      logger18.throwArgumentError("invalid raw transaction", "rawTransaction", rawTransaction);
    }
    const tx = {
      nonce: handleNumber(transaction[0]).toNumber(),
      gasPrice: handleNumber(transaction[1]),
      gasLimit: handleNumber(transaction[2]),
      to: handleAddress(transaction[3]),
      value: handleNumber(transaction[4]),
      data: transaction[5],
      chainId: 0
    };
    if (transaction.length === 6) {
      return tx;
    }
    try {
      tx.v = BigNumber.from(transaction[6]).toNumber();
    } catch (error) {
      console.log(error);
      return tx;
    }
    tx.r = hexZeroPad(transaction[7], 32);
    tx.s = hexZeroPad(transaction[8], 32);
    if (BigNumber.from(tx.r).isZero() && BigNumber.from(tx.s).isZero()) {
      tx.chainId = tx.v;
      tx.v = 0;
    } else {
      tx.chainId = Math.floor((tx.v - 35) / 2);
      if (tx.chainId < 0) {
        tx.chainId = 0;
      }
      let recoveryParam = tx.v - 27;
      const raw = transaction.slice(0, 6);
      if (tx.chainId !== 0) {
        raw.push(hexlify(tx.chainId));
        raw.push("0x");
        raw.push("0x");
        recoveryParam -= tx.chainId * 2 + 8;
      }
      const digest = keccak256(encode(raw));
      try {
        tx.from = recoverAddress(digest, { r: hexlify(tx.r), s: hexlify(tx.s), recoveryParam });
      } catch (error) {
        console.log(error);
      }
      tx.hash = keccak256(rawTransaction);
    }
    tx.type = null;
    return tx;
  }
  function parse(rawTransaction) {
    const payload = arrayify(rawTransaction);
    if (payload[0] > 127) {
      return _parse(payload);
    }
    switch (payload[0]) {
      case 1:
        return _parseEip2930(payload);
      case 2:
        return _parseEip1559(payload);
      default:
        break;
    }
    return logger18.throwError(`unsupported transaction type: ${payload[0]}`, Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "parseTransaction",
      transactionType: payload[0]
    });
  }

  // node_modules/@ethersproject/contracts/lib.esm/_version.js
  var version14 = "contracts/5.4.1";

  // node_modules/@ethersproject/contracts/lib.esm/index.js
  "use strict";
  var __awaiter5 = function(thisArg, _arguments, P3, generator) {
    function adopt(value) {
      return value instanceof P3 ? value : new P3(function(resolve) {
        resolve(value);
      });
    }
    return new (P3 || (P3 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e3) {
          reject(e3);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e3) {
          reject(e3);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var logger19 = new Logger(version14);
  var allowedTransactionKeys3 = {
    chainId: true,
    data: true,
    from: true,
    gasLimit: true,
    gasPrice: true,
    nonce: true,
    to: true,
    value: true,
    type: true,
    accessList: true,
    maxFeePerGas: true,
    maxPriorityFeePerGas: true
  };
  function resolveName(resolver, nameOrPromise) {
    return __awaiter5(this, void 0, void 0, function* () {
      const name2 = yield nameOrPromise;
      try {
        return getAddress(name2);
      } catch (error) {
      }
      if (!resolver) {
        logger19.throwError("a provider or signer is needed to resolve ENS names", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "resolveName"
        });
      }
      const address = yield resolver.resolveName(name2);
      if (address == null) {
        logger19.throwArgumentError("resolver or addr is not configured for ENS name", "name", name2);
      }
      return address;
    });
  }
  function resolveAddresses(resolver, value, paramType) {
    return __awaiter5(this, void 0, void 0, function* () {
      if (Array.isArray(paramType)) {
        return yield Promise.all(paramType.map((paramType2, index) => {
          return resolveAddresses(resolver, Array.isArray(value) ? value[index] : value[paramType2.name], paramType2);
        }));
      }
      if (paramType.type === "address") {
        return yield resolveName(resolver, value);
      }
      if (paramType.type === "tuple") {
        return yield resolveAddresses(resolver, value, paramType.components);
      }
      if (paramType.baseType === "array") {
        if (!Array.isArray(value)) {
          return Promise.reject(new Error("invalid value for array"));
        }
        return yield Promise.all(value.map((v3) => resolveAddresses(resolver, v3, paramType.arrayChildren)));
      }
      return value;
    });
  }
  function populateTransaction(contract, fragment, args) {
    return __awaiter5(this, void 0, void 0, function* () {
      let overrides = {};
      if (args.length === fragment.inputs.length + 1 && typeof args[args.length - 1] === "object") {
        overrides = shallowCopy(args.pop());
      }
      logger19.checkArgumentCount(args.length, fragment.inputs.length, "passed to contract");
      if (contract.signer) {
        if (overrides.from) {
          overrides.from = resolveProperties({
            override: resolveName(contract.signer, overrides.from),
            signer: contract.signer.getAddress()
          }).then((check) => __awaiter5(this, void 0, void 0, function* () {
            if (getAddress(check.signer) !== check.override) {
              logger19.throwError("Contract with a Signer cannot override from", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "overrides.from"
              });
            }
            return check.override;
          }));
        } else {
          overrides.from = contract.signer.getAddress();
        }
      } else if (overrides.from) {
        overrides.from = resolveName(contract.provider, overrides.from);
      }
      const resolved = yield resolveProperties({
        args: resolveAddresses(contract.signer || contract.provider, args, fragment.inputs),
        address: contract.resolvedAddress,
        overrides: resolveProperties(overrides) || {}
      });
      const data4 = contract.interface.encodeFunctionData(fragment, resolved.args);
      const tx = {
        data: data4,
        to: resolved.address
      };
      const ro = resolved.overrides;
      if (ro.nonce != null) {
        tx.nonce = BigNumber.from(ro.nonce).toNumber();
      }
      if (ro.gasLimit != null) {
        tx.gasLimit = BigNumber.from(ro.gasLimit);
      }
      if (ro.gasPrice != null) {
        tx.gasPrice = BigNumber.from(ro.gasPrice);
      }
      if (ro.maxFeePerGas != null) {
        tx.maxFeePerGas = BigNumber.from(ro.maxFeePerGas);
      }
      if (ro.maxPriorityFeePerGas != null) {
        tx.maxPriorityFeePerGas = BigNumber.from(ro.maxPriorityFeePerGas);
      }
      if (ro.from != null) {
        tx.from = ro.from;
      }
      if (ro.type != null) {
        tx.type = ro.type;
      }
      if (ro.accessList != null) {
        tx.accessList = accessListify(ro.accessList);
      }
      if (tx.gasLimit == null && fragment.gas != null) {
        let intrinsic = 21e3;
        const bytes = arrayify(data4);
        for (let i3 = 0; i3 < bytes.length; i3++) {
          intrinsic += 4;
          if (bytes[i3]) {
            intrinsic += 64;
          }
        }
        tx.gasLimit = BigNumber.from(fragment.gas).add(intrinsic);
      }
      if (ro.value) {
        const roValue = BigNumber.from(ro.value);
        if (!roValue.isZero() && !fragment.payable) {
          logger19.throwError("non-payable method cannot override value", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "overrides.value",
            value: overrides.value
          });
        }
        tx.value = roValue;
      }
      delete overrides.nonce;
      delete overrides.gasLimit;
      delete overrides.gasPrice;
      delete overrides.from;
      delete overrides.value;
      delete overrides.type;
      delete overrides.accessList;
      delete overrides.maxFeePerGas;
      delete overrides.maxPriorityFeePerGas;
      const leftovers = Object.keys(overrides).filter((key2) => overrides[key2] != null);
      if (leftovers.length) {
        logger19.throwError(`cannot override ${leftovers.map((l3) => JSON.stringify(l3)).join(",")}`, Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "overrides",
          overrides: leftovers
        });
      }
      return tx;
    });
  }
  function buildPopulate(contract, fragment) {
    return function(...args) {
      return populateTransaction(contract, fragment, args);
    };
  }
  function buildEstimate(contract, fragment) {
    const signerOrProvider = contract.signer || contract.provider;
    return function(...args) {
      return __awaiter5(this, void 0, void 0, function* () {
        if (!signerOrProvider) {
          logger19.throwError("estimate require a provider or signer", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "estimateGas"
          });
        }
        const tx = yield populateTransaction(contract, fragment, args);
        return yield signerOrProvider.estimateGas(tx);
      });
    };
  }
  function buildCall(contract, fragment, collapseSimple) {
    const signerOrProvider = contract.signer || contract.provider;
    return function(...args) {
      return __awaiter5(this, void 0, void 0, function* () {
        let blockTag = void 0;
        if (args.length === fragment.inputs.length + 1 && typeof args[args.length - 1] === "object") {
          const overrides = shallowCopy(args.pop());
          if (overrides.blockTag != null) {
            blockTag = yield overrides.blockTag;
          }
          delete overrides.blockTag;
          args.push(overrides);
        }
        if (contract.deployTransaction != null) {
          yield contract._deployed(blockTag);
        }
        const tx = yield populateTransaction(contract, fragment, args);
        const result = yield signerOrProvider.call(tx, blockTag);
        try {
          let value = contract.interface.decodeFunctionResult(fragment, result);
          if (collapseSimple && fragment.outputs.length === 1) {
            value = value[0];
          }
          return value;
        } catch (error) {
          if (error.code === Logger.errors.CALL_EXCEPTION) {
            error.address = contract.address;
            error.args = args;
            error.transaction = tx;
          }
          throw error;
        }
      });
    };
  }
  function buildSend(contract, fragment) {
    return function(...args) {
      return __awaiter5(this, void 0, void 0, function* () {
        if (!contract.signer) {
          logger19.throwError("sending a transaction requires a signer", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "sendTransaction"
          });
        }
        if (contract.deployTransaction != null) {
          yield contract._deployed();
        }
        const txRequest = yield populateTransaction(contract, fragment, args);
        const tx = yield contract.signer.sendTransaction(txRequest);
        const wait = tx.wait.bind(tx);
        tx.wait = (confirmations) => {
          return wait(confirmations).then((receipt) => {
            receipt.events = receipt.logs.map((log) => {
              let event = deepCopy(log);
              let parsed = null;
              try {
                parsed = contract.interface.parseLog(log);
              } catch (e3) {
              }
              if (parsed) {
                event.args = parsed.args;
                event.decode = (data4, topics) => {
                  return contract.interface.decodeEventLog(parsed.eventFragment, data4, topics);
                };
                event.event = parsed.name;
                event.eventSignature = parsed.signature;
              }
              event.removeListener = () => {
                return contract.provider;
              };
              event.getBlock = () => {
                return contract.provider.getBlock(receipt.blockHash);
              };
              event.getTransaction = () => {
                return contract.provider.getTransaction(receipt.transactionHash);
              };
              event.getTransactionReceipt = () => {
                return Promise.resolve(receipt);
              };
              return event;
            });
            return receipt;
          });
        };
        return tx;
      });
    };
  }
  function buildDefault(contract, fragment, collapseSimple) {
    if (fragment.constant) {
      return buildCall(contract, fragment, collapseSimple);
    }
    return buildSend(contract, fragment);
  }
  function getEventTag(filter) {
    if (filter.address && (filter.topics == null || filter.topics.length === 0)) {
      return "*";
    }
    return (filter.address || "*") + "@" + (filter.topics ? filter.topics.map((topic) => {
      if (Array.isArray(topic)) {
        return topic.join("|");
      }
      return topic;
    }).join(":") : "");
  }
  var RunningEvent = class {
    constructor(tag, filter) {
      defineReadOnly(this, "tag", tag);
      defineReadOnly(this, "filter", filter);
      this._listeners = [];
    }
    addListener(listener, once) {
      this._listeners.push({ listener, once });
    }
    removeListener(listener) {
      let done = false;
      this._listeners = this._listeners.filter((item) => {
        if (done || item.listener !== listener) {
          return true;
        }
        done = true;
        return false;
      });
    }
    removeAllListeners() {
      this._listeners = [];
    }
    listeners() {
      return this._listeners.map((i3) => i3.listener);
    }
    listenerCount() {
      return this._listeners.length;
    }
    run(args) {
      const listenerCount = this.listenerCount();
      this._listeners = this._listeners.filter((item) => {
        const argsCopy = args.slice();
        setTimeout(() => {
          item.listener.apply(this, argsCopy);
        }, 0);
        return !item.once;
      });
      return listenerCount;
    }
    prepareEvent(event) {
    }
    getEmit(event) {
      return [event];
    }
  };
  var ErrorRunningEvent = class extends RunningEvent {
    constructor() {
      super("error", null);
    }
  };
  var FragmentRunningEvent = class extends RunningEvent {
    constructor(address, contractInterface, fragment, topics) {
      const filter = {
        address
      };
      let topic = contractInterface.getEventTopic(fragment);
      if (topics) {
        if (topic !== topics[0]) {
          logger19.throwArgumentError("topic mismatch", "topics", topics);
        }
        filter.topics = topics.slice();
      } else {
        filter.topics = [topic];
      }
      super(getEventTag(filter), filter);
      defineReadOnly(this, "address", address);
      defineReadOnly(this, "interface", contractInterface);
      defineReadOnly(this, "fragment", fragment);
    }
    prepareEvent(event) {
      super.prepareEvent(event);
      event.event = this.fragment.name;
      event.eventSignature = this.fragment.format();
      event.decode = (data4, topics) => {
        return this.interface.decodeEventLog(this.fragment, data4, topics);
      };
      try {
        event.args = this.interface.decodeEventLog(this.fragment, event.data, event.topics);
      } catch (error) {
        event.args = null;
        event.decodeError = error;
      }
    }
    getEmit(event) {
      const errors = checkResultErrors(event.args);
      if (errors.length) {
        throw errors[0].error;
      }
      const args = (event.args || []).slice();
      args.push(event);
      return args;
    }
  };
  var WildcardRunningEvent = class extends RunningEvent {
    constructor(address, contractInterface) {
      super("*", { address });
      defineReadOnly(this, "address", address);
      defineReadOnly(this, "interface", contractInterface);
    }
    prepareEvent(event) {
      super.prepareEvent(event);
      try {
        const parsed = this.interface.parseLog(event);
        event.event = parsed.name;
        event.eventSignature = parsed.signature;
        event.decode = (data4, topics) => {
          return this.interface.decodeEventLog(parsed.eventFragment, data4, topics);
        };
        event.args = parsed.args;
      } catch (error) {
      }
    }
  };
  var BaseContract = class {
    constructor(addressOrName, contractInterface, signerOrProvider) {
      logger19.checkNew(new.target, Contract);
      defineReadOnly(this, "interface", getStatic(new.target, "getInterface")(contractInterface));
      if (signerOrProvider == null) {
        defineReadOnly(this, "provider", null);
        defineReadOnly(this, "signer", null);
      } else if (Signer.isSigner(signerOrProvider)) {
        defineReadOnly(this, "provider", signerOrProvider.provider || null);
        defineReadOnly(this, "signer", signerOrProvider);
      } else if (Provider.isProvider(signerOrProvider)) {
        defineReadOnly(this, "provider", signerOrProvider);
        defineReadOnly(this, "signer", null);
      } else {
        logger19.throwArgumentError("invalid signer or provider", "signerOrProvider", signerOrProvider);
      }
      defineReadOnly(this, "callStatic", {});
      defineReadOnly(this, "estimateGas", {});
      defineReadOnly(this, "functions", {});
      defineReadOnly(this, "populateTransaction", {});
      defineReadOnly(this, "filters", {});
      {
        const uniqueFilters = {};
        Object.keys(this.interface.events).forEach((eventSignature) => {
          const event = this.interface.events[eventSignature];
          defineReadOnly(this.filters, eventSignature, (...args) => {
            return {
              address: this.address,
              topics: this.interface.encodeFilterTopics(event, args)
            };
          });
          if (!uniqueFilters[event.name]) {
            uniqueFilters[event.name] = [];
          }
          uniqueFilters[event.name].push(eventSignature);
        });
        Object.keys(uniqueFilters).forEach((name2) => {
          const filters = uniqueFilters[name2];
          if (filters.length === 1) {
            defineReadOnly(this.filters, name2, this.filters[filters[0]]);
          } else {
            logger19.warn(`Duplicate definition of ${name2} (${filters.join(", ")})`);
          }
        });
      }
      defineReadOnly(this, "_runningEvents", {});
      defineReadOnly(this, "_wrappedEmits", {});
      if (addressOrName == null) {
        logger19.throwArgumentError("invalid contract address or ENS name", "addressOrName", addressOrName);
      }
      defineReadOnly(this, "address", addressOrName);
      if (this.provider) {
        defineReadOnly(this, "resolvedAddress", resolveName(this.provider, addressOrName));
      } else {
        try {
          defineReadOnly(this, "resolvedAddress", Promise.resolve(getAddress(addressOrName)));
        } catch (error) {
          logger19.throwError("provider is required to use ENS name as contract address", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "new Contract"
          });
        }
      }
      const uniqueNames = {};
      const uniqueSignatures = {};
      Object.keys(this.interface.functions).forEach((signature2) => {
        const fragment = this.interface.functions[signature2];
        if (uniqueSignatures[signature2]) {
          logger19.warn(`Duplicate ABI entry for ${JSON.stringify(signature2)}`);
          return;
        }
        uniqueSignatures[signature2] = true;
        {
          const name2 = fragment.name;
          if (!uniqueNames[name2]) {
            uniqueNames[name2] = [];
          }
          uniqueNames[name2].push(signature2);
        }
        if (this[signature2] == null) {
          defineReadOnly(this, signature2, buildDefault(this, fragment, true));
        }
        if (this.functions[signature2] == null) {
          defineReadOnly(this.functions, signature2, buildDefault(this, fragment, false));
        }
        if (this.callStatic[signature2] == null) {
          defineReadOnly(this.callStatic, signature2, buildCall(this, fragment, true));
        }
        if (this.populateTransaction[signature2] == null) {
          defineReadOnly(this.populateTransaction, signature2, buildPopulate(this, fragment));
        }
        if (this.estimateGas[signature2] == null) {
          defineReadOnly(this.estimateGas, signature2, buildEstimate(this, fragment));
        }
      });
      Object.keys(uniqueNames).forEach((name2) => {
        const signatures = uniqueNames[name2];
        if (signatures.length > 1) {
          return;
        }
        const signature2 = signatures[0];
        try {
          if (this[name2] == null) {
            defineReadOnly(this, name2, this[signature2]);
          }
        } catch (e3) {
        }
        if (this.functions[name2] == null) {
          defineReadOnly(this.functions, name2, this.functions[signature2]);
        }
        if (this.callStatic[name2] == null) {
          defineReadOnly(this.callStatic, name2, this.callStatic[signature2]);
        }
        if (this.populateTransaction[name2] == null) {
          defineReadOnly(this.populateTransaction, name2, this.populateTransaction[signature2]);
        }
        if (this.estimateGas[name2] == null) {
          defineReadOnly(this.estimateGas, name2, this.estimateGas[signature2]);
        }
      });
    }
    static getContractAddress(transaction) {
      return getContractAddress(transaction);
    }
    static getInterface(contractInterface) {
      if (Interface.isInterface(contractInterface)) {
        return contractInterface;
      }
      return new Interface(contractInterface);
    }
    deployed() {
      return this._deployed();
    }
    _deployed(blockTag) {
      if (!this._deployedPromise) {
        if (this.deployTransaction) {
          this._deployedPromise = this.deployTransaction.wait().then(() => {
            return this;
          });
        } else {
          this._deployedPromise = this.provider.getCode(this.address, blockTag).then((code) => {
            if (code === "0x") {
              logger19.throwError("contract not deployed", Logger.errors.UNSUPPORTED_OPERATION, {
                contractAddress: this.address,
                operation: "getDeployed"
              });
            }
            return this;
          });
        }
      }
      return this._deployedPromise;
    }
    fallback(overrides) {
      if (!this.signer) {
        logger19.throwError("sending a transactions require a signer", Logger.errors.UNSUPPORTED_OPERATION, { operation: "sendTransaction(fallback)" });
      }
      const tx = shallowCopy(overrides || {});
      ["from", "to"].forEach(function(key2) {
        if (tx[key2] == null) {
          return;
        }
        logger19.throwError("cannot override " + key2, Logger.errors.UNSUPPORTED_OPERATION, { operation: key2 });
      });
      tx.to = this.resolvedAddress;
      return this.deployed().then(() => {
        return this.signer.sendTransaction(tx);
      });
    }
    connect(signerOrProvider) {
      if (typeof signerOrProvider === "string") {
        signerOrProvider = new VoidSigner(signerOrProvider, this.provider);
      }
      const contract = new this.constructor(this.address, this.interface, signerOrProvider);
      if (this.deployTransaction) {
        defineReadOnly(contract, "deployTransaction", this.deployTransaction);
      }
      return contract;
    }
    attach(addressOrName) {
      return new this.constructor(addressOrName, this.interface, this.signer || this.provider);
    }
    static isIndexed(value) {
      return Indexed.isIndexed(value);
    }
    _normalizeRunningEvent(runningEvent) {
      if (this._runningEvents[runningEvent.tag]) {
        return this._runningEvents[runningEvent.tag];
      }
      return runningEvent;
    }
    _getRunningEvent(eventName) {
      if (typeof eventName === "string") {
        if (eventName === "error") {
          return this._normalizeRunningEvent(new ErrorRunningEvent());
        }
        if (eventName === "event") {
          return this._normalizeRunningEvent(new RunningEvent("event", null));
        }
        if (eventName === "*") {
          return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));
        }
        const fragment = this.interface.getEvent(eventName);
        return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment));
      }
      if (eventName.topics && eventName.topics.length > 0) {
        try {
          const topic = eventName.topics[0];
          if (typeof topic !== "string") {
            throw new Error("invalid topic");
          }
          const fragment = this.interface.getEvent(topic);
          return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment, eventName.topics));
        } catch (error) {
        }
        const filter = {
          address: this.address,
          topics: eventName.topics
        };
        return this._normalizeRunningEvent(new RunningEvent(getEventTag(filter), filter));
      }
      return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));
    }
    _checkRunningEvents(runningEvent) {
      if (runningEvent.listenerCount() === 0) {
        delete this._runningEvents[runningEvent.tag];
        const emit = this._wrappedEmits[runningEvent.tag];
        if (emit && runningEvent.filter) {
          this.provider.off(runningEvent.filter, emit);
          delete this._wrappedEmits[runningEvent.tag];
        }
      }
    }
    _wrapEvent(runningEvent, log, listener) {
      const event = deepCopy(log);
      event.removeListener = () => {
        if (!listener) {
          return;
        }
        runningEvent.removeListener(listener);
        this._checkRunningEvents(runningEvent);
      };
      event.getBlock = () => {
        return this.provider.getBlock(log.blockHash);
      };
      event.getTransaction = () => {
        return this.provider.getTransaction(log.transactionHash);
      };
      event.getTransactionReceipt = () => {
        return this.provider.getTransactionReceipt(log.transactionHash);
      };
      runningEvent.prepareEvent(event);
      return event;
    }
    _addEventListener(runningEvent, listener, once) {
      if (!this.provider) {
        logger19.throwError("events require a provider or a signer with a provider", Logger.errors.UNSUPPORTED_OPERATION, { operation: "once" });
      }
      runningEvent.addListener(listener, once);
      this._runningEvents[runningEvent.tag] = runningEvent;
      if (!this._wrappedEmits[runningEvent.tag]) {
        const wrappedEmit = (log) => {
          let event = this._wrapEvent(runningEvent, log, listener);
          if (event.decodeError == null) {
            try {
              const args = runningEvent.getEmit(event);
              this.emit(runningEvent.filter, ...args);
            } catch (error) {
              event.decodeError = error.error;
            }
          }
          if (runningEvent.filter != null) {
            this.emit("event", event);
          }
          if (event.decodeError != null) {
            this.emit("error", event.decodeError, event);
          }
        };
        this._wrappedEmits[runningEvent.tag] = wrappedEmit;
        if (runningEvent.filter != null) {
          this.provider.on(runningEvent.filter, wrappedEmit);
        }
      }
    }
    queryFilter(event, fromBlockOrBlockhash, toBlock) {
      const runningEvent = this._getRunningEvent(event);
      const filter = shallowCopy(runningEvent.filter);
      if (typeof fromBlockOrBlockhash === "string" && isHexString(fromBlockOrBlockhash, 32)) {
        if (toBlock != null) {
          logger19.throwArgumentError("cannot specify toBlock with blockhash", "toBlock", toBlock);
        }
        filter.blockHash = fromBlockOrBlockhash;
      } else {
        filter.fromBlock = fromBlockOrBlockhash != null ? fromBlockOrBlockhash : 0;
        filter.toBlock = toBlock != null ? toBlock : "latest";
      }
      return this.provider.getLogs(filter).then((logs) => {
        return logs.map((log) => this._wrapEvent(runningEvent, log, null));
      });
    }
    on(event, listener) {
      this._addEventListener(this._getRunningEvent(event), listener, false);
      return this;
    }
    once(event, listener) {
      this._addEventListener(this._getRunningEvent(event), listener, true);
      return this;
    }
    emit(eventName, ...args) {
      if (!this.provider) {
        return false;
      }
      const runningEvent = this._getRunningEvent(eventName);
      const result = runningEvent.run(args) > 0;
      this._checkRunningEvents(runningEvent);
      return result;
    }
    listenerCount(eventName) {
      if (!this.provider) {
        return 0;
      }
      if (eventName == null) {
        return Object.keys(this._runningEvents).reduce((accum, key2) => {
          return accum + this._runningEvents[key2].listenerCount();
        }, 0);
      }
      return this._getRunningEvent(eventName).listenerCount();
    }
    listeners(eventName) {
      if (!this.provider) {
        return [];
      }
      if (eventName == null) {
        const result = [];
        for (let tag in this._runningEvents) {
          this._runningEvents[tag].listeners().forEach((listener) => {
            result.push(listener);
          });
        }
        return result;
      }
      return this._getRunningEvent(eventName).listeners();
    }
    removeAllListeners(eventName) {
      if (!this.provider) {
        return this;
      }
      if (eventName == null) {
        for (const tag in this._runningEvents) {
          const runningEvent2 = this._runningEvents[tag];
          runningEvent2.removeAllListeners();
          this._checkRunningEvents(runningEvent2);
        }
        return this;
      }
      const runningEvent = this._getRunningEvent(eventName);
      runningEvent.removeAllListeners();
      this._checkRunningEvents(runningEvent);
      return this;
    }
    off(eventName, listener) {
      if (!this.provider) {
        return this;
      }
      const runningEvent = this._getRunningEvent(eventName);
      runningEvent.removeListener(listener);
      this._checkRunningEvents(runningEvent);
      return this;
    }
    removeListener(eventName, listener) {
      return this.off(eventName, listener);
    }
  };
  var Contract = class extends BaseContract {
  };
  var ContractFactory = class {
    constructor(contractInterface, bytecode, signer) {
      let bytecodeHex = null;
      if (typeof bytecode === "string") {
        bytecodeHex = bytecode;
      } else if (isBytes(bytecode)) {
        bytecodeHex = hexlify(bytecode);
      } else if (bytecode && typeof bytecode.object === "string") {
        bytecodeHex = bytecode.object;
      } else {
        bytecodeHex = "!";
      }
      if (bytecodeHex.substring(0, 2) !== "0x") {
        bytecodeHex = "0x" + bytecodeHex;
      }
      if (!isHexString(bytecodeHex) || bytecodeHex.length % 2) {
        logger19.throwArgumentError("invalid bytecode", "bytecode", bytecode);
      }
      if (signer && !Signer.isSigner(signer)) {
        logger19.throwArgumentError("invalid signer", "signer", signer);
      }
      defineReadOnly(this, "bytecode", bytecodeHex);
      defineReadOnly(this, "interface", getStatic(new.target, "getInterface")(contractInterface));
      defineReadOnly(this, "signer", signer || null);
    }
    getDeployTransaction(...args) {
      let tx = {};
      if (args.length === this.interface.deploy.inputs.length + 1 && typeof args[args.length - 1] === "object") {
        tx = shallowCopy(args.pop());
        for (const key2 in tx) {
          if (!allowedTransactionKeys3[key2]) {
            throw new Error("unknown transaction override " + key2);
          }
        }
      }
      ["data", "from", "to"].forEach((key2) => {
        if (tx[key2] == null) {
          return;
        }
        logger19.throwError("cannot override " + key2, Logger.errors.UNSUPPORTED_OPERATION, { operation: key2 });
      });
      if (tx.value) {
        const value = BigNumber.from(tx.value);
        if (!value.isZero() && !this.interface.deploy.payable) {
          logger19.throwError("non-payable constructor cannot override value", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "overrides.value",
            value: tx.value
          });
        }
      }
      logger19.checkArgumentCount(args.length, this.interface.deploy.inputs.length, " in Contract constructor");
      tx.data = hexlify(concat([
        this.bytecode,
        this.interface.encodeDeploy(args)
      ]));
      return tx;
    }
    deploy(...args) {
      return __awaiter5(this, void 0, void 0, function* () {
        let overrides = {};
        if (args.length === this.interface.deploy.inputs.length + 1) {
          overrides = args.pop();
        }
        logger19.checkArgumentCount(args.length, this.interface.deploy.inputs.length, " in Contract constructor");
        const params = yield resolveAddresses(this.signer, args, this.interface.deploy.inputs);
        params.push(overrides);
        const unsignedTx = this.getDeployTransaction(...params);
        const tx = yield this.signer.sendTransaction(unsignedTx);
        const address = getStatic(this.constructor, "getContractAddress")(tx);
        const contract = getStatic(this.constructor, "getContract")(address, this.interface, this.signer);
        defineReadOnly(contract, "deployTransaction", tx);
        return contract;
      });
    }
    attach(address) {
      return this.constructor.getContract(address, this.interface, this.signer);
    }
    connect(signer) {
      return new this.constructor(this.interface, this.bytecode, signer);
    }
    static fromSolidity(compilerOutput, signer) {
      if (compilerOutput == null) {
        logger19.throwError("missing compiler output", Logger.errors.MISSING_ARGUMENT, { argument: "compilerOutput" });
      }
      if (typeof compilerOutput === "string") {
        compilerOutput = JSON.parse(compilerOutput);
      }
      const abi = compilerOutput.abi;
      let bytecode = null;
      if (compilerOutput.bytecode) {
        bytecode = compilerOutput.bytecode;
      } else if (compilerOutput.evm && compilerOutput.evm.bytecode) {
        bytecode = compilerOutput.evm.bytecode;
      }
      return new this(abi, bytecode, signer);
    }
    static getInterface(contractInterface) {
      return Contract.getInterface(contractInterface);
    }
    static getContractAddress(tx) {
      return getContractAddress(tx);
    }
    static getContract(address, contractInterface, signer) {
      return new Contract(address, contractInterface, signer);
    }
  };

  // node_modules/@ethersproject/basex/lib.esm/index.js
  var BaseX = class {
    constructor(alphabet) {
      defineReadOnly(this, "alphabet", alphabet);
      defineReadOnly(this, "base", alphabet.length);
      defineReadOnly(this, "_alphabetMap", {});
      defineReadOnly(this, "_leader", alphabet.charAt(0));
      for (let i3 = 0; i3 < alphabet.length; i3++) {
        this._alphabetMap[alphabet.charAt(i3)] = i3;
      }
    }
    encode(value) {
      let source = arrayify(value);
      if (source.length === 0) {
        return "";
      }
      let digits = [0];
      for (let i3 = 0; i3 < source.length; ++i3) {
        let carry = source[i3];
        for (let j3 = 0; j3 < digits.length; ++j3) {
          carry += digits[j3] << 8;
          digits[j3] = carry % this.base;
          carry = carry / this.base | 0;
        }
        while (carry > 0) {
          digits.push(carry % this.base);
          carry = carry / this.base | 0;
        }
      }
      let string = "";
      for (let k3 = 0; source[k3] === 0 && k3 < source.length - 1; ++k3) {
        string += this._leader;
      }
      for (let q3 = digits.length - 1; q3 >= 0; --q3) {
        string += this.alphabet[digits[q3]];
      }
      return string;
    }
    decode(value) {
      if (typeof value !== "string") {
        throw new TypeError("Expected String");
      }
      let bytes = [];
      if (value.length === 0) {
        return new Uint8Array(bytes);
      }
      bytes.push(0);
      for (let i3 = 0; i3 < value.length; i3++) {
        let byte = this._alphabetMap[value[i3]];
        if (byte === void 0) {
          throw new Error("Non-base" + this.base + " character");
        }
        let carry = byte;
        for (let j3 = 0; j3 < bytes.length; ++j3) {
          carry += bytes[j3] * this.base;
          bytes[j3] = carry & 255;
          carry >>= 8;
        }
        while (carry > 0) {
          bytes.push(carry & 255);
          carry >>= 8;
        }
      }
      for (let k3 = 0; value[k3] === this._leader && k3 < value.length - 1; ++k3) {
        bytes.push(0);
      }
      return arrayify(new Uint8Array(bytes.reverse()));
    }
  };
  var Base32 = new BaseX("abcdefghijklmnopqrstuvwxyz234567");
  var Base58 = new BaseX("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");

  // node_modules/@ethersproject/sha2/lib.esm/sha2.js
  var import_hash3 = __toModule(require_hash());

  // node_modules/@ethersproject/sha2/lib.esm/types.js
  var SupportedAlgorithm;
  (function(SupportedAlgorithm2) {
    SupportedAlgorithm2["sha256"] = "sha256";
    SupportedAlgorithm2["sha512"] = "sha512";
  })(SupportedAlgorithm || (SupportedAlgorithm = {}));

  // node_modules/@ethersproject/sha2/lib.esm/_version.js
  var version15 = "sha2/5.4.0";

  // node_modules/@ethersproject/sha2/lib.esm/sha2.js
  "use strict";
  var logger20 = new Logger(version15);
  function ripemd160(data4) {
    return "0x" + import_hash3.default.ripemd160().update(arrayify(data4)).digest("hex");
  }
  function sha256(data4) {
    return "0x" + import_hash3.default.sha256().update(arrayify(data4)).digest("hex");
  }
  function sha512(data4) {
    return "0x" + import_hash3.default.sha512().update(arrayify(data4)).digest("hex");
  }
  function computeHmac(algorithm, key2, data4) {
    if (!SupportedAlgorithm[algorithm]) {
      logger20.throwError("unsupported algorithm " + algorithm, Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "hmac",
        algorithm
      });
    }
    return "0x" + import_hash3.default.hmac(import_hash3.default[algorithm], arrayify(key2)).update(arrayify(data4)).digest("hex");
  }

  // node_modules/@ethersproject/pbkdf2/lib.esm/pbkdf2.js
  "use strict";
  function pbkdf2(password, salt, iterations, keylen, hashAlgorithm) {
    password = arrayify(password);
    salt = arrayify(salt);
    let hLen;
    let l3 = 1;
    const DK = new Uint8Array(keylen);
    const block1 = new Uint8Array(salt.length + 4);
    block1.set(salt);
    let r3;
    let T4;
    for (let i3 = 1; i3 <= l3; i3++) {
      block1[salt.length] = i3 >> 24 & 255;
      block1[salt.length + 1] = i3 >> 16 & 255;
      block1[salt.length + 2] = i3 >> 8 & 255;
      block1[salt.length + 3] = i3 & 255;
      let U2 = arrayify(computeHmac(hashAlgorithm, password, block1));
      if (!hLen) {
        hLen = U2.length;
        T4 = new Uint8Array(hLen);
        l3 = Math.ceil(keylen / hLen);
        r3 = keylen - (l3 - 1) * hLen;
      }
      T4.set(U2);
      for (let j3 = 1; j3 < iterations; j3++) {
        U2 = arrayify(computeHmac(hashAlgorithm, password, U2));
        for (let k3 = 0; k3 < hLen; k3++)
          T4[k3] ^= U2[k3];
      }
      const destPos = (i3 - 1) * hLen;
      const len = i3 === l3 ? r3 : hLen;
      DK.set(arrayify(T4).slice(0, len), destPos);
    }
    return hexlify(DK);
  }

  // node_modules/@ethersproject/wordlists/lib.esm/_version.js
  var version16 = "wordlists/5.4.0";

  // node_modules/@ethersproject/wordlists/lib.esm/wordlist.js
  "use strict";
  var exportWordlist = false;
  var logger21 = new Logger(version16);
  var Wordlist = class {
    constructor(locale) {
      logger21.checkAbstract(new.target, Wordlist);
      defineReadOnly(this, "locale", locale);
    }
    split(mnemonic) {
      return mnemonic.toLowerCase().split(/ +/g);
    }
    join(words6) {
      return words6.join(" ");
    }
    static check(wordlist9) {
      const words6 = [];
      for (let i3 = 0; i3 < 2048; i3++) {
        const word = wordlist9.getWord(i3);
        if (i3 !== wordlist9.getWordIndex(word)) {
          return "0x";
        }
        words6.push(word);
      }
      return id(words6.join("\n") + "\n");
    }
    static register(lang, name2) {
      if (!name2) {
        name2 = lang.locale;
      }
      if (exportWordlist) {
        try {
          const anyGlobal2 = window;
          if (anyGlobal2._ethers && anyGlobal2._ethers.wordlists) {
            if (!anyGlobal2._ethers.wordlists[name2]) {
              defineReadOnly(anyGlobal2._ethers.wordlists, name2, lang);
            }
          }
        } catch (error) {
        }
      }
    }
  };

  // node_modules/@ethersproject/wordlists/lib.esm/lang-cz.js
  "use strict";
  var words = "AbdikaceAbecedaAdresaAgreseAkceAktovkaAlejAlkoholAmputaceAnanasAndulkaAnekdotaAnketaAntikaAnulovatArchaAroganceAsfaltAsistentAspiraceAstmaAstronomAtlasAtletikaAtolAutobusAzylBabkaBachorBacilBaculkaBadatelBagetaBagrBahnoBakterieBaladaBaletkaBalkonBalonekBalvanBalzaBambusBankomatBarbarBaretBarmanBarokoBarvaBaterkaBatohBavlnaBazalkaBazilikaBazukaBednaBeranBesedaBestieBetonBezinkaBezmocBeztakBicyklBidloBiftekBikinyBilanceBiografBiologBitvaBizonBlahobytBlatouchBlechaBleduleBleskBlikatBliznaBlokovatBlouditBludBobekBobrBodlinaBodnoutBohatostBojkotBojovatBokorysBolestBorecBoroviceBotaBoubelBouchatBoudaBouleBouratBoxerBradavkaBramboraBrankaBratrBreptaBriketaBrkoBrlohBronzBroskevBrunetkaBrusinkaBrzdaBrzyBublinaBubnovatBuchtaBuditelBudkaBudovaBufetBujarostBukviceBuldokBulvaBundaBunkrBurzaButikBuvolBuzolaBydletBylinaBytovkaBzukotCapartCarevnaCedrCeduleCejchCejnCelaCelerCelkemCelniceCeninaCennostCenovkaCentrumCenzorCestopisCetkaChalupaChapadloCharitaChataChechtatChemieChichotChirurgChladChlebaChlubitChmelChmuraChobotChocholChodbaCholeraChomoutChopitChorobaChovChrapotChrlitChrtChrupChtivostChudinaChutnatChvatChvilkaChvostChybaChystatChytitCibuleCigaretaCihelnaCihlaCinkotCirkusCisternaCitaceCitrusCizinecCizostClonaCokolivCouvatCtitelCtnostCudnostCuketaCukrCupotCvaknoutCvalCvikCvrkotCyklistaDalekoDarebaDatelDatumDceraDebataDechovkaDecibelDeficitDeflaceDeklDekretDemokratDepreseDerbyDeskaDetektivDikobrazDiktovatDiodaDiplomDiskDisplejDivadloDivochDlahaDlouhoDluhopisDnesDobroDobytekDocentDochutitDodnesDohledDohodaDohraDojemDojniceDokladDokolaDoktorDokumentDolarDolevaDolinaDomaDominantDomluvitDomovDonutitDopadDopisDoplnitDoposudDoprovodDopustitDorazitDorostDortDosahDoslovDostatekDosudDosytaDotazDotekDotknoutDoufatDoutnatDovozceDozaduDoznatDozorceDrahotaDrakDramatikDravecDrazeDrdolDrobnostDrogerieDrozdDrsnostDrtitDrzostDubenDuchovnoDudekDuhaDuhovkaDusitDusnoDutostDvojiceDvorecDynamitEkologEkonomieElektronElipsaEmailEmiseEmoceEmpatieEpizodaEpochaEpopejEposEsejEsenceEskortaEskymoEtiketaEuforieEvoluceExekuceExkurzeExpediceExplozeExportExtraktFackaFajfkaFakultaFanatikFantazieFarmacieFavoritFazoleFederaceFejetonFenkaFialkaFigurantFilozofFiltrFinanceFintaFixaceFjordFlanelFlirtFlotilaFondFosforFotbalFotkaFotonFrakceFreskaFrontaFukarFunkceFyzikaGalejeGarantGenetikaGeologGilotinaGlazuraGlejtGolemGolfistaGotikaGrafGramofonGranuleGrepGrilGrogGroteskaGumaHadiceHadrHalaHalenkaHanbaHanopisHarfaHarpunaHavranHebkostHejkalHejnoHejtmanHektarHelmaHematomHerecHernaHesloHezkyHistorikHladovkaHlasivkyHlavaHledatHlenHlodavecHlohHloupostHltatHlubinaHluchotaHmatHmotaHmyzHnisHnojivoHnoutHoblinaHobojHochHodinyHodlatHodnotaHodovatHojnostHokejHolinkaHolkaHolubHomoleHonitbaHonoraceHoralHordaHorizontHorkoHorlivecHormonHorninaHoroskopHorstvoHospodaHostinaHotovostHoubaHoufHoupatHouskaHovorHradbaHraniceHravostHrazdaHrbolekHrdinaHrdloHrdostHrnekHrobkaHromadaHrotHroudaHrozenHrstkaHrubostHryzatHubenostHubnoutHudbaHukotHumrHusitaHustotaHvozdHybnostHydrantHygienaHymnaHysterikIdylkaIhnedIkonaIluzeImunitaInfekceInflaceInkasoInovaceInspekceInternetInvalidaInvestorInzerceIronieJablkoJachtaJahodaJakmileJakostJalovecJantarJarmarkJaroJasanJasnoJatkaJavorJazykJedinecJedleJednatelJehlanJekotJelenJelitoJemnostJenomJepiceJeseterJevitJezdecJezeroJinakJindyJinochJiskraJistotaJitrniceJizvaJmenovatJogurtJurtaKabaretKabelKabinetKachnaKadetKadidloKahanKajakKajutaKakaoKaktusKalamitaKalhotyKalibrKalnostKameraKamkolivKamnaKanibalKanoeKantorKapalinaKapelaKapitolaKapkaKapleKapotaKaprKapustaKapybaraKaramelKarotkaKartonKasaKatalogKatedraKauceKauzaKavalecKazajkaKazetaKazivostKdekolivKdesiKedlubenKempKeramikaKinoKlacekKladivoKlamKlapotKlasikaKlaunKlecKlenbaKlepatKlesnoutKlidKlimaKlisnaKloboukKlokanKlopaKloubKlubovnaKlusatKluzkostKmenKmitatKmotrKnihaKnotKoaliceKoberecKobkaKoblihaKobylaKocourKohoutKojenecKokosKoktejlKolapsKoledaKolizeKoloKomandoKometaKomikKomnataKomoraKompasKomunitaKonatKonceptKondiceKonecKonfeseKongresKoninaKonkursKontaktKonzervaKopanecKopieKopnoutKoprovkaKorbelKorektorKormidloKoroptevKorpusKorunaKorytoKorzetKosatecKostkaKotelKotletaKotoulKoukatKoupelnaKousekKouzloKovbojKozaKozorohKrabiceKrachKrajinaKralovatKrasopisKravataKreditKrejcarKresbaKrevetaKriketKritikKrizeKrkavecKrmelecKrmivoKrocanKrokKronikaKropitKroupaKrovkaKrtekKruhadloKrupiceKrutostKrvinkaKrychleKryptaKrystalKrytKudlankaKufrKujnostKuklaKulajdaKulichKulkaKulometKulturaKunaKupodivuKurtKurzorKutilKvalitaKvasinkaKvestorKynologKyselinaKytaraKyticeKytkaKytovecKyvadloLabradorLachtanLadnostLaikLakomecLamelaLampaLanovkaLasiceLasoLasturaLatinkaLavinaLebkaLeckdyLedenLedniceLedovkaLedvinaLegendaLegieLegraceLehceLehkostLehnoutLektvarLenochodLentilkaLepenkaLepidloLetadloLetecLetmoLetokruhLevhartLevitaceLevobokLibraLichotkaLidojedLidskostLihovinaLijavecLilekLimetkaLinieLinkaLinoleumListopadLitinaLitovatLobistaLodivodLogikaLogopedLokalitaLoketLomcovatLopataLopuchLordLososLotrLoudalLouhLoukaLouskatLovecLstivostLucernaLuciferLumpLuskLustraceLviceLyraLyrikaLysinaMadamMadloMagistrMahagonMajetekMajitelMajoritaMakakMakoviceMakrelaMalbaMalinaMalovatMalviceMaminkaMandleMankoMarnostMasakrMaskotMasopustMaticeMatrikaMaturitaMazanecMazivoMazlitMazurkaMdlobaMechanikMeditaceMedovinaMelasaMelounMentolkaMetlaMetodaMetrMezeraMigraceMihnoutMihuleMikinaMikrofonMilenecMilimetrMilostMimikaMincovnaMinibarMinometMinulostMiskaMistrMixovatMladostMlhaMlhovinaMlokMlsatMluvitMnichMnohemMobilMocnostModelkaModlitbaMohylaMokroMolekulaMomentkaMonarchaMonoklMonstrumMontovatMonzunMosazMoskytMostMotivaceMotorkaMotykaMouchaMoudrostMozaikaMozekMozolMramorMravenecMrkevMrtvolaMrzetMrzutostMstitelMudrcMuflonMulatMumieMuniceMusetMutaceMuzeumMuzikantMyslivecMzdaNabouratNachytatNadaceNadbytekNadhozNadobroNadpisNahlasNahnatNahodileNahraditNaivitaNajednouNajistoNajmoutNaklonitNakonecNakrmitNalevoNamazatNamluvitNanometrNaokoNaopakNaostroNapadatNapevnoNaplnitNapnoutNaposledNaprostoNaroditNarubyNarychloNasaditNasekatNaslepoNastatNatolikNavenekNavrchNavzdoryNazvatNebeNechatNeckyNedalekoNedbatNeduhNegaceNehetNehodaNejenNejprveNeklidNelibostNemilostNemocNeochotaNeonkaNepokojNerostNervNesmyslNesouladNetvorNeuronNevinaNezvykleNicotaNijakNikamNikdyNiklNikterakNitroNoclehNohaviceNominaceNoraNorekNositelNosnostNouzeNovinyNovotaNozdraNudaNudleNugetNutitNutnostNutrieNymfaObalObarvitObavaObdivObecObehnatObejmoutObezitaObhajobaObilniceObjasnitObjektObklopitOblastOblekOblibaOblohaObludaObnosObohatitObojekOboutObrazecObrnaObrubaObrysObsahObsluhaObstaratObuvObvazObvinitObvodObvykleObyvatelObzorOcasOcelOcenitOchladitOchotaOchranaOcitnoutOdbojOdbytOdchodOdcizitOdebratOdeslatOdevzdatOdezvaOdhadceOdhoditOdjetOdjinudOdkazOdkoupitOdlivOdlukaOdmlkaOdolnostOdpadOdpisOdploutOdporOdpustitOdpykatOdrazkaOdsouditOdstupOdsunOdtokOdtudOdvahaOdvetaOdvolatOdvracetOdznakOfinaOfsajdOhlasOhniskoOhradaOhrozitOhryzekOkapOkeniceOklikaOknoOkouzlitOkovyOkrasaOkresOkrsekOkruhOkupantOkurkaOkusitOlejninaOlizovatOmakOmeletaOmezitOmladinaOmlouvatOmluvaOmylOnehdyOpakovatOpasekOperaceOpiceOpilostOpisovatOporaOpoziceOpravduOprotiOrbitalOrchestrOrgieOrliceOrlojOrtelOsadaOschnoutOsikaOsivoOslavaOslepitOslnitOslovitOsnovaOsobaOsolitOspalecOstenOstrahaOstudaOstychOsvojitOteplitOtiskOtopOtrhatOtrlostOtrokOtrubyOtvorOvanoutOvarOvesOvlivnitOvoceOxidOzdobaPachatelPacientPadouchPahorekPaktPalandaPalecPalivoPalubaPamfletPamlsekPanenkaPanikaPannaPanovatPanstvoPantoflePaprikaParketaParodiePartaParukaParybaPasekaPasivitaPastelkaPatentPatronaPavoukPaznehtPazourekPeckaPedagogPejsekPekloPelotonPenaltaPendrekPenzePeriskopPeroPestrostPetardaPeticePetrolejPevninaPexesoPianistaPihaPijavicePiklePiknikPilinaPilnostPilulkaPinzetaPipetaPisatelPistolePitevnaPivnicePivovarPlacentaPlakatPlamenPlanetaPlastikaPlatitPlavidloPlazPlechPlemenoPlentaPlesPletivoPlevelPlivatPlnitPlnoPlochaPlodinaPlombaPloutPlukPlynPobavitPobytPochodPocitPoctivecPodatPodcenitPodepsatPodhledPodivitPodkladPodmanitPodnikPodobaPodporaPodrazPodstataPodvodPodzimPoeziePohankaPohnutkaPohovorPohromaPohybPointaPojistkaPojmoutPokazitPoklesPokojPokrokPokutaPokynPolednePolibekPolknoutPolohaPolynomPomaluPominoutPomlkaPomocPomstaPomysletPonechatPonorkaPonurostPopadatPopelPopisekPoplachPoprositPopsatPopudPoradcePorcePorodPoruchaPoryvPosaditPosedPosilaPoskokPoslanecPosouditPospoluPostavaPosudekPosypPotahPotkanPotleskPotomekPotravaPotupaPotvoraPoukazPoutoPouzdroPovahaPovidlaPovlakPovozPovrchPovstatPovykPovzdechPozdravPozemekPoznatekPozorPozvatPracovatPrahoryPraktikaPralesPraotecPraporekPrasePravdaPrincipPrknoProbuditProcentoProdejProfeseProhraProjektProlomitPromilePronikatPropadProrokProsbaProtonProutekProvazPrskavkaPrstenPrudkostPrutPrvekPrvohoryPsanecPsovodPstruhPtactvoPubertaPuchPudlPukavecPuklinaPukrlePultPumpaPuncPupenPusaPusinkaPustinaPutovatPutykaPyramidaPyskPytelRacekRachotRadiaceRadniceRadonRaftRagbyRaketaRakovinaRamenoRampouchRandeRarachRaritaRasovnaRastrRatolestRazanceRazidloReagovatReakceReceptRedaktorReferentReflexRejnokReklamaRekordRekrutRektorReputaceRevizeRevmaRevolverRezervaRiskovatRizikoRobotikaRodokmenRohovkaRokleRokokoRomanetoRopovodRopuchaRorejsRosolRostlinaRotmistrRotopedRotundaRoubenkaRouchoRoupRouraRovinaRovniceRozborRozchodRozdatRozeznatRozhodceRozinkaRozjezdRozkazRozlohaRozmarRozpadRozruchRozsahRoztokRozumRozvodRubrikaRuchadloRukaviceRukopisRybaRybolovRychlostRydloRypadloRytinaRyzostSadistaSahatSakoSamecSamizdatSamotaSanitkaSardinkaSasankaSatelitSazbaSazeniceSborSchovatSebrankaSeceseSedadloSedimentSedloSehnatSejmoutSekeraSektaSekundaSekvojeSemenoSenoServisSesaditSeshoraSeskokSeslatSestraSesuvSesypatSetbaSetinaSetkatSetnoutSetrvatSeverSeznamShodaShrnoutSifonSilniceSirkaSirotekSirupSituaceSkafandrSkaliskoSkanzenSkautSkeptikSkicaSkladbaSkleniceSkloSkluzSkobaSkokanSkoroSkriptaSkrzSkupinaSkvostSkvrnaSlabikaSladidloSlaninaSlastSlavnostSledovatSlepecSlevaSlezinaSlibSlinaSlizniceSlonSloupekSlovoSluchSluhaSlunceSlupkaSlzaSmaragdSmetanaSmilstvoSmlouvaSmogSmradSmrkSmrtkaSmutekSmyslSnadSnahaSnobSobotaSochaSodovkaSokolSopkaSotvaSoubojSoucitSoudceSouhlasSouladSoumrakSoupravaSousedSoutokSouvisetSpalovnaSpasitelSpisSplavSpodekSpojenecSpoluSponzorSpornostSpoustaSprchaSpustitSrandaSrazSrdceSrnaSrnecSrovnatSrpenSrstSrubStaniceStarostaStatikaStavbaStehnoStezkaStodolaStolekStopaStornoStoupatStrachStresStrhnoutStromStrunaStudnaStupniceStvolStykSubjektSubtropySucharSudostSuknoSundatSunoutSurikataSurovinaSvahSvalstvoSvetrSvatbaSvazekSvisleSvitekSvobodaSvodidloSvorkaSvrabSykavkaSykotSynekSynovecSypatSypkostSyrovostSyselSytostTabletkaTabuleTahounTajemnoTajfunTajgaTajitTajnostTaktikaTamhleTamponTancovatTanecTankerTapetaTaveninaTazatelTechnikaTehdyTekutinaTelefonTemnotaTendenceTenistaTenorTeplotaTepnaTeprveTerapieTermoskaTextilTichoTiskopisTitulekTkadlecTkaninaTlapkaTleskatTlukotTlupaTmelToaletaTopinkaTopolTorzoTouhaToulecTradiceTraktorTrampTrasaTraverzaTrefitTrestTrezorTrhavinaTrhlinaTrochuTrojiceTroskaTroubaTrpceTrpitelTrpkostTrubecTruchlitTruhliceTrusTrvatTudyTuhnoutTuhostTundraTuristaTurnajTuzemskoTvarohTvorbaTvrdostTvrzTygrTykevUbohostUbozeUbratUbrousekUbrusUbytovnaUchoUctivostUdivitUhraditUjednatUjistitUjmoutUkazatelUklidnitUklonitUkotvitUkrojitUliceUlitaUlovitUmyvadloUnavitUniformaUniknoutUpadnoutUplatnitUplynoutUpoutatUpravitUranUrazitUsednoutUsilovatUsmrtitUsnadnitUsnoutUsouditUstlatUstrnoutUtahovatUtkatUtlumitUtonoutUtopenecUtrousitUvalitUvolnitUvozovkaUzdravitUzelUzeninaUzlinaUznatVagonValchaValounVanaVandalVanilkaVaranVarhanyVarovatVcelkuVchodVdovaVedroVegetaceVejceVelbloudVeletrhVelitelVelmocVelrybaVenkovVerandaVerzeVeselkaVeskrzeVesniceVespoduVestaVeterinaVeverkaVibraceVichrVideohraVidinaVidleVilaViniceVisetVitalitaVizeVizitkaVjezdVkladVkusVlajkaVlakVlasecVlevoVlhkostVlivVlnovkaVloupatVnucovatVnukVodaVodivostVodoznakVodstvoVojenskyVojnaVojskoVolantVolbaVolitVolnoVoskovkaVozidloVozovnaVpravoVrabecVracetVrahVrataVrbaVrcholekVrhatVrstvaVrtuleVsaditVstoupitVstupVtipVybavitVybratVychovatVydatVydraVyfotitVyhledatVyhnoutVyhoditVyhraditVyhubitVyjasnitVyjetVyjmoutVyklopitVykonatVylekatVymazatVymezitVymizetVymysletVynechatVynikatVynutitVypadatVyplatitVypravitVypustitVyrazitVyrovnatVyrvatVyslovitVysokoVystavitVysunoutVysypatVytasitVytesatVytratitVyvinoutVyvolatVyvrhelVyzdobitVyznatVzaduVzbuditVzchopitVzdorVzduchVzdychatVzestupVzhledemVzkazVzlykatVznikVzorekVzpouraVztahVztekXylofonZabratZabydletZachovatZadarmoZadusitZafoukatZahltitZahoditZahradaZahynoutZajatecZajetZajistitZaklepatZakoupitZalepitZamezitZamotatZamysletZanechatZanikatZaplatitZapojitZapsatZarazitZastavitZasunoutZatajitZatemnitZatknoutZaujmoutZavalitZaveletZavinitZavolatZavrtatZazvonitZbavitZbrusuZbudovatZbytekZdalekaZdarmaZdatnostZdivoZdobitZdrojZdvihZdymadloZeleninaZemanZeminaZeptatZezaduZezdolaZhatitZhltnoutZhlubokaZhotovitZhrubaZimaZimniceZjemnitZklamatZkoumatZkratkaZkumavkaZlatoZlehkaZlobaZlomZlostZlozvykZmapovatZmarZmatekZmijeZmizetZmocnitZmodratZmrzlinaZmutovatZnakZnalostZnamenatZnovuZobrazitZotavitZoubekZoufaleZploditZpomalitZpravaZprostitZprudkaZprvuZradaZranitZrcadloZrnitostZrnoZrovnaZrychlitZrzavostZtichaZtratitZubovinaZubrZvednoutZvenkuZveselaZvonZvratZvukovodZvyk";
  var wordlist = null;
  function loadWords(lang) {
    if (wordlist != null) {
      return;
    }
    wordlist = words.replace(/([A-Z])/g, " $1").toLowerCase().substring(1).split(" ");
    if (Wordlist.check(lang) !== "0x25f44555f4af25b51a711136e1c7d6e50ce9f8917d39d6b1f076b2bb4d2fac1a") {
      wordlist = null;
      throw new Error("BIP39 Wordlist for en (English) FAILED");
    }
  }
  var LangCz = class extends Wordlist {
    constructor() {
      super("cz");
    }
    getWord(index) {
      loadWords(this);
      return wordlist[index];
    }
    getWordIndex(word) {
      loadWords(this);
      return wordlist.indexOf(word);
    }
  };
  var langCz = new LangCz();
  Wordlist.register(langCz);

  // node_modules/@ethersproject/wordlists/lib.esm/lang-en.js
  "use strict";
  var words2 = "AbandonAbilityAbleAboutAboveAbsentAbsorbAbstractAbsurdAbuseAccessAccidentAccountAccuseAchieveAcidAcousticAcquireAcrossActActionActorActressActualAdaptAddAddictAddressAdjustAdmitAdultAdvanceAdviceAerobicAffairAffordAfraidAgainAgeAgentAgreeAheadAimAirAirportAisleAlarmAlbumAlcoholAlertAlienAllAlleyAllowAlmostAloneAlphaAlreadyAlsoAlterAlwaysAmateurAmazingAmongAmountAmusedAnalystAnchorAncientAngerAngleAngryAnimalAnkleAnnounceAnnualAnotherAnswerAntennaAntiqueAnxietyAnyApartApologyAppearAppleApproveAprilArchArcticAreaArenaArgueArmArmedArmorArmyAroundArrangeArrestArriveArrowArtArtefactArtistArtworkAskAspectAssaultAssetAssistAssumeAsthmaAthleteAtomAttackAttendAttitudeAttractAuctionAuditAugustAuntAuthorAutoAutumnAverageAvocadoAvoidAwakeAwareAwayAwesomeAwfulAwkwardAxisBabyBachelorBaconBadgeBagBalanceBalconyBallBambooBananaBannerBarBarelyBargainBarrelBaseBasicBasketBattleBeachBeanBeautyBecauseBecomeBeefBeforeBeginBehaveBehindBelieveBelowBeltBenchBenefitBestBetrayBetterBetweenBeyondBicycleBidBikeBindBiologyBirdBirthBitterBlackBladeBlameBlanketBlastBleakBlessBlindBloodBlossomBlouseBlueBlurBlushBoardBoatBodyBoilBombBoneBonusBookBoostBorderBoringBorrowBossBottomBounceBoxBoyBracketBrainBrandBrassBraveBreadBreezeBrickBridgeBriefBrightBringBriskBroccoliBrokenBronzeBroomBrotherBrownBrushBubbleBuddyBudgetBuffaloBuildBulbBulkBulletBundleBunkerBurdenBurgerBurstBusBusinessBusyButterBuyerBuzzCabbageCabinCableCactusCageCakeCallCalmCameraCampCanCanalCancelCandyCannonCanoeCanvasCanyonCapableCapitalCaptainCarCarbonCardCargoCarpetCarryCartCaseCashCasinoCastleCasualCatCatalogCatchCategoryCattleCaughtCauseCautionCaveCeilingCeleryCementCensusCenturyCerealCertainChairChalkChampionChangeChaosChapterChargeChaseChatCheapCheckCheeseChefCherryChestChickenChiefChildChimneyChoiceChooseChronicChuckleChunkChurnCigarCinnamonCircleCitizenCityCivilClaimClapClarifyClawClayCleanClerkCleverClickClientCliffClimbClinicClipClockClogCloseClothCloudClownClubClumpClusterClutchCoachCoastCoconutCodeCoffeeCoilCoinCollectColorColumnCombineComeComfortComicCommonCompanyConcertConductConfirmCongressConnectConsiderControlConvinceCookCoolCopperCopyCoralCoreCornCorrectCostCottonCouchCountryCoupleCourseCousinCoverCoyoteCrackCradleCraftCramCraneCrashCraterCrawlCrazyCreamCreditCreekCrewCricketCrimeCrispCriticCropCrossCrouchCrowdCrucialCruelCruiseCrumbleCrunchCrushCryCrystalCubeCultureCupCupboardCuriousCurrentCurtainCurveCushionCustomCuteCycleDadDamageDampDanceDangerDaringDashDaughterDawnDayDealDebateDebrisDecadeDecemberDecideDeclineDecorateDecreaseDeerDefenseDefineDefyDegreeDelayDeliverDemandDemiseDenialDentistDenyDepartDependDepositDepthDeputyDeriveDescribeDesertDesignDeskDespairDestroyDetailDetectDevelopDeviceDevoteDiagramDialDiamondDiaryDiceDieselDietDifferDigitalDignityDilemmaDinnerDinosaurDirectDirtDisagreeDiscoverDiseaseDishDismissDisorderDisplayDistanceDivertDivideDivorceDizzyDoctorDocumentDogDollDolphinDomainDonateDonkeyDonorDoorDoseDoubleDoveDraftDragonDramaDrasticDrawDreamDressDriftDrillDrinkDripDriveDropDrumDryDuckDumbDuneDuringDustDutchDutyDwarfDynamicEagerEagleEarlyEarnEarthEasilyEastEasyEchoEcologyEconomyEdgeEditEducateEffortEggEightEitherElbowElderElectricElegantElementElephantElevatorEliteElseEmbarkEmbodyEmbraceEmergeEmotionEmployEmpowerEmptyEnableEnactEndEndlessEndorseEnemyEnergyEnforceEngageEngineEnhanceEnjoyEnlistEnoughEnrichEnrollEnsureEnterEntireEntryEnvelopeEpisodeEqualEquipEraEraseErodeErosionErrorEruptEscapeEssayEssenceEstateEternalEthicsEvidenceEvilEvokeEvolveExactExampleExcessExchangeExciteExcludeExcuseExecuteExerciseExhaustExhibitExileExistExitExoticExpandExpectExpireExplainExposeExpressExtendExtraEyeEyebrowFabricFaceFacultyFadeFaintFaithFallFalseFameFamilyFamousFanFancyFantasyFarmFashionFatFatalFatherFatigueFaultFavoriteFeatureFebruaryFederalFeeFeedFeelFemaleFenceFestivalFetchFeverFewFiberFictionFieldFigureFileFilmFilterFinalFindFineFingerFinishFireFirmFirstFiscalFishFitFitnessFixFlagFlameFlashFlatFlavorFleeFlightFlipFloatFlockFloorFlowerFluidFlushFlyFoamFocusFogFoilFoldFollowFoodFootForceForestForgetForkFortuneForumForwardFossilFosterFoundFoxFragileFrameFrequentFreshFriendFringeFrogFrontFrostFrownFrozenFruitFuelFunFunnyFurnaceFuryFutureGadgetGainGalaxyGalleryGameGapGarageGarbageGardenGarlicGarmentGasGaspGateGatherGaugeGazeGeneralGeniusGenreGentleGenuineGestureGhostGiantGiftGiggleGingerGiraffeGirlGiveGladGlanceGlareGlassGlideGlimpseGlobeGloomGloryGloveGlowGlueGoatGoddessGoldGoodGooseGorillaGospelGossipGovernGownGrabGraceGrainGrantGrapeGrassGravityGreatGreenGridGriefGritGroceryGroupGrowGruntGuardGuessGuideGuiltGuitarGunGymHabitHairHalfHammerHamsterHandHappyHarborHardHarshHarvestHatHaveHawkHazardHeadHealthHeartHeavyHedgehogHeightHelloHelmetHelpHenHeroHiddenHighHillHintHipHireHistoryHobbyHockeyHoldHoleHolidayHollowHomeHoneyHoodHopeHornHorrorHorseHospitalHostHotelHourHoverHubHugeHumanHumbleHumorHundredHungryHuntHurdleHurryHurtHusbandHybridIceIconIdeaIdentifyIdleIgnoreIllIllegalIllnessImageImitateImmenseImmuneImpactImposeImproveImpulseInchIncludeIncomeIncreaseIndexIndicateIndoorIndustryInfantInflictInformInhaleInheritInitialInjectInjuryInmateInnerInnocentInputInquiryInsaneInsectInsideInspireInstallIntactInterestIntoInvestInviteInvolveIronIslandIsolateIssueItemIvoryJacketJaguarJarJazzJealousJeansJellyJewelJobJoinJokeJourneyJoyJudgeJuiceJumpJungleJuniorJunkJustKangarooKeenKeepKetchupKeyKickKidKidneyKindKingdomKissKitKitchenKiteKittenKiwiKneeKnifeKnockKnowLabLabelLaborLadderLadyLakeLampLanguageLaptopLargeLaterLatinLaughLaundryLavaLawLawnLawsuitLayerLazyLeaderLeafLearnLeaveLectureLeftLegLegalLegendLeisureLemonLendLengthLensLeopardLessonLetterLevelLiarLibertyLibraryLicenseLifeLiftLightLikeLimbLimitLinkLionLiquidListLittleLiveLizardLoadLoanLobsterLocalLockLogicLonelyLongLoopLotteryLoudLoungeLoveLoyalLuckyLuggageLumberLunarLunchLuxuryLyricsMachineMadMagicMagnetMaidMailMainMajorMakeMammalManManageMandateMangoMansionManualMapleMarbleMarchMarginMarineMarketMarriageMaskMassMasterMatchMaterialMathMatrixMatterMaximumMazeMeadowMeanMeasureMeatMechanicMedalMediaMelodyMeltMemberMemoryMentionMenuMercyMergeMeritMerryMeshMessageMetalMethodMiddleMidnightMilkMillionMimicMindMinimumMinorMinuteMiracleMirrorMiseryMissMistakeMixMixedMixtureMobileModelModifyMomMomentMonitorMonkeyMonsterMonthMoonMoralMoreMorningMosquitoMotherMotionMotorMountainMouseMoveMovieMuchMuffinMuleMultiplyMuscleMuseumMushroomMusicMustMutualMyselfMysteryMythNaiveNameNapkinNarrowNastyNationNatureNearNeckNeedNegativeNeglectNeitherNephewNerveNestNetNetworkNeutralNeverNewsNextNiceNightNobleNoiseNomineeNoodleNormalNorthNoseNotableNoteNothingNoticeNovelNowNuclearNumberNurseNutOakObeyObjectObligeObscureObserveObtainObviousOccurOceanOctoberOdorOffOfferOfficeOftenOilOkayOldOliveOlympicOmitOnceOneOnionOnlineOnlyOpenOperaOpinionOpposeOptionOrangeOrbitOrchardOrderOrdinaryOrganOrientOriginalOrphanOstrichOtherOutdoorOuterOutputOutsideOvalOvenOverOwnOwnerOxygenOysterOzonePactPaddlePagePairPalacePalmPandaPanelPanicPantherPaperParadeParentParkParrotPartyPassPatchPathPatientPatrolPatternPausePavePaymentPeacePeanutPearPeasantPelicanPenPenaltyPencilPeoplePepperPerfectPermitPersonPetPhonePhotoPhrasePhysicalPianoPicnicPicturePiecePigPigeonPillPilotPinkPioneerPipePistolPitchPizzaPlacePlanetPlasticPlatePlayPleasePledgePluckPlugPlungePoemPoetPointPolarPolePolicePondPonyPoolPopularPortionPositionPossiblePostPotatoPotteryPovertyPowderPowerPracticePraisePredictPreferPreparePresentPrettyPreventPricePridePrimaryPrintPriorityPrisonPrivatePrizeProblemProcessProduceProfitProgramProjectPromoteProofPropertyProsperProtectProudProvidePublicPuddingPullPulpPulsePumpkinPunchPupilPuppyPurchasePurityPurposePursePushPutPuzzlePyramidQualityQuantumQuarterQuestionQuickQuitQuizQuoteRabbitRaccoonRaceRackRadarRadioRailRainRaiseRallyRampRanchRandomRangeRapidRareRateRatherRavenRawRazorReadyRealReasonRebelRebuildRecallReceiveRecipeRecordRecycleReduceReflectReformRefuseRegionRegretRegularRejectRelaxReleaseReliefRelyRemainRememberRemindRemoveRenderRenewRentReopenRepairRepeatReplaceReportRequireRescueResembleResistResourceResponseResultRetireRetreatReturnReunionRevealReviewRewardRhythmRibRibbonRiceRichRideRidgeRifleRightRigidRingRiotRippleRiskRitualRivalRiverRoadRoastRobotRobustRocketRomanceRoofRookieRoomRoseRotateRoughRoundRouteRoyalRubberRudeRugRuleRunRunwayRuralSadSaddleSadnessSafeSailSaladSalmonSalonSaltSaluteSameSampleSandSatisfySatoshiSauceSausageSaveSayScaleScanScareScatterSceneSchemeSchoolScienceScissorsScorpionScoutScrapScreenScriptScrubSeaSearchSeasonSeatSecondSecretSectionSecuritySeedSeekSegmentSelectSellSeminarSeniorSenseSentenceSeriesServiceSessionSettleSetupSevenShadowShaftShallowShareShedShellSheriffShieldShiftShineShipShiverShockShoeShootShopShortShoulderShoveShrimpShrugShuffleShySiblingSickSideSiegeSightSignSilentSilkSillySilverSimilarSimpleSinceSingSirenSisterSituateSixSizeSkateSketchSkiSkillSkinSkirtSkullSlabSlamSleepSlenderSliceSlideSlightSlimSloganSlotSlowSlushSmallSmartSmileSmokeSmoothSnackSnakeSnapSniffSnowSoapSoccerSocialSockSodaSoftSolarSoldierSolidSolutionSolveSomeoneSongSoonSorrySortSoulSoundSoupSourceSouthSpaceSpareSpatialSpawnSpeakSpecialSpeedSpellSpendSphereSpiceSpiderSpikeSpinSpiritSplitSpoilSponsorSpoonSportSpotSpraySpreadSpringSpySquareSqueezeSquirrelStableStadiumStaffStageStairsStampStandStartStateStaySteakSteelStemStepStereoStickStillStingStockStomachStoneStoolStoryStoveStrategyStreetStrikeStrongStruggleStudentStuffStumbleStyleSubjectSubmitSubwaySuccessSuchSuddenSufferSugarSuggestSuitSummerSunSunnySunsetSuperSupplySupremeSureSurfaceSurgeSurpriseSurroundSurveySuspectSustainSwallowSwampSwapSwarmSwearSweetSwiftSwimSwingSwitchSwordSymbolSymptomSyrupSystemTableTackleTagTailTalentTalkTankTapeTargetTaskTasteTattooTaxiTeachTeamTellTenTenantTennisTentTermTestTextThankThatThemeThenTheoryThereTheyThingThisThoughtThreeThriveThrowThumbThunderTicketTideTigerTiltTimberTimeTinyTipTiredTissueTitleToastTobaccoTodayToddlerToeTogetherToiletTokenTomatoTomorrowToneTongueTonightToolToothTopTopicToppleTorchTornadoTortoiseTossTotalTouristTowardTowerTownToyTrackTradeTrafficTragicTrainTransferTrapTrashTravelTrayTreatTreeTrendTrialTribeTrickTriggerTrimTripTrophyTroubleTruckTrueTrulyTrumpetTrustTruthTryTubeTuitionTumbleTunaTunnelTurkeyTurnTurtleTwelveTwentyTwiceTwinTwistTwoTypeTypicalUglyUmbrellaUnableUnawareUncleUncoverUnderUndoUnfairUnfoldUnhappyUniformUniqueUnitUniverseUnknownUnlockUntilUnusualUnveilUpdateUpgradeUpholdUponUpperUpsetUrbanUrgeUsageUseUsedUsefulUselessUsualUtilityVacantVacuumVagueValidValleyValveVanVanishVaporVariousVastVaultVehicleVelvetVendorVentureVenueVerbVerifyVersionVeryVesselVeteranViableVibrantViciousVictoryVideoViewVillageVintageViolinVirtualVirusVisaVisitVisualVitalVividVocalVoiceVoidVolcanoVolumeVoteVoyageWageWagonWaitWalkWallWalnutWantWarfareWarmWarriorWashWaspWasteWaterWaveWayWealthWeaponWearWeaselWeatherWebWeddingWeekendWeirdWelcomeWestWetWhaleWhatWheatWheelWhenWhereWhipWhisperWideWidthWifeWildWillWinWindowWineWingWinkWinnerWinterWireWisdomWiseWishWitnessWolfWomanWonderWoodWoolWordWorkWorldWorryWorthWrapWreckWrestleWristWriteWrongYardYearYellowYouYoungYouthZebraZeroZoneZoo";
  var wordlist2 = null;
  function loadWords2(lang) {
    if (wordlist2 != null) {
      return;
    }
    wordlist2 = words2.replace(/([A-Z])/g, " $1").toLowerCase().substring(1).split(" ");
    if (Wordlist.check(lang) !== "0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60") {
      wordlist2 = null;
      throw new Error("BIP39 Wordlist for en (English) FAILED");
    }
  }
  var LangEn = class extends Wordlist {
    constructor() {
      super("en");
    }
    getWord(index) {
      loadWords2(this);
      return wordlist2[index];
    }
    getWordIndex(word) {
      loadWords2(this);
      return wordlist2.indexOf(word);
    }
  };
  var langEn = new LangEn();
  Wordlist.register(langEn);

  // node_modules/@ethersproject/wordlists/lib.esm/lang-es.js
  "use strict";
  var words3 = "A/bacoAbdomenAbejaAbiertoAbogadoAbonoAbortoAbrazoAbrirAbueloAbusoAcabarAcademiaAccesoAccio/nAceiteAcelgaAcentoAceptarA/cidoAclararAcne/AcogerAcosoActivoActoActrizActuarAcudirAcuerdoAcusarAdictoAdmitirAdoptarAdornoAduanaAdultoAe/reoAfectarAficio/nAfinarAfirmarA/gilAgitarAgoni/aAgostoAgotarAgregarAgrioAguaAgudoA/guilaAgujaAhogoAhorroAireAislarAjedrezAjenoAjusteAlacra/nAlambreAlarmaAlbaA/lbumAlcaldeAldeaAlegreAlejarAlertaAletaAlfilerAlgaAlgodo/nAliadoAlientoAlivioAlmaAlmejaAlmi/barAltarAltezaAltivoAltoAlturaAlumnoAlzarAmableAmanteAmapolaAmargoAmasarA/mbarA/mbitoAmenoAmigoAmistadAmorAmparoAmplioAnchoAncianoAnclaAndarAnde/nAnemiaA/nguloAnilloA/nimoAni/sAnotarAntenaAntiguoAntojoAnualAnularAnuncioA~adirA~ejoA~oApagarAparatoApetitoApioAplicarApodoAporteApoyoAprenderAprobarApuestaApuroAradoAra~aArarA/rbitroA/rbolArbustoArchivoArcoArderArdillaArduoA/reaA/ridoAriesArmoni/aArne/sAromaArpaArpo/nArregloArrozArrugaArteArtistaAsaAsadoAsaltoAscensoAsegurarAseoAsesorAsientoAsiloAsistirAsnoAsombroA/speroAstillaAstroAstutoAsumirAsuntoAtajoAtaqueAtarAtentoAteoA/ticoAtletaA/tomoAtraerAtrozAtu/nAudazAudioAugeAulaAumentoAusenteAutorAvalAvanceAvaroAveAvellanaAvenaAvestruzAvio/nAvisoAyerAyudaAyunoAzafra/nAzarAzoteAzu/carAzufreAzulBabaBaborBacheBahi/aBaileBajarBalanzaBalco/nBaldeBambu/BancoBandaBa~oBarbaBarcoBarnizBarroBa/sculaBasto/nBasuraBatallaBateri/aBatirBatutaBau/lBazarBebe/BebidaBelloBesarBesoBestiaBichoBienBingoBlancoBloqueBlusaBoaBobinaBoboBocaBocinaBodaBodegaBoinaBolaBoleroBolsaBombaBondadBonitoBonoBonsa/iBordeBorrarBosqueBoteBoti/nBo/vedaBozalBravoBrazoBrechaBreveBrilloBrincoBrisaBrocaBromaBronceBroteBrujaBruscoBrutoBuceoBucleBuenoBueyBufandaBufo/nBu/hoBuitreBultoBurbujaBurlaBurroBuscarButacaBuzo/nCaballoCabezaCabinaCabraCacaoCada/verCadenaCaerCafe/Cai/daCaima/nCajaCajo/nCalCalamarCalcioCaldoCalidadCalleCalmaCalorCalvoCamaCambioCamelloCaminoCampoCa/ncerCandilCanelaCanguroCanicaCantoCa~aCa~o/nCaobaCaosCapazCapita/nCapoteCaptarCapuchaCaraCarbo/nCa/rcelCaretaCargaCari~oCarneCarpetaCarroCartaCasaCascoCaseroCaspaCastorCatorceCatreCaudalCausaCazoCebollaCederCedroCeldaCe/lebreCelosoCe/lulaCementoCenizaCentroCercaCerdoCerezaCeroCerrarCertezaCe/spedCetroChacalChalecoChampu/ChanclaChapaCharlaChicoChisteChivoChoqueChozaChuletaChuparCiclo/nCiegoCieloCienCiertoCifraCigarroCimaCincoCineCintaCipre/sCircoCiruelaCisneCitaCiudadClamorClanClaroClaseClaveClienteClimaCli/nicaCobreCoccio/nCochinoCocinaCocoCo/digoCodoCofreCogerCoheteCoji/nCojoColaColchaColegioColgarColinaCollarColmoColumnaCombateComerComidaCo/modoCompraCondeConejoCongaConocerConsejoContarCopaCopiaCorazo/nCorbataCorchoCordo/nCoronaCorrerCoserCosmosCostaCra/neoCra/terCrearCrecerCrei/doCremaCri/aCrimenCriptaCrisisCromoCro/nicaCroquetaCrudoCruzCuadroCuartoCuatroCuboCubrirCucharaCuelloCuentoCuerdaCuestaCuevaCuidarCulebraCulpaCultoCumbreCumplirCunaCunetaCuotaCupo/nCu/pulaCurarCuriosoCursoCurvaCutisDamaDanzaDarDardoDa/tilDeberDe/bilDe/cadaDecirDedoDefensaDefinirDejarDelfi/nDelgadoDelitoDemoraDensoDentalDeporteDerechoDerrotaDesayunoDeseoDesfileDesnudoDestinoDesvi/oDetalleDetenerDeudaDi/aDiabloDiademaDiamanteDianaDiarioDibujoDictarDienteDietaDiezDifi/cilDignoDilemaDiluirDineroDirectoDirigirDiscoDise~oDisfrazDivaDivinoDobleDoceDolorDomingoDonDonarDoradoDormirDorsoDosDosisDrago/nDrogaDuchaDudaDueloDue~oDulceDu/oDuqueDurarDurezaDuroE/banoEbrioEcharEcoEcuadorEdadEdicio/nEdificioEditorEducarEfectoEficazEjeEjemploElefanteElegirElementoElevarElipseE/liteElixirElogioEludirEmbudoEmitirEmocio/nEmpateEmpe~oEmpleoEmpresaEnanoEncargoEnchufeEnci/aEnemigoEneroEnfadoEnfermoEnga~oEnigmaEnlaceEnormeEnredoEnsayoEnse~arEnteroEntrarEnvaseEnvi/oE/pocaEquipoErizoEscalaEscenaEscolarEscribirEscudoEsenciaEsferaEsfuerzoEspadaEspejoEspi/aEsposaEspumaEsqui/EstarEsteEstiloEstufaEtapaEternoE/ticaEtniaEvadirEvaluarEventoEvitarExactoExamenExcesoExcusaExentoExigirExilioExistirE/xitoExpertoExplicarExponerExtremoFa/bricaFa/bulaFachadaFa/cilFactorFaenaFajaFaldaFalloFalsoFaltarFamaFamiliaFamosoFarao/nFarmaciaFarolFarsaFaseFatigaFaunaFavorFaxFebreroFechaFelizFeoFeriaFerozFe/rtilFervorFesti/nFiableFianzaFiarFibraFiccio/nFichaFideoFiebreFielFieraFiestaFiguraFijarFijoFilaFileteFilialFiltroFinFincaFingirFinitoFirmaFlacoFlautaFlechaFlorFlotaFluirFlujoFlu/orFobiaFocaFogataFogo/nFolioFolletoFondoFormaForroFortunaForzarFosaFotoFracasoFra/gilFranjaFraseFraudeFrei/rFrenoFresaFri/oFritoFrutaFuegoFuenteFuerzaFugaFumarFuncio/nFundaFurgo/nFuriaFusilFu/tbolFuturoGacelaGafasGaitaGajoGalaGaleri/aGalloGambaGanarGanchoGangaGansoGarajeGarzaGasolinaGastarGatoGavila/nGemeloGemirGenGe/neroGenioGenteGeranioGerenteGermenGestoGiganteGimnasioGirarGiroGlaciarGloboGloriaGolGolfoGolosoGolpeGomaGordoGorilaGorraGotaGoteoGozarGradaGra/ficoGranoGrasaGratisGraveGrietaGrilloGripeGrisGritoGrosorGru/aGruesoGrumoGrupoGuanteGuapoGuardiaGuerraGui/aGui~oGuionGuisoGuitarraGusanoGustarHaberHa/bilHablarHacerHachaHadaHallarHamacaHarinaHazHaza~aHebillaHebraHechoHeladoHelioHembraHerirHermanoHe/roeHervirHieloHierroHi/gadoHigieneHijoHimnoHistoriaHocicoHogarHogueraHojaHombreHongoHonorHonraHoraHormigaHornoHostilHoyoHuecoHuelgaHuertaHuesoHuevoHuidaHuirHumanoHu/medoHumildeHumoHundirHuraca/nHurtoIconoIdealIdiomaI/doloIglesiaIglu/IgualIlegalIlusio/nImagenIma/nImitarImparImperioImponerImpulsoIncapazI/ndiceInerteInfielInformeIngenioInicioInmensoInmuneInnatoInsectoInstanteIntere/sI/ntimoIntuirInu/tilInviernoIraIrisIroni/aIslaIsloteJabali/Jabo/nJamo/nJarabeJardi/nJarraJaulaJazmi/nJefeJeringaJineteJornadaJorobaJovenJoyaJuergaJuevesJuezJugadorJugoJugueteJuicioJuncoJunglaJunioJuntarJu/piterJurarJustoJuvenilJuzgarKiloKoalaLabioLacioLacraLadoLadro/nLagartoLa/grimaLagunaLaicoLamerLa/minaLa/mparaLanaLanchaLangostaLanzaLa/pizLargoLarvaLa/stimaLataLa/texLatirLaurelLavarLazoLealLeccio/nLecheLectorLeerLegio/nLegumbreLejanoLenguaLentoLe~aLeo/nLeopardoLesio/nLetalLetraLeveLeyendaLibertadLibroLicorLi/derLidiarLienzoLigaLigeroLimaLi/miteLimo/nLimpioLinceLindoLi/neaLingoteLinoLinternaLi/quidoLisoListaLiteraLitioLitroLlagaLlamaLlantoLlaveLlegarLlenarLlevarLlorarLloverLluviaLoboLocio/nLocoLocuraLo/gicaLogroLombrizLomoLonjaLoteLuchaLucirLugarLujoLunaLunesLupaLustroLutoLuzMacetaMachoMaderaMadreMaduroMaestroMafiaMagiaMagoMai/zMaldadMaletaMallaMaloMama/MamboMamutMancoMandoManejarMangaManiqui/ManjarManoMansoMantaMa~anaMapaMa/quinaMarMarcoMareaMarfilMargenMaridoMa/rmolMarro/nMartesMarzoMasaMa/scaraMasivoMatarMateriaMatizMatrizMa/ximoMayorMazorcaMechaMedallaMedioMe/dulaMejillaMejorMelenaMelo/nMemoriaMenorMensajeMenteMenu/MercadoMerengueMe/ritoMesMeso/nMetaMeterMe/todoMetroMezclaMiedoMielMiembroMigaMilMilagroMilitarMillo/nMimoMinaMineroMi/nimoMinutoMiopeMirarMisaMiseriaMisilMismoMitadMitoMochilaMocio/nModaModeloMohoMojarMoldeMolerMolinoMomentoMomiaMonarcaMonedaMonjaMontoMo~oMoradaMorderMorenoMorirMorroMorsaMortalMoscaMostrarMotivoMoverMo/vilMozoMuchoMudarMuebleMuelaMuerteMuestraMugreMujerMulaMuletaMultaMundoMu~ecaMuralMuroMu/sculoMuseoMusgoMu/sicaMusloNa/carNacio/nNadarNaipeNaranjaNarizNarrarNasalNatalNativoNaturalNa/useaNavalNaveNavidadNecioNe/ctarNegarNegocioNegroNeo/nNervioNetoNeutroNevarNeveraNichoNidoNieblaNietoNi~ezNi~oNi/tidoNivelNoblezaNocheNo/minaNoriaNormaNorteNotaNoticiaNovatoNovelaNovioNubeNucaNu/cleoNudilloNudoNueraNueveNuezNuloNu/meroNutriaOasisObesoObispoObjetoObraObreroObservarObtenerObvioOcaOcasoOce/anoOchentaOchoOcioOcreOctavoOctubreOcultoOcuparOcurrirOdiarOdioOdiseaOesteOfensaOfertaOficioOfrecerOgroOi/doOi/rOjoOlaOleadaOlfatoOlivoOllaOlmoOlorOlvidoOmbligoOndaOnzaOpacoOpcio/nO/peraOpinarOponerOptarO/pticaOpuestoOracio/nOradorOralO/rbitaOrcaOrdenOrejaO/rganoOrgi/aOrgulloOrienteOrigenOrillaOroOrquestaOrugaOsadi/aOscuroOseznoOsoOstraOto~oOtroOvejaO/vuloO/xidoOxi/genoOyenteOzonoPactoPadrePaellaPa/ginaPagoPai/sPa/jaroPalabraPalcoPaletaPa/lidoPalmaPalomaPalparPanPanalPa/nicoPanteraPa~ueloPapa/PapelPapillaPaquetePararParcelaParedParirParoPa/rpadoParquePa/rrafoPartePasarPaseoPasio/nPasoPastaPataPatioPatriaPausaPautaPavoPayasoPeato/nPecadoPeceraPechoPedalPedirPegarPeinePelarPelda~oPeleaPeligroPellejoPeloPelucaPenaPensarPe~o/nPeo/nPeorPepinoPeque~oPeraPerchaPerderPerezaPerfilPericoPerlaPermisoPerroPersonaPesaPescaPe/simoPesta~aPe/taloPetro/leoPezPezu~aPicarPicho/nPiePiedraPiernaPiezaPijamaPilarPilotoPimientaPinoPintorPinzaPi~aPiojoPipaPirataPisarPiscinaPisoPistaPito/nPizcaPlacaPlanPlataPlayaPlazaPleitoPlenoPlomoPlumaPluralPobrePocoPoderPodioPoemaPoesi/aPoetaPolenPolici/aPolloPolvoPomadaPomeloPomoPompaPonerPorcio/nPortalPosadaPoseerPosiblePostePotenciaPotroPozoPradoPrecozPreguntaPremioPrensaPresoPrevioPrimoPri/ncipePrisio/nPrivarProaProbarProcesoProductoProezaProfesorProgramaProlePromesaProntoPropioPro/ximoPruebaPu/blicoPucheroPudorPuebloPuertaPuestoPulgaPulirPulmo/nPulpoPulsoPumaPuntoPu~alPu~oPupaPupilaPure/QuedarQuejaQuemarQuererQuesoQuietoQui/micaQuinceQuitarRa/banoRabiaRaboRacio/nRadicalRai/zRamaRampaRanchoRangoRapazRa/pidoRaptoRasgoRaspaRatoRayoRazaRazo/nReaccio/nRealidadReba~oReboteRecaerRecetaRechazoRecogerRecreoRectoRecursoRedRedondoReducirReflejoReformaRefra/nRefugioRegaloRegirReglaRegresoRehe/nReinoRei/rRejaRelatoRelevoRelieveRellenoRelojRemarRemedioRemoRencorRendirRentaRepartoRepetirReposoReptilResRescateResinaRespetoRestoResumenRetiroRetornoRetratoReunirReve/sRevistaReyRezarRicoRiegoRiendaRiesgoRifaRi/gidoRigorRinco/nRi~o/nRi/oRiquezaRisaRitmoRitoRizoRobleRoceRociarRodarRodeoRodillaRoerRojizoRojoRomeroRomperRonRoncoRondaRopaRoperoRosaRoscaRostroRotarRubi/RuborRudoRuedaRugirRuidoRuinaRuletaRuloRumboRumorRupturaRutaRutinaSa/badoSaberSabioSableSacarSagazSagradoSalaSaldoSaleroSalirSalmo/nSalo/nSalsaSaltoSaludSalvarSambaSancio/nSandi/aSanearSangreSanidadSanoSantoSapoSaqueSardinaSarte/nSastreSata/nSaunaSaxofo/nSeccio/nSecoSecretoSectaSedSeguirSeisSelloSelvaSemanaSemillaSendaSensorSe~alSe~orSepararSepiaSequi/aSerSerieSermo/nServirSesentaSesio/nSetaSetentaSeveroSexoSextoSidraSiestaSieteSigloSignoSi/labaSilbarSilencioSillaSi/mboloSimioSirenaSistemaSitioSituarSobreSocioSodioSolSolapaSoldadoSoledadSo/lidoSoltarSolucio/nSombraSondeoSonidoSonoroSonrisaSopaSoplarSoporteSordoSorpresaSorteoSoste/nSo/tanoSuaveSubirSucesoSudorSuegraSueloSue~oSuerteSufrirSujetoSulta/nSumarSuperarSuplirSuponerSupremoSurSurcoSure~oSurgirSustoSutilTabacoTabiqueTablaTabu/TacoTactoTajoTalarTalcoTalentoTallaTalo/nTama~oTamborTangoTanqueTapaTapeteTapiaTapo/nTaquillaTardeTareaTarifaTarjetaTarotTarroTartaTatuajeTauroTazaTazo/nTeatroTechoTeclaTe/cnicaTejadoTejerTejidoTelaTele/fonoTemaTemorTemploTenazTenderTenerTenisTensoTeori/aTerapiaTercoTe/rminoTernuraTerrorTesisTesoroTestigoTeteraTextoTezTibioTiburo/nTiempoTiendaTierraTiesoTigreTijeraTildeTimbreTi/midoTimoTintaTi/oTi/picoTipoTiraTiro/nTita/nTi/tereTi/tuloTizaToallaTobilloTocarTocinoTodoTogaToldoTomarTonoTontoToparTopeToqueTo/raxToreroTormentaTorneoToroTorpedoTorreTorsoTortugaTosToscoToserTo/xicoTrabajoTractorTraerTra/ficoTragoTrajeTramoTranceTratoTraumaTrazarTre/bolTreguaTreintaTrenTreparTresTribuTrigoTripaTristeTriunfoTrofeoTrompaTroncoTropaTroteTrozoTrucoTruenoTrufaTuberi/aTuboTuertoTumbaTumorTu/nelTu/nicaTurbinaTurismoTurnoTutorUbicarU/lceraUmbralUnidadUnirUniversoUnoUntarU~aUrbanoUrbeUrgenteUrnaUsarUsuarioU/tilUtopi/aUvaVacaVaci/oVacunaVagarVagoVainaVajillaValeVa/lidoValleValorVa/lvulaVampiroVaraVariarVaro/nVasoVecinoVectorVehi/culoVeinteVejezVelaVeleroVelozVenaVencerVendaVenenoVengarVenirVentaVenusVerVeranoVerboVerdeVeredaVerjaVersoVerterVi/aViajeVibrarVicioVi/ctimaVidaVi/deoVidrioViejoViernesVigorVilVillaVinagreVinoVi~edoVioli/nViralVirgoVirtudVisorVi/speraVistaVitaminaViudoVivazViveroVivirVivoVolca/nVolumenVolverVorazVotarVotoVozVueloVulgarYacerYateYeguaYemaYernoYesoYodoYogaYogurZafiroZanjaZapatoZarzaZonaZorroZumoZurdo";
  var lookup = {};
  var wordlist3 = null;
  function dropDiacritic(word) {
    logger21.checkNormalize();
    return toUtf8String(Array.prototype.filter.call(toUtf8Bytes(word.normalize("NFD").toLowerCase()), (c3) => {
      return c3 >= 65 && c3 <= 90 || c3 >= 97 && c3 <= 123;
    }));
  }
  function expand(word) {
    const output = [];
    Array.prototype.forEach.call(toUtf8Bytes(word), (c3) => {
      if (c3 === 47) {
        output.push(204);
        output.push(129);
      } else if (c3 === 126) {
        output.push(110);
        output.push(204);
        output.push(131);
      } else {
        output.push(c3);
      }
    });
    return toUtf8String(output);
  }
  function loadWords3(lang) {
    if (wordlist3 != null) {
      return;
    }
    wordlist3 = words3.replace(/([A-Z])/g, " $1").toLowerCase().substring(1).split(" ").map((w4) => expand(w4));
    wordlist3.forEach((word, index) => {
      lookup[dropDiacritic(word)] = index;
    });
    if (Wordlist.check(lang) !== "0xf74fb7092aeacdfbf8959557de22098da512207fb9f109cb526994938cf40300") {
      wordlist3 = null;
      throw new Error("BIP39 Wordlist for es (Spanish) FAILED");
    }
  }
  var LangEs = class extends Wordlist {
    constructor() {
      super("es");
    }
    getWord(index) {
      loadWords3(this);
      return wordlist3[index];
    }
    getWordIndex(word) {
      loadWords3(this);
      return lookup[dropDiacritic(word)];
    }
  };
  var langEs = new LangEs();
  Wordlist.register(langEs);

  // node_modules/@ethersproject/wordlists/lib.esm/lang-fr.js
  "use strict";
  var words4 = "AbaisserAbandonAbdiquerAbeilleAbolirAborderAboutirAboyerAbrasifAbreuverAbriterAbrogerAbruptAbsenceAbsoluAbsurdeAbusifAbyssalAcade/mieAcajouAcarienAccablerAccepterAcclamerAccoladeAccrocheAccuserAcerbeAchatAcheterAcidulerAcierAcompteAcque/rirAcronymeActeurActifActuelAdepteAde/quatAdhe/sifAdjectifAdjugerAdmettreAdmirerAdopterAdorerAdoucirAdresseAdroitAdulteAdverbeAe/rerAe/ronefAffaireAffecterAfficheAffreuxAffublerAgacerAgencerAgileAgiterAgraferAgre/ableAgrumeAiderAiguilleAilierAimableAisanceAjouterAjusterAlarmerAlchimieAlerteAlge-breAlgueAlie/nerAlimentAlle/gerAlliageAllouerAllumerAlourdirAlpagaAltesseAlve/oleAmateurAmbiguAmbreAme/nagerAmertumeAmidonAmiralAmorcerAmourAmovibleAmphibieAmpleurAmusantAnalyseAnaphoreAnarchieAnatomieAncienAne/antirAngleAngoisseAnguleuxAnimalAnnexerAnnonceAnnuelAnodinAnomalieAnonymeAnormalAntenneAntidoteAnxieuxApaiserApe/ritifAplanirApologieAppareilAppelerApporterAppuyerAquariumAqueducArbitreArbusteArdeurArdoiseArgentArlequinArmatureArmementArmoireArmureArpenterArracherArriverArroserArsenicArte/rielArticleAspectAsphalteAspirerAssautAsservirAssietteAssocierAssurerAsticotAstreAstuceAtelierAtomeAtriumAtroceAttaqueAttentifAttirerAttraperAubaineAubergeAudaceAudibleAugurerAuroreAutomneAutrucheAvalerAvancerAvariceAvenirAverseAveugleAviateurAvideAvionAviserAvoineAvouerAvrilAxialAxiomeBadgeBafouerBagageBaguetteBaignadeBalancerBalconBaleineBalisageBambinBancaireBandageBanlieueBannie-reBanquierBarbierBarilBaronBarqueBarrageBassinBastionBatailleBateauBatterieBaudrierBavarderBeletteBe/lierBeloteBe/ne/ficeBerceauBergerBerlineBermudaBesaceBesogneBe/tailBeurreBiberonBicycleBiduleBijouBilanBilingueBillardBinaireBiologieBiopsieBiotypeBiscuitBisonBistouriBitumeBizarreBlafardBlagueBlanchirBlessantBlinderBlondBloquerBlousonBobardBobineBoireBoiserBolideBonbonBondirBonheurBonifierBonusBordureBorneBotteBoucleBoueuxBougieBoulonBouquinBourseBoussoleBoutiqueBoxeurBrancheBrasierBraveBrebisBre-cheBreuvageBricolerBrigadeBrillantBriocheBriqueBrochureBroderBronzerBrousseBroyeurBrumeBrusqueBrutalBruyantBuffleBuissonBulletinBureauBurinBustierButinerButoirBuvableBuvetteCabanonCabineCachetteCadeauCadreCafe/ineCaillouCaissonCalculerCalepinCalibreCalmerCalomnieCalvaireCamaradeCame/raCamionCampagneCanalCanetonCanonCantineCanularCapableCaporalCapriceCapsuleCapterCapucheCarabineCarboneCaresserCaribouCarnageCarotteCarreauCartonCascadeCasierCasqueCassureCauserCautionCavalierCaverneCaviarCe/dilleCeintureCe/lesteCelluleCendrierCensurerCentralCercleCe/re/bralCeriseCernerCerveauCesserChagrinChaiseChaleurChambreChanceChapitreCharbonChasseurChatonChaussonChavirerChemiseChenilleChe/quierChercherChevalChienChiffreChignonChime-reChiotChlorureChocolatChoisirChoseChouetteChromeChuteCigareCigogneCimenterCine/maCintrerCirculerCirerCirqueCiterneCitoyenCitronCivilClaironClameurClaquerClasseClavierClientClignerClimatClivageClocheClonageCloporteCobaltCobraCocasseCocotierCoderCodifierCoffreCognerCohe/sionCoifferCoincerCole-reColibriCollineColmaterColonelCombatCome/dieCommandeCompactConcertConduireConfierCongelerConnoterConsonneContactConvexeCopainCopieCorailCorbeauCordageCornicheCorpusCorrectCorte-geCosmiqueCostumeCotonCoudeCoupureCourageCouteauCouvrirCoyoteCrabeCrainteCravateCrayonCre/atureCre/diterCre/meuxCreuserCrevetteCriblerCrierCristalCrite-reCroireCroquerCrotaleCrucialCruelCrypterCubiqueCueillirCuille-reCuisineCuivreCulminerCultiverCumulerCupideCuratifCurseurCyanureCycleCylindreCyniqueDaignerDamierDangerDanseurDauphinDe/battreDe/biterDe/borderDe/briderDe/butantDe/calerDe/cembreDe/chirerDe/ciderDe/clarerDe/corerDe/crireDe/cuplerDe/daleDe/ductifDe/esseDe/fensifDe/filerDe/frayerDe/gagerDe/givrerDe/glutirDe/graferDe/jeunerDe/liceDe/logerDemanderDemeurerDe/molirDe/nicherDe/nouerDentelleDe/nuderDe/partDe/penserDe/phaserDe/placerDe/poserDe/rangerDe/roberDe/sastreDescenteDe/sertDe/signerDe/sobe/irDessinerDestrierDe/tacherDe/testerDe/tourerDe/tresseDevancerDevenirDevinerDevoirDiableDialogueDiamantDicterDiffe/rerDige/rerDigitalDigneDiluerDimancheDiminuerDioxydeDirectifDirigerDiscuterDisposerDissiperDistanceDivertirDiviserDocileDocteurDogmeDoigtDomaineDomicileDompterDonateurDonjonDonnerDopamineDortoirDorureDosageDoseurDossierDotationDouanierDoubleDouceurDouterDoyenDragonDraperDresserDribblerDroitureDuperieDuplexeDurableDurcirDynastieE/blouirE/carterE/charpeE/chelleE/clairerE/clipseE/cloreE/cluseE/coleE/conomieE/corceE/couterE/craserE/cre/merE/crivainE/crouE/cumeE/cureuilE/difierE/duquerEffacerEffectifEffigieEffortEffrayerEffusionE/galiserE/garerE/jecterE/laborerE/largirE/lectronE/le/gantE/le/phantE/le-veE/ligibleE/litismeE/logeE/luciderE/luderEmballerEmbellirEmbryonE/meraudeE/missionEmmenerE/motionE/mouvoirEmpereurEmployerEmporterEmpriseE/mulsionEncadrerEnche-reEnclaveEncocheEndiguerEndosserEndroitEnduireE/nergieEnfanceEnfermerEnfouirEngagerEnginEngloberE/nigmeEnjamberEnjeuEnleverEnnemiEnnuyeuxEnrichirEnrobageEnseigneEntasserEntendreEntierEntourerEntraverE/nume/rerEnvahirEnviableEnvoyerEnzymeE/olienE/paissirE/pargneE/patantE/pauleE/picerieE/pide/mieE/pierE/pilogueE/pineE/pisodeE/pitapheE/poqueE/preuveE/prouverE/puisantE/querreE/quipeE/rigerE/rosionErreurE/ruptionEscalierEspadonEspe-ceEspie-gleEspoirEspritEsquiverEssayerEssenceEssieuEssorerEstimeEstomacEstradeE/tage-reE/talerE/tancheE/tatiqueE/teindreE/tendoirE/ternelE/thanolE/thiqueEthnieE/tirerE/tofferE/toileE/tonnantE/tourdirE/trangeE/troitE/tudeEuphorieE/valuerE/vasionE/ventailE/videnceE/viterE/volutifE/voquerExactExage/rerExaucerExcellerExcitantExclusifExcuseExe/cuterExempleExercerExhalerExhorterExigenceExilerExisterExotiqueExpe/dierExplorerExposerExprimerExquisExtensifExtraireExulterFableFabuleuxFacetteFacileFactureFaiblirFalaiseFameuxFamilleFarceurFarfeluFarineFaroucheFascinerFatalFatigueFauconFautifFaveurFavoriFe/brileFe/conderFe/de/rerFe/linFemmeFe/murFendoirFe/odalFermerFe/roceFerveurFestivalFeuilleFeutreFe/vrierFiascoFicelerFictifFide-leFigureFilatureFiletageFilie-reFilleulFilmerFilouFiltrerFinancerFinirFioleFirmeFissureFixerFlairerFlammeFlasqueFlatteurFle/auFle-cheFleurFlexionFloconFloreFluctuerFluideFluvialFolieFonderieFongibleFontaineForcerForgeronFormulerFortuneFossileFoudreFouge-reFouillerFoulureFourmiFragileFraiseFranchirFrapperFrayeurFre/gateFreinerFrelonFre/mirFre/ne/sieFre-reFriableFrictionFrissonFrivoleFroidFromageFrontalFrotterFruitFugitifFuiteFureurFurieuxFurtifFusionFuturGagnerGalaxieGalerieGambaderGarantirGardienGarnirGarrigueGazelleGazonGe/antGe/latineGe/luleGendarmeGe/ne/ralGe/nieGenouGentilGe/ologieGe/ome-treGe/raniumGermeGestuelGeyserGibierGiclerGirafeGivreGlaceGlaiveGlisserGlobeGloireGlorieuxGolfeurGommeGonflerGorgeGorilleGoudronGouffreGoulotGoupilleGourmandGoutteGraduelGraffitiGraineGrandGrappinGratuitGravirGrenatGriffureGrillerGrimperGrognerGronderGrotteGroupeGrugerGrutierGruye-reGue/pardGuerrierGuideGuimauveGuitareGustatifGymnasteGyrostatHabitudeHachoirHalteHameauHangarHannetonHaricotHarmonieHarponHasardHe/liumHe/matomeHerbeHe/rissonHermineHe/ronHe/siterHeureuxHibernerHibouHilarantHistoireHiverHomardHommageHomoge-neHonneurHonorerHonteuxHordeHorizonHorlogeHormoneHorribleHouleuxHousseHublotHuileuxHumainHumbleHumideHumourHurlerHydromelHygie-neHymneHypnoseIdylleIgnorerIguaneIlliciteIllusionImageImbiberImiterImmenseImmobileImmuableImpactImpe/rialImplorerImposerImprimerImputerIncarnerIncendieIncidentInclinerIncoloreIndexerIndiceInductifIne/ditIneptieInexactInfiniInfligerInformerInfusionInge/rerInhalerInhiberInjecterInjureInnocentInoculerInonderInscrireInsecteInsigneInsoliteInspirerInstinctInsulterIntactIntenseIntimeIntrigueIntuitifInutileInvasionInventerInviterInvoquerIroniqueIrradierIrre/elIrriterIsolerIvoireIvresseJaguarJaillirJambeJanvierJardinJaugerJauneJavelotJetableJetonJeudiJeunesseJoindreJoncherJonglerJoueurJouissifJournalJovialJoyauJoyeuxJubilerJugementJuniorJuponJuristeJusticeJuteuxJuve/nileKayakKimonoKiosqueLabelLabialLabourerLace/rerLactoseLaguneLaineLaisserLaitierLambeauLamelleLampeLanceurLangageLanterneLapinLargeurLarmeLaurierLavaboLavoirLectureLe/galLe/gerLe/gumeLessiveLettreLevierLexiqueLe/zardLiasseLibe/rerLibreLicenceLicorneLie-geLie-vreLigatureLigoterLigueLimerLimiteLimonadeLimpideLine/aireLingotLionceauLiquideLisie-reListerLithiumLitigeLittoralLivreurLogiqueLointainLoisirLombricLoterieLouerLourdLoutreLouveLoyalLubieLucideLucratifLueurLugubreLuisantLumie-reLunaireLundiLuronLutterLuxueuxMachineMagasinMagentaMagiqueMaigreMaillonMaintienMairieMaisonMajorerMalaxerMale/ficeMalheurMaliceMalletteMammouthMandaterManiableManquantManteauManuelMarathonMarbreMarchandMardiMaritimeMarqueurMarronMartelerMascotteMassifMate/rielMatie-reMatraqueMaudireMaussadeMauveMaximalMe/chantMe/connuMe/dailleMe/decinMe/diterMe/duseMeilleurMe/langeMe/lodieMembreMe/moireMenacerMenerMenhirMensongeMentorMercrediMe/riteMerleMessagerMesureMe/talMe/te/oreMe/thodeMe/tierMeubleMiaulerMicrobeMietteMignonMigrerMilieuMillionMimiqueMinceMine/ralMinimalMinorerMinuteMiracleMiroiterMissileMixteMobileModerneMoelleuxMondialMoniteurMonnaieMonotoneMonstreMontagneMonumentMoqueurMorceauMorsureMortierMoteurMotifMoucheMoufleMoulinMoussonMoutonMouvantMultipleMunitionMurailleMure-neMurmureMuscleMuse/umMusicienMutationMuterMutuelMyriadeMyrtilleMyste-reMythiqueNageurNappeNarquoisNarrerNatationNationNatureNaufrageNautiqueNavireNe/buleuxNectarNe/fasteNe/gationNe/gligerNe/gocierNeigeNerveuxNettoyerNeuroneNeutronNeveuNicheNickelNitrateNiveauNobleNocifNocturneNoirceurNoisetteNomadeNombreuxNommerNormatifNotableNotifierNotoireNourrirNouveauNovateurNovembreNoviceNuageNuancerNuireNuisibleNume/roNuptialNuqueNutritifObe/irObjectifObligerObscurObserverObstacleObtenirObturerOccasionOccuperOce/anOctobreOctroyerOctuplerOculaireOdeurOdorantOffenserOfficierOffrirOgiveOiseauOisillonOlfactifOlivierOmbrageOmettreOnctueuxOndulerOne/reuxOniriqueOpaleOpaqueOpe/rerOpinionOpportunOpprimerOpterOptiqueOrageuxOrangeOrbiteOrdonnerOreilleOrganeOrgueilOrificeOrnementOrqueOrtieOscillerOsmoseOssatureOtarieOuraganOursonOutilOutragerOuvrageOvationOxydeOxyge-neOzonePaisiblePalacePalmare-sPalourdePalperPanachePandaPangolinPaniquerPanneauPanoramaPantalonPapayePapierPapoterPapyrusParadoxeParcelleParesseParfumerParlerParoleParrainParsemerPartagerParureParvenirPassionPaste-quePaternelPatiencePatronPavillonPavoiserPayerPaysagePeignePeintrePelagePe/licanPellePelousePeluchePendulePe/ne/trerPe/niblePensifPe/nuriePe/pitePe/plumPerdrixPerforerPe/riodePermuterPerplexePersilPertePeserPe/talePetitPe/trirPeuplePharaonPhobiePhoquePhotonPhrasePhysiquePianoPicturalPie-cePierrePieuvrePilotePinceauPipettePiquerPiroguePiscinePistonPivoterPixelPizzaPlacardPlafondPlaisirPlanerPlaquePlastronPlateauPleurerPlexusPliagePlombPlongerPluiePlumagePochettePoe/siePoe-tePointePoirierPoissonPoivrePolairePolicierPollenPolygonePommadePompierPonctuelPonde/rerPoneyPortiquePositionPosse/derPosturePotagerPoteauPotionPoucePoulainPoumonPourprePoussinPouvoirPrairiePratiquePre/cieuxPre/direPre/fixePre/ludePre/nomPre/sencePre/textePre/voirPrimitifPrincePrisonPriverProble-meProce/derProdigeProfondProgre-sProieProjeterProloguePromenerPropreProspe-reProte/gerProuesseProverbePrudencePruneauPsychosePublicPuceronPuiserPulpePulsarPunaisePunitifPupitrePurifierPuzzlePyramideQuasarQuerelleQuestionQuie/tudeQuitterQuotientRacineRaconterRadieuxRagondinRaideurRaisinRalentirRallongeRamasserRapideRasageRatisserRavagerRavinRayonnerRe/actifRe/agirRe/aliserRe/animerRecevoirRe/citerRe/clamerRe/colterRecruterReculerRecyclerRe/digerRedouterRefaireRe/flexeRe/formerRefrainRefugeRe/galienRe/gionRe/glageRe/gulierRe/ite/rerRejeterRejouerRelatifReleverReliefRemarqueReme-deRemiseRemonterRemplirRemuerRenardRenfortReniflerRenoncerRentrerRenvoiReplierReporterRepriseReptileRequinRe/serveRe/sineuxRe/soudreRespectResterRe/sultatRe/tablirRetenirRe/ticuleRetomberRetracerRe/unionRe/ussirRevancheRevivreRe/volteRe/vulsifRichesseRideauRieurRigideRigolerRincerRiposterRisibleRisqueRituelRivalRivie-reRocheuxRomanceRompreRonceRondinRoseauRosierRotatifRotorRotuleRougeRouilleRouleauRoutineRoyaumeRubanRubisRucheRuelleRugueuxRuinerRuisseauRuserRustiqueRythmeSablerSaboterSabreSacocheSafariSagesseSaisirSaladeSaliveSalonSaluerSamediSanctionSanglierSarcasmeSardineSaturerSaugrenuSaumonSauterSauvageSavantSavonnerScalpelScandaleSce/le/ratSce/narioSceptreSche/maScienceScinderScoreScrutinSculpterSe/anceSe/cableSe/cherSecouerSe/cre/terSe/datifSe/duireSeigneurSe/jourSe/lectifSemaineSemblerSemenceSe/minalSe/nateurSensibleSentenceSe/parerSe/quenceSereinSergentSe/rieuxSerrureSe/rumServiceSe/sameSe/virSevrageSextupleSide/ralSie-cleSie/gerSifflerSigleSignalSilenceSiliciumSimpleSince-reSinistreSiphonSiropSismiqueSituerSkierSocialSocleSodiumSoigneuxSoldatSoleilSolitudeSolubleSombreSommeilSomnolerSondeSongeurSonnetteSonoreSorcierSortirSosieSottiseSoucieuxSoudureSouffleSouleverSoupapeSourceSoutirerSouvenirSpacieuxSpatialSpe/cialSphe-reSpiralStableStationSternumStimulusStipulerStrictStudieuxStupeurStylisteSublimeSubstratSubtilSubvenirSucce-sSucreSuffixeSugge/rerSuiveurSulfateSuperbeSupplierSurfaceSuricateSurmenerSurpriseSursautSurvieSuspectSyllabeSymboleSyme/trieSynapseSyntaxeSyste-meTabacTablierTactileTaillerTalentTalismanTalonnerTambourTamiserTangibleTapisTaquinerTarderTarifTartineTasseTatamiTatouageTaupeTaureauTaxerTe/moinTemporelTenailleTendreTeneurTenirTensionTerminerTerneTerribleTe/tineTexteThe-meThe/orieThe/rapieThoraxTibiaTie-deTimideTirelireTiroirTissuTitaneTitreTituberTobogganTole/rantTomateToniqueTonneauToponymeTorcheTordreTornadeTorpilleTorrentTorseTortueTotemToucherTournageTousserToxineTractionTraficTragiqueTrahirTrainTrancherTravailTre-fleTremperTre/sorTreuilTriageTribunalTricoterTrilogieTriompheTriplerTriturerTrivialTromboneTroncTropicalTroupeauTuileTulipeTumulteTunnelTurbineTuteurTutoyerTuyauTympanTyphonTypiqueTyranUbuesqueUltimeUltrasonUnanimeUnifierUnionUniqueUnitaireUniversUraniumUrbainUrticantUsageUsineUsuelUsureUtileUtopieVacarmeVaccinVagabondVagueVaillantVaincreVaisseauValableValiseVallonValveVampireVanilleVapeurVarierVaseuxVassalVasteVecteurVedetteVe/ge/talVe/hiculeVeinardVe/loceVendrediVe/ne/rerVengerVenimeuxVentouseVerdureVe/rinVernirVerrouVerserVertuVestonVe/te/ranVe/tusteVexantVexerViaducViandeVictoireVidangeVide/oVignetteVigueurVilainVillageVinaigreViolonVipe-reVirementVirtuoseVirusVisageViseurVisionVisqueuxVisuelVitalVitesseViticoleVitrineVivaceVivipareVocationVoguerVoileVoisinVoitureVolailleVolcanVoltigerVolumeVoraceVortexVoterVouloirVoyageVoyelleWagonXe/nonYachtZe-breZe/nithZesteZoologie";
  var wordlist4 = null;
  var lookup2 = {};
  function dropDiacritic2(word) {
    logger21.checkNormalize();
    return toUtf8String(Array.prototype.filter.call(toUtf8Bytes(word.normalize("NFD").toLowerCase()), (c3) => {
      return c3 >= 65 && c3 <= 90 || c3 >= 97 && c3 <= 123;
    }));
  }
  function expand2(word) {
    const output = [];
    Array.prototype.forEach.call(toUtf8Bytes(word), (c3) => {
      if (c3 === 47) {
        output.push(204);
        output.push(129);
      } else if (c3 === 45) {
        output.push(204);
        output.push(128);
      } else {
        output.push(c3);
      }
    });
    return toUtf8String(output);
  }
  function loadWords4(lang) {
    if (wordlist4 != null) {
      return;
    }
    wordlist4 = words4.replace(/([A-Z])/g, " $1").toLowerCase().substring(1).split(" ").map((w4) => expand2(w4));
    wordlist4.forEach((word, index) => {
      lookup2[dropDiacritic2(word)] = index;
    });
    if (Wordlist.check(lang) !== "0x51deb7ae009149dc61a6bd18a918eb7ac78d2775726c68e598b92d002519b045") {
      wordlist4 = null;
      throw new Error("BIP39 Wordlist for fr (French) FAILED");
    }
  }
  var LangFr = class extends Wordlist {
    constructor() {
      super("fr");
    }
    getWord(index) {
      loadWords4(this);
      return wordlist4[index];
    }
    getWordIndex(word) {
      loadWords4(this);
      return lookup2[dropDiacritic2(word)];
    }
  };
  var langFr = new LangFr();
  Wordlist.register(langFr);

  // node_modules/@ethersproject/wordlists/lib.esm/lang-ja.js
  "use strict";
  var data = [
    "AQRASRAGBAGUAIRAHBAghAURAdBAdcAnoAMEAFBAFCBKFBQRBSFBCXBCDBCHBGFBEQBpBBpQBIkBHNBeOBgFBVCBhBBhNBmOBmRBiHBiFBUFBZDBvFBsXBkFBlcBjYBwDBMBBTBBTRBWBBWXXaQXaRXQWXSRXCFXYBXpHXOQXHRXhRXuRXmXXbRXlXXwDXTRXrCXWQXWGaBWaKcaYgasFadQalmaMBacAKaRKKBKKXKKjKQRKDRKCYKCRKIDKeVKHcKlXKjHKrYNAHNBWNaRNKcNIBNIONmXNsXNdXNnBNMBNRBNrXNWDNWMNFOQABQAHQBrQXBQXFQaRQKXQKDQKOQKFQNBQNDQQgQCXQCDQGBQGDQGdQYXQpBQpQQpHQLXQHuQgBQhBQhCQuFQmXQiDQUFQZDQsFQdRQkHQbRQlOQlmQPDQjDQwXQMBQMDQcFQTBQTHQrDDXQDNFDGBDGQDGRDpFDhFDmXDZXDbRDMYDRdDTRDrXSAhSBCSBrSGQSEQSHBSVRShYShkSyQSuFSiBSdcSoESocSlmSMBSFBSFKSFNSFdSFcCByCaRCKcCSBCSRCCrCGbCEHCYXCpBCpQCIBCIHCeNCgBCgFCVECVcCmkCmwCZXCZFCdRClOClmClFCjDCjdCnXCwBCwXCcRCFQCFjGXhGNhGDEGDMGCDGCHGIFGgBGVXGVEGVRGmXGsXGdYGoSGbRGnXGwXGwDGWRGFNGFLGFOGFdGFkEABEBDEBFEXOEaBEKSENBENDEYXEIgEIkEgBEgQEgHEhFEudEuFEiBEiHEiFEZDEvBEsXEsFEdXEdREkFEbBEbRElFEPCEfkEFNYAEYAhYBNYQdYDXYSRYCEYYoYgQYgRYuRYmCYZTYdBYbEYlXYjQYRbYWRpKXpQopQnpSFpCXpIBpISphNpdBpdRpbRpcZpFBpFNpFDpFopFrLADLBuLXQLXcLaFLCXLEhLpBLpFLHXLeVLhILdHLdRLoDLbRLrXIABIBQIBCIBsIBoIBMIBRIXaIaRIKYIKRINBINuICDIGBIIDIIkIgRIxFIyQIiHIdRIbYIbRIlHIwRIMYIcRIRVITRIFBIFNIFQOABOAFOBQOaFONBONMOQFOSFOCDOGBOEQOpBOLXOIBOIFOgQOgFOyQOycOmXOsXOdIOkHOMEOMkOWWHBNHXNHXWHNXHDuHDRHSuHSRHHoHhkHmRHdRHkQHlcHlRHwBHWcgAEgAggAkgBNgBQgBEgXOgYcgLXgHjgyQgiBgsFgdagMYgWSgFQgFEVBTVXEVKBVKNVKDVKYVKRVNBVNYVDBVDxVSBVSRVCjVGNVLXVIFVhBVhcVsXVdRVbRVlRhBYhKYhDYhGShxWhmNhdahdkhbRhjohMXhTRxAXxXSxKBxNBxEQxeNxeQxhXxsFxdbxlHxjcxFBxFNxFQxFOxFoyNYyYoybcyMYuBQuBRuBruDMuCouHBudQukkuoBulVuMXuFEmCYmCRmpRmeDmiMmjdmTFmFQiADiBOiaRiKRiNBiNRiSFiGkiGFiERipRiLFiIFihYibHijBijEiMXiWBiFBiFCUBQUXFUaRUNDUNcUNRUNFUDBUSHUCDUGBUGFUEqULNULoUIRUeEUeYUgBUhFUuRUiFUsXUdFUkHUbBUjSUjYUwXUMDUcHURdUTBUrBUrXUrQZAFZXZZaRZKFZNBZQFZCXZGBZYdZpBZLDZIFZHXZHNZeQZVRZVFZmXZiBZvFZdFZkFZbHZbFZwXZcCZcRZRBvBQvBGvBLvBWvCovMYsAFsBDsaRsKFsNFsDrsSHsSFsCXsCRsEBsEHsEfspBsLBsLDsIgsIRseGsbRsFBsFQsFSdNBdSRdCVdGHdYDdHcdVbdySduDdsXdlRdwXdWYdWcdWRkBMkXOkaRkNIkNFkSFkCFkYBkpRkeNkgBkhVkmXksFklVkMBkWDkFNoBNoaQoaFoNBoNXoNaoNEoSRoEroYXoYCoYbopRopFomXojkowXorFbBEbEIbdBbjYlaRlDElMXlFDjKjjSRjGBjYBjYkjpRjLXjIBjOFjeVjbRjwBnXQnSHnpFnLXnINnMBnTRwXBwXNwXYwNFwQFwSBwGFwLXwLDweNwgBwuHwjDwnXMBXMpFMIBMeNMTHcaQcNBcDHcSFcCXcpBcLXcLDcgFcuFcnXcwXccDcTQcrFTQErXNrCHrpFrgFrbFrTHrFcWNYWNbWEHWMXWTR",
    "ABGHABIJAEAVAYJQALZJAIaRAHNXAHdcAHbRAZJMAZJRAZTRAdVJAklmAbcNAjdRAMnRAMWYAWpRAWgRAFgBAFhBAFdcBNJBBNJDBQKBBQhcBQlmBDEJBYJkBYJTBpNBBpJFBIJBBIJDBIcABOKXBOEJBOVJBOiJBOZJBepBBeLXBeIFBegBBgGJBVJXBuocBiJRBUJQBlXVBlITBwNFBMYVBcqXBTlmBWNFBWiJBWnRBFGHBFwXXKGJXNJBXNZJXDTTXSHSXSVRXSlHXCJDXGQJXEhXXYQJXYbRXOfXXeNcXVJFXhQJXhEJXdTRXjdXXMhBXcQTXRGBXTEBXTnQXFCXXFOFXFgFaBaFaBNJaBCJaBpBaBwXaNJKaNJDaQIBaDpRaEPDaHMFamDJalEJaMZJaFaFaFNBaFQJaFLDaFVHKBCYKBEBKBHDKXaFKXGdKXEJKXpHKXIBKXZDKXwXKKwLKNacKNYJKNJoKNWcKDGdKDTRKChXKGaRKGhBKGbRKEBTKEaRKEPTKLMDKLWRKOHDKVJcKdBcKlIBKlOPKFSBKFEPKFpFNBNJNJBQNBGHNBEPNBHXNBgFNBVXNBZDNBsXNBwXNNaRNNJDNNJENNJkNDCJNDVDNGJRNJiDNZJNNsCJNJFNNFSBNFCXNFEPNFLXNFIFQJBFQCaRQJEQQLJDQLJFQIaRQOqXQHaFQHHQQVJXQVJDQhNJQmEIQZJFQsJXQJrFQWbRDJABDBYJDXNFDXCXDXLXDXZDDXsJDQqXDSJFDJCXDEPkDEqXDYmQDpSJDOCkDOGQDHEIDVJDDuDuDWEBDJFgSBNDSBSFSBGHSBIBSBTQSKVYSJQNSJQiSJCXSEqXSJYVSIiJSOMYSHAHSHaQSeCFSepQSegBSHdHSHrFShSJSJuHSJUFSkNRSrSrSWEBSFaHSJFQSFCXSFGDSFYXSFODSFgBSFVXSFhBSFxFSFkFSFbBSFMFCADdCJXBCXaFCXKFCXNFCXCXCXGBCXEJCXYBCXLDCXIBCXOPCXHXCXgBCXhBCXiBCXlDCXcHCJNBCJNFCDCJCDGBCDVXCDhBCDiDCDJdCCmNCpJFCIaRCOqXCHCHCHZJCViJCuCuCmddCJiFCdNBCdHhClEJCnUJCreSCWlgCWTRCFBFCFNBCFYBCFVFCFhFCFdSCFTBCFWDGBNBGBQFGJBCGBEqGBpBGBgQGNBEGNJYGNkOGNJRGDUFGJpQGHaBGJeNGJeEGVBlGVKjGiJDGvJHGsVJGkEBGMIJGWjNGFBFGFCXGFGBGFYXGFpBGFMFEASJEAWpEJNFECJVEIXSEIQJEOqXEOcFEeNcEHEJEHlFEJgFEhlmEmDJEmZJEiMBEUqXEoSREPBFEPXFEPKFEPSFEPEFEPpFEPLXEPIBEJPdEPcFEPTBEJnXEqlHEMpREFCXEFODEFcFYASJYJAFYBaBYBVXYXpFYDhBYCJBYJGFYYbRYeNcYJeVYiIJYZJcYvJgYvJRYJsXYsJFYMYMYreVpBNHpBEJpBwXpQxFpYEJpeNDpJeDpeSFpeCHpHUJpHbBpHcHpmUJpiiJpUJrpsJuplITpFaBpFQqpFGBpFEfpFYBpFpBpFLJpFIDpFgBpFVXpFyQpFuFpFlFpFjDpFnXpFwXpJFMpFTBLXCJLXEFLXhFLXUJLXbFLalmLNJBLSJQLCLCLGJBLLDJLHaFLeNFLeSHLeCXLepFLhaRLZsJLsJDLsJrLocaLlLlLMdbLFNBLFSBLFEHLFkFIBBFIBXFIBaQIBKXIBSFIBpHIBLXIBgBIBhBIBuHIBmXIBiFIBZXIBvFIBbFIBjQIBwXIBWFIKTRIQUJIDGFICjQIYSRIINXIJeCIVaRImEkIZJFIvJRIsJXIdCJIJoRIbBQIjYBIcqXITFVIreVIFKFIFSFIFCJIFGFIFLDIFIBIJFOIFgBIFVXIJFhIFxFIFmXIFdHIFbBIJFrIJFWOBGBOQfXOOKjOUqXOfXBOqXEOcqXORVJOFIBOFlDHBIOHXiFHNTRHCJXHIaRHHJDHHEJHVbRHZJYHbIBHRsJHRkDHWlmgBKFgBSBgBCDgBGHgBpBgBIBgBVJgBuBgBvFgKDTgQVXgDUJgGSJgOqXgmUMgZIJgTUJgWIEgFBFgFNBgFDJgFSFgFGBgFYXgJFOgFgQgFVXgFhBgFbHgJFWVJABVQKcVDgFVOfXVeDFVhaRVmGdViJYVMaRVFNHhBNDhBCXhBEqhBpFhBLXhNJBhSJRheVXhhKEhxlmhZIJhdBQhkIJhbMNhMUJhMZJxNJgxQUJxDEkxDdFxSJRxplmxeSBxeCXxeGFxeYXxepQxegBxWVcxFEQxFLXxFIBxFgBxFxDxFZtxFdcxFbBxFwXyDJXyDlcuASJuDJpuDIBuCpJuGSJuIJFueEFuZIJusJXudWEuoIBuWGJuFBcuFKEuFNFuFQFuFDJuFGJuFVJuFUtuFdHuFTBmBYJmNJYmQhkmLJDmLJomIdXmiJYmvJRmsJRmklmmMBymMuCmclmmcnQiJABiJBNiJBDiBSFiBCJiBEFiBYBiBpFiBLXiBTHiJNciDEfiCZJiECJiJEqiOkHiHKFieNDiHJQieQcieDHieSFieCXieGFieEFieIHiegFihUJixNoioNXiFaBiFKFiFNDiFEPiFYXitFOitFHiFgBiFVEiFmXiFitiFbBiFMFiFrFUCXQUIoQUIJcUHQJUeCEUHwXUUJDUUqXUdWcUcqXUrnQUFNDUFSHUFCFUFEfUFLXUtFOZBXOZXSBZXpFZXVXZEQJZEJkZpDJZOqXZeNHZeCDZUqXZFBQZFEHZFLXvBAFvBKFvBCXvBEPvBpHvBIDvBgFvBuHvQNJvFNFvFGBvFIBvJFcsXCDsXLXsXsXsXlFsXcHsQqXsJQFsEqXseIFsFEHsFjDdBxOdNpRdNJRdEJbdpJRdhZJdnSJdrjNdFNJdFQHdFhNkNJDkYaRkHNRkHSRkVbRkuMRkjSJkcqDoSJFoEiJoYZJoOfXohEBoMGQocqXbBAFbBXFbBaFbBNDbBGBbBLXbBTBbBWDbGJYbIJHbFQqbFpQlDgQlOrFlVJRjGEBjZJRnXvJnXbBnEfHnOPDngJRnxfXnUJWwXEJwNpJwDpBwEfXwrEBMDCJMDGHMDIJMLJDcQGDcQpHcqXccqNFcqCXcFCJRBSBRBGBRBEJRBpQTBNFTBQJTBpBTBVXTFABTFSBTFCFTFGBTFMDrXCJrXLDrDNJrEfHrFQJrFitWNjdWNTR",
    "AKLJMANOPFASNJIAEJWXAYJNRAIIbRAIcdaAeEfDAgidRAdjNYAMYEJAMIbRAFNJBAFpJFBBIJYBDZJFBSiJhBGdEBBEJfXBEJqXBEJWRBpaUJBLXrXBIYJMBOcfXBeEfFBestXBjNJRBcDJOBFEqXXNvJRXDMBhXCJNYXOAWpXONJWXHDEBXeIaRXhYJDXZJSJXMDJOXcASJXFVJXaBQqXaBZJFasXdQaFSJQaFEfXaFpJHaFOqXKBNSRKXvJBKQJhXKEJQJKEJGFKINJBKIJjNKgJNSKVElmKVhEBKiJGFKlBgJKjnUJKwsJYKMFIJKFNJDKFIJFKFOfXNJBSFNJBCXNBpJFNJBvQNJBMBNJLJXNJOqXNJeCXNJeGFNdsJCNbTKFNwXUJQNFEPQDiJcQDMSJQSFpBQGMQJQJeOcQyCJEQUJEBQJFBrQFEJqDXDJFDJXpBDJXIMDGiJhDIJGRDJeYcDHrDJDVXgFDkAWpDkIgRDjDEqDMvJRDJFNFDJFIBSKclmSJQOFSJQVHSJQjDSJGJBSJGJFSECJoSHEJqSJHTBSJVJDSViJYSZJNBSJsJDSFSJFSFEfXSJFLXCBUJVCJXSBCJXpBCXVJXCJXsXCJXdFCJNJHCLIJgCHiJFCVNJMChCJhCUHEJCsJTRCJdYcCoQJCCFEfXCFIJgCFUJxCFstFGJBaQGJBIDGQJqXGYJNRGJHKFGeQqDGHEJFGJeLXGHIiJGHdBlGUJEBGkIJTGFQPDGJFEqEAGegEJIJBEJVJXEhQJTEiJNcEJZJFEJoEqEjDEqEPDsXEPGJBEPOqXEPeQFEfDiDEJfEFEfepQEfMiJEqXNBEqDIDEqeSFEqVJXEMvJRYXNJDYXEJHYKVJcYYJEBYJeEcYJUqXYFpJFYFstXpAZJMpBSJFpNBNFpeQPDpHLJDpHIJFpHgJFpeitFpHZJFpJFADpFSJFpJFCJpFOqXpFitBpJFZJLXIJFLIJgRLVNJWLVHJMLwNpJLFGJBLFLJDLFOqXLJFUJIBDJXIBGJBIJBYQIJBIBIBOqXIBcqDIEGJFILNJTIIJEBIOiJhIJeNBIJeIBIhiJIIWoTRIJFAHIJFpBIJFuHIFUtFIJFTHOSBYJOEcqXOHEJqOvBpFOkVJrObBVJOncqDOcNJkHhNJRHuHJuHdMhBgBUqXgBsJXgONJBgHNJDgHHJQgJeitgHsJXgJyNagyDJBgZJDrgsVJQgkEJNgkjSJgJFAHgFCJDgFZtMVJXNFVXQfXVJXDJVXoQJVQVJQVDEfXVDvJHVEqNFVeQfXVHpJFVHxfXVVJSRVVmaRVlIJOhCXVJhHjYkhxCJVhWVUJhWiJcxBNJIxeEqDxfXBFxcFEPxFSJFxFYJXyBDQJydaUJyFOPDuYCJYuLvJRuHLJXuZJLDuFOPDuFZJHuFcqXmKHJdmCQJcmOsVJiJAGFitLCFieOfXiestXiZJMEikNJQirXzFiFQqXiFIJFiFZJFiFvtFUHpJFUteIcUteOcUVCJkUhdHcUbEJEUJqXQUMNJhURjYkUFitFZDGJHZJIxDZJVJXZJFDJZJFpQvBNJBvBSJFvJxBrseQqDsVFVJdFLJDkEJNBkmNJYkFLJDoQJOPoGsJRoEAHBoEJfFbBQqDbBZJHbFVJXlFIJBjYIrXjeitcjjCEBjWMNBwXQfXwXOaFwDsJXwCJTRwrCZJMDNJQcDDJFcqDOPRYiJFTBsJXTQIJBTFEfXTFLJDrXEJFrEJXMrFZJFWEJdEWYTlm",
    "ABCDEFACNJTRAMBDJdAcNJVXBLNJEBXSIdWRXErNJkXYDJMBXZJCJaXMNJaYKKVJKcKDEJqXKDcNJhKVJrNYKbgJVXKFVJSBNBYBwDNJeQfXNJeEqXNhGJWENJFiJRQlIJbEQJfXxDQqXcfXQFNDEJQFwXUJDYcnUJDJIBgQDIUJTRDJFEqDSJQSJFSJQIJFSOPeZtSJFZJHCJXQfXCTDEqFGJBSJFGJBOfXGJBcqXGJHNJDGJRLiJEJfXEqEJFEJPEFpBEJYJBZJFYBwXUJYiJMEBYJZJyTYTONJXpQMFXFpeGIDdpJFstXpJFcPDLBVSJRLHQJqXLJFZJFIJBNJDIJBUqXIBkFDJIJEJPTIYJGWRIJeQPDIJeEfHIJFsJXOqGDSFHXEJqXgJCsJCgGQJqXgdQYJEgFMFNBgJFcqDVJwXUJVJFZJchIgJCCxOEJqXxOwXUJyDJBVRuscisciJBiJBieUtqXiJFDJkiFsJXQUGEZJcUJFsJXZtXIrXZDZJDrZJFNJDZJFstXvJFQqXvJFCJEsJXQJqkhkNGBbDJdTRbYJMEBlDwXUJMEFiJFcfXNJDRcNJWMTBLJXC",
    "BraFUtHBFSJFdbNBLJXVJQoYJNEBSJBEJfHSJHwXUJCJdAZJMGjaFVJXEJPNJBlEJfFiJFpFbFEJqIJBVJCrIBdHiJhOPFChvJVJZJNJWxGFNIFLueIBQJqUHEJfUFstOZJDrlXEASJRlXVJXSFwVJNJWD",
    "QJEJNNJDQJEJIBSFQJEJxegBQJEJfHEPSJBmXEJFSJCDEJqXLXNJFQqXIcQsFNJFIFEJqXUJgFsJXIJBUJEJfHNFvJxEqXNJnXUJFQqD",
    "IJBEJqXZJ"
  ];
  var mapping = "~~AzB~X~a~KN~Q~D~S~C~G~E~Y~p~L~I~O~eH~g~V~hxyumi~~U~~Z~~v~~s~~dkoblPjfnqwMcRTr~W~~~F~~~~~Jt";
  var wordlist5 = null;
  function hex(word) {
    return hexlify(toUtf8Bytes(word));
  }
  var KiYoKu = "0xe3818de38284e3818f";
  var KyoKu = "0xe3818de38283e3818f";
  function loadWords5(lang) {
    if (wordlist5 !== null) {
      return;
    }
    wordlist5 = [];
    const transform = {};
    transform[toUtf8String([227, 130, 154])] = false;
    transform[toUtf8String([227, 130, 153])] = false;
    transform[toUtf8String([227, 130, 133])] = toUtf8String([227, 130, 134]);
    transform[toUtf8String([227, 129, 163])] = toUtf8String([227, 129, 164]);
    transform[toUtf8String([227, 130, 131])] = toUtf8String([227, 130, 132]);
    transform[toUtf8String([227, 130, 135])] = toUtf8String([227, 130, 136]);
    function normalize(word) {
      let result = "";
      for (let i3 = 0; i3 < word.length; i3++) {
        let kana = word[i3];
        const target = transform[kana];
        if (target === false) {
          continue;
        }
        if (target) {
          kana = target;
        }
        result += kana;
      }
      return result;
    }
    function sortJapanese(a3, b2) {
      a3 = normalize(a3);
      b2 = normalize(b2);
      if (a3 < b2) {
        return -1;
      }
      if (a3 > b2) {
        return 1;
      }
      return 0;
    }
    for (let length = 3; length <= 9; length++) {
      const d3 = data[length - 3];
      for (let offset = 0; offset < d3.length; offset += length) {
        const word = [];
        for (let i3 = 0; i3 < length; i3++) {
          const k3 = mapping.indexOf(d3[offset + i3]);
          word.push(227);
          word.push(k3 & 64 ? 130 : 129);
          word.push((k3 & 63) + 128);
        }
        wordlist5.push(toUtf8String(word));
      }
    }
    wordlist5.sort(sortJapanese);
    if (hex(wordlist5[442]) === KiYoKu && hex(wordlist5[443]) === KyoKu) {
      const tmp = wordlist5[442];
      wordlist5[442] = wordlist5[443];
      wordlist5[443] = tmp;
    }
    if (Wordlist.check(lang) !== "0xcb36b09e6baa935787fd762ce65e80b0c6a8dabdfbc3a7f86ac0e2c4fd111600") {
      wordlist5 = null;
      throw new Error("BIP39 Wordlist for ja (Japanese) FAILED");
    }
  }
  var LangJa = class extends Wordlist {
    constructor() {
      super("ja");
    }
    getWord(index) {
      loadWords5(this);
      return wordlist5[index];
    }
    getWordIndex(word) {
      loadWords5(this);
      return wordlist5.indexOf(word);
    }
    split(mnemonic) {
      logger21.checkNormalize();
      return mnemonic.split(/(?:\u3000| )+/g);
    }
    join(words6) {
      return words6.join("\u3000");
    }
  };
  var langJa = new LangJa();
  Wordlist.register(langJa);

  // node_modules/@ethersproject/wordlists/lib.esm/lang-ko.js
  "use strict";
  var data2 = [
    "OYAa",
    "ATAZoATBl3ATCTrATCl8ATDloATGg3ATHT8ATJT8ATJl3ATLlvATLn4ATMT8ATMX8ATMboATMgoAToLbAToMTATrHgATvHnAT3AnAT3JbAT3MTAT8DbAT8JTAT8LmAT8MYAT8MbAT#LnAUHT8AUHZvAUJXrAUJX8AULnrAXJnvAXLUoAXLgvAXMn6AXRg3AXrMbAX3JTAX3QbAYLn3AZLgvAZrSUAZvAcAZ8AaAZ8AbAZ8AnAZ8HnAZ8LgAZ8MYAZ8MgAZ8OnAaAboAaDTrAaFTrAaJTrAaJboAaLVoAaMXvAaOl8AaSeoAbAUoAbAg8AbAl4AbGnrAbMT8AbMXrAbMn4AbQb8AbSV8AbvRlAb8AUAb8AnAb8HgAb8JTAb8NTAb8RbAcGboAcLnvAcMT8AcMX8AcSToAcrAaAcrFnAc8AbAc8MgAfGgrAfHboAfJnvAfLV8AfLkoAfMT8AfMnoAfQb8AfScrAfSgrAgAZ8AgFl3AgGX8AgHZvAgHgrAgJXoAgJX8AgJboAgLZoAgLn4AgOX8AgoATAgoAnAgoCUAgoJgAgoLXAgoMYAgoSeAgrDUAgrJTAhrFnAhrLjAhrQgAjAgoAjJnrAkMX8AkOnoAlCTvAlCV8AlClvAlFg4AlFl6AlFn3AloSnAlrAXAlrAfAlrFUAlrFbAlrGgAlrOXAlvKnAlvMTAl3AbAl3MnAnATrAnAcrAnCZ3AnCl8AnDg8AnFboAnFl3AnHX4AnHbrAnHgrAnIl3AnJgvAnLXoAnLX4AnLbrAnLgrAnLhrAnMXoAnMgrAnOn3AnSbrAnSeoAnvLnAn3OnCTGgvCTSlvCTvAUCTvKnCTvNTCT3CZCT3GUCT3MTCT8HnCUCZrCULf8CULnvCU3HnCU3JUCY6NUCbDb8CbFZoCbLnrCboOTCboScCbrFnCbvLnCb8AgCb8HgCb$LnCkLfoClBn3CloDUDTHT8DTLl3DTSU8DTrAaDTrLXDTrLjDTrOYDTrOgDTvFXDTvFnDT3HUDT3LfDUCT9DUDT4DUFVoDUFV8DUFkoDUGgrDUJnrDULl8DUMT8DUMXrDUMX4DUMg8DUOUoDUOgvDUOg8DUSToDUSZ8DbDXoDbDgoDbGT8DbJn3DbLg3DbLn4DbMXrDbMg8DbOToDboJXGTClvGTDT8GTFZrGTLVoGTLlvGTLl3GTMg8GTOTvGTSlrGToCUGTrDgGTrJYGTrScGTtLnGTvAnGTvQgGUCZrGUDTvGUFZoGUHXrGULnvGUMT8GUoMgGXoLnGXrMXGXrMnGXvFnGYLnvGZOnvGZvOnGZ8LaGZ8LmGbAl3GbDYvGbDlrGbHX3GbJl4GbLV8GbLn3GbMn4GboJTGboRfGbvFUGb3GUGb4JnGgDX3GgFl$GgJlrGgLX6GgLZoGgLf8GgOXoGgrAgGgrJXGgrMYGgrScGgvATGgvOYGnAgoGnJgvGnLZoGnLg3GnLnrGnQn8GnSbrGnrMgHTClvHTDToHTFT3HTQT8HToJTHToJgHTrDUHTrMnHTvFYHTvRfHT8MnHT8SUHUAZ8HUBb4HUDTvHUoMYHXFl6HXJX6HXQlrHXrAUHXrMnHXrSbHXvFYHXvKXHX3LjHX3MeHYvQlHZrScHZvDbHbAcrHbFT3HbFl3HbJT8HbLTrHbMT8HbMXrHbMbrHbQb8HbSX3HboDbHboJTHbrFUHbrHgHbrJTHb8JTHb8MnHb8QgHgAlrHgDT3HgGgrHgHgrHgJTrHgJT8HgLX@HgLnrHgMT8HgMX8HgMboHgOnrHgQToHgRg3HgoHgHgrCbHgrFnHgrLVHgvAcHgvAfHnAloHnCTrHnCnvHnGTrHnGZ8HnGnvHnJT8HnLf8HnLkvHnMg8HnRTrITvFUITvFnJTAXrJTCV8JTFT3JTFT8JTFn4JTGgvJTHT8JTJT8JTJXvJTJl3JTJnvJTLX4JTLf8JTLhvJTMT8JTMXrJTMnrJTObrJTQT8JTSlvJT8DUJT8FkJT8MTJT8OXJT8OgJT8QUJT8RfJUHZoJXFT4JXFlrJXGZ8JXGnrJXLV8JXLgvJXMXoJXMX3JXNboJXPlvJXoJTJXoLkJXrAXJXrHUJXrJgJXvJTJXvOnJX4KnJYAl3JYJT8JYLhvJYQToJYrQXJY6NUJbAl3JbCZrJbDloJbGT8JbGgrJbJXvJbJboJbLf8JbLhrJbLl3JbMnvJbRg8JbSZ8JboDbJbrCZJbrSUJb3KnJb8LnJfRn8JgAXrJgCZrJgDTrJgGZrJgGZ8JgHToJgJT8JgJXoJgJgvJgLX4JgLZ3JgLZ8JgLn4JgMgrJgMn4JgOgvJgPX6JgRnvJgSToJgoCZJgoJbJgoMYJgrJXJgrJgJgrLjJg6MTJlCn3JlGgvJlJl8Jl4AnJl8FnJl8HgJnAToJnATrJnAbvJnDUoJnGnrJnJXrJnJXvJnLhvJnLnrJnLnvJnMToJnMT8JnMXvJnMX3JnMg8JnMlrJnMn4JnOX8JnST4JnSX3JnoAgJnoAnJnoJTJnoObJnrAbJnrAkJnrHnJnrJTJnrJYJnrOYJnrScJnvCUJnvFaJnvJgJnvJnJnvOYJnvQUJnvRUJn3FnJn3JTKnFl3KnLT6LTDlvLTMnoLTOn3LTRl3LTSb4LTSlrLToAnLToJgLTrAULTrAcLTrCULTrHgLTrMgLT3JnLULnrLUMX8LUoJgLVATrLVDTrLVLb8LVoJgLV8MgLV8RTLXDg3LXFlrLXrCnLXrLXLX3GTLX4GgLX4OYLZAXrLZAcrLZAgrLZAhrLZDXyLZDlrLZFbrLZFl3LZJX6LZJX8LZLc8LZLnrLZSU8LZoJTLZoJnLZrAgLZrAnLZrJYLZrLULZrMgLZrSkLZvAnLZvGULZvJeLZvOTLZ3FZLZ4JXLZ8STLZ8ScLaAT3LaAl3LaHT8LaJTrLaJT8LaJXrLaJgvLaJl4LaLVoLaMXrLaMXvLaMX8LbClvLbFToLbHlrLbJn4LbLZ3LbLhvLbMXrLbMnoLbvSULcLnrLc8HnLc8MTLdrMnLeAgoLeOgvLeOn3LfAl3LfLnvLfMl3LfOX8Lf8AnLf8JXLf8LXLgJTrLgJXrLgJl8LgMX8LgRZrLhCToLhrAbLhrFULhrJXLhvJYLjHTrLjHX4LjJX8LjLhrLjSX3LjSZ4LkFX4LkGZ8LkGgvLkJTrLkMXoLkSToLkSU8LkSZ8LkoOYLl3FfLl3MgLmAZrLmCbrLmGgrLmHboLmJnoLmJn3LmLfoLmLhrLmSToLnAX6LnAb6LnCZ3LnCb3LnDTvLnDb8LnFl3LnGnrLnHZvLnHgvLnITvLnJT8LnJX8LnJlvLnLf8LnLg6LnLhvLnLnoLnMXrLnMg8LnQlvLnSbrLnrAgLnrAnLnrDbLnrFkLnrJdLnrMULnrOYLnrSTLnvAnLnvDULnvHgLnvOYLnvOnLn3GgLn4DULn4JTLn4JnMTAZoMTAloMTDb8MTFT8MTJnoMTJnrMTLZrMTLhrMTLkvMTMX8MTRTrMToATMTrDnMTrOnMT3JnMT4MnMT8FUMT8FaMT8FlMT8GTMT8GbMT8GnMT8HnMT8JTMT8JbMT8OTMUCl8MUJTrMUJU8MUMX8MURTrMUSToMXAX6MXAb6MXCZoMXFXrMXHXrMXLgvMXOgoMXrAUMXrAnMXrHgMXrJYMXrJnMXrMTMXrMgMXrOYMXrSZMXrSgMXvDUMXvOTMX3JgMX3OTMX4JnMX8DbMX8FnMX8HbMX8HgMX8HnMX8LbMX8MnMX8OnMYAb8MYGboMYHTvMYHX4MYLTrMYLnvMYMToMYOgvMYRg3MYSTrMbAToMbAXrMbAl3MbAn8MbGZ8MbJT8MbJXrMbMXvMbMX8MbMnoMbrMUMb8AfMb8FbMb8FkMcJXoMeLnrMgFl3MgGTvMgGXoMgGgrMgGnrMgHT8MgHZrMgJnoMgLnrMgLnvMgMT8MgQUoMgrHnMgvAnMg8HgMg8JYMg8LfMloJnMl8ATMl8AXMl8JYMnAToMnAT4MnAZ8MnAl3MnAl4MnCl8MnHT8MnHg8MnJnoMnLZoMnLhrMnMXoMnMX3MnMnrMnOgvMnrFbMnrFfMnrFnMnrNTMnvJXNTMl8OTCT3OTFV8OTFn3OTHZvOTJXrOTOl3OT3ATOT3JUOT3LZOT3LeOT3MbOT8ATOT8AbOT8AgOT8MbOUCXvOUMX3OXHXvOXLl3OXrMUOXvDbOX6NUOX8JbOYFZoOYLbrOYLkoOYMg8OYSX3ObHTrObHT4ObJgrObLhrObMX3ObOX8Ob8FnOeAlrOeJT8OeJXrOeJnrOeLToOeMb8OgJXoOgLXoOgMnrOgOXrOgOloOgoAgOgoJbOgoMYOgoSTOg8AbOjLX4OjMnoOjSV8OnLVoOnrAgOn3DUPXQlrPXvFXPbvFTPdAT3PlFn3PnvFbQTLn4QToAgQToMTQULV8QURg8QUoJnQXCXvQbFbrQb8AaQb8AcQb8FbQb8MYQb8ScQeAlrQeLhrQjAn3QlFXoQloJgQloSnRTLnvRTrGURTrJTRUJZrRUoJlRUrQnRZrLmRZrMnRZrSnRZ8ATRZ8JbRZ8ScRbMT8RbST3RfGZrRfMX8RfMgrRfSZrRnAbrRnGT8RnvJgRnvLfRnvMTRn8AaSTClvSTJgrSTOXrSTRg3STRnvSToAcSToAfSToAnSToHnSToLjSToMTSTrAaSTrEUST3BYST8AgST8LmSUAZvSUAgrSUDT4SUDT8SUGgvSUJXoSUJXvSULTrSU8JTSU8LjSV8AnSV8JgSXFToSXLf8SYvAnSZrDUSZrMUSZrMnSZ8HgSZ8JTSZ8JgSZ8MYSZ8QUSaQUoSbCT3SbHToSbQYvSbSl4SboJnSbvFbSb8HbSb8JgSb8OTScGZrScHgrScJTvScMT8ScSToScoHbScrMTScvAnSeAZrSeAcrSeHboSeJUoSeLhrSeMT8SeMXrSe6JgSgHTrSkJnoSkLnvSk8CUSlFl3SlrSnSl8GnSmAboSmGT8SmJU8",
    "ATLnDlATrAZoATrJX4ATrMT8ATrMX4ATrRTrATvDl8ATvJUoATvMl8AT3AToAT3MX8AT8CT3AT8DT8AT8HZrAT8HgoAUAgFnAUCTFnAXoMX8AXrAT8AXrGgvAXrJXvAXrOgoAXvLl3AZvAgoAZvFbrAZvJXoAZvJl8AZvJn3AZvMX8AZvSbrAZ8FZoAZ8LZ8AZ8MU8AZ8OTvAZ8SV8AZ8SX3AbAgFZAboJnoAbvGboAb8ATrAb8AZoAb8AgrAb8Al4Ab8Db8Ab8JnoAb8LX4Ab8LZrAb8LhrAb8MT8Ab8OUoAb8Qb8Ab8ST8AcrAUoAcrAc8AcrCZ3AcrFT3AcrFZrAcrJl4AcrJn3AcrMX3AcrOTvAc8AZ8Ac8MT8AfAcJXAgoFn4AgoGgvAgoGnrAgoLc8AgoMXoAgrLnrAkrSZ8AlFXCTAloHboAlrHbrAlrLhrAlrLkoAl3CZrAl3LUoAl3LZrAnrAl4AnrMT8An3HT4BT3IToBX4MnvBb!Ln$CTGXMnCToLZ4CTrHT8CT3JTrCT3RZrCT#GTvCU6GgvCU8Db8CU8GZrCU8HT8CboLl3CbrGgrCbrMU8Cb8DT3Cb8GnrCb8LX4Cb8MT8Cb8ObrCgrGgvCgrKX4Cl8FZoDTrAbvDTrDboDTrGT6DTrJgrDTrMX3DTrRZrDTrRg8DTvAVvDTvFZoDT3DT8DT3Ln3DT4HZrDT4MT8DT8AlrDT8MT8DUAkGbDUDbJnDYLnQlDbDUOYDbMTAnDbMXSnDboAT3DboFn4DboLnvDj6JTrGTCgFTGTGgFnGTJTMnGTLnPlGToJT8GTrCT3GTrLVoGTrLnvGTrMX3GTrMboGTvKl3GZClFnGZrDT3GZ8DTrGZ8FZ8GZ8MXvGZ8On8GZ8ST3GbCnQXGbMbFnGboFboGboJg3GboMXoGb3JTvGb3JboGb3Mn6Gb3Qb8GgDXLjGgMnAUGgrDloGgrHX4GgrSToGgvAXrGgvAZvGgvFbrGgvLl3GgvMnvGnDnLXGnrATrGnrMboGnuLl3HTATMnHTAgCnHTCTCTHTrGTvHTrHTvHTrJX8HTrLl8HTrMT8HTrMgoHTrOTrHTuOn3HTvAZrHTvDTvHTvGboHTvJU8HTvLl3HTvMXrHTvQb4HT4GT6HT4JT8HT4Jb#HT8Al3HT8GZrHT8GgrHT8HX4HT8Jb8HT8JnoHT8LTrHT8LgvHT8SToHT8SV8HUoJUoHUoJX8HUoLnrHXrLZoHXvAl3HX3LnrHX4FkvHX4LhrHX4MXoHX4OnoHZrAZ8HZrDb8HZrGZ8HZrJnrHZvGZ8HZvLnvHZ8JnvHZ8LhrHbCXJlHbMTAnHboJl4HbpLl3HbrJX8HbrLnrHbrMnvHbvRYrHgoSTrHgrFV8HgrGZ8HgrJXoHgrRnvHgvBb!HgvGTrHgvHX4HgvHn!HgvLTrHgvSU8HnDnLbHnFbJbHnvDn8Hn6GgvHn!BTvJTCTLnJTQgFnJTrAnvJTrLX4JTrOUoJTvFn3JTvLnrJTvNToJT3AgoJT3Jn4JT3LhvJT3ObrJT8AcrJT8Al3JT8JT8JT8JnoJT8LX4JT8LnrJT8MX3JT8Rg3JT8Sc8JUoBTvJU8AToJU8GZ8JU8GgvJU8JTrJU8JXrJU8JnrJU8LnvJU8ScvJXHnJlJXrGgvJXrJU8JXrLhrJXrMT8JXrMXrJXrQUoJXvCTvJXvGZ8JXvGgrJXvQT8JX8Ab8JX8DT8JX8GZ8JX8HZvJX8LnrJX8MT8JX8MXoJX8MnvJX8ST3JYGnCTJbAkGbJbCTAnJbLTAcJboDT3JboLb6JbrAnvJbrCn3JbrDl8JbrGboJbrIZoJbrJnvJbrMnvJbrQb4Jb8RZrJeAbAnJgJnFbJgScAnJgrATrJgvHZ8JgvMn4JlJlFbJlLiQXJlLjOnJlRbOlJlvNXoJlvRl3Jl4AcrJl8AUoJl8MnrJnFnMlJnHgGbJnoDT8JnoFV8JnoGgvJnoIT8JnoQToJnoRg3JnrCZ3JnrGgrJnrHTvJnrLf8JnrOX8JnvAT3JnvFZoJnvGT8JnvJl4JnvMT8JnvMX8JnvOXrJnvPX6JnvSX3JnvSZrJn3MT8Jn3MX8Jn3RTrLTATKnLTJnLTLTMXKnLTRTQlLToGb8LTrAZ8LTrCZ8LTrDb8LTrHT8LT3PX6LT4FZoLT$CTvLT$GgrLUvHX3LVoATrLVoAgoLVoJboLVoMX3LVoRg3LV8CZ3LV8FZoLV8GTvLXrDXoLXrFbrLXvAgvLXvFlrLXvLl3LXvRn6LX4Mb8LX8GT8LYCXMnLYrMnrLZoSTvLZrAZvLZrAloLZrFToLZrJXvLZrJboLZrJl4LZrLnrLZrMT8LZrOgvLZrRnvLZrST4LZvMX8LZvSlvLZ8AgoLZ8CT3LZ8JT8LZ8LV8LZ8LZoLZ8Lg8LZ8SV8LZ8SbrLZ$HT8LZ$Mn4La6CTvLbFbMnLbRYFTLbSnFZLboJT8LbrAT9LbrGb3LbrQb8LcrJX8LcrMXrLerHTvLerJbrLerNboLgrDb8LgrGZ8LgrHTrLgrMXrLgrSU8LgvJTrLgvLl3Lg6Ll3LhrLnrLhrMT8LhvAl4LiLnQXLkoAgrLkoJT8LkoJn4LlrSU8Ll3FZoLl3HTrLl3JX8Ll3JnoLl3LToLmLeFbLnDUFbLnLVAnLnrATrLnrAZoLnrAb8LnrAlrLnrGgvLnrJU8LnrLZrLnrLhrLnrMb8LnrOXrLnrSZ8LnvAb4LnvDTrLnvDl8LnvHTrLnvHbrLnvJT8LnvJU8LnvJbrLnvLhvLnvMX8LnvMb8LnvNnoLnvSU8Ln3Al3Ln4FZoLn4GT6Ln4JgvLn4LhrLn4MT8Ln4SToMToCZrMToJX8MToLX4MToLf8MToRg3MTrEloMTvGb6MT3BTrMT3Lb6MT8AcrMT8AgrMT8GZrMT8JnoMT8LnrMT8MX3MUOUAnMXAbFnMXoAloMXoJX8MXoLf8MXoLl8MXrAb8MXrDTvMXrGT8MXrGgrMXrHTrMXrLf8MXrMU8MXrOXvMXrQb8MXvGT8MXvHTrMXvLVoMX3AX3MX3Jn3MX3LhrMX3MX3MX4AlrMX4OboMX8GTvMX8GZrMX8GgrMX8JT8MX8JX8MX8LhrMX8MT8MYDUFbMYMgDbMbGnFfMbvLX4MbvLl3Mb8Mb8Mb8ST4MgGXCnMg8ATrMg8AgoMg8CZrMg8DTrMg8DboMg8HTrMg8JgrMg8LT8MloJXoMl8AhrMl8JT8MnLgAUMnoJXrMnoLX4MnoLhrMnoMT8MnrAl4MnrDb8MnrOTvMnrOgvMnrQb8MnrSU8MnvGgrMnvHZ8Mn3MToMn4DTrMn4LTrMn4Mg8NnBXAnOTFTFnOToAToOTrGgvOTrJX8OT3JXoOT6MTrOT8GgrOT8HTpOT8MToOUoHT8OUoJT8OUoLn3OXrAgoOXrDg8OXrMT8OXvSToOX6CTvOX8CZrOX8OgrOb6HgvOb8AToOb8MT8OcvLZ8OgvAlrOgvHTvOgvJTrOgvJnrOgvLZrOgvLn4OgvMT8OgvRTrOg8AZoOg8DbvOnrOXoOnvJn4OnvLhvOnvRTrOn3GgoOn3JnvOn6JbvOn8OTrPTGYFTPbBnFnPbGnDnPgDYQTPlrAnvPlrETvPlrLnvPlrMXvPlvFX4QTMTAnQTrJU8QYCnJlQYJlQlQbGTQbQb8JnrQb8LZoQb8LnvQb8MT8Qb8Ml8Qb8ST4QloAl4QloHZvQloJX8QloMn8QnJZOlRTrAZvRTrDTrRTvJn4RTvLhvRT4Jb8RZrAZrRZ8AkrRZ8JU8RZ8LV8RZ8LnvRbJlQXRg3GboRg3MnvRg8AZ8Rg8JboRg8Jl4RnLTCbRnvFl3RnvQb8SToAl4SToCZrSToFZoSToHXrSToJU8SToJgvSToJl4SToLhrSToMX3STrAlvSTrCT9STrCgrSTrGgrSTrHXrSTrHboSTrJnoSTrNboSTvLnrST4AZoST8Ab8ST8JT8SUoJn3SU6HZ#SU6JTvSU8Db8SU8HboSU8LgrSV8JT8SZrAcrSZrAl3SZrJT8SZrJnvSZrMT8SZvLUoSZ4FZoSZ8JnoSZ8RZrScoLnrScoMT8ScoMX8ScrAT4ScrAZ8ScrLZ8ScrLkvScvDb8ScvLf8ScvNToSgrFZrShvKnrSloHUoSloLnrSlrMXoSl8HgrSmrJUoSn3BX6",
    "ATFlOn3ATLgrDYAT4MTAnAT8LTMnAYJnRTrAbGgJnrAbLV8LnAbvNTAnAeFbLg3AgOYMXoAlQbFboAnDboAfAnJgoJTBToDgAnBUJbAl3BboDUAnCTDlvLnCTFTrSnCYoQTLnDTwAbAnDUDTrSnDUHgHgrDX8LXFnDbJXAcrETvLTLnGTFTQbrGTMnGToGT3DUFbGUJlPX3GbQg8LnGboJbFnGb3GgAYGgAg8ScGgMbAXrGgvAbAnGnJTLnvGnvATFgHTDT6ATHTrDlJnHYLnMn8HZrSbJTHZ8LTFnHbFTJUoHgSeMT8HgrLjAnHgvAbAnHlFUrDlHnDgvAnHnHTFT3HnQTGnrJTAaMXvJTGbCn3JTOgrAnJXvAXMnJbMg8SnJbMnRg3Jb8LTMnJnAl3OnJnGYrQlJnJlQY3LTDlCn3LTJjLg3LTLgvFXLTMg3GTLV8HUOgLXFZLg3LXNXrMnLX8QXFnLX9AlMYLYLXPXrLZAbJU8LZDUJU8LZMXrSnLZ$AgFnLaPXrDULbFYrMnLbMn8LXLboJgJgLeFbLg3LgLZrSnLgOYAgoLhrRnJlLkCTrSnLkOnLhrLnFX%AYLnFZoJXLnHTvJbLnLloAbMTATLf8MTHgJn3MTMXrAXMT3MTFnMUITvFnMXFX%AYMXMXvFbMXrFTDbMYAcMX3MbLf8SnMb8JbFnMgMXrMTMgvAXFnMgvGgCmMnAloSnMnFnJTrOXvMXSnOX8HTMnObJT8ScObLZFl3ObMXCZoPTLgrQXPUFnoQXPU3RXJlPX3RkQXPbrJXQlPlrJbFnQUAhrDbQXGnCXvQYLnHlvQbLfLnvRTOgvJbRXJYrQlRYLnrQlRbLnrQlRlFT8JlRlFnrQXSTClCn3STHTrAnSTLZQlrSTMnGTrSToHgGbSTrGTDnSTvGXCnST3HgFbSU3HXAXSbAnJn3SbFT8LnScLfLnv",
    "AT3JgJX8AT8FZoSnAT8JgFV8AT8LhrDbAZ8JT8DbAb8GgLhrAb8SkLnvAe8MT8SnAlMYJXLVAl3GYDTvAl3LfLnvBUDTvLl3CTOn3HTrCT3DUGgrCU8MT8AbCbFTrJUoCgrDb8MTDTLV8JX8DTLnLXQlDT8LZrSnDUQb8FZ8DUST4JnvDb8ScOUoDj6GbJl4GTLfCYMlGToAXvFnGboAXvLnGgAcrJn3GgvFnSToGnLf8JnvGn#HTDToHTLnFXJlHTvATFToHTvHTDToHTvMTAgoHT3STClvHT4AlFl6HT8HTDToHUoDgJTrHUoScMX3HbRZrMXoHboJg8LTHgDb8JTrHgMToLf8HgvLnLnoHnHn3HT4Hn6MgvAnJTJU8ScvJT3AaQT8JT8HTrAnJXrRg8AnJbAloMXoJbrATFToJbvMnoSnJgDb6GgvJgDb8MXoJgSX3JU8JguATFToJlPYLnQlJlQkDnLbJlQlFYJlJl8Lf8OTJnCTFnLbJnLTHXMnJnLXGXCnJnoFfRg3JnrMYRg3Jn3HgFl3KT8Dg8LnLTRlFnPTLTvPbLbvLVoSbrCZLXMY6HT3LXNU7DlrLXNXDTATLX8DX8LnLZDb8JU8LZMnoLhrLZSToJU8LZrLaLnrLZvJn3SnLZ8LhrSnLaJnoMT8LbFlrHTvLbrFTLnrLbvATLlvLb6OTFn3LcLnJZOlLeAT6Mn4LeJT3ObrLg6LXFlrLhrJg8LnLhvDlPX4LhvLfLnvLj6JTFT3LnFbrMXoLnQluCTvLnrQXCY6LnvLfLnvLnvMgLnvLnvSeLf8MTMbrJn3MT3JgST3MT8AnATrMT8LULnrMUMToCZrMUScvLf8MXoDT8SnMX6ATFToMX8AXMT8MX8FkMT8MX8HTrDUMX8ScoSnMYJT6CTvMgAcrMXoMg8SToAfMlvAXLg3MnFl3AnvOT3AnFl3OUoATHT8OU3RnLXrOXrOXrSnObPbvFn6Og8HgrSnOg8OX8DbPTvAgoJgPU3RYLnrPXrDnJZrPb8CTGgvPlrLTDlvPlvFUJnoQUvFXrQlQeMnoAl3QlrQlrSnRTFTrJUoSTDlLiLXSTFg6HT3STJgoMn4STrFTJTrSTrLZFl3ST4FnMXoSUrDlHUoScvHTvSnSfLkvMXo",
    "AUoAcrMXoAZ8HboAg8AbOg6ATFgAg8AloMXoAl3AT8JTrAl8MX8MXoCT3SToJU8Cl8Db8MXoDT8HgrATrDboOT8MXoGTOTrATMnGT8LhrAZ8GnvFnGnQXHToGgvAcrHTvAXvLl3HbrAZoMXoHgBlFXLg3HgMnFXrSnHgrSb8JUoHn6HT8LgvITvATrJUoJUoLZrRnvJU8HT8Jb8JXvFX8QT8JXvLToJTrJYrQnGnQXJgrJnoATrJnoJU8ScvJnvMnvMXoLTCTLgrJXLTJlRTvQlLbRnJlQYvLbrMb8LnvLbvFn3RnoLdCVSTGZrLeSTvGXCnLg3MnoLn3MToLlrETvMT8SToAl3MbrDU6GTvMb8LX4LhrPlrLXGXCnSToLf8Rg3STrDb8LTrSTvLTHXMnSb3RYLnMnSgOg6ATFg",
    "HUDlGnrQXrJTrHgLnrAcJYMb8DULc8LTvFgGnCk3Mg8JbAnLX4QYvFYHnMXrRUoJnGnvFnRlvFTJlQnoSTrBXHXrLYSUJgLfoMT8Se8DTrHbDb",
    "AbDl8SToJU8An3RbAb8ST8DUSTrGnrAgoLbFU6Db8LTrMg8AaHT8Jb8ObDl8SToJU8Pb3RlvFYoJl"
  ];
  var codes = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*";
  function getHangul(code) {
    if (code >= 40) {
      code = code + 168 - 40;
    } else if (code >= 19) {
      code = code + 97 - 19;
    }
    return toUtf8String([225, (code >> 6) + 132, (code & 63) + 128]);
  }
  var wordlist6 = null;
  function loadWords6(lang) {
    if (wordlist6 != null) {
      return;
    }
    wordlist6 = [];
    data2.forEach((data4, length) => {
      length += 4;
      for (let i3 = 0; i3 < data4.length; i3 += length) {
        let word = "";
        for (let j3 = 0; j3 < length; j3++) {
          word += getHangul(codes.indexOf(data4[i3 + j3]));
        }
        wordlist6.push(word);
      }
    });
    wordlist6.sort();
    if (Wordlist.check(lang) !== "0xf9eddeace9c5d3da9c93cf7d3cd38f6a13ed3affb933259ae865714e8a3ae71a") {
      wordlist6 = null;
      throw new Error("BIP39 Wordlist for ko (Korean) FAILED");
    }
  }
  var LangKo = class extends Wordlist {
    constructor() {
      super("ko");
    }
    getWord(index) {
      loadWords6(this);
      return wordlist6[index];
    }
    getWordIndex(word) {
      loadWords6(this);
      return wordlist6.indexOf(word);
    }
  };
  var langKo = new LangKo();
  Wordlist.register(langKo);

  // node_modules/@ethersproject/wordlists/lib.esm/lang-it.js
  "use strict";
  var words5 = "AbacoAbbaglioAbbinatoAbeteAbissoAbolireAbrasivoAbrogatoAccadereAccennoAccusatoAcetoneAchilleAcidoAcquaAcreAcrilicoAcrobataAcutoAdagioAddebitoAddomeAdeguatoAderireAdipeAdottareAdulareAffabileAffettoAffissoAffrantoAforismaAfosoAfricanoAgaveAgenteAgevoleAggancioAgireAgitareAgonismoAgricoloAgrumetoAguzzoAlabardaAlatoAlbatroAlberatoAlboAlbumeAlceAlcolicoAlettoneAlfaAlgebraAlianteAlibiAlimentoAllagatoAllegroAllievoAllodolaAllusivoAlmenoAlogenoAlpacaAlpestreAltalenaAlternoAlticcioAltroveAlunnoAlveoloAlzareAmalgamaAmanitaAmarenaAmbitoAmbratoAmebaAmericaAmetistaAmicoAmmassoAmmendaAmmirareAmmonitoAmoreAmpioAmpliareAmuletoAnacardoAnagrafeAnalistaAnarchiaAnatraAncaAncellaAncoraAndareAndreaAnelloAngeloAngolareAngustoAnimaAnnegareAnnidatoAnnoAnnuncioAnonimoAnticipoAnziApaticoAperturaApodeApparireAppetitoAppoggioApprodoAppuntoAprileArabicaArachideAragostaAraldicaArancioAraturaArazzoArbitroArchivioArditoArenileArgentoArgineArgutoAriaArmoniaArneseArredatoArringaArrostoArsenicoArsoArteficeArzilloAsciuttoAscoltoAsepsiAsetticoAsfaltoAsinoAsolaAspiratoAsproAssaggioAsseAssolutoAssurdoAstaAstenutoAsticeAstrattoAtavicoAteismoAtomicoAtonoAttesaAttivareAttornoAttritoAttualeAusilioAustriaAutistaAutonomoAutunnoAvanzatoAvereAvvenireAvvisoAvvolgereAzioneAzotoAzzimoAzzurroBabeleBaccanoBacinoBacoBadessaBadilataBagnatoBaitaBalconeBaldoBalenaBallataBalzanoBambinoBandireBaraondaBarbaroBarcaBaritonoBarlumeBaroccoBasilicoBassoBatostaBattutoBauleBavaBavosaBeccoBeffaBelgioBelvaBendaBenevoleBenignoBenzinaBereBerlinaBetaBibitaBiciBidoneBifidoBigaBilanciaBimboBinocoloBiologoBipedeBipolareBirbanteBirraBiscottoBisestoBisnonnoBisonteBisturiBizzarroBlandoBlattaBollitoBonificoBordoBoscoBotanicoBottinoBozzoloBraccioBradipoBramaBrancaBravuraBretellaBrevettoBrezzaBrigliaBrillanteBrindareBroccoloBrodoBronzinaBrulloBrunoBubboneBucaBudinoBuffoneBuioBulboBuonoBurloneBurrascaBussolaBustaCadettoCaducoCalamaroCalcoloCalesseCalibroCalmoCaloriaCambusaCamerataCamiciaCamminoCamolaCampaleCanapaCandelaCaneCaninoCanottoCantinaCapaceCapelloCapitoloCapogiroCapperoCapraCapsulaCarapaceCarcassaCardoCarismaCarovanaCarrettoCartolinaCasaccioCascataCasermaCasoCassoneCastelloCasualeCatastaCatenaCatrameCautoCavilloCedibileCedrataCefaloCelebreCellulareCenaCenoneCentesimoCeramicaCercareCertoCerumeCervelloCesoiaCespoCetoChelaChiaroChiccaChiedereChimeraChinaChirurgoChitarraCiaoCiclismoCifrareCignoCilindroCiottoloCircaCirrosiCitricoCittadinoCiuffoCivettaCivileClassicoClinicaCloroCoccoCodardoCodiceCoerenteCognomeCollareColmatoColoreColposoColtivatoColzaComaCometaCommandoComodoComputerComuneConcisoCondurreConfermaCongelareConiugeConnessoConoscereConsumoContinuoConvegnoCopertoCopioneCoppiaCopricapoCorazzaCordataCoricatoCorniceCorollaCorpoCorredoCorsiaCorteseCosmicoCostanteCotturaCovatoCratereCravattaCreatoCredereCremosoCrescitaCretaCricetoCrinaleCrisiCriticoCroceCronacaCrostataCrucialeCruscaCucireCuculoCuginoCullatoCupolaCuratoreCursoreCurvoCuscinoCustodeDadoDainoDalmataDamerinoDanielaDannosoDanzareDatatoDavantiDavveroDebuttoDecennioDecisoDeclinoDecolloDecretoDedicatoDefinitoDeformeDegnoDelegareDelfinoDelirioDeltaDemenzaDenotatoDentroDepositoDerapataDerivareDerogaDescrittoDesertoDesiderioDesumereDetersivoDevotoDiametroDicembreDiedroDifesoDiffusoDigerireDigitaleDiluvioDinamicoDinnanziDipintoDiplomaDipoloDiradareDireDirottoDirupoDisagioDiscretoDisfareDisgeloDispostoDistanzaDisumanoDitoDivanoDiveltoDividereDivoratoDobloneDocenteDoganaleDogmaDolceDomatoDomenicaDominareDondoloDonoDormireDoteDottoreDovutoDozzinaDragoDruidoDubbioDubitareDucaleDunaDuomoDupliceDuraturoEbanoEccessoEccoEclissiEconomiaEderaEdicolaEdileEditoriaEducareEgemoniaEgliEgoismoEgregioElaboratoElargireEleganteElencatoElettoElevareElficoElicaElmoElsaElusoEmanatoEmblemaEmessoEmiroEmotivoEmozioneEmpiricoEmuloEndemicoEnduroEnergiaEnfasiEnotecaEntrareEnzimaEpatiteEpilogoEpisodioEpocaleEppureEquatoreErarioErbaErbosoEredeEremitaErigereErmeticoEroeErosivoErranteEsagonoEsameEsanimeEsaudireEscaEsempioEsercitoEsibitoEsigenteEsistereEsitoEsofagoEsortatoEsosoEspansoEspressoEssenzaEssoEstesoEstimareEstoniaEstrosoEsultareEtilicoEtnicoEtruscoEttoEuclideoEuropaEvasoEvidenzaEvitatoEvolutoEvvivaFabbricaFaccendaFachiroFalcoFamigliaFanaleFanfaraFangoFantasmaFareFarfallaFarinosoFarmacoFasciaFastosoFasulloFaticareFatoFavolosoFebbreFecolaFedeFegatoFelpaFeltroFemminaFendereFenomenoFermentoFerroFertileFessuraFestivoFettaFeudoFiabaFiduciaFifaFiguratoFiloFinanzaFinestraFinireFioreFiscaleFisicoFiumeFlaconeFlamencoFleboFlemmaFloridoFluenteFluoroFobicoFocacciaFocosoFoderatoFoglioFolataFolcloreFolgoreFondenteFoneticoFoniaFontanaForbitoForchettaForestaFormicaFornaioForoFortezzaForzareFosfatoFossoFracassoFranaFrassinoFratelloFreccettaFrenataFrescoFrigoFrollinoFrondeFrugaleFruttaFucilataFucsiaFuggenteFulmineFulvoFumanteFumettoFumosoFuneFunzioneFuocoFurboFurgoneFuroreFusoFutileGabbianoGaffeGalateoGallinaGaloppoGamberoGammaGaranziaGarboGarofanoGarzoneGasdottoGasolioGastricoGattoGaudioGazeboGazzellaGecoGelatinaGelsoGemelloGemmatoGeneGenitoreGennaioGenotipoGergoGhepardoGhiaccioGhisaGialloGildaGineproGiocareGioielloGiornoGioveGiratoGironeGittataGiudizioGiuratoGiustoGlobuloGlutineGnomoGobbaGolfGomitoGommoneGonfioGonnaGovernoGracileGradoGraficoGrammoGrandeGrattareGravosoGraziaGrecaGreggeGrifoneGrigioGrinzaGrottaGruppoGuadagnoGuaioGuantoGuardareGufoGuidareIbernatoIconaIdenticoIdillioIdoloIdraIdricoIdrogenoIgieneIgnaroIgnoratoIlareIllesoIllogicoIlludereImballoImbevutoImboccoImbutoImmaneImmersoImmolatoImpaccoImpetoImpiegoImportoImprontaInalareInarcareInattivoIncantoIncendioInchinoIncisivoInclusoIncontroIncrocioIncuboIndagineIndiaIndoleIneditoInfattiInfilareInflittoIngaggioIngegnoIngleseIngordoIngrossoInnescoInodoreInoltrareInondatoInsanoInsettoInsiemeInsonniaInsulinaIntasatoInteroIntonacoIntuitoInumidireInvalidoInveceInvitoIperboleIpnoticoIpotesiIppicaIrideIrlandaIronicoIrrigatoIrrorareIsolatoIsotopoIstericoIstitutoIstriceItaliaIterareLabbroLabirintoLaccaLaceratoLacrimaLacunaLaddoveLagoLampoLancettaLanternaLardosoLargaLaringeLastraLatenzaLatinoLattugaLavagnaLavoroLegaleLeggeroLemboLentezzaLenzaLeoneLepreLesivoLessatoLestoLetteraleLevaLevigatoLiberoLidoLievitoLillaLimaturaLimitareLimpidoLineareLinguaLiquidoLiraLiricaLiscaLiteLitigioLivreaLocandaLodeLogicaLombareLondraLongevoLoquaceLorenzoLotoLotteriaLuceLucidatoLumacaLuminosoLungoLupoLuppoloLusingaLussoLuttoMacabroMacchinaMaceroMacinatoMadamaMagicoMagliaMagneteMagroMaiolicaMalafedeMalgradoMalintesoMalsanoMaltoMalumoreManaManciaMandorlaMangiareManifestoMannaroManovraMansardaMantideManubrioMappaMaratonaMarcireMarettaMarmoMarsupioMascheraMassaiaMastinoMaterassoMatricolaMattoneMaturoMazurcaMeandroMeccanicoMecenateMedesimoMeditareMegaMelassaMelisMelodiaMeningeMenoMensolaMercurioMerendaMerloMeschinoMeseMessereMestoloMetalloMetodoMettereMiagolareMicaMicelioMicheleMicroboMidolloMieleMiglioreMilanoMiliteMimosaMineraleMiniMinoreMirinoMirtilloMiscelaMissivaMistoMisurareMitezzaMitigareMitraMittenteMnemonicoModelloModificaModuloMoganoMogioMoleMolossoMonasteroMoncoMondinaMonetarioMonileMonotonoMonsoneMontatoMonvisoMoraMordereMorsicatoMostroMotivatoMotosegaMottoMovenzaMovimentoMozzoMuccaMucosaMuffaMughettoMugnaioMulattoMulinelloMultiploMummiaMuntoMuovereMuraleMusaMuscoloMusicaMutevoleMutoNababboNaftaNanometroNarcisoNariceNarratoNascereNastrareNaturaleNauticaNaviglioNebulosaNecrosiNegativoNegozioNemmenoNeofitaNerettoNervoNessunoNettunoNeutraleNeveNevroticoNicchiaNinfaNitidoNobileNocivoNodoNomeNominaNordicoNormaleNorvegeseNostranoNotareNotiziaNotturnoNovellaNucleoNullaNumeroNuovoNutrireNuvolaNuzialeOasiObbedireObbligoObeliscoOblioOboloObsoletoOccasioneOcchioOccidenteOccorrereOccultareOcraOculatoOdiernoOdorareOffertaOffrireOffuscatoOggettoOggiOgnunoOlandeseOlfattoOliatoOlivaOlogrammaOltreOmaggioOmbelicoOmbraOmegaOmissioneOndosoOnereOniceOnnivoroOnorevoleOntaOperatoOpinioneOppostoOracoloOrafoOrdineOrecchinoOreficeOrfanoOrganicoOrigineOrizzonteOrmaOrmeggioOrnativoOrologioOrrendoOrribileOrtensiaOrticaOrzataOrzoOsareOscurareOsmosiOspedaleOspiteOssaOssidareOstacoloOsteOtiteOtreOttagonoOttimoOttobreOvaleOvestOvinoOviparoOvocitoOvunqueOvviareOzioPacchettoPacePacificoPadellaPadronePaesePagaPaginaPalazzinaPalesarePallidoPaloPaludePandoroPannelloPaoloPaonazzoPapricaParabolaParcellaParerePargoloPariParlatoParolaPartireParvenzaParzialePassivoPasticcaPataccaPatologiaPattumePavonePeccatoPedalarePedonalePeggioPelosoPenarePendicePenisolaPennutoPenombraPensarePentolaPepePepitaPerbenePercorsoPerdonatoPerforarePergamenaPeriodoPermessoPernoPerplessoPersuasoPertugioPervasoPesatorePesistaPesoPestiferoPetaloPettinePetulantePezzoPiacerePiantaPiattinoPiccinoPicozzaPiegaPietraPifferoPigiamaPigolioPigroPilaPiliferoPillolaPilotaPimpantePinetaPinnaPinoloPioggiaPiomboPiramidePireticoPiritePirolisiPitonePizzicoPlaceboPlanarePlasmaPlatanoPlenarioPochezzaPoderosoPodismoPoesiaPoggiarePolentaPoligonoPollicePolmonitePolpettaPolsoPoltronaPolverePomicePomodoroPontePopolosoPorfidoPorosoPorporaPorrePortataPosaPositivoPossessoPostulatoPotassioPoterePranzoPrassiPraticaPreclusoPredicaPrefissoPregiatoPrelievoPremerePrenotarePreparatoPresenzaPretestoPrevalsoPrimaPrincipePrivatoProblemaProcuraProdurreProfumoProgettoProlungaPromessaPronomePropostaProrogaProtesoProvaPrudentePrugnaPruritoPsichePubblicoPudicaPugilatoPugnoPulcePulitoPulsantePuntarePupazzoPupillaPuroQuadroQualcosaQuasiQuerelaQuotaRaccoltoRaddoppioRadicaleRadunatoRafficaRagazzoRagioneRagnoRamarroRamingoRamoRandagioRantolareRapatoRapinaRappresoRasaturaRaschiatoRasenteRassegnaRastrelloRataRavvedutoRealeRecepireRecintoReclutaReconditoRecuperoRedditoRedimereRegalatoRegistroRegolaRegressoRelazioneRemareRemotoRennaReplicaReprimereReputareResaResidenteResponsoRestauroReteRetinaRetoricaRettificaRevocatoRiassuntoRibadireRibelleRibrezzoRicaricaRiccoRicevereRiciclatoRicordoRicredutoRidicoloRidurreRifasareRiflessoRiformaRifugioRigareRigettatoRighelloRilassatoRilevatoRimanereRimbalzoRimedioRimorchioRinascitaRincaroRinforzoRinnovoRinomatoRinsavitoRintoccoRinunciaRinvenireRiparatoRipetutoRipienoRiportareRipresaRipulireRisataRischioRiservaRisibileRisoRispettoRistoroRisultatoRisvoltoRitardoRitegnoRitmicoRitrovoRiunioneRivaRiversoRivincitaRivoltoRizomaRobaRoboticoRobustoRocciaRocoRodaggioRodereRoditoreRogitoRollioRomanticoRompereRonzioRosolareRospoRotanteRotondoRotulaRovescioRubizzoRubricaRugaRullinoRumineRumorosoRuoloRupeRussareRusticoSabatoSabbiareSabotatoSagomaSalassoSaldaturaSalgemmaSalivareSalmoneSaloneSaltareSalutoSalvoSapereSapidoSaporitoSaracenoSarcasmoSartoSassosoSatelliteSatiraSatolloSaturnoSavanaSavioSaziatoSbadiglioSbalzoSbancatoSbarraSbattereSbavareSbendareSbirciareSbloccatoSbocciatoSbrinareSbruffoneSbuffareScabrosoScadenzaScalaScambiareScandaloScapolaScarsoScatenareScavatoSceltoScenicoScettroSchedaSchienaSciarpaScienzaScindereScippoSciroppoScivoloSclerareScodellaScolpitoScompartoSconfortoScoprireScortaScossoneScozzeseScribaScrollareScrutinioScuderiaScultoreScuolaScuroScusareSdebitareSdoganareSeccaturaSecondoSedanoSeggiolaSegnalatoSegregatoSeguitoSelciatoSelettivoSellaSelvaggioSemaforoSembrareSemeSeminatoSempreSensoSentireSepoltoSequenzaSerataSerbatoSerenoSerioSerpenteSerraglioServireSestinaSetolaSettimanaSfaceloSfaldareSfamatoSfarzosoSfaticatoSferaSfidaSfilatoSfingeSfocatoSfoderareSfogoSfoltireSforzatoSfrattoSfruttatoSfuggitoSfumareSfusoSgabelloSgarbatoSgonfiareSgorbioSgrassatoSguardoSibiloSiccomeSierraSiglaSignoreSilenzioSillabaSimboloSimpaticoSimulatoSinfoniaSingoloSinistroSinoSintesiSinusoideSiparioSismaSistoleSituatoSlittaSlogaturaSlovenoSmarritoSmemoratoSmentitoSmeraldoSmilzoSmontareSmottatoSmussatoSnellireSnervatoSnodoSobbalzoSobrioSoccorsoSocialeSodaleSoffittoSognoSoldatoSolenneSolidoSollazzoSoloSolubileSolventeSomaticoSommaSondaSonettoSonniferoSopireSoppesoSopraSorgereSorpassoSorrisoSorsoSorteggioSorvolatoSospiroSostaSottileSpadaSpallaSpargereSpatolaSpaventoSpazzolaSpecieSpedireSpegnereSpelaturaSperanzaSpessoreSpettraleSpezzatoSpiaSpigolosoSpillatoSpinosoSpiraleSplendidoSportivoSposoSprangaSprecareSpronatoSpruzzoSpuntinoSquilloSradicareSrotolatoStabileStaccoStaffaStagnareStampatoStantioStarnutoStaseraStatutoSteloSteppaSterzoStilettoStimaStirpeStivaleStizzosoStonatoStoricoStrappoStregatoStriduloStrozzareStruttoStuccareStufoStupendoSubentroSuccosoSudoreSuggeritoSugoSultanoSuonareSuperboSupportoSurgelatoSurrogatoSussurroSuturaSvagareSvedeseSveglioSvelareSvenutoSveziaSviluppoSvistaSvizzeraSvoltaSvuotareTabaccoTabulatoTacciareTaciturnoTaleTalismanoTamponeTanninoTaraTardivoTargatoTariffaTarpareTartarugaTastoTatticoTavernaTavolataTazzaTecaTecnicoTelefonoTemerarioTempoTemutoTendoneTeneroTensioneTentacoloTeoremaTermeTerrazzoTerzettoTesiTesseratoTestatoTetroTettoiaTifareTigellaTimbroTintoTipicoTipografoTiraggioTiroTitanioTitoloTitubanteTizioTizzoneToccareTollerareToltoTombolaTomoTonfoTonsillaTopazioTopologiaToppaTorbaTornareTorroneTortoraToscanoTossireTostaturaTotanoTraboccoTracheaTrafilaTragediaTralcioTramontoTransitoTrapanoTrarreTraslocoTrattatoTraveTrecciaTremolioTrespoloTributoTrichecoTrifoglioTrilloTrinceaTrioTristezzaTrituratoTrivellaTrombaTronoTroppoTrottolaTrovareTruccatoTubaturaTuffatoTulipanoTumultoTunisiaTurbareTurchinoTutaTutelaUbicatoUccelloUccisoreUdireUditivoUffaUfficioUgualeUlisseUltimatoUmanoUmileUmorismoUncinettoUngereUnghereseUnicornoUnificatoUnisonoUnitarioUnteUovoUpupaUraganoUrgenzaUrloUsanzaUsatoUscitoUsignoloUsuraioUtensileUtilizzoUtopiaVacanteVaccinatoVagabondoVagliatoValangaValgoValicoVallettaValorosoValutareValvolaVampataVangareVanitosoVanoVantaggioVanveraVaporeVaranoVarcatoVarianteVascaVedettaVedovaVedutoVegetaleVeicoloVelcroVelinaVellutoVeloceVenatoVendemmiaVentoVeraceVerbaleVergognaVerificaVeroVerrucaVerticaleVescicaVessilloVestaleVeteranoVetrinaVetustoViandanteVibranteVicendaVichingoVicinanzaVidimareVigiliaVignetoVigoreVileVillanoViminiVincitoreViolaViperaVirgolaVirologoVirulentoViscosoVisioneVispoVissutoVisuraVitaVitelloVittimaVivandaVividoViziareVoceVogaVolatileVolereVolpeVoragineVulcanoZampognaZannaZappatoZatteraZavorraZefiroZelanteZeloZenzeroZerbinoZibettoZincoZirconeZittoZollaZoticoZuccheroZufoloZuluZuppa";
  var wordlist7 = null;
  function loadWords7(lang) {
    if (wordlist7 != null) {
      return;
    }
    wordlist7 = words5.replace(/([A-Z])/g, " $1").toLowerCase().substring(1).split(" ");
    if (Wordlist.check(lang) !== "0x5c1362d88fd4cf614a96f3234941d29f7d37c08c5292fde03bf62c2db6ff7620") {
      wordlist7 = null;
      throw new Error("BIP39 Wordlist for it (Italian) FAILED");
    }
  }
  var LangIt = class extends Wordlist {
    constructor() {
      super("it");
    }
    getWord(index) {
      loadWords7(this);
      return wordlist7[index];
    }
    getWordIndex(word) {
      loadWords7(this);
      return wordlist7.indexOf(word);
    }
  };
  var langIt = new LangIt();
  Wordlist.register(langIt);

  // node_modules/@ethersproject/wordlists/lib.esm/lang-zh.js
  "use strict";
  var data3 = "}aE#4A=Yv&co#4N#6G=cJ&SM#66|/Z#4t&kn~46#4K~4q%b9=IR#7l,mB#7W_X2*dl}Uo~7s}Uf&Iw#9c&cw~6O&H6&wx&IG%v5=IQ~8a&Pv#47$PR&50%Ko&QM&3l#5f,D9#4L|/H&tQ;v0~6n]nN<di,AM=W5%QO&ka&ua,hM^tm=zV=JA=wR&+X]7P&NB#4J#5L|/b[dA}tJ<Do&6m&u2[U1&Kb.HM&mC=w0&MW<rY,Hq#6M}QG,13&wP}Jp]Ow%ue&Kg<HP<D9~4k~9T&I2_c6$9T#9/[C5~7O~4a=cs&O7=KK=An&l9$6U$8A&uD&QI|/Y&bg}Ux&F2#6b}E2&JN&kW&kp=U/&bb=Xl<Cj}k+~5J#6L&5z&9i}b4&Fo,ho(X0_g3~4O$Fz&QE<HN=Ww]6/%GF-Vw=tj&/D&PN#9g=YO}cL&Of&PI~5I&Ip=vU=IW#9G;0o-wU}ss&QR<BT&R9=tk$PY_dh&Pq-yh]7T,nj.Xu=EP&76=cI&Fs*Xg}z7$Gb&+I=DF,AF=cA}rL#7j=Dz&3y<Aa$52=PQ}b0(iY$Fa}oL&xV#6U=ec=WZ,xh%RY<dp#9N&Fl&44=WH*A7=sh&TB&8P=07;u+&PK}uh}J5#72)V/=xC,AB$k0&f6;1E|+5=1B,3v]6n&wR%b+&xx]7f=Ol}fl;+D^wG]7E;nB;uh^Ir&l5=JL,nS=cf=g5;u6|/Q$Gc=MH%Hg#5d%M6^86=U+$Gz,l/,ir^5y&Ba&/F-IY&FI&be%IZ#77&PW_Nu$kE(Yf&NX]7Z,Jy&FJ(Xo&Nz#/d=y7&MX<Ag}Z+;nE]Dt(iG#4D=13&Pj~4c%v8&Zo%OL&/X#4W<HR&ie~6J_1O(Y2=y5=Ad*cv_eB#6k&PX:BU#7A;uk&Ft&Fx_dD=U2;vB=U5=4F}+O&GN.HH:9s=b0%NV(jO&IH=JT}Z9=VZ<Af,Kx^4m&uJ%c6,6r;9m#+L}cf%Kh&F3~4H=vP}bu,Hz|++,1w]nv}k6;uu$jw*Kl*WX&uM[x7&Fr[m7$NO&QN]hu=JN}nR^8g#/h(ps|KC;vd}xz=V0}p6&FD$G1#7K<bG_4p~8g&cf;u4=tl}+k%5/}fz;uw<cA=u1}gU}VM=LJ=eX&+L&Pr#4U}p2:nC,2K]7H:jF&9x}uX#9O=MB<fz~8X~5m&4D&kN&u5%E/(h7(ZF&VG<de(qM|/e-Wt=3x(a+,/R]f/&ND$Ro&nU}0g=KA%kH&NK$Ke<dS}cB&IX~5g$TN]6m=Uv,Is&Py=Ef%Kz#+/%bi&+A<F4$OG&4C&FL#9V<Zk=2I_eE&6c]nw&kq$HG}y+&A8$P3}OH=XP]70%IS(AJ_gH%GZ&tY&AZ=vb~6y&/r=VI=Wv<Zi=fl=xf&eL}c8}OL=MJ=g8$F7=YT}9u=0+^xC}JH&nL^N0~4T]K2,Cy%OC#6s;vG(AC^xe^cG&MF}Br#9P;wD-7h$O/&xA}Fn^PC]6i]7G&8V$Qs;vl(TB~73~4l<mW&6V=2y&uY&+3)aP}XF;LP&kx$wU=t7;uy<FN&lz)7E=Oo*Y+;wI}9q}le;J6&Ri&4t&Qr#8B=cb&vG=J5|Ql(h5<Yy~4+}QD,Lx=wn%K/&RK=dO&Pw,Q9=co%4u;9u}g0@6a^4I%b0=zo|/c&tX=dQ=OS#+b=yz_AB&wB&Pm=W9$HP_gR=62=AO=ti=hI,oA&jr&dH=tm&b6$P2(x8=zi;nG~7F;05]0n[Ix&3m}rg=Xp=cd&uz]7t;97=cN;vV<jf&FF&F1=6Q&Ik*Kk&P4,2z=fQ]7D&3u,H0=d/}Uw<ZN<7R}Kv;0f$H7,MD]7n$F0#88~9Z%da=by;+T#/u=VF&fO&kr^kf<AB]sU,I5$Ng&Pz;0i&QD&vM=Yl:BM;nJ_xJ]U7&Kf&30,3f|Z9*dC)je_jA&Q4&Kp$NH(Yz#6S&Id%Ib=KX,AD=KV%dP}tW&Pk^+E_Ni=cq,3R}VZ(Si=b+}rv;0j}rZ]uA,/w(Sx&Jv$w9&4d&wE,NJ$Gy=J/]Ls#7k<ZQ<Y/&uj]Ov$PM;v3,2F&+u:up=On&3e,Jv;90=J+&Qm]6q}bK#+d~8Y(h2]hA;99&AS=I/}qB&dQ}yJ-VM}Vl&ui,iB&G3|Dc]7d=eQ%dX%JC_1L~4d^NP;vJ&/1)ZI#7N]9X[bQ&PL=0L(UZ,Lm&kc&IR}n7(iR<AQ<dg=33=vN}ft}au]7I,Ba=x9=dR~6R&Tq=Xi,3d$Nr&Bc}DI&ku&vf]Dn,/F&iD,Ll&Nw=0y&I7=Ls=/A&tU=Qe}Ua&uk&+F=g4=gh=Vj#+1&Qn}Uy*44#5F,Pc&Rz*Xn=oh=5W;0n_Nf(iE<Y7=vr=Zu]oz#5Z%mI=kN=Bv_Jp(T2;vt_Ml<FS&uI=L/&6P]64$M7}86<bo%QX(SI%IY&VK=Al&Ux;vv;ut*E/%uh<ZE|O3,M2(yc]yu=Wk&tp:Ex}hr,Cl&WE)+Z=8U}I2_4Q,hA_si=iw=OM=tM=yZ%Ia=U7;wT}b+;uo=Za}yS!5x}HD}fb#5O_dA;Nv%uB(yB;01(Sf}Fk;v7}Pt#8v<mZ#7L,/r&Pl~4w&f5=Ph$Fw_LF&8m,bL=yJ&BH}p/*Jn}tU~5Q;wB(h6]Df]8p^+B;E4&Wc=d+;Ea&bw$8C&FN,DM=Yf}mP~5w=fT#6V=mC=Fi=AV}jB&AN}lW}aH#/D)dZ;hl;vE}/7,CJ;31&w8,hj%u9_Js=jJ&4M~8k=TN&eC}nL&uc-wi&lX}dj=Mv=e2#6u=cr$uq$6G]8W}Jb:nm=Yg<b3(UA;vX&6n&xF=KT,jC,De&R8&oY=Zv&oB]7/=Z2&Oa}bf,hh(4h^tZ&72&Nx;D2&xL~5h~40)ZG)h+=OJ&RA]Bv$yB=Oq=df,AQ%Jn}OJ;11,3z&Tl&tj;v+^Hv,Dh(id=s+]7N&N3)9Q~8f,S4=uW=w4&uX,LX&3d]CJ&yp&8x<b2_do&lP=y/<cy_dG=Oi=7R(VH(lt_1T,Iq_AA;12^6T%k6#8K[B1{oO<AU[Bt;1b$9S&Ps<8T=St{bY,jB(Zp&63&Uv$9V,PM]6v&Af}zW[bW_oq}sm}nB&Kq&gC&ff_eq_2m&5F&TI}rf}Gf;Zr_z9;ER&jk}iz_sn<BN~+n&vo=Vi%97|ZR=Wc,WE&6t]6z%85(ly#84=KY)6m_5/=aX,N3}Tm&he&6K]tR_B2-I3;u/&hU&lH<AP=iB&IA=XL;/5&Nh=wv<BH#79=vS=zl<AA=0X_RG}Bw&9p$NW,AX&kP_Lp&/Z(Tc]Mu}hs#6I}5B&cI<bq&H9#6m=K9}vH(Y1(Y0#4B&w6,/9&gG<bE,/O=zb}I4_l8<B/;wL%Qo<HO[Mq=XX}0v&BP&F4(mG}0i}nm,EC=9u{I3,xG&/9=JY*DK&hR)BX=EI=cx=b/{6k}yX%A+&wa}Xb=la;wi^lL;0t}jo&Qb=xg=XB}iO<qo{bR=NV&8f=a0&Jy;0v=uK)HK;vN#6h&jB(h/%ud&NI%wY.X7=Pt}Cu-uL&Gs_hl%mH,tm]78=Lb^Q0#7Y=1u<Bt&+Q=Co_RH,w3;1e}ux<aU;ui}U3&Q5%bt]63&UQ|0l&uL}O7&3o,AV&dm|Nj(Xt*5+(Uu&Hh(p7(UF=VR=Bp^Jl&Hd[ix)9/=Iq]C8<67]66}mB%6f}bb}JI]8T$HA}db=YM&pa=2J}tS&Y0=PS&y4=cX$6E,hX,XP&nR;04,FQ&l0&Vm_Dv#5Y~8Z=Bi%MA]6x=JO:+p,Az&9q,Hj~6/}SD=K1:EJ}nA;Qo#/E]9R,Ie&6X%W3]61&v4=xX_MC=0q;06(Xq=fs}IG}Dv=0l}o7$iZ;9v&LH&DP-7a&OY,SZ,Kz,Cv&dh=fx|Nh,F/~7q=XF&w+;9n&Gw;0h}Z7<7O&JK(S7&LS<AD<ac=wo<Dt&zw%4B=4v#8P;9o~6p*vV=Tm,Or&I6=1q}nY=P0=gq&Bl&Uu,Ch%yb}UY=zh}dh}rl(T4_xk(YA#8R*xH,IN}Jn]7V}C4&Ty}j3]7p=cL=3h&wW%Qv<Z3=f0&RI&+S(ic_zq}oN&/Y=z1;Td=LW=0e=OI(Vc,+b^ju(UL;0r:Za%8v=Rp=zw&58&73&wK}qX]6y&8E)a2}WR=wP^ur&nQ<cH}Re=Aq&wk}Q0&+q=PP,Gc|/d^k5,Fw]8Y}Pg]p3=ju=ed}r5_yf&Cs]7z$/G<Cm&Jp&54_1G_gP_Ll}JZ;0u]k8_7k(Sg]65{9i=LN&Sx&WK,iW&fD&Lk{9a}Em-9c#8N&io=sy]8d&nT&IK(lx#7/$lW(Td<s8~49,3o<7Y=MW(T+_Jr&Wd,iL}Ct=xh&5V;v4&8n%Kx=iF&l2_0B{B+,If(J0,Lv;u8=Kx-vB=HC&vS=Z6&fU&vE^xK;3D=4h=MR#45:Jw;0d}iw=LU}I5=I0]gB*im,K9}GU,1k_4U&Tt=Vs(iX&lU(TF#7y,ZO}oA&m5#5P}PN}Uz=hM<B1&FB<aG,e6~7T<tP(UQ_ZT=wu&F8)aQ]iN,1r_Lo&/g:CD}84{J1_Ki&Na&3n$jz&FE=dc;uv;va}in}ll=fv(h1&3h}fp=Cy}BM(+E~8m}lo%v7=hC(T6$cj=BQ=Bw(DR,2j=Ks,NS|F+;00=fU=70}Mb(YU;+G&m7&hr=Sk%Co]t+(X5_Jw}0r}gC(AS-IP&QK<Z2#8Q$WC]WX}T2&pG_Ka,HC=R4&/N;Z+;ch(C7,D4$3p_Mk&B2$8D=n9%Ky#5z(CT&QJ#7B]DC]gW}nf~5M;Iw#80}Tc_1F#4Z-aC}Hl=ph=fz,/3=aW}JM}nn;DG;vm}wn,4P}T3;wx&RG$u+}zK=0b;+J_Ek{re<aZ=AS}yY#5D]7q,Cp}xN=VP*2C}GZ}aG~+m_Cs=OY#6r]6g<GS}LC(UB=3A=Bo}Jy<c4}Is;1P<AG}Op<Z1}ld}nS=1Z,yM&95&98=CJ(4t:2L$Hk=Zo}Vc;+I}np&N1}9y=iv}CO*7p=jL)px]tb^zh&GS&Vl%v/;vR=14=zJ&49|/f]hF}WG;03=8P}o/&Gg&rp;DB,Kv}Ji&Pb;aA^ll(4j%yt}+K$Ht#4y&hY]7Y<F1,eN}bG(Uh%6Z]t5%G7;+F_RE;it}tL=LS&Da=Xx(S+(4f=8G=yI}cJ}WP=37=jS}pX}hd)fp<A8=Jt~+o$HJ=M6}iX=g9}CS=dv=Cj(mP%Kd,xq|+9&LD(4/=Xm&QP=Lc}LX&fL;+K=Op(lu=Qs.qC:+e&L+=Jj#8w;SL]7S(b+#4I=c1&nG_Lf&uH;+R)ZV<bV%B/,TE&0H&Jq&Ah%OF&Ss(p2,Wv&I3=Wl}Vq;1L&lJ#9b_1H=8r=b8=JH(SZ=hD=J2#7U,/U#/X~6P,FU<eL=jx,mG=hG=CE&PU=Se(qX&LY=X6=y4&tk&QQ&tf=4g&xI}W+&mZ=Dc#7w}Lg;DA;wQ_Kb(cJ=hR%yX&Yb,hw{bX_4X;EP;1W_2M}Uc=b5(YF,CM&Tp^OJ{DD]6s=vF=Yo~8q}XH}Fu%P5(SJ=Qt;MO]s8<F3&B3&8T(Ul-BS*dw&dR<87}/8]62$PZ]Lx<Au}9Q]7c=ja=KR,Go,Us&v6(qk}pG&G2=ev^GM%w4&H4]7F&dv]J6}Ew:9w=sj-ZL}Ym$+h(Ut(Um~4n=Xs(U7%eE=Qc_JR<CA#6t<Fv|/I,IS,EG<F2(Xy$/n<Fa(h9}+9_2o&N4#7X<Zq|+f_Dp=dt&na,Ca=NJ)jY=8C=YG=s6&Q+<DO}D3=xB&R1(lw;Qn<bF(Cu|/B}HV=SS&n7,10&u0]Dm%A6^4Q=WR(TD=Xo<GH,Rj(l8)bP&n/=LM&CF,F5&ml=PJ;0k=LG=tq,Rh,D6@4i=1p&+9=YC%er_Mh;nI;0q=Fw]80=xq=FM$Gv;v6&nc;wK%H2&Kj;vs,AA=YP,66}bI(qR~5U=6q~4b$Ni=K5.X3$So&Iu(p+]8G=Cf=RY(TS_O3(iH&57=fE=Dg_Do#9z#7H;FK{qd_2k%JR}en&gh_z8;Rx}9p<cN_Ne,DO;LN_7o~/p=NF=5Y}gN<ce<C1,QE]Wv=3u<BC}GK]yq}DY&u/_hj=II(pz&rC,jV&+Z}ut=NQ;Cg-SR_ZS,+o=u/;Oy_RK_QF(Fx&xP}Wr&TA,Uh&g1=yr{ax[VF$Pg(YB;Ox=Vy;+W(Sp}XV%dd&33(l/]l4#4Y}OE=6c=bw(A7&9t%wd&N/&mo,JH&Qe)fm=Ao}fu=tH";
  var deltaData = "FAZDC6BALcLZCA+GBARCW8wNCcDDZ8LVFBOqqDUiou+M42TFAyERXFb7EjhP+vmBFpFrUpfDV2F7eB+eCltCHJFWLFCED+pWTojEIHFXc3aFn4F68zqjEuKidS1QBVPDEhE7NA4mhMF7oThD49ot3FgtzHFCK0acW1x8DH1EmLoIlrWFBLE+y5+NA3Cx65wJHTaEZVaK1mWAmPGxgYCdxwOjTDIt/faOEhTl1vqNsKtJCOhJWuio2g07KLZEQsFBUpNtwEByBgxFslFheFbiEPvi61msDvApxCzB6rBCzox7joYA5UdDc+Cb4FSgIabpXFAj3bjkmFAxCZE+mD/SFf/0ELecYCt3nLoxC6WEZf2tKDB4oZvrEmqFkKk7BwILA7gtYBpsTq//D4jD0F0wEB9pyQ1BD5Ba0oYHDI+sbDFhvrHXdDHfgFEIJLi5r8qercNFBgFLC4bo5ERJtamWBDFy73KCEb6M8VpmEt330ygCTK58EIIFkYgF84gtGA9Uyh3m68iVrFbWFbcbqiCYHZ9J1jeRPbL8yswhMiDbhEhdNoSwFbZrLT740ABEqgCkO8J1BLd1VhKKR4sD1yUo0z+FF59Mvg71CFbyEhbHSFBKEIKyoQNgQppq9T0KAqePu0ZFGrXOHdKJqkoTFhYvpDNyuuznrN84thJbsCoO6Cu6Xlvntvy0QYuAExQEYtTUBf3CoCqwgGFZ4u1HJFzDVwEy3cjcpV4QvsPaBC3rCGyCF23o4K3pp2gberGgFEJEHo4nHICtyKH2ZqyxhN05KBBJIQlKh/Oujv/DH32VrlqFdIFC7Fz9Ct4kaqFME0UETLprnN9kfy+kFmtQBB0+5CFu0N9Ij8l/VvJDh2oq3hT6EzjTHKFN7ZjZwoTsAZ4Exsko6Fpa6WC+sduz8jyrLpegTv2h1EBeYpLpm2czQW0KoCcS0bCVXCmuWJDBjN1nQNLdF58SFJ0h7i3pC3oEOKy/FjBklL70XvBEEIWp2yZ04xObzAWDDJG7f+DbqBEA7LyiR95j7MDVdDViz2RE5vWlBMv5e4+VfhP3aXNPhvLSynb9O2x4uFBV+3jqu6d5pCG28/sETByvmu/+IJ0L3wb4rj9DNOLBF6XPIODr4L19U9RRofAG6Nxydi8Bki8BhGJbBAJKzbJxkZSlF9Q2Cu8oKqggB9hBArwLLqEBWEtFowy8XK8bEyw9snT+BeyFk1ZCSrdmgfEwFePTgCjELBEnIbjaDDPJm36rG9pztcEzT8dGk23SBhXBB1H4z+OWze0ooFzz8pDBYFvp9j9tvFByf9y4EFdVnz026CGR5qMr7fxMHN8UUdlyJAzlTBDRC28k+L4FB8078ljyD91tUj1ocnTs8vdEf7znbzm+GIjEZnoZE5rnLL700Xc7yHfz05nWxy03vBB9YGHYOWxgMQGBCR24CVYNE1hpfKxN0zKnfJDmmMgMmBWqNbjfSyFCBWSCGCgR8yFXiHyEj+VtD1FB3FpC1zI0kFbzifiKTLm9yq5zFmur+q8FHqjoOBWsBPiDbnCC2ErunV6cJ6TygXFYHYp7MKN9RUlSIS8/xBAGYLzeqUnBF4QbsTuUkUqGs6CaiDWKWjQK9EJkjpkTmNCPYXL";
  var wordlist8 = {
    zh_cn: null,
    zh_tw: null
  };
  var Checks = {
    zh_cn: "0x17bcc4d8547e5a7135e365d1ab443aaae95e76d8230c2782c67305d4f21497a1",
    zh_tw: "0x51e720e90c7b87bec1d70eb6e74a21a449bd3ec9c020b01d3a40ed991b60ce5d"
  };
  var codes2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  var style = "~!@#$%^&*_-=[]{}|;:,.()<>?";
  function loadWords8(lang) {
    if (wordlist8[lang.locale] !== null) {
      return;
    }
    wordlist8[lang.locale] = [];
    let deltaOffset = 0;
    for (let i3 = 0; i3 < 2048; i3++) {
      const s3 = style.indexOf(data3[i3 * 3]);
      const bytes = [
        228 + (s3 >> 2),
        128 + codes2.indexOf(data3[i3 * 3 + 1]),
        128 + codes2.indexOf(data3[i3 * 3 + 2])
      ];
      if (lang.locale === "zh_tw") {
        const common = s3 % 4;
        for (let i4 = common; i4 < 3; i4++) {
          bytes[i4] = codes2.indexOf(deltaData[deltaOffset++]) + (i4 == 0 ? 228 : 128);
        }
      }
      wordlist8[lang.locale].push(toUtf8String(bytes));
    }
    if (Wordlist.check(lang) !== Checks[lang.locale]) {
      wordlist8[lang.locale] = null;
      throw new Error("BIP39 Wordlist for " + lang.locale + " (Chinese) FAILED");
    }
  }
  var LangZh = class extends Wordlist {
    constructor(country) {
      super("zh_" + country);
    }
    getWord(index) {
      loadWords8(this);
      return wordlist8[this.locale][index];
    }
    getWordIndex(word) {
      loadWords8(this);
      return wordlist8[this.locale].indexOf(word);
    }
    split(mnemonic) {
      mnemonic = mnemonic.replace(/(?:\u3000| )+/g, "");
      return mnemonic.split("");
    }
  };
  var langZhCn = new LangZh("cn");
  Wordlist.register(langZhCn);
  Wordlist.register(langZhCn, "zh");
  var langZhTw = new LangZh("tw");
  Wordlist.register(langZhTw);

  // node_modules/@ethersproject/wordlists/lib.esm/wordlists.js
  var wordlists = {
    cz: langCz,
    en: langEn,
    es: langEs,
    fr: langFr,
    it: langIt,
    ja: langJa,
    ko: langKo,
    zh: langZhCn,
    zh_cn: langZhCn,
    zh_tw: langZhTw
  };

  // node_modules/@ethersproject/wordlists/lib.esm/index.js
  "use strict";

  // node_modules/@ethersproject/hdnode/lib.esm/_version.js
  var version17 = "hdnode/5.4.0";

  // node_modules/@ethersproject/hdnode/lib.esm/index.js
  "use strict";
  var logger22 = new Logger(version17);
  var N = BigNumber.from("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
  var MasterSecret = toUtf8Bytes("Bitcoin seed");
  var HardenedBit = 2147483648;
  function getUpperMask(bits) {
    return (1 << bits) - 1 << 8 - bits;
  }
  function getLowerMask(bits) {
    return (1 << bits) - 1;
  }
  function bytes32(value) {
    return hexZeroPad(hexlify(value), 32);
  }
  function base58check(data4) {
    return Base58.encode(concat([data4, hexDataSlice(sha256(sha256(data4)), 0, 4)]));
  }
  function getWordlist(wordlist9) {
    if (wordlist9 == null) {
      return wordlists["en"];
    }
    if (typeof wordlist9 === "string") {
      const words6 = wordlists[wordlist9];
      if (words6 == null) {
        logger22.throwArgumentError("unknown locale", "wordlist", wordlist9);
      }
      return words6;
    }
    return wordlist9;
  }
  var _constructorGuard4 = {};
  var defaultPath = "m/44'/60'/0'/0/0";
  var HDNode = class {
    constructor(constructorGuard, privateKey, publicKey, parentFingerprint, chainCode, index, depth, mnemonicOrPath) {
      logger22.checkNew(new.target, HDNode);
      if (constructorGuard !== _constructorGuard4) {
        throw new Error("HDNode constructor cannot be called directly");
      }
      if (privateKey) {
        const signingKey = new SigningKey(privateKey);
        defineReadOnly(this, "privateKey", signingKey.privateKey);
        defineReadOnly(this, "publicKey", signingKey.compressedPublicKey);
      } else {
        defineReadOnly(this, "privateKey", null);
        defineReadOnly(this, "publicKey", hexlify(publicKey));
      }
      defineReadOnly(this, "parentFingerprint", parentFingerprint);
      defineReadOnly(this, "fingerprint", hexDataSlice(ripemd160(sha256(this.publicKey)), 0, 4));
      defineReadOnly(this, "address", computeAddress(this.publicKey));
      defineReadOnly(this, "chainCode", chainCode);
      defineReadOnly(this, "index", index);
      defineReadOnly(this, "depth", depth);
      if (mnemonicOrPath == null) {
        defineReadOnly(this, "mnemonic", null);
        defineReadOnly(this, "path", null);
      } else if (typeof mnemonicOrPath === "string") {
        defineReadOnly(this, "mnemonic", null);
        defineReadOnly(this, "path", mnemonicOrPath);
      } else {
        defineReadOnly(this, "mnemonic", mnemonicOrPath);
        defineReadOnly(this, "path", mnemonicOrPath.path);
      }
    }
    get extendedKey() {
      if (this.depth >= 256) {
        throw new Error("Depth too large!");
      }
      return base58check(concat([
        this.privateKey != null ? "0x0488ADE4" : "0x0488B21E",
        hexlify(this.depth),
        this.parentFingerprint,
        hexZeroPad(hexlify(this.index), 4),
        this.chainCode,
        this.privateKey != null ? concat(["0x00", this.privateKey]) : this.publicKey
      ]));
    }
    neuter() {
      return new HDNode(_constructorGuard4, null, this.publicKey, this.parentFingerprint, this.chainCode, this.index, this.depth, this.path);
    }
    _derive(index) {
      if (index > 4294967295) {
        throw new Error("invalid index - " + String(index));
      }
      let path = this.path;
      if (path) {
        path += "/" + (index & ~HardenedBit);
      }
      const data4 = new Uint8Array(37);
      if (index & HardenedBit) {
        if (!this.privateKey) {
          throw new Error("cannot derive child of neutered node");
        }
        data4.set(arrayify(this.privateKey), 1);
        if (path) {
          path += "'";
        }
      } else {
        data4.set(arrayify(this.publicKey));
      }
      for (let i3 = 24; i3 >= 0; i3 -= 8) {
        data4[33 + (i3 >> 3)] = index >> 24 - i3 & 255;
      }
      const I3 = arrayify(computeHmac(SupportedAlgorithm.sha512, this.chainCode, data4));
      const IL = I3.slice(0, 32);
      const IR = I3.slice(32);
      let ki = null;
      let Ki = null;
      if (this.privateKey) {
        ki = bytes32(BigNumber.from(IL).add(this.privateKey).mod(N));
      } else {
        const ek = new SigningKey(hexlify(IL));
        Ki = ek._addPoint(this.publicKey);
      }
      let mnemonicOrPath = path;
      const srcMnemonic = this.mnemonic;
      if (srcMnemonic) {
        mnemonicOrPath = Object.freeze({
          phrase: srcMnemonic.phrase,
          path,
          locale: srcMnemonic.locale || "en"
        });
      }
      return new HDNode(_constructorGuard4, ki, Ki, this.fingerprint, bytes32(IR), index, this.depth + 1, mnemonicOrPath);
    }
    derivePath(path) {
      const components = path.split("/");
      if (components.length === 0 || components[0] === "m" && this.depth !== 0) {
        throw new Error("invalid path - " + path);
      }
      if (components[0] === "m") {
        components.shift();
      }
      let result = this;
      for (let i3 = 0; i3 < components.length; i3++) {
        const component = components[i3];
        if (component.match(/^[0-9]+'$/)) {
          const index = parseInt(component.substring(0, component.length - 1));
          if (index >= HardenedBit) {
            throw new Error("invalid path index - " + component);
          }
          result = result._derive(HardenedBit + index);
        } else if (component.match(/^[0-9]+$/)) {
          const index = parseInt(component);
          if (index >= HardenedBit) {
            throw new Error("invalid path index - " + component);
          }
          result = result._derive(index);
        } else {
          throw new Error("invalid path component - " + component);
        }
      }
      return result;
    }
    static _fromSeed(seed, mnemonic) {
      const seedArray = arrayify(seed);
      if (seedArray.length < 16 || seedArray.length > 64) {
        throw new Error("invalid seed");
      }
      const I3 = arrayify(computeHmac(SupportedAlgorithm.sha512, MasterSecret, seedArray));
      return new HDNode(_constructorGuard4, bytes32(I3.slice(0, 32)), null, "0x00000000", bytes32(I3.slice(32)), 0, 0, mnemonic);
    }
    static fromMnemonic(mnemonic, password, wordlist9) {
      wordlist9 = getWordlist(wordlist9);
      mnemonic = entropyToMnemonic(mnemonicToEntropy(mnemonic, wordlist9), wordlist9);
      return HDNode._fromSeed(mnemonicToSeed(mnemonic, password), {
        phrase: mnemonic,
        path: "m",
        locale: wordlist9.locale
      });
    }
    static fromSeed(seed) {
      return HDNode._fromSeed(seed, null);
    }
    static fromExtendedKey(extendedKey) {
      const bytes = Base58.decode(extendedKey);
      if (bytes.length !== 82 || base58check(bytes.slice(0, 78)) !== extendedKey) {
        logger22.throwArgumentError("invalid extended key", "extendedKey", "[REDACTED]");
      }
      const depth = bytes[4];
      const parentFingerprint = hexlify(bytes.slice(5, 9));
      const index = parseInt(hexlify(bytes.slice(9, 13)).substring(2), 16);
      const chainCode = hexlify(bytes.slice(13, 45));
      const key2 = bytes.slice(45, 78);
      switch (hexlify(bytes.slice(0, 4))) {
        case "0x0488b21e":
        case "0x043587cf":
          return new HDNode(_constructorGuard4, null, hexlify(key2), parentFingerprint, chainCode, index, depth, null);
        case "0x0488ade4":
        case "0x04358394 ":
          if (key2[0] !== 0) {
            break;
          }
          return new HDNode(_constructorGuard4, hexlify(key2.slice(1)), null, parentFingerprint, chainCode, index, depth, null);
      }
      return logger22.throwArgumentError("invalid extended key", "extendedKey", "[REDACTED]");
    }
  };
  function mnemonicToSeed(mnemonic, password) {
    if (!password) {
      password = "";
    }
    const salt = toUtf8Bytes("mnemonic" + password, UnicodeNormalizationForm.NFKD);
    return pbkdf2(toUtf8Bytes(mnemonic, UnicodeNormalizationForm.NFKD), salt, 2048, 64, "sha512");
  }
  function mnemonicToEntropy(mnemonic, wordlist9) {
    wordlist9 = getWordlist(wordlist9);
    logger22.checkNormalize();
    const words6 = wordlist9.split(mnemonic);
    if (words6.length % 3 !== 0) {
      throw new Error("invalid mnemonic");
    }
    const entropy = arrayify(new Uint8Array(Math.ceil(11 * words6.length / 8)));
    let offset = 0;
    for (let i3 = 0; i3 < words6.length; i3++) {
      let index = wordlist9.getWordIndex(words6[i3].normalize("NFKD"));
      if (index === -1) {
        throw new Error("invalid mnemonic");
      }
      for (let bit = 0; bit < 11; bit++) {
        if (index & 1 << 10 - bit) {
          entropy[offset >> 3] |= 1 << 7 - offset % 8;
        }
        offset++;
      }
    }
    const entropyBits = 32 * words6.length / 3;
    const checksumBits = words6.length / 3;
    const checksumMask = getUpperMask(checksumBits);
    const checksum = arrayify(sha256(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;
    if (checksum !== (entropy[entropy.length - 1] & checksumMask)) {
      throw new Error("invalid checksum");
    }
    return hexlify(entropy.slice(0, entropyBits / 8));
  }
  function entropyToMnemonic(entropy, wordlist9) {
    wordlist9 = getWordlist(wordlist9);
    entropy = arrayify(entropy);
    if (entropy.length % 4 !== 0 || entropy.length < 16 || entropy.length > 32) {
      throw new Error("invalid entropy");
    }
    const indices = [0];
    let remainingBits = 11;
    for (let i3 = 0; i3 < entropy.length; i3++) {
      if (remainingBits > 8) {
        indices[indices.length - 1] <<= 8;
        indices[indices.length - 1] |= entropy[i3];
        remainingBits -= 8;
      } else {
        indices[indices.length - 1] <<= remainingBits;
        indices[indices.length - 1] |= entropy[i3] >> 8 - remainingBits;
        indices.push(entropy[i3] & getLowerMask(8 - remainingBits));
        remainingBits += 3;
      }
    }
    const checksumBits = entropy.length / 4;
    const checksum = arrayify(sha256(entropy))[0] & getUpperMask(checksumBits);
    indices[indices.length - 1] <<= checksumBits;
    indices[indices.length - 1] |= checksum >> 8 - checksumBits;
    return wordlist9.join(indices.map((index) => wordlist9.getWord(index)));
  }
  function isValidMnemonic(mnemonic, wordlist9) {
    try {
      mnemonicToEntropy(mnemonic, wordlist9);
      return true;
    } catch (error) {
    }
    return false;
  }
  function getAccountPath(index) {
    if (typeof index !== "number" || index < 0 || index >= HardenedBit || index % 1) {
      logger22.throwArgumentError("invalid account index", "index", index);
    }
    return `m/44'/60'/${index}'/0/0`;
  }

  // node_modules/@ethersproject/random/lib.esm/_version.js
  var version18 = "random/5.4.0";

  // node_modules/@ethersproject/random/lib.esm/random.js
  "use strict";
  var logger23 = new Logger(version18);
  var anyGlobal = null;
  try {
    anyGlobal = window;
    if (anyGlobal == null) {
      throw new Error("try next");
    }
  } catch (error) {
    try {
      anyGlobal = global;
      if (anyGlobal == null) {
        throw new Error("try next");
      }
    } catch (error2) {
      anyGlobal = {};
    }
  }
  var crypto = anyGlobal.crypto || anyGlobal.msCrypto;
  if (!crypto || !crypto.getRandomValues) {
    logger23.warn("WARNING: Missing strong random number source");
    crypto = {
      getRandomValues: function(buffer) {
        return logger23.throwError("no secure random source avaialble", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "crypto.getRandomValues"
        });
      }
    };
  }
  function randomBytes(length) {
    if (length <= 0 || length > 1024 || length % 1) {
      logger23.throwArgumentError("invalid length", "length", length);
    }
    const result = new Uint8Array(length);
    crypto.getRandomValues(result);
    return arrayify(result);
  }

  // node_modules/@ethersproject/random/lib.esm/shuffle.js
  "use strict";
  function shuffled(array) {
    array = array.slice();
    for (let i3 = array.length - 1; i3 > 0; i3--) {
      const j3 = Math.floor(Math.random() * (i3 + 1));
      const tmp = array[i3];
      array[i3] = array[j3];
      array[j3] = tmp;
    }
    return array;
  }

  // node_modules/@ethersproject/random/lib.esm/index.js
  "use strict";

  // node_modules/@ethersproject/json-wallets/lib.esm/crowdsale.js
  var import_aes_js = __toModule(require_aes_js());

  // node_modules/@ethersproject/json-wallets/lib.esm/_version.js
  var version19 = "json-wallets/5.4.0";

  // node_modules/@ethersproject/json-wallets/lib.esm/utils.js
  "use strict";
  function looseArrayify(hexString) {
    if (typeof hexString === "string" && hexString.substring(0, 2) !== "0x") {
      hexString = "0x" + hexString;
    }
    return arrayify(hexString);
  }
  function zpad(value, length) {
    value = String(value);
    while (value.length < length) {
      value = "0" + value;
    }
    return value;
  }
  function getPassword(password) {
    if (typeof password === "string") {
      return toUtf8Bytes(password, UnicodeNormalizationForm.NFKC);
    }
    return arrayify(password);
  }
  function searchPath(object, path) {
    let currentChild = object;
    const comps = path.toLowerCase().split("/");
    for (let i3 = 0; i3 < comps.length; i3++) {
      let matchingChild = null;
      for (const key2 in currentChild) {
        if (key2.toLowerCase() === comps[i3]) {
          matchingChild = currentChild[key2];
          break;
        }
      }
      if (matchingChild === null) {
        return null;
      }
      currentChild = matchingChild;
    }
    return currentChild;
  }
  function uuidV4(randomBytes3) {
    const bytes = arrayify(randomBytes3);
    bytes[6] = bytes[6] & 15 | 64;
    bytes[8] = bytes[8] & 63 | 128;
    const value = hexlify(bytes);
    return [
      value.substring(2, 10),
      value.substring(10, 14),
      value.substring(14, 18),
      value.substring(18, 22),
      value.substring(22, 34)
    ].join("-");
  }

  // node_modules/@ethersproject/json-wallets/lib.esm/crowdsale.js
  "use strict";
  var logger24 = new Logger(version19);
  var CrowdsaleAccount = class extends Description {
    isCrowdsaleAccount(value) {
      return !!(value && value._isCrowdsaleAccount);
    }
  };
  function decrypt(json, password) {
    const data4 = JSON.parse(json);
    password = getPassword(password);
    const ethaddr = getAddress(searchPath(data4, "ethaddr"));
    const encseed = looseArrayify(searchPath(data4, "encseed"));
    if (!encseed || encseed.length % 16 !== 0) {
      logger24.throwArgumentError("invalid encseed", "json", json);
    }
    const key2 = arrayify(pbkdf2(password, password, 2e3, 32, "sha256")).slice(0, 16);
    const iv = encseed.slice(0, 16);
    const encryptedSeed = encseed.slice(16);
    const aesCbc = new import_aes_js.default.ModeOfOperation.cbc(key2, iv);
    const seed = import_aes_js.default.padding.pkcs7.strip(arrayify(aesCbc.decrypt(encryptedSeed)));
    let seedHex = "";
    for (let i3 = 0; i3 < seed.length; i3++) {
      seedHex += String.fromCharCode(seed[i3]);
    }
    const seedHexBytes = toUtf8Bytes(seedHex);
    const privateKey = keccak256(seedHexBytes);
    return new CrowdsaleAccount({
      _isCrowdsaleAccount: true,
      address: ethaddr,
      privateKey
    });
  }

  // node_modules/@ethersproject/json-wallets/lib.esm/inspect.js
  "use strict";
  function isCrowdsaleWallet(json) {
    let data4 = null;
    try {
      data4 = JSON.parse(json);
    } catch (error) {
      return false;
    }
    return data4.encseed && data4.ethaddr;
  }
  function isKeystoreWallet(json) {
    let data4 = null;
    try {
      data4 = JSON.parse(json);
    } catch (error) {
      return false;
    }
    if (!data4.version || parseInt(data4.version) !== data4.version || parseInt(data4.version) !== 3) {
      return false;
    }
    return true;
  }
  function getJsonWalletAddress(json) {
    if (isCrowdsaleWallet(json)) {
      try {
        return getAddress(JSON.parse(json).ethaddr);
      } catch (error) {
        return null;
      }
    }
    if (isKeystoreWallet(json)) {
      try {
        return getAddress(JSON.parse(json).address);
      } catch (error) {
        return null;
      }
    }
    return null;
  }

  // node_modules/@ethersproject/json-wallets/lib.esm/keystore.js
  var import_aes_js2 = __toModule(require_aes_js());
  var import_scrypt_js = __toModule(require_scrypt());
  "use strict";
  var __awaiter6 = function(thisArg, _arguments, P3, generator) {
    function adopt(value) {
      return value instanceof P3 ? value : new P3(function(resolve) {
        resolve(value);
      });
    }
    return new (P3 || (P3 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e3) {
          reject(e3);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e3) {
          reject(e3);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var logger25 = new Logger(version19);
  function hasMnemonic(value) {
    return value != null && value.mnemonic && value.mnemonic.phrase;
  }
  var KeystoreAccount = class extends Description {
    isKeystoreAccount(value) {
      return !!(value && value._isKeystoreAccount);
    }
  };
  function _decrypt(data4, key2, ciphertext) {
    const cipher = searchPath(data4, "crypto/cipher");
    if (cipher === "aes-128-ctr") {
      const iv = looseArrayify(searchPath(data4, "crypto/cipherparams/iv"));
      const counter = new import_aes_js2.default.Counter(iv);
      const aesCtr = new import_aes_js2.default.ModeOfOperation.ctr(key2, counter);
      return arrayify(aesCtr.decrypt(ciphertext));
    }
    return null;
  }
  function _getAccount(data4, key2) {
    const ciphertext = looseArrayify(searchPath(data4, "crypto/ciphertext"));
    const computedMAC = hexlify(keccak256(concat([key2.slice(16, 32), ciphertext]))).substring(2);
    if (computedMAC !== searchPath(data4, "crypto/mac").toLowerCase()) {
      throw new Error("invalid password");
    }
    const privateKey = _decrypt(data4, key2.slice(0, 16), ciphertext);
    if (!privateKey) {
      logger25.throwError("unsupported cipher", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "decrypt"
      });
    }
    const mnemonicKey = key2.slice(32, 64);
    const address = computeAddress(privateKey);
    if (data4.address) {
      let check = data4.address.toLowerCase();
      if (check.substring(0, 2) !== "0x") {
        check = "0x" + check;
      }
      if (getAddress(check) !== address) {
        throw new Error("address mismatch");
      }
    }
    const account = {
      _isKeystoreAccount: true,
      address,
      privateKey: hexlify(privateKey)
    };
    if (searchPath(data4, "x-ethers/version") === "0.1") {
      const mnemonicCiphertext = looseArrayify(searchPath(data4, "x-ethers/mnemonicCiphertext"));
      const mnemonicIv = looseArrayify(searchPath(data4, "x-ethers/mnemonicCounter"));
      const mnemonicCounter = new import_aes_js2.default.Counter(mnemonicIv);
      const mnemonicAesCtr = new import_aes_js2.default.ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);
      const path = searchPath(data4, "x-ethers/path") || defaultPath;
      const locale = searchPath(data4, "x-ethers/locale") || "en";
      const entropy = arrayify(mnemonicAesCtr.decrypt(mnemonicCiphertext));
      try {
        const mnemonic = entropyToMnemonic(entropy, locale);
        const node = HDNode.fromMnemonic(mnemonic, null, locale).derivePath(path);
        if (node.privateKey != account.privateKey) {
          throw new Error("mnemonic mismatch");
        }
        account.mnemonic = node.mnemonic;
      } catch (error) {
        if (error.code !== Logger.errors.INVALID_ARGUMENT || error.argument !== "wordlist") {
          throw error;
        }
      }
    }
    return new KeystoreAccount(account);
  }
  function pbkdf2Sync(passwordBytes, salt, count, dkLen, prfFunc) {
    return arrayify(pbkdf2(passwordBytes, salt, count, dkLen, prfFunc));
  }
  function pbkdf22(passwordBytes, salt, count, dkLen, prfFunc) {
    return Promise.resolve(pbkdf2Sync(passwordBytes, salt, count, dkLen, prfFunc));
  }
  function _computeKdfKey(data4, password, pbkdf2Func, scryptFunc, progressCallback) {
    const passwordBytes = getPassword(password);
    const kdf = searchPath(data4, "crypto/kdf");
    if (kdf && typeof kdf === "string") {
      const throwError = function(name2, value) {
        return logger25.throwArgumentError("invalid key-derivation function parameters", name2, value);
      };
      if (kdf.toLowerCase() === "scrypt") {
        const salt = looseArrayify(searchPath(data4, "crypto/kdfparams/salt"));
        const N4 = parseInt(searchPath(data4, "crypto/kdfparams/n"));
        const r3 = parseInt(searchPath(data4, "crypto/kdfparams/r"));
        const p3 = parseInt(searchPath(data4, "crypto/kdfparams/p"));
        if (!N4 || !r3 || !p3) {
          throwError("kdf", kdf);
        }
        if ((N4 & N4 - 1) !== 0) {
          throwError("N", N4);
        }
        const dkLen = parseInt(searchPath(data4, "crypto/kdfparams/dklen"));
        if (dkLen !== 32) {
          throwError("dklen", dkLen);
        }
        return scryptFunc(passwordBytes, salt, N4, r3, p3, 64, progressCallback);
      } else if (kdf.toLowerCase() === "pbkdf2") {
        const salt = looseArrayify(searchPath(data4, "crypto/kdfparams/salt"));
        let prfFunc = null;
        const prf = searchPath(data4, "crypto/kdfparams/prf");
        if (prf === "hmac-sha256") {
          prfFunc = "sha256";
        } else if (prf === "hmac-sha512") {
          prfFunc = "sha512";
        } else {
          throwError("prf", prf);
        }
        const count = parseInt(searchPath(data4, "crypto/kdfparams/c"));
        const dkLen = parseInt(searchPath(data4, "crypto/kdfparams/dklen"));
        if (dkLen !== 32) {
          throwError("dklen", dkLen);
        }
        return pbkdf2Func(passwordBytes, salt, count, dkLen, prfFunc);
      }
    }
    return logger25.throwArgumentError("unsupported key-derivation function", "kdf", kdf);
  }
  function decryptSync(json, password) {
    const data4 = JSON.parse(json);
    const key2 = _computeKdfKey(data4, password, pbkdf2Sync, import_scrypt_js.default.syncScrypt);
    return _getAccount(data4, key2);
  }
  function decrypt2(json, password, progressCallback) {
    return __awaiter6(this, void 0, void 0, function* () {
      const data4 = JSON.parse(json);
      const key2 = yield _computeKdfKey(data4, password, pbkdf22, import_scrypt_js.default.scrypt, progressCallback);
      return _getAccount(data4, key2);
    });
  }
  function encrypt(account, password, options, progressCallback) {
    try {
      if (getAddress(account.address) !== computeAddress(account.privateKey)) {
        throw new Error("address/privateKey mismatch");
      }
      if (hasMnemonic(account)) {
        const mnemonic = account.mnemonic;
        const node = HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path || defaultPath);
        if (node.privateKey != account.privateKey) {
          throw new Error("mnemonic mismatch");
        }
      }
    } catch (e3) {
      return Promise.reject(e3);
    }
    if (typeof options === "function" && !progressCallback) {
      progressCallback = options;
      options = {};
    }
    if (!options) {
      options = {};
    }
    const privateKey = arrayify(account.privateKey);
    const passwordBytes = getPassword(password);
    let entropy = null;
    let path = null;
    let locale = null;
    if (hasMnemonic(account)) {
      const srcMnemonic = account.mnemonic;
      entropy = arrayify(mnemonicToEntropy(srcMnemonic.phrase, srcMnemonic.locale || "en"));
      path = srcMnemonic.path || defaultPath;
      locale = srcMnemonic.locale || "en";
    }
    let client = options.client;
    if (!client) {
      client = "ethers.js";
    }
    let salt = null;
    if (options.salt) {
      salt = arrayify(options.salt);
    } else {
      salt = randomBytes(32);
      ;
    }
    let iv = null;
    if (options.iv) {
      iv = arrayify(options.iv);
      if (iv.length !== 16) {
        throw new Error("invalid iv");
      }
    } else {
      iv = randomBytes(16);
    }
    let uuidRandom = null;
    if (options.uuid) {
      uuidRandom = arrayify(options.uuid);
      if (uuidRandom.length !== 16) {
        throw new Error("invalid uuid");
      }
    } else {
      uuidRandom = randomBytes(16);
    }
    let N4 = 1 << 17, r3 = 8, p3 = 1;
    if (options.scrypt) {
      if (options.scrypt.N) {
        N4 = options.scrypt.N;
      }
      if (options.scrypt.r) {
        r3 = options.scrypt.r;
      }
      if (options.scrypt.p) {
        p3 = options.scrypt.p;
      }
    }
    return import_scrypt_js.default.scrypt(passwordBytes, salt, N4, r3, p3, 64, progressCallback).then((key2) => {
      key2 = arrayify(key2);
      const derivedKey = key2.slice(0, 16);
      const macPrefix = key2.slice(16, 32);
      const mnemonicKey = key2.slice(32, 64);
      const counter = new import_aes_js2.default.Counter(iv);
      const aesCtr = new import_aes_js2.default.ModeOfOperation.ctr(derivedKey, counter);
      const ciphertext = arrayify(aesCtr.encrypt(privateKey));
      const mac = keccak256(concat([macPrefix, ciphertext]));
      const data4 = {
        address: account.address.substring(2).toLowerCase(),
        id: uuidV4(uuidRandom),
        version: 3,
        Crypto: {
          cipher: "aes-128-ctr",
          cipherparams: {
            iv: hexlify(iv).substring(2)
          },
          ciphertext: hexlify(ciphertext).substring(2),
          kdf: "scrypt",
          kdfparams: {
            salt: hexlify(salt).substring(2),
            n: N4,
            dklen: 32,
            p: p3,
            r: r3
          },
          mac: mac.substring(2)
        }
      };
      if (entropy) {
        const mnemonicIv = randomBytes(16);
        const mnemonicCounter = new import_aes_js2.default.Counter(mnemonicIv);
        const mnemonicAesCtr = new import_aes_js2.default.ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);
        const mnemonicCiphertext = arrayify(mnemonicAesCtr.encrypt(entropy));
        const now2 = new Date();
        const timestamp = now2.getUTCFullYear() + "-" + zpad(now2.getUTCMonth() + 1, 2) + "-" + zpad(now2.getUTCDate(), 2) + "T" + zpad(now2.getUTCHours(), 2) + "-" + zpad(now2.getUTCMinutes(), 2) + "-" + zpad(now2.getUTCSeconds(), 2) + ".0Z";
        data4["x-ethers"] = {
          client,
          gethFilename: "UTC--" + timestamp + "--" + data4.address,
          mnemonicCounter: hexlify(mnemonicIv).substring(2),
          mnemonicCiphertext: hexlify(mnemonicCiphertext).substring(2),
          path,
          locale,
          version: "0.1"
        };
      }
      return JSON.stringify(data4);
    });
  }

  // node_modules/@ethersproject/json-wallets/lib.esm/index.js
  "use strict";
  function decryptJsonWallet(json, password, progressCallback) {
    if (isCrowdsaleWallet(json)) {
      if (progressCallback) {
        progressCallback(0);
      }
      const account = decrypt(json, password);
      if (progressCallback) {
        progressCallback(1);
      }
      return Promise.resolve(account);
    }
    if (isKeystoreWallet(json)) {
      return decrypt2(json, password, progressCallback);
    }
    return Promise.reject(new Error("invalid JSON wallet"));
  }
  function decryptJsonWalletSync(json, password) {
    if (isCrowdsaleWallet(json)) {
      return decrypt(json, password);
    }
    if (isKeystoreWallet(json)) {
      return decryptSync(json, password);
    }
    throw new Error("invalid JSON wallet");
  }

  // node_modules/@ethersproject/wallet/lib.esm/_version.js
  var version20 = "wallet/5.4.0";

  // node_modules/@ethersproject/wallet/lib.esm/index.js
  "use strict";
  var __awaiter7 = function(thisArg, _arguments, P3, generator) {
    function adopt(value) {
      return value instanceof P3 ? value : new P3(function(resolve) {
        resolve(value);
      });
    }
    return new (P3 || (P3 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e3) {
          reject(e3);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e3) {
          reject(e3);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var logger26 = new Logger(version20);
  function isAccount(value) {
    return value != null && isHexString(value.privateKey, 32) && value.address != null;
  }
  function hasMnemonic2(value) {
    const mnemonic = value.mnemonic;
    return mnemonic && mnemonic.phrase;
  }
  var Wallet = class extends Signer {
    constructor(privateKey, provider) {
      logger26.checkNew(new.target, Wallet);
      super();
      if (isAccount(privateKey)) {
        const signingKey = new SigningKey(privateKey.privateKey);
        defineReadOnly(this, "_signingKey", () => signingKey);
        defineReadOnly(this, "address", computeAddress(this.publicKey));
        if (this.address !== getAddress(privateKey.address)) {
          logger26.throwArgumentError("privateKey/address mismatch", "privateKey", "[REDACTED]");
        }
        if (hasMnemonic2(privateKey)) {
          const srcMnemonic = privateKey.mnemonic;
          defineReadOnly(this, "_mnemonic", () => ({
            phrase: srcMnemonic.phrase,
            path: srcMnemonic.path || defaultPath,
            locale: srcMnemonic.locale || "en"
          }));
          const mnemonic = this.mnemonic;
          const node = HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path);
          if (computeAddress(node.privateKey) !== this.address) {
            logger26.throwArgumentError("mnemonic/address mismatch", "privateKey", "[REDACTED]");
          }
        } else {
          defineReadOnly(this, "_mnemonic", () => null);
        }
      } else {
        if (SigningKey.isSigningKey(privateKey)) {
          if (privateKey.curve !== "secp256k1") {
            logger26.throwArgumentError("unsupported curve; must be secp256k1", "privateKey", "[REDACTED]");
          }
          defineReadOnly(this, "_signingKey", () => privateKey);
        } else {
          if (typeof privateKey === "string") {
            if (privateKey.match(/^[0-9a-f]*$/i) && privateKey.length === 64) {
              privateKey = "0x" + privateKey;
            }
          }
          const signingKey = new SigningKey(privateKey);
          defineReadOnly(this, "_signingKey", () => signingKey);
        }
        defineReadOnly(this, "_mnemonic", () => null);
        defineReadOnly(this, "address", computeAddress(this.publicKey));
      }
      if (provider && !Provider.isProvider(provider)) {
        logger26.throwArgumentError("invalid provider", "provider", provider);
      }
      defineReadOnly(this, "provider", provider || null);
    }
    get mnemonic() {
      return this._mnemonic();
    }
    get privateKey() {
      return this._signingKey().privateKey;
    }
    get publicKey() {
      return this._signingKey().publicKey;
    }
    getAddress() {
      return Promise.resolve(this.address);
    }
    connect(provider) {
      return new Wallet(this, provider);
    }
    signTransaction(transaction) {
      return resolveProperties(transaction).then((tx) => {
        if (tx.from != null) {
          if (getAddress(tx.from) !== this.address) {
            logger26.throwArgumentError("transaction from address mismatch", "transaction.from", transaction.from);
          }
          delete tx.from;
        }
        const signature2 = this._signingKey().signDigest(keccak256(serialize(tx)));
        return serialize(tx, signature2);
      });
    }
    signMessage(message) {
      return __awaiter7(this, void 0, void 0, function* () {
        return joinSignature(this._signingKey().signDigest(hashMessage(message)));
      });
    }
    _signTypedData(domain2, types, value) {
      return __awaiter7(this, void 0, void 0, function* () {
        const populated = yield TypedDataEncoder.resolveNames(domain2, types, value, (name2) => {
          if (this.provider == null) {
            logger26.throwError("cannot resolve ENS names without a provider", Logger.errors.UNSUPPORTED_OPERATION, {
              operation: "resolveName",
              value: name2
            });
          }
          return this.provider.resolveName(name2);
        });
        return joinSignature(this._signingKey().signDigest(TypedDataEncoder.hash(populated.domain, types, populated.value)));
      });
    }
    encrypt(password, options, progressCallback) {
      if (typeof options === "function" && !progressCallback) {
        progressCallback = options;
        options = {};
      }
      if (progressCallback && typeof progressCallback !== "function") {
        throw new Error("invalid callback");
      }
      if (!options) {
        options = {};
      }
      return encrypt(this, password, options, progressCallback);
    }
    static createRandom(options) {
      let entropy = randomBytes(16);
      if (!options) {
        options = {};
      }
      if (options.extraEntropy) {
        entropy = arrayify(hexDataSlice(keccak256(concat([entropy, options.extraEntropy])), 0, 16));
      }
      const mnemonic = entropyToMnemonic(entropy, options.locale);
      return Wallet.fromMnemonic(mnemonic, options.path, options.locale);
    }
    static fromEncryptedJson(json, password, progressCallback) {
      return decryptJsonWallet(json, password, progressCallback).then((account) => {
        return new Wallet(account);
      });
    }
    static fromEncryptedJsonSync(json, password) {
      return new Wallet(decryptJsonWalletSync(json, password));
    }
    static fromMnemonic(mnemonic, path, wordlist9) {
      if (!path) {
        path = defaultPath;
      }
      return new Wallet(HDNode.fromMnemonic(mnemonic, null, wordlist9).derivePath(path));
    }
  };
  function verifyMessage(message, signature2) {
    return recoverAddress(hashMessage(message), signature2);
  }
  function verifyTypedData(domain2, types, value, signature2) {
    return recoverAddress(TypedDataEncoder.hash(domain2, types, value), signature2);
  }

  // node_modules/@ethersproject/providers/lib.esm/index.js
  var lib_exports4 = {};
  __export(lib_exports4, {
    AlchemyProvider: () => AlchemyProvider,
    AlchemyWebSocketProvider: () => AlchemyWebSocketProvider,
    BaseProvider: () => BaseProvider,
    CloudflareProvider: () => CloudflareProvider,
    EtherscanProvider: () => EtherscanProvider,
    FallbackProvider: () => FallbackProvider,
    Formatter: () => Formatter,
    InfuraProvider: () => InfuraProvider,
    InfuraWebSocketProvider: () => InfuraWebSocketProvider,
    IpcProvider: () => IpcProvider,
    JsonRpcBatchProvider: () => JsonRpcBatchProvider,
    JsonRpcProvider: () => JsonRpcProvider,
    JsonRpcSigner: () => JsonRpcSigner,
    NodesmithProvider: () => NodesmithProvider,
    PocketProvider: () => PocketProvider,
    Provider: () => Provider,
    Resolver: () => Resolver,
    StaticJsonRpcProvider: () => StaticJsonRpcProvider,
    UrlJsonRpcProvider: () => UrlJsonRpcProvider,
    Web3Provider: () => Web3Provider,
    WebSocketProvider: () => WebSocketProvider,
    getDefaultProvider: () => getDefaultProvider,
    getNetwork: () => getNetwork,
    isCommunityResourcable: () => isCommunityResourcable,
    isCommunityResource: () => isCommunityResource,
    showThrottleMessage: () => showThrottleMessage
  });

  // node_modules/@ethersproject/networks/lib.esm/_version.js
  var version21 = "networks/5.4.2";

  // node_modules/@ethersproject/networks/lib.esm/index.js
  "use strict";
  var logger27 = new Logger(version21);
  function isRenetworkable(value) {
    return value && typeof value.renetwork === "function";
  }
  function ethDefaultProvider(network) {
    const func = function(providers, options) {
      if (options == null) {
        options = {};
      }
      const providerList = [];
      if (providers.InfuraProvider) {
        try {
          providerList.push(new providers.InfuraProvider(network, options.infura));
        } catch (error) {
        }
      }
      if (providers.EtherscanProvider) {
        try {
          providerList.push(new providers.EtherscanProvider(network, options.etherscan));
        } catch (error) {
        }
      }
      if (providers.AlchemyProvider) {
        try {
          providerList.push(new providers.AlchemyProvider(network, options.alchemy));
        } catch (error) {
        }
      }
      if (providers.PocketProvider) {
        const skip = ["goerli", "ropsten", "rinkeby"];
        try {
          const provider = new providers.PocketProvider(network);
          if (provider.network && skip.indexOf(provider.network.name) === -1) {
            providerList.push(provider);
          }
        } catch (error) {
        }
      }
      if (providers.CloudflareProvider) {
        try {
          providerList.push(new providers.CloudflareProvider(network));
        } catch (error) {
        }
      }
      if (providerList.length === 0) {
        return null;
      }
      if (providers.FallbackProvider) {
        let quorum = 1;
        if (options.quorum != null) {
          quorum = options.quorum;
        } else if (network === "homestead") {
          quorum = 2;
        }
        return new providers.FallbackProvider(providerList, quorum);
      }
      return providerList[0];
    };
    func.renetwork = function(network2) {
      return ethDefaultProvider(network2);
    };
    return func;
  }
  function etcDefaultProvider(url, network) {
    const func = function(providers, options) {
      if (providers.JsonRpcProvider) {
        return new providers.JsonRpcProvider(url, network);
      }
      return null;
    };
    func.renetwork = function(network2) {
      return etcDefaultProvider(url, network2);
    };
    return func;
  }
  var homestead = {
    chainId: 1,
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    name: "homestead",
    _defaultProvider: ethDefaultProvider("homestead")
  };
  var ropsten = {
    chainId: 3,
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    name: "ropsten",
    _defaultProvider: ethDefaultProvider("ropsten")
  };
  var classicMordor = {
    chainId: 63,
    name: "classicMordor",
    _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/mordor", "classicMordor")
  };
  var networks = {
    unspecified: { chainId: 0, name: "unspecified" },
    homestead,
    mainnet: homestead,
    morden: { chainId: 2, name: "morden" },
    ropsten,
    testnet: ropsten,
    rinkeby: {
      chainId: 4,
      ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
      name: "rinkeby",
      _defaultProvider: ethDefaultProvider("rinkeby")
    },
    kovan: {
      chainId: 42,
      name: "kovan",
      _defaultProvider: ethDefaultProvider("kovan")
    },
    goerli: {
      chainId: 5,
      ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
      name: "goerli",
      _defaultProvider: ethDefaultProvider("goerli")
    },
    classic: {
      chainId: 61,
      name: "classic",
      _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/etc", "classic")
    },
    classicMorden: { chainId: 62, name: "classicMorden" },
    classicMordor,
    classicTestnet: classicMordor,
    classicKotti: {
      chainId: 6,
      name: "classicKotti",
      _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/kotti", "classicKotti")
    },
    xdai: { chainId: 100, name: "xdai" },
    matic: { chainId: 137, name: "matic" },
    maticmum: { chainId: 80001, name: "maticmum" },
    bnb: { chainId: 56, name: "bnb" },
    bnbt: { chainId: 97, name: "bnbt" }
  };
  function getNetwork(network) {
    if (network == null) {
      return null;
    }
    if (typeof network === "number") {
      for (const name2 in networks) {
        const standard2 = networks[name2];
        if (standard2.chainId === network) {
          return {
            name: standard2.name,
            chainId: standard2.chainId,
            ensAddress: standard2.ensAddress || null,
            _defaultProvider: standard2._defaultProvider || null
          };
        }
      }
      return {
        chainId: network,
        name: "unknown"
      };
    }
    if (typeof network === "string") {
      const standard2 = networks[network];
      if (standard2 == null) {
        return null;
      }
      return {
        name: standard2.name,
        chainId: standard2.chainId,
        ensAddress: standard2.ensAddress,
        _defaultProvider: standard2._defaultProvider || null
      };
    }
    const standard = networks[network.name];
    if (!standard) {
      if (typeof network.chainId !== "number") {
        logger27.throwArgumentError("invalid network chainId", "network", network);
      }
      return network;
    }
    if (network.chainId !== 0 && network.chainId !== standard.chainId) {
      logger27.throwArgumentError("network chainId mismatch", "network", network);
    }
    let defaultProvider = network._defaultProvider || null;
    if (defaultProvider == null && standard._defaultProvider) {
      if (isRenetworkable(standard._defaultProvider)) {
        defaultProvider = standard._defaultProvider.renetwork(network);
      } else {
        defaultProvider = standard._defaultProvider;
      }
    }
    return {
      name: network.name,
      chainId: standard.chainId,
      ensAddress: network.ensAddress || standard.ensAddress || null,
      _defaultProvider: defaultProvider
    };
  }

  // node_modules/@ethersproject/base64/lib.esm/index.js
  var lib_exports3 = {};
  __export(lib_exports3, {
    decode: () => decode2,
    encode: () => encode3
  });

  // node_modules/@ethersproject/base64/lib.esm/base64.js
  "use strict";
  function decode2(textData) {
    textData = atob(textData);
    const data4 = [];
    for (let i3 = 0; i3 < textData.length; i3++) {
      data4.push(textData.charCodeAt(i3));
    }
    return arrayify(data4);
  }
  function encode3(data4) {
    data4 = arrayify(data4);
    let textData = "";
    for (let i3 = 0; i3 < data4.length; i3++) {
      textData += String.fromCharCode(data4[i3]);
    }
    return btoa(textData);
  }

  // node_modules/@ethersproject/base64/lib.esm/index.js
  "use strict";

  // node_modules/@ethersproject/web/lib.esm/_version.js
  var version22 = "web/5.4.0";

  // node_modules/@ethersproject/web/lib.esm/geturl.js
  "use strict";
  var __awaiter8 = function(thisArg, _arguments, P3, generator) {
    function adopt(value) {
      return value instanceof P3 ? value : new P3(function(resolve) {
        resolve(value);
      });
    }
    return new (P3 || (P3 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e3) {
          reject(e3);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e3) {
          reject(e3);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  function getUrl(href, options) {
    return __awaiter8(this, void 0, void 0, function* () {
      if (options == null) {
        options = {};
      }
      const request = {
        method: options.method || "GET",
        headers: options.headers || {},
        body: options.body || void 0,
        mode: "cors",
        cache: "no-cache",
        credentials: "same-origin",
        redirect: "follow",
        referrer: "client"
      };
      const response = yield fetch(href, request);
      const body = yield response.arrayBuffer();
      const headers = {};
      if (response.headers.forEach) {
        response.headers.forEach((value, key2) => {
          headers[key2.toLowerCase()] = value;
        });
      } else {
        response.headers.keys().forEach((key2) => {
          headers[key2.toLowerCase()] = response.headers.get(key2);
        });
      }
      return {
        headers,
        statusCode: response.status,
        statusMessage: response.statusText,
        body: arrayify(new Uint8Array(body))
      };
    });
  }

  // node_modules/@ethersproject/web/lib.esm/index.js
  "use strict";
  var __awaiter9 = function(thisArg, _arguments, P3, generator) {
    function adopt(value) {
      return value instanceof P3 ? value : new P3(function(resolve) {
        resolve(value);
      });
    }
    return new (P3 || (P3 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e3) {
          reject(e3);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e3) {
          reject(e3);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var logger28 = new Logger(version22);
  function staller(duration) {
    return new Promise((resolve) => {
      setTimeout(resolve, duration);
    });
  }
  function bodyify(value, type) {
    if (value == null) {
      return null;
    }
    if (typeof value === "string") {
      return value;
    }
    if (isBytesLike(value)) {
      if (type && (type.split("/")[0] === "text" || type.split(";")[0].trim() === "application/json")) {
        try {
          return toUtf8String(value);
        } catch (error) {
        }
        ;
      }
      return hexlify(value);
    }
    return value;
  }
  function _fetchData(connection, body, processFunc) {
    const attemptLimit = typeof connection === "object" && connection.throttleLimit != null ? connection.throttleLimit : 12;
    logger28.assertArgument(attemptLimit > 0 && attemptLimit % 1 === 0, "invalid connection throttle limit", "connection.throttleLimit", attemptLimit);
    const throttleCallback = typeof connection === "object" ? connection.throttleCallback : null;
    const throttleSlotInterval = typeof connection === "object" && typeof connection.throttleSlotInterval === "number" ? connection.throttleSlotInterval : 100;
    logger28.assertArgument(throttleSlotInterval > 0 && throttleSlotInterval % 1 === 0, "invalid connection throttle slot interval", "connection.throttleSlotInterval", throttleSlotInterval);
    const headers = {};
    let url = null;
    const options = {
      method: "GET"
    };
    let allow304 = false;
    let timeout = 2 * 60 * 1e3;
    if (typeof connection === "string") {
      url = connection;
    } else if (typeof connection === "object") {
      if (connection == null || connection.url == null) {
        logger28.throwArgumentError("missing URL", "connection.url", connection);
      }
      url = connection.url;
      if (typeof connection.timeout === "number" && connection.timeout > 0) {
        timeout = connection.timeout;
      }
      if (connection.headers) {
        for (const key2 in connection.headers) {
          headers[key2.toLowerCase()] = { key: key2, value: String(connection.headers[key2]) };
          if (["if-none-match", "if-modified-since"].indexOf(key2.toLowerCase()) >= 0) {
            allow304 = true;
          }
        }
      }
      options.allowGzip = !!connection.allowGzip;
      if (connection.user != null && connection.password != null) {
        if (url.substring(0, 6) !== "https:" && connection.allowInsecureAuthentication !== true) {
          logger28.throwError("basic authentication requires a secure https url", Logger.errors.INVALID_ARGUMENT, { argument: "url", url, user: connection.user, password: "[REDACTED]" });
        }
        const authorization = connection.user + ":" + connection.password;
        headers["authorization"] = {
          key: "Authorization",
          value: "Basic " + encode3(toUtf8Bytes(authorization))
        };
      }
    }
    if (body) {
      options.method = "POST";
      options.body = body;
      if (headers["content-type"] == null) {
        headers["content-type"] = { key: "Content-Type", value: "application/octet-stream" };
      }
      if (headers["content-length"] == null) {
        headers["content-length"] = { key: "Content-Length", value: String(body.length) };
      }
    }
    const flatHeaders = {};
    Object.keys(headers).forEach((key2) => {
      const header = headers[key2];
      flatHeaders[header.key] = header.value;
    });
    options.headers = flatHeaders;
    const runningTimeout = function() {
      let timer2 = null;
      const promise = new Promise(function(resolve, reject) {
        if (timeout) {
          timer2 = setTimeout(() => {
            if (timer2 == null) {
              return;
            }
            timer2 = null;
            reject(logger28.makeError("timeout", Logger.errors.TIMEOUT, {
              requestBody: bodyify(options.body, flatHeaders["content-type"]),
              requestMethod: options.method,
              timeout,
              url
            }));
          }, timeout);
        }
      });
      const cancel = function() {
        if (timer2 == null) {
          return;
        }
        clearTimeout(timer2);
        timer2 = null;
      };
      return { promise, cancel };
    }();
    const runningFetch = function() {
      return __awaiter9(this, void 0, void 0, function* () {
        for (let attempt = 0; attempt < attemptLimit; attempt++) {
          let response = null;
          try {
            response = yield getUrl(url, options);
            if (response.statusCode === 429 && attempt < attemptLimit) {
              let tryAgain = true;
              if (throttleCallback) {
                tryAgain = yield throttleCallback(attempt, url);
              }
              if (tryAgain) {
                let stall3 = 0;
                const retryAfter = response.headers["retry-after"];
                if (typeof retryAfter === "string" && retryAfter.match(/^[1-9][0-9]*$/)) {
                  stall3 = parseInt(retryAfter) * 1e3;
                } else {
                  stall3 = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));
                }
                yield staller(stall3);
                continue;
              }
            }
          } catch (error) {
            response = error.response;
            if (response == null) {
              runningTimeout.cancel();
              logger28.throwError("missing response", Logger.errors.SERVER_ERROR, {
                requestBody: bodyify(options.body, flatHeaders["content-type"]),
                requestMethod: options.method,
                serverError: error,
                url
              });
            }
          }
          let body2 = response.body;
          if (allow304 && response.statusCode === 304) {
            body2 = null;
          } else if (response.statusCode < 200 || response.statusCode >= 300) {
            runningTimeout.cancel();
            logger28.throwError("bad response", Logger.errors.SERVER_ERROR, {
              status: response.statusCode,
              headers: response.headers,
              body: bodyify(body2, response.headers ? response.headers["content-type"] : null),
              requestBody: bodyify(options.body, flatHeaders["content-type"]),
              requestMethod: options.method,
              url
            });
          }
          if (processFunc) {
            try {
              const result = yield processFunc(body2, response);
              runningTimeout.cancel();
              return result;
            } catch (error) {
              if (error.throttleRetry && attempt < attemptLimit) {
                let tryAgain = true;
                if (throttleCallback) {
                  tryAgain = yield throttleCallback(attempt, url);
                }
                if (tryAgain) {
                  const timeout2 = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));
                  yield staller(timeout2);
                  continue;
                }
              }
              runningTimeout.cancel();
              logger28.throwError("processing response error", Logger.errors.SERVER_ERROR, {
                body: bodyify(body2, response.headers ? response.headers["content-type"] : null),
                error,
                requestBody: bodyify(options.body, flatHeaders["content-type"]),
                requestMethod: options.method,
                url
              });
            }
          }
          runningTimeout.cancel();
          return body2;
        }
        return logger28.throwError("failed response", Logger.errors.SERVER_ERROR, {
          requestBody: bodyify(options.body, flatHeaders["content-type"]),
          requestMethod: options.method,
          url
        });
      });
    }();
    return Promise.race([runningTimeout.promise, runningFetch]);
  }
  function fetchJson(connection, json, processFunc) {
    let processJsonFunc = (value, response) => {
      let result = null;
      if (value != null) {
        try {
          result = JSON.parse(toUtf8String(value));
        } catch (error) {
          logger28.throwError("invalid JSON", Logger.errors.SERVER_ERROR, {
            body: value,
            error
          });
        }
      }
      if (processFunc) {
        result = processFunc(result, response);
      }
      return result;
    };
    let body = null;
    if (json != null) {
      body = toUtf8Bytes(json);
      const updated = typeof connection === "string" ? { url: connection } : shallowCopy(connection);
      if (updated.headers) {
        const hasContentType = Object.keys(updated.headers).filter((k3) => k3.toLowerCase() === "content-type").length !== 0;
        if (!hasContentType) {
          updated.headers = shallowCopy(updated.headers);
          updated.headers["content-type"] = "application/json";
        }
      } else {
        updated.headers = { "content-type": "application/json" };
      }
      connection = updated;
    }
    return _fetchData(connection, body, processJsonFunc);
  }
  function poll(func, options) {
    if (!options) {
      options = {};
    }
    options = shallowCopy(options);
    if (options.floor == null) {
      options.floor = 0;
    }
    if (options.ceiling == null) {
      options.ceiling = 1e4;
    }
    if (options.interval == null) {
      options.interval = 250;
    }
    return new Promise(function(resolve, reject) {
      let timer2 = null;
      let done = false;
      const cancel = () => {
        if (done) {
          return false;
        }
        done = true;
        if (timer2) {
          clearTimeout(timer2);
        }
        return true;
      };
      if (options.timeout) {
        timer2 = setTimeout(() => {
          if (cancel()) {
            reject(new Error("timeout"));
          }
        }, options.timeout);
      }
      const retryLimit = options.retryLimit;
      let attempt = 0;
      function check() {
        return func().then(function(result) {
          if (result !== void 0) {
            if (cancel()) {
              resolve(result);
            }
          } else if (options.oncePoll) {
            options.oncePoll.once("poll", check);
          } else if (options.onceBlock) {
            options.onceBlock.once("block", check);
          } else if (!done) {
            attempt++;
            if (attempt > retryLimit) {
              if (cancel()) {
                reject(new Error("retry limit reached"));
              }
              return;
            }
            let timeout = options.interval * parseInt(String(Math.random() * Math.pow(2, attempt)));
            if (timeout < options.floor) {
              timeout = options.floor;
            }
            if (timeout > options.ceiling) {
              timeout = options.ceiling;
            }
            setTimeout(check, timeout);
          }
          return null;
        }, function(error) {
          if (cancel()) {
            reject(error);
          }
        });
      }
      check();
    });
  }

  // node_modules/@ethersproject/providers/lib.esm/base-provider.js
  var import_bech32 = __toModule(require_bech32());

  // node_modules/@ethersproject/providers/lib.esm/_version.js
  var version23 = "providers/5.4.3";

  // node_modules/@ethersproject/providers/lib.esm/formatter.js
  "use strict";
  var logger29 = new Logger(version23);
  var Formatter = class {
    constructor() {
      logger29.checkNew(new.target, Formatter);
      this.formats = this.getDefaultFormats();
    }
    getDefaultFormats() {
      const formats = {};
      const address = this.address.bind(this);
      const bigNumber = this.bigNumber.bind(this);
      const blockTag = this.blockTag.bind(this);
      const data4 = this.data.bind(this);
      const hash3 = this.hash.bind(this);
      const hex2 = this.hex.bind(this);
      const number = this.number.bind(this);
      const type = this.type.bind(this);
      const strictData = (v3) => {
        return this.data(v3, true);
      };
      formats.transaction = {
        hash: hash3,
        type,
        accessList: Formatter.allowNull(this.accessList.bind(this), null),
        blockHash: Formatter.allowNull(hash3, null),
        blockNumber: Formatter.allowNull(number, null),
        transactionIndex: Formatter.allowNull(number, null),
        confirmations: Formatter.allowNull(number, null),
        from: address,
        gasPrice: Formatter.allowNull(bigNumber),
        maxPriorityFeePerGas: Formatter.allowNull(bigNumber),
        maxFeePerGas: Formatter.allowNull(bigNumber),
        gasLimit: bigNumber,
        to: Formatter.allowNull(address, null),
        value: bigNumber,
        nonce: number,
        data: data4,
        r: Formatter.allowNull(this.uint256),
        s: Formatter.allowNull(this.uint256),
        v: Formatter.allowNull(number),
        creates: Formatter.allowNull(address, null),
        raw: Formatter.allowNull(data4)
      };
      formats.transactionRequest = {
        from: Formatter.allowNull(address),
        nonce: Formatter.allowNull(number),
        gasLimit: Formatter.allowNull(bigNumber),
        gasPrice: Formatter.allowNull(bigNumber),
        maxPriorityFeePerGas: Formatter.allowNull(bigNumber),
        maxFeePerGas: Formatter.allowNull(bigNumber),
        to: Formatter.allowNull(address),
        value: Formatter.allowNull(bigNumber),
        data: Formatter.allowNull(strictData),
        type: Formatter.allowNull(number),
        accessList: Formatter.allowNull(this.accessList.bind(this), null)
      };
      formats.receiptLog = {
        transactionIndex: number,
        blockNumber: number,
        transactionHash: hash3,
        address,
        topics: Formatter.arrayOf(hash3),
        data: data4,
        logIndex: number,
        blockHash: hash3
      };
      formats.receipt = {
        to: Formatter.allowNull(this.address, null),
        from: Formatter.allowNull(this.address, null),
        contractAddress: Formatter.allowNull(address, null),
        transactionIndex: number,
        root: Formatter.allowNull(hex2),
        gasUsed: bigNumber,
        logsBloom: Formatter.allowNull(data4),
        blockHash: hash3,
        transactionHash: hash3,
        logs: Formatter.arrayOf(this.receiptLog.bind(this)),
        blockNumber: number,
        confirmations: Formatter.allowNull(number, null),
        cumulativeGasUsed: bigNumber,
        effectiveGasPrice: Formatter.allowNull(bigNumber),
        status: Formatter.allowNull(number),
        type
      };
      formats.block = {
        hash: hash3,
        parentHash: hash3,
        number,
        timestamp: number,
        nonce: Formatter.allowNull(hex2),
        difficulty: this.difficulty.bind(this),
        gasLimit: bigNumber,
        gasUsed: bigNumber,
        miner: address,
        extraData: data4,
        transactions: Formatter.allowNull(Formatter.arrayOf(hash3)),
        baseFeePerGas: Formatter.allowNull(bigNumber)
      };
      formats.blockWithTransactions = shallowCopy(formats.block);
      formats.blockWithTransactions.transactions = Formatter.allowNull(Formatter.arrayOf(this.transactionResponse.bind(this)));
      formats.filter = {
        fromBlock: Formatter.allowNull(blockTag, void 0),
        toBlock: Formatter.allowNull(blockTag, void 0),
        blockHash: Formatter.allowNull(hash3, void 0),
        address: Formatter.allowNull(address, void 0),
        topics: Formatter.allowNull(this.topics.bind(this), void 0)
      };
      formats.filterLog = {
        blockNumber: Formatter.allowNull(number),
        blockHash: Formatter.allowNull(hash3),
        transactionIndex: number,
        removed: Formatter.allowNull(this.boolean.bind(this)),
        address,
        data: Formatter.allowFalsish(data4, "0x"),
        topics: Formatter.arrayOf(hash3),
        transactionHash: hash3,
        logIndex: number
      };
      return formats;
    }
    accessList(accessList) {
      return accessListify(accessList || []);
    }
    number(number) {
      if (number === "0x") {
        return 0;
      }
      return BigNumber.from(number).toNumber();
    }
    type(number) {
      if (number === "0x" || number == null) {
        return 0;
      }
      return BigNumber.from(number).toNumber();
    }
    bigNumber(value) {
      return BigNumber.from(value);
    }
    boolean(value) {
      if (typeof value === "boolean") {
        return value;
      }
      if (typeof value === "string") {
        value = value.toLowerCase();
        if (value === "true") {
          return true;
        }
        if (value === "false") {
          return false;
        }
      }
      throw new Error("invalid boolean - " + value);
    }
    hex(value, strict) {
      if (typeof value === "string") {
        if (!strict && value.substring(0, 2) !== "0x") {
          value = "0x" + value;
        }
        if (isHexString(value)) {
          return value.toLowerCase();
        }
      }
      return logger29.throwArgumentError("invalid hash", "value", value);
    }
    data(value, strict) {
      const result = this.hex(value, strict);
      if (result.length % 2 !== 0) {
        throw new Error("invalid data; odd-length - " + value);
      }
      return result;
    }
    address(value) {
      return getAddress(value);
    }
    callAddress(value) {
      if (!isHexString(value, 32)) {
        return null;
      }
      const address = getAddress(hexDataSlice(value, 12));
      return address === AddressZero ? null : address;
    }
    contractAddress(value) {
      return getContractAddress(value);
    }
    blockTag(blockTag) {
      if (blockTag == null) {
        return "latest";
      }
      if (blockTag === "earliest") {
        return "0x0";
      }
      if (blockTag === "latest" || blockTag === "pending") {
        return blockTag;
      }
      if (typeof blockTag === "number" || isHexString(blockTag)) {
        return hexValue(blockTag);
      }
      throw new Error("invalid blockTag");
    }
    hash(value, strict) {
      const result = this.hex(value, strict);
      if (hexDataLength(result) !== 32) {
        return logger29.throwArgumentError("invalid hash", "value", value);
      }
      return result;
    }
    difficulty(value) {
      if (value == null) {
        return null;
      }
      const v3 = BigNumber.from(value);
      try {
        return v3.toNumber();
      } catch (error) {
      }
      return null;
    }
    uint256(value) {
      if (!isHexString(value)) {
        throw new Error("invalid uint256");
      }
      return hexZeroPad(value, 32);
    }
    _block(value, format) {
      if (value.author != null && value.miner == null) {
        value.miner = value.author;
      }
      return Formatter.check(format, value);
    }
    block(value) {
      return this._block(value, this.formats.block);
    }
    blockWithTransactions(value) {
      return this._block(value, this.formats.blockWithTransactions);
    }
    transactionRequest(value) {
      return Formatter.check(this.formats.transactionRequest, value);
    }
    transactionResponse(transaction) {
      if (transaction.gas != null && transaction.gasLimit == null) {
        transaction.gasLimit = transaction.gas;
      }
      if (transaction.to && BigNumber.from(transaction.to).isZero()) {
        transaction.to = "0x0000000000000000000000000000000000000000";
      }
      if (transaction.input != null && transaction.data == null) {
        transaction.data = transaction.input;
      }
      if (transaction.to == null && transaction.creates == null) {
        transaction.creates = this.contractAddress(transaction);
      }
      if (transaction.type === 1 && transaction.accessList == null) {
        transaction.accessList = [];
      }
      const result = Formatter.check(this.formats.transaction, transaction);
      if (transaction.chainId != null) {
        let chainId = transaction.chainId;
        if (isHexString(chainId)) {
          chainId = BigNumber.from(chainId).toNumber();
        }
        result.chainId = chainId;
      } else {
        let chainId = transaction.networkId;
        if (chainId == null && result.v == null) {
          chainId = transaction.chainId;
        }
        if (isHexString(chainId)) {
          chainId = BigNumber.from(chainId).toNumber();
        }
        if (typeof chainId !== "number" && result.v != null) {
          chainId = (result.v - 35) / 2;
          if (chainId < 0) {
            chainId = 0;
          }
          chainId = parseInt(chainId);
        }
        if (typeof chainId !== "number") {
          chainId = 0;
        }
        result.chainId = chainId;
      }
      if (result.blockHash && result.blockHash.replace(/0/g, "") === "x") {
        result.blockHash = null;
      }
      return result;
    }
    transaction(value) {
      return parse(value);
    }
    receiptLog(value) {
      return Formatter.check(this.formats.receiptLog, value);
    }
    receipt(value) {
      const result = Formatter.check(this.formats.receipt, value);
      if (result.root != null) {
        if (result.root.length <= 4) {
          const value2 = BigNumber.from(result.root).toNumber();
          if (value2 === 0 || value2 === 1) {
            if (result.status != null && result.status !== value2) {
              logger29.throwArgumentError("alt-root-status/status mismatch", "value", { root: result.root, status: result.status });
            }
            result.status = value2;
            delete result.root;
          } else {
            logger29.throwArgumentError("invalid alt-root-status", "value.root", result.root);
          }
        } else if (result.root.length !== 66) {
          logger29.throwArgumentError("invalid root hash", "value.root", result.root);
        }
      }
      if (result.status != null) {
        result.byzantium = true;
      }
      return result;
    }
    topics(value) {
      if (Array.isArray(value)) {
        return value.map((v3) => this.topics(v3));
      } else if (value != null) {
        return this.hash(value, true);
      }
      return null;
    }
    filter(value) {
      return Formatter.check(this.formats.filter, value);
    }
    filterLog(value) {
      return Formatter.check(this.formats.filterLog, value);
    }
    static check(format, object) {
      const result = {};
      for (const key2 in format) {
        try {
          const value = format[key2](object[key2]);
          if (value !== void 0) {
            result[key2] = value;
          }
        } catch (error) {
          error.checkKey = key2;
          error.checkValue = object[key2];
          throw error;
        }
      }
      return result;
    }
    static allowNull(format, nullValue) {
      return function(value) {
        if (value == null) {
          return nullValue;
        }
        return format(value);
      };
    }
    static allowFalsish(format, replaceValue) {
      return function(value) {
        if (!value) {
          return replaceValue;
        }
        return format(value);
      };
    }
    static arrayOf(format) {
      return function(array) {
        if (!Array.isArray(array)) {
          throw new Error("not an array");
        }
        const result = [];
        array.forEach(function(value) {
          result.push(format(value));
        });
        return result;
      };
    }
  };
  function isCommunityResourcable(value) {
    return value && typeof value.isCommunityResource === "function";
  }
  function isCommunityResource(value) {
    return isCommunityResourcable(value) && value.isCommunityResource();
  }
  var throttleMessage = false;
  function showThrottleMessage() {
    if (throttleMessage) {
      return;
    }
    throttleMessage = true;
    console.log("========= NOTICE =========");
    console.log("Request-Rate Exceeded  (this message will not be repeated)");
    console.log("");
    console.log("The default API keys for each service are provided as a highly-throttled,");
    console.log("community resource for low-traffic projects and early prototyping.");
    console.log("");
    console.log("While your application will continue to function, we highly recommended");
    console.log("signing up for your own API keys to improve performance, increase your");
    console.log("request rate/limit and enable other perks, such as metrics and advanced APIs.");
    console.log("");
    console.log("For more details: https://docs.ethers.io/api-keys/");
    console.log("==========================");
  }

  // node_modules/@ethersproject/providers/lib.esm/base-provider.js
  "use strict";
  var __awaiter10 = function(thisArg, _arguments, P3, generator) {
    function adopt(value) {
      return value instanceof P3 ? value : new P3(function(resolve) {
        resolve(value);
      });
    }
    return new (P3 || (P3 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e3) {
          reject(e3);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e3) {
          reject(e3);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var logger30 = new Logger(version23);
  function checkTopic(topic) {
    if (topic == null) {
      return "null";
    }
    if (hexDataLength(topic) !== 32) {
      logger30.throwArgumentError("invalid topic", "topic", topic);
    }
    return topic.toLowerCase();
  }
  function serializeTopics(topics) {
    topics = topics.slice();
    while (topics.length > 0 && topics[topics.length - 1] == null) {
      topics.pop();
    }
    return topics.map((topic) => {
      if (Array.isArray(topic)) {
        const unique = {};
        topic.forEach((topic2) => {
          unique[checkTopic(topic2)] = true;
        });
        const sorted = Object.keys(unique);
        sorted.sort();
        return sorted.join("|");
      } else {
        return checkTopic(topic);
      }
    }).join("&");
  }
  function deserializeTopics(data4) {
    if (data4 === "") {
      return [];
    }
    return data4.split(/&/g).map((topic) => {
      if (topic === "") {
        return [];
      }
      const comps = topic.split("|").map((topic2) => {
        return topic2 === "null" ? null : topic2;
      });
      return comps.length === 1 ? comps[0] : comps;
    });
  }
  function getEventTag2(eventName) {
    if (typeof eventName === "string") {
      eventName = eventName.toLowerCase();
      if (hexDataLength(eventName) === 32) {
        return "tx:" + eventName;
      }
      if (eventName.indexOf(":") === -1) {
        return eventName;
      }
    } else if (Array.isArray(eventName)) {
      return "filter:*:" + serializeTopics(eventName);
    } else if (ForkEvent.isForkEvent(eventName)) {
      logger30.warn("not implemented");
      throw new Error("not implemented");
    } else if (eventName && typeof eventName === "object") {
      return "filter:" + (eventName.address || "*") + ":" + serializeTopics(eventName.topics || []);
    }
    throw new Error("invalid event - " + eventName);
  }
  function getTime() {
    return new Date().getTime();
  }
  function stall(duration) {
    return new Promise((resolve) => {
      setTimeout(resolve, duration);
    });
  }
  var PollableEvents = ["block", "network", "pending", "poll"];
  var Event = class {
    constructor(tag, listener, once) {
      defineReadOnly(this, "tag", tag);
      defineReadOnly(this, "listener", listener);
      defineReadOnly(this, "once", once);
    }
    get event() {
      switch (this.type) {
        case "tx":
          return this.hash;
        case "filter":
          return this.filter;
      }
      return this.tag;
    }
    get type() {
      return this.tag.split(":")[0];
    }
    get hash() {
      const comps = this.tag.split(":");
      if (comps[0] !== "tx") {
        return null;
      }
      return comps[1];
    }
    get filter() {
      const comps = this.tag.split(":");
      if (comps[0] !== "filter") {
        return null;
      }
      const address = comps[1];
      const topics = deserializeTopics(comps[2]);
      const filter = {};
      if (topics.length > 0) {
        filter.topics = topics;
      }
      if (address && address !== "*") {
        filter.address = address;
      }
      return filter;
    }
    pollable() {
      return this.tag.indexOf(":") >= 0 || PollableEvents.indexOf(this.tag) >= 0;
    }
  };
  var coinInfos = {
    "0": { symbol: "btc", p2pkh: 0, p2sh: 5, prefix: "bc" },
    "2": { symbol: "ltc", p2pkh: 48, p2sh: 50, prefix: "ltc" },
    "3": { symbol: "doge", p2pkh: 30, p2sh: 22 },
    "60": { symbol: "eth", ilk: "eth" },
    "61": { symbol: "etc", ilk: "eth" },
    "700": { symbol: "xdai", ilk: "eth" }
  };
  function bytes32ify(value) {
    return hexZeroPad(BigNumber.from(value).toHexString(), 32);
  }
  function base58Encode(data4) {
    return Base58.encode(concat([data4, hexDataSlice(sha256(sha256(data4)), 0, 4)]));
  }
  var Resolver = class {
    constructor(provider, address, name2) {
      defineReadOnly(this, "provider", provider);
      defineReadOnly(this, "name", name2);
      defineReadOnly(this, "address", provider.formatter.address(address));
    }
    _fetchBytes(selector, parameters) {
      return __awaiter10(this, void 0, void 0, function* () {
        const transaction = {
          to: this.address,
          data: hexConcat([selector, namehash(this.name), parameters || "0x"])
        };
        try {
          const result = yield this.provider.call(transaction);
          if (result === "0x") {
            return null;
          }
          const offset = BigNumber.from(hexDataSlice(result, 0, 32)).toNumber();
          const length = BigNumber.from(hexDataSlice(result, offset, offset + 32)).toNumber();
          return hexDataSlice(result, offset + 32, offset + 32 + length);
        } catch (error) {
          if (error.code === Logger.errors.CALL_EXCEPTION) {
            return null;
          }
          return null;
        }
      });
    }
    _getAddress(coinType, hexBytes) {
      const coinInfo = coinInfos[String(coinType)];
      if (coinInfo == null) {
        logger30.throwError(`unsupported coin type: ${coinType}`, Logger.errors.UNSUPPORTED_OPERATION, {
          operation: `getAddress(${coinType})`
        });
      }
      if (coinInfo.ilk === "eth") {
        return this.provider.formatter.address(hexBytes);
      }
      const bytes = arrayify(hexBytes);
      if (coinInfo.p2pkh != null) {
        const p2pkh = hexBytes.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);
        if (p2pkh) {
          const length = parseInt(p2pkh[1], 16);
          if (p2pkh[2].length === length * 2 && length >= 1 && length <= 75) {
            return base58Encode(concat([[coinInfo.p2pkh], "0x" + p2pkh[2]]));
          }
        }
      }
      if (coinInfo.p2sh != null) {
        const p2sh = hexBytes.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);
        if (p2sh) {
          const length = parseInt(p2sh[1], 16);
          if (p2sh[2].length === length * 2 && length >= 1 && length <= 75) {
            return base58Encode(concat([[coinInfo.p2sh], "0x" + p2sh[2]]));
          }
        }
      }
      if (coinInfo.prefix != null) {
        const length = bytes[1];
        let version26 = bytes[0];
        if (version26 === 0) {
          if (length !== 20 && length !== 32) {
            version26 = -1;
          }
        } else {
          version26 = -1;
        }
        if (version26 >= 0 && bytes.length === 2 + length && length >= 1 && length <= 75) {
          const words6 = import_bech32.default.toWords(bytes.slice(2));
          words6.unshift(version26);
          return import_bech32.default.encode(coinInfo.prefix, words6);
        }
      }
      return null;
    }
    getAddress(coinType) {
      return __awaiter10(this, void 0, void 0, function* () {
        if (coinType == null) {
          coinType = 60;
        }
        if (coinType === 60) {
          try {
            const transaction = {
              to: this.address,
              data: "0x3b3b57de" + namehash(this.name).substring(2)
            };
            const hexBytes2 = yield this.provider.call(transaction);
            if (hexBytes2 === "0x" || hexBytes2 === HashZero) {
              return null;
            }
            return this.provider.formatter.callAddress(hexBytes2);
          } catch (error) {
            if (error.code === Logger.errors.CALL_EXCEPTION) {
              return null;
            }
            throw error;
          }
        }
        const hexBytes = yield this._fetchBytes("0xf1cb7e06", bytes32ify(coinType));
        if (hexBytes == null || hexBytes === "0x") {
          return null;
        }
        const address = this._getAddress(coinType, hexBytes);
        if (address == null) {
          logger30.throwError(`invalid or unsupported coin data`, Logger.errors.UNSUPPORTED_OPERATION, {
            operation: `getAddress(${coinType})`,
            coinType,
            data: hexBytes
          });
        }
        return address;
      });
    }
    getContentHash() {
      return __awaiter10(this, void 0, void 0, function* () {
        const hexBytes = yield this._fetchBytes("0xbc1c58d1");
        if (hexBytes == null || hexBytes === "0x") {
          return null;
        }
        const ipfs = hexBytes.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
        if (ipfs) {
          const length = parseInt(ipfs[3], 16);
          if (ipfs[4].length === length * 2) {
            return "ipfs://" + Base58.encode("0x" + ipfs[1]);
          }
        }
        const swarm = hexBytes.match(/^0xe40101fa011b20([0-9a-f]*)$/);
        if (swarm) {
          if (swarm[1].length === 32 * 2) {
            return "bzz://" + swarm[1];
          }
        }
        return logger30.throwError(`invalid or unsupported content hash data`, Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "getContentHash()",
          data: hexBytes
        });
      });
    }
    getText(key2) {
      return __awaiter10(this, void 0, void 0, function* () {
        let keyBytes = toUtf8Bytes(key2);
        keyBytes = concat([bytes32ify(64), bytes32ify(keyBytes.length), keyBytes]);
        if (keyBytes.length % 32 !== 0) {
          keyBytes = concat([keyBytes, hexZeroPad("0x", 32 - key2.length % 32)]);
        }
        const hexBytes = yield this._fetchBytes("0x59d1d43c", hexlify(keyBytes));
        if (hexBytes == null || hexBytes === "0x") {
          return null;
        }
        return toUtf8String(hexBytes);
      });
    }
  };
  var defaultFormatter = null;
  var nextPollId = 1;
  var BaseProvider = class extends Provider {
    constructor(network) {
      logger30.checkNew(new.target, Provider);
      super();
      this._events = [];
      this._emitted = { block: -2 };
      this.formatter = new.target.getFormatter();
      defineReadOnly(this, "anyNetwork", network === "any");
      if (this.anyNetwork) {
        network = this.detectNetwork();
      }
      if (network instanceof Promise) {
        this._networkPromise = network;
        network.catch((error) => {
        });
        this._ready().catch((error) => {
        });
      } else {
        const knownNetwork = getStatic(new.target, "getNetwork")(network);
        if (knownNetwork) {
          defineReadOnly(this, "_network", knownNetwork);
          this.emit("network", knownNetwork, null);
        } else {
          logger30.throwArgumentError("invalid network", "network", network);
        }
      }
      this._maxInternalBlockNumber = -1024;
      this._lastBlockNumber = -2;
      this._pollingInterval = 4e3;
      this._fastQueryDate = 0;
    }
    _ready() {
      return __awaiter10(this, void 0, void 0, function* () {
        if (this._network == null) {
          let network = null;
          if (this._networkPromise) {
            try {
              network = yield this._networkPromise;
            } catch (error) {
            }
          }
          if (network == null) {
            network = yield this.detectNetwork();
          }
          if (!network) {
            logger30.throwError("no network detected", Logger.errors.UNKNOWN_ERROR, {});
          }
          if (this._network == null) {
            if (this.anyNetwork) {
              this._network = network;
            } else {
              defineReadOnly(this, "_network", network);
            }
            this.emit("network", network, null);
          }
        }
        return this._network;
      });
    }
    get ready() {
      return poll(() => {
        return this._ready().then((network) => {
          return network;
        }, (error) => {
          if (error.code === Logger.errors.NETWORK_ERROR && error.event === "noNetwork") {
            return void 0;
          }
          throw error;
        });
      });
    }
    static getFormatter() {
      if (defaultFormatter == null) {
        defaultFormatter = new Formatter();
      }
      return defaultFormatter;
    }
    static getNetwork(network) {
      return getNetwork(network == null ? "homestead" : network);
    }
    _getInternalBlockNumber(maxAge) {
      return __awaiter10(this, void 0, void 0, function* () {
        yield this._ready();
        if (maxAge > 0) {
          while (this._internalBlockNumber) {
            const internalBlockNumber = this._internalBlockNumber;
            try {
              const result = yield internalBlockNumber;
              if (getTime() - result.respTime <= maxAge) {
                return result.blockNumber;
              }
              break;
            } catch (error) {
              if (this._internalBlockNumber === internalBlockNumber) {
                break;
              }
            }
          }
        }
        const reqTime = getTime();
        const checkInternalBlockNumber = resolveProperties({
          blockNumber: this.perform("getBlockNumber", {}),
          networkError: this.getNetwork().then((network) => null, (error) => error)
        }).then(({ blockNumber, networkError }) => {
          if (networkError) {
            if (this._internalBlockNumber === checkInternalBlockNumber) {
              this._internalBlockNumber = null;
            }
            throw networkError;
          }
          const respTime = getTime();
          blockNumber = BigNumber.from(blockNumber).toNumber();
          if (blockNumber < this._maxInternalBlockNumber) {
            blockNumber = this._maxInternalBlockNumber;
          }
          this._maxInternalBlockNumber = blockNumber;
          this._setFastBlockNumber(blockNumber);
          return { blockNumber, reqTime, respTime };
        });
        this._internalBlockNumber = checkInternalBlockNumber;
        checkInternalBlockNumber.catch((error) => {
          if (this._internalBlockNumber === checkInternalBlockNumber) {
            this._internalBlockNumber = null;
          }
        });
        return (yield checkInternalBlockNumber).blockNumber;
      });
    }
    poll() {
      return __awaiter10(this, void 0, void 0, function* () {
        const pollId = nextPollId++;
        const runners = [];
        let blockNumber = null;
        try {
          blockNumber = yield this._getInternalBlockNumber(100 + this.pollingInterval / 2);
        } catch (error) {
          this.emit("error", error);
          return;
        }
        this._setFastBlockNumber(blockNumber);
        this.emit("poll", pollId, blockNumber);
        if (blockNumber === this._lastBlockNumber) {
          this.emit("didPoll", pollId);
          return;
        }
        if (this._emitted.block === -2) {
          this._emitted.block = blockNumber - 1;
        }
        if (Math.abs(this._emitted.block - blockNumber) > 1e3) {
          logger30.warn(`network block skew detected; skipping block events (emitted=${this._emitted.block} blockNumber${blockNumber})`);
          this.emit("error", logger30.makeError("network block skew detected", Logger.errors.NETWORK_ERROR, {
            blockNumber,
            event: "blockSkew",
            previousBlockNumber: this._emitted.block
          }));
          this.emit("block", blockNumber);
        } else {
          for (let i3 = this._emitted.block + 1; i3 <= blockNumber; i3++) {
            this.emit("block", i3);
          }
        }
        if (this._emitted.block !== blockNumber) {
          this._emitted.block = blockNumber;
          Object.keys(this._emitted).forEach((key2) => {
            if (key2 === "block") {
              return;
            }
            const eventBlockNumber = this._emitted[key2];
            if (eventBlockNumber === "pending") {
              return;
            }
            if (blockNumber - eventBlockNumber > 12) {
              delete this._emitted[key2];
            }
          });
        }
        if (this._lastBlockNumber === -2) {
          this._lastBlockNumber = blockNumber - 1;
        }
        this._events.forEach((event) => {
          switch (event.type) {
            case "tx": {
              const hash3 = event.hash;
              let runner = this.getTransactionReceipt(hash3).then((receipt) => {
                if (!receipt || receipt.blockNumber == null) {
                  return null;
                }
                this._emitted["t:" + hash3] = receipt.blockNumber;
                this.emit(hash3, receipt);
                return null;
              }).catch((error) => {
                this.emit("error", error);
              });
              runners.push(runner);
              break;
            }
            case "filter": {
              const filter = event.filter;
              filter.fromBlock = this._lastBlockNumber + 1;
              filter.toBlock = blockNumber;
              const runner = this.getLogs(filter).then((logs) => {
                if (logs.length === 0) {
                  return;
                }
                logs.forEach((log) => {
                  this._emitted["b:" + log.blockHash] = log.blockNumber;
                  this._emitted["t:" + log.transactionHash] = log.blockNumber;
                  this.emit(filter, log);
                });
              }).catch((error) => {
                this.emit("error", error);
              });
              runners.push(runner);
              break;
            }
          }
        });
        this._lastBlockNumber = blockNumber;
        Promise.all(runners).then(() => {
          this.emit("didPoll", pollId);
        }).catch((error) => {
          this.emit("error", error);
        });
        return;
      });
    }
    resetEventsBlock(blockNumber) {
      this._lastBlockNumber = blockNumber - 1;
      if (this.polling) {
        this.poll();
      }
    }
    get network() {
      return this._network;
    }
    detectNetwork() {
      return __awaiter10(this, void 0, void 0, function* () {
        return logger30.throwError("provider does not support network detection", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "provider.detectNetwork"
        });
      });
    }
    getNetwork() {
      return __awaiter10(this, void 0, void 0, function* () {
        const network = yield this._ready();
        const currentNetwork = yield this.detectNetwork();
        if (network.chainId !== currentNetwork.chainId) {
          if (this.anyNetwork) {
            this._network = currentNetwork;
            this._lastBlockNumber = -2;
            this._fastBlockNumber = null;
            this._fastBlockNumberPromise = null;
            this._fastQueryDate = 0;
            this._emitted.block = -2;
            this._maxInternalBlockNumber = -1024;
            this._internalBlockNumber = null;
            this.emit("network", currentNetwork, network);
            yield stall(0);
            return this._network;
          }
          const error = logger30.makeError("underlying network changed", Logger.errors.NETWORK_ERROR, {
            event: "changed",
            network,
            detectedNetwork: currentNetwork
          });
          this.emit("error", error);
          throw error;
        }
        return network;
      });
    }
    get blockNumber() {
      this._getInternalBlockNumber(100 + this.pollingInterval / 2).then((blockNumber) => {
        this._setFastBlockNumber(blockNumber);
      }, (error) => {
      });
      return this._fastBlockNumber != null ? this._fastBlockNumber : -1;
    }
    get polling() {
      return this._poller != null;
    }
    set polling(value) {
      if (value && !this._poller) {
        this._poller = setInterval(() => {
          this.poll();
        }, this.pollingInterval);
        if (!this._bootstrapPoll) {
          this._bootstrapPoll = setTimeout(() => {
            this.poll();
            this._bootstrapPoll = setTimeout(() => {
              if (!this._poller) {
                this.poll();
              }
              this._bootstrapPoll = null;
            }, this.pollingInterval);
          }, 0);
        }
      } else if (!value && this._poller) {
        clearInterval(this._poller);
        this._poller = null;
      }
    }
    get pollingInterval() {
      return this._pollingInterval;
    }
    set pollingInterval(value) {
      if (typeof value !== "number" || value <= 0 || parseInt(String(value)) != value) {
        throw new Error("invalid polling interval");
      }
      this._pollingInterval = value;
      if (this._poller) {
        clearInterval(this._poller);
        this._poller = setInterval(() => {
          this.poll();
        }, this._pollingInterval);
      }
    }
    _getFastBlockNumber() {
      const now2 = getTime();
      if (now2 - this._fastQueryDate > 2 * this._pollingInterval) {
        this._fastQueryDate = now2;
        this._fastBlockNumberPromise = this.getBlockNumber().then((blockNumber) => {
          if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {
            this._fastBlockNumber = blockNumber;
          }
          return this._fastBlockNumber;
        });
      }
      return this._fastBlockNumberPromise;
    }
    _setFastBlockNumber(blockNumber) {
      if (this._fastBlockNumber != null && blockNumber < this._fastBlockNumber) {
        return;
      }
      this._fastQueryDate = getTime();
      if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {
        this._fastBlockNumber = blockNumber;
        this._fastBlockNumberPromise = Promise.resolve(blockNumber);
      }
    }
    waitForTransaction(transactionHash, confirmations, timeout) {
      return __awaiter10(this, void 0, void 0, function* () {
        return this._waitForTransaction(transactionHash, confirmations == null ? 1 : confirmations, timeout || 0, null);
      });
    }
    _waitForTransaction(transactionHash, confirmations, timeout, replaceable) {
      return __awaiter10(this, void 0, void 0, function* () {
        const receipt = yield this.getTransactionReceipt(transactionHash);
        if ((receipt ? receipt.confirmations : 0) >= confirmations) {
          return receipt;
        }
        return new Promise((resolve, reject) => {
          const cancelFuncs = [];
          let done = false;
          const alreadyDone = function() {
            if (done) {
              return true;
            }
            done = true;
            cancelFuncs.forEach((func) => {
              func();
            });
            return false;
          };
          const minedHandler = (receipt2) => {
            if (receipt2.confirmations < confirmations) {
              return;
            }
            if (alreadyDone()) {
              return;
            }
            resolve(receipt2);
          };
          this.on(transactionHash, minedHandler);
          cancelFuncs.push(() => {
            this.removeListener(transactionHash, minedHandler);
          });
          if (replaceable) {
            let lastBlockNumber = replaceable.startBlock;
            let scannedBlock = null;
            const replaceHandler = (blockNumber) => __awaiter10(this, void 0, void 0, function* () {
              if (done) {
                return;
              }
              yield stall(1e3);
              this.getTransactionCount(replaceable.from).then((nonce) => __awaiter10(this, void 0, void 0, function* () {
                if (done) {
                  return;
                }
                if (nonce <= replaceable.nonce) {
                  lastBlockNumber = blockNumber;
                } else {
                  {
                    const mined = yield this.getTransaction(transactionHash);
                    if (mined && mined.blockNumber != null) {
                      return;
                    }
                  }
                  if (scannedBlock == null) {
                    scannedBlock = lastBlockNumber - 3;
                    if (scannedBlock < replaceable.startBlock) {
                      scannedBlock = replaceable.startBlock;
                    }
                  }
                  while (scannedBlock <= blockNumber) {
                    if (done) {
                      return;
                    }
                    const block = yield this.getBlockWithTransactions(scannedBlock);
                    for (let ti = 0; ti < block.transactions.length; ti++) {
                      const tx = block.transactions[ti];
                      if (tx.hash === transactionHash) {
                        return;
                      }
                      if (tx.from === replaceable.from && tx.nonce === replaceable.nonce) {
                        if (done) {
                          return;
                        }
                        const receipt2 = yield this.waitForTransaction(tx.hash, confirmations);
                        if (alreadyDone()) {
                          return;
                        }
                        let reason = "replaced";
                        if (tx.data === replaceable.data && tx.to === replaceable.to && tx.value.eq(replaceable.value)) {
                          reason = "repriced";
                        } else if (tx.data === "0x" && tx.from === tx.to && tx.value.isZero()) {
                          reason = "cancelled";
                        }
                        reject(logger30.makeError("transaction was replaced", Logger.errors.TRANSACTION_REPLACED, {
                          cancelled: reason === "replaced" || reason === "cancelled",
                          reason,
                          replacement: this._wrapTransaction(tx),
                          hash: transactionHash,
                          receipt: receipt2
                        }));
                        return;
                      }
                    }
                    scannedBlock++;
                  }
                }
                if (done) {
                  return;
                }
                this.once("block", replaceHandler);
              }), (error) => {
                if (done) {
                  return;
                }
                this.once("block", replaceHandler);
              });
            });
            if (done) {
              return;
            }
            this.once("block", replaceHandler);
            cancelFuncs.push(() => {
              this.removeListener("block", replaceHandler);
            });
          }
          if (typeof timeout === "number" && timeout > 0) {
            const timer2 = setTimeout(() => {
              if (alreadyDone()) {
                return;
              }
              reject(logger30.makeError("timeout exceeded", Logger.errors.TIMEOUT, { timeout }));
            }, timeout);
            if (timer2.unref) {
              timer2.unref();
            }
            cancelFuncs.push(() => {
              clearTimeout(timer2);
            });
          }
        });
      });
    }
    getBlockNumber() {
      return __awaiter10(this, void 0, void 0, function* () {
        return this._getInternalBlockNumber(0);
      });
    }
    getGasPrice() {
      return __awaiter10(this, void 0, void 0, function* () {
        yield this.getNetwork();
        const result = yield this.perform("getGasPrice", {});
        try {
          return BigNumber.from(result);
        } catch (error) {
          return logger30.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
            method: "getGasPrice",
            result,
            error
          });
        }
      });
    }
    getBalance(addressOrName, blockTag) {
      return __awaiter10(this, void 0, void 0, function* () {
        yield this.getNetwork();
        const params = yield resolveProperties({
          address: this._getAddress(addressOrName),
          blockTag: this._getBlockTag(blockTag)
        });
        const result = yield this.perform("getBalance", params);
        try {
          return BigNumber.from(result);
        } catch (error) {
          return logger30.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
            method: "getBalance",
            params,
            result,
            error
          });
        }
      });
    }
    getTransactionCount(addressOrName, blockTag) {
      return __awaiter10(this, void 0, void 0, function* () {
        yield this.getNetwork();
        const params = yield resolveProperties({
          address: this._getAddress(addressOrName),
          blockTag: this._getBlockTag(blockTag)
        });
        const result = yield this.perform("getTransactionCount", params);
        try {
          return BigNumber.from(result).toNumber();
        } catch (error) {
          return logger30.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
            method: "getTransactionCount",
            params,
            result,
            error
          });
        }
      });
    }
    getCode(addressOrName, blockTag) {
      return __awaiter10(this, void 0, void 0, function* () {
        yield this.getNetwork();
        const params = yield resolveProperties({
          address: this._getAddress(addressOrName),
          blockTag: this._getBlockTag(blockTag)
        });
        const result = yield this.perform("getCode", params);
        try {
          return hexlify(result);
        } catch (error) {
          return logger30.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
            method: "getCode",
            params,
            result,
            error
          });
        }
      });
    }
    getStorageAt(addressOrName, position, blockTag) {
      return __awaiter10(this, void 0, void 0, function* () {
        yield this.getNetwork();
        const params = yield resolveProperties({
          address: this._getAddress(addressOrName),
          blockTag: this._getBlockTag(blockTag),
          position: Promise.resolve(position).then((p3) => hexValue(p3))
        });
        const result = yield this.perform("getStorageAt", params);
        try {
          return hexlify(result);
        } catch (error) {
          return logger30.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
            method: "getStorageAt",
            params,
            result,
            error
          });
        }
      });
    }
    _wrapTransaction(tx, hash3, startBlock) {
      if (hash3 != null && hexDataLength(hash3) !== 32) {
        throw new Error("invalid response - sendTransaction");
      }
      const result = tx;
      if (hash3 != null && tx.hash !== hash3) {
        logger30.throwError("Transaction hash mismatch from Provider.sendTransaction.", Logger.errors.UNKNOWN_ERROR, { expectedHash: tx.hash, returnedHash: hash3 });
      }
      result.wait = (confirms, timeout) => __awaiter10(this, void 0, void 0, function* () {
        if (confirms == null) {
          confirms = 1;
        }
        if (timeout == null) {
          timeout = 0;
        }
        let replacement = void 0;
        if (confirms !== 0 && startBlock != null) {
          replacement = {
            data: tx.data,
            from: tx.from,
            nonce: tx.nonce,
            to: tx.to,
            value: tx.value,
            startBlock
          };
        }
        const receipt = yield this._waitForTransaction(tx.hash, confirms, timeout, replacement);
        if (receipt == null && confirms === 0) {
          return null;
        }
        this._emitted["t:" + tx.hash] = receipt.blockNumber;
        if (receipt.status === 0) {
          logger30.throwError("transaction failed", Logger.errors.CALL_EXCEPTION, {
            transactionHash: tx.hash,
            transaction: tx,
            receipt
          });
        }
        return receipt;
      });
      return result;
    }
    sendTransaction(signedTransaction) {
      return __awaiter10(this, void 0, void 0, function* () {
        yield this.getNetwork();
        const hexTx = yield Promise.resolve(signedTransaction).then((t3) => hexlify(t3));
        const tx = this.formatter.transaction(signedTransaction);
        if (tx.confirmations == null) {
          tx.confirmations = 0;
        }
        const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
        try {
          const hash3 = yield this.perform("sendTransaction", { signedTransaction: hexTx });
          return this._wrapTransaction(tx, hash3, blockNumber);
        } catch (error) {
          error.transaction = tx;
          error.transactionHash = tx.hash;
          throw error;
        }
      });
    }
    _getTransactionRequest(transaction) {
      return __awaiter10(this, void 0, void 0, function* () {
        const values = yield transaction;
        const tx = {};
        ["from", "to"].forEach((key2) => {
          if (values[key2] == null) {
            return;
          }
          tx[key2] = Promise.resolve(values[key2]).then((v3) => v3 ? this._getAddress(v3) : null);
        });
        ["gasLimit", "gasPrice", "maxFeePerGas", "maxPriorityFeePerGas", "value"].forEach((key2) => {
          if (values[key2] == null) {
            return;
          }
          tx[key2] = Promise.resolve(values[key2]).then((v3) => v3 ? BigNumber.from(v3) : null);
        });
        ["type"].forEach((key2) => {
          if (values[key2] == null) {
            return;
          }
          tx[key2] = Promise.resolve(values[key2]).then((v3) => v3 != null ? v3 : null);
        });
        if (values.accessList) {
          tx.accessList = this.formatter.accessList(values.accessList);
        }
        ["data"].forEach((key2) => {
          if (values[key2] == null) {
            return;
          }
          tx[key2] = Promise.resolve(values[key2]).then((v3) => v3 ? hexlify(v3) : null);
        });
        return this.formatter.transactionRequest(yield resolveProperties(tx));
      });
    }
    _getFilter(filter) {
      return __awaiter10(this, void 0, void 0, function* () {
        filter = yield filter;
        const result = {};
        if (filter.address != null) {
          result.address = this._getAddress(filter.address);
        }
        ["blockHash", "topics"].forEach((key2) => {
          if (filter[key2] == null) {
            return;
          }
          result[key2] = filter[key2];
        });
        ["fromBlock", "toBlock"].forEach((key2) => {
          if (filter[key2] == null) {
            return;
          }
          result[key2] = this._getBlockTag(filter[key2]);
        });
        return this.formatter.filter(yield resolveProperties(result));
      });
    }
    call(transaction, blockTag) {
      return __awaiter10(this, void 0, void 0, function* () {
        yield this.getNetwork();
        const params = yield resolveProperties({
          transaction: this._getTransactionRequest(transaction),
          blockTag: this._getBlockTag(blockTag)
        });
        const result = yield this.perform("call", params);
        try {
          return hexlify(result);
        } catch (error) {
          return logger30.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
            method: "call",
            params,
            result,
            error
          });
        }
      });
    }
    estimateGas(transaction) {
      return __awaiter10(this, void 0, void 0, function* () {
        yield this.getNetwork();
        const params = yield resolveProperties({
          transaction: this._getTransactionRequest(transaction)
        });
        const result = yield this.perform("estimateGas", params);
        try {
          return BigNumber.from(result);
        } catch (error) {
          return logger30.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
            method: "estimateGas",
            params,
            result,
            error
          });
        }
      });
    }
    _getAddress(addressOrName) {
      return __awaiter10(this, void 0, void 0, function* () {
        const address = yield this.resolveName(addressOrName);
        if (address == null) {
          logger30.throwError("ENS name not configured", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: `resolveName(${JSON.stringify(addressOrName)})`
          });
        }
        return address;
      });
    }
    _getBlock(blockHashOrBlockTag, includeTransactions) {
      return __awaiter10(this, void 0, void 0, function* () {
        yield this.getNetwork();
        blockHashOrBlockTag = yield blockHashOrBlockTag;
        let blockNumber = -128;
        const params = {
          includeTransactions: !!includeTransactions
        };
        if (isHexString(blockHashOrBlockTag, 32)) {
          params.blockHash = blockHashOrBlockTag;
        } else {
          try {
            params.blockTag = this.formatter.blockTag(yield this._getBlockTag(blockHashOrBlockTag));
            if (isHexString(params.blockTag)) {
              blockNumber = parseInt(params.blockTag.substring(2), 16);
            }
          } catch (error) {
            logger30.throwArgumentError("invalid block hash or block tag", "blockHashOrBlockTag", blockHashOrBlockTag);
          }
        }
        return poll(() => __awaiter10(this, void 0, void 0, function* () {
          const block = yield this.perform("getBlock", params);
          if (block == null) {
            if (params.blockHash != null) {
              if (this._emitted["b:" + params.blockHash] == null) {
                return null;
              }
            }
            if (params.blockTag != null) {
              if (blockNumber > this._emitted.block) {
                return null;
              }
            }
            return void 0;
          }
          if (includeTransactions) {
            let blockNumber2 = null;
            for (let i3 = 0; i3 < block.transactions.length; i3++) {
              const tx = block.transactions[i3];
              if (tx.blockNumber == null) {
                tx.confirmations = 0;
              } else if (tx.confirmations == null) {
                if (blockNumber2 == null) {
                  blockNumber2 = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
                }
                let confirmations = blockNumber2 - tx.blockNumber + 1;
                if (confirmations <= 0) {
                  confirmations = 1;
                }
                tx.confirmations = confirmations;
              }
            }
            const blockWithTxs = this.formatter.blockWithTransactions(block);
            blockWithTxs.transactions = block.transactions.map((tx) => this._wrapTransaction(tx));
            return blockWithTxs;
          }
          return this.formatter.block(block);
        }), { oncePoll: this });
      });
    }
    getBlock(blockHashOrBlockTag) {
      return this._getBlock(blockHashOrBlockTag, false);
    }
    getBlockWithTransactions(blockHashOrBlockTag) {
      return this._getBlock(blockHashOrBlockTag, true);
    }
    getTransaction(transactionHash) {
      return __awaiter10(this, void 0, void 0, function* () {
        yield this.getNetwork();
        transactionHash = yield transactionHash;
        const params = { transactionHash: this.formatter.hash(transactionHash, true) };
        return poll(() => __awaiter10(this, void 0, void 0, function* () {
          const result = yield this.perform("getTransaction", params);
          if (result == null) {
            if (this._emitted["t:" + transactionHash] == null) {
              return null;
            }
            return void 0;
          }
          const tx = this.formatter.transactionResponse(result);
          if (tx.blockNumber == null) {
            tx.confirmations = 0;
          } else if (tx.confirmations == null) {
            const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
            let confirmations = blockNumber - tx.blockNumber + 1;
            if (confirmations <= 0) {
              confirmations = 1;
            }
            tx.confirmations = confirmations;
          }
          return this._wrapTransaction(tx);
        }), { oncePoll: this });
      });
    }
    getTransactionReceipt(transactionHash) {
      return __awaiter10(this, void 0, void 0, function* () {
        yield this.getNetwork();
        transactionHash = yield transactionHash;
        const params = { transactionHash: this.formatter.hash(transactionHash, true) };
        return poll(() => __awaiter10(this, void 0, void 0, function* () {
          const result = yield this.perform("getTransactionReceipt", params);
          if (result == null) {
            if (this._emitted["t:" + transactionHash] == null) {
              return null;
            }
            return void 0;
          }
          if (result.blockHash == null) {
            return void 0;
          }
          const receipt = this.formatter.receipt(result);
          if (receipt.blockNumber == null) {
            receipt.confirmations = 0;
          } else if (receipt.confirmations == null) {
            const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
            let confirmations = blockNumber - receipt.blockNumber + 1;
            if (confirmations <= 0) {
              confirmations = 1;
            }
            receipt.confirmations = confirmations;
          }
          return receipt;
        }), { oncePoll: this });
      });
    }
    getLogs(filter) {
      return __awaiter10(this, void 0, void 0, function* () {
        yield this.getNetwork();
        const params = yield resolveProperties({ filter: this._getFilter(filter) });
        const logs = yield this.perform("getLogs", params);
        logs.forEach((log) => {
          if (log.removed == null) {
            log.removed = false;
          }
        });
        return Formatter.arrayOf(this.formatter.filterLog.bind(this.formatter))(logs);
      });
    }
    getEtherPrice() {
      return __awaiter10(this, void 0, void 0, function* () {
        yield this.getNetwork();
        return this.perform("getEtherPrice", {});
      });
    }
    _getBlockTag(blockTag) {
      return __awaiter10(this, void 0, void 0, function* () {
        blockTag = yield blockTag;
        if (typeof blockTag === "number" && blockTag < 0) {
          if (blockTag % 1) {
            logger30.throwArgumentError("invalid BlockTag", "blockTag", blockTag);
          }
          let blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
          blockNumber += blockTag;
          if (blockNumber < 0) {
            blockNumber = 0;
          }
          return this.formatter.blockTag(blockNumber);
        }
        return this.formatter.blockTag(blockTag);
      });
    }
    getResolver(name2) {
      return __awaiter10(this, void 0, void 0, function* () {
        try {
          const address = yield this._getResolver(name2);
          if (address == null) {
            return null;
          }
          return new Resolver(this, address, name2);
        } catch (error) {
          if (error.code === Logger.errors.CALL_EXCEPTION) {
            return null;
          }
          return null;
        }
      });
    }
    _getResolver(name2) {
      return __awaiter10(this, void 0, void 0, function* () {
        const network = yield this.getNetwork();
        if (!network.ensAddress) {
          logger30.throwError("network does not support ENS", Logger.errors.UNSUPPORTED_OPERATION, { operation: "ENS", network: network.name });
        }
        const transaction = {
          to: network.ensAddress,
          data: "0x0178b8bf" + namehash(name2).substring(2)
        };
        try {
          return this.formatter.callAddress(yield this.call(transaction));
        } catch (error) {
          if (error.code === Logger.errors.CALL_EXCEPTION) {
            return null;
          }
          throw error;
        }
      });
    }
    resolveName(name2) {
      return __awaiter10(this, void 0, void 0, function* () {
        name2 = yield name2;
        try {
          return Promise.resolve(this.formatter.address(name2));
        } catch (error) {
          if (isHexString(name2)) {
            throw error;
          }
        }
        if (typeof name2 !== "string") {
          logger30.throwArgumentError("invalid ENS name", "name", name2);
        }
        const resolver = yield this.getResolver(name2);
        if (!resolver) {
          return null;
        }
        return yield resolver.getAddress();
      });
    }
    lookupAddress(address) {
      return __awaiter10(this, void 0, void 0, function* () {
        address = yield address;
        address = this.formatter.address(address);
        const reverseName = address.substring(2).toLowerCase() + ".addr.reverse";
        const resolverAddress = yield this._getResolver(reverseName);
        if (!resolverAddress) {
          return null;
        }
        let bytes = arrayify(yield this.call({
          to: resolverAddress,
          data: "0x691f3431" + namehash(reverseName).substring(2)
        }));
        if (bytes.length < 32 || !BigNumber.from(bytes.slice(0, 32)).eq(32)) {
          return null;
        }
        bytes = bytes.slice(32);
        if (bytes.length < 32) {
          return null;
        }
        const length = BigNumber.from(bytes.slice(0, 32)).toNumber();
        bytes = bytes.slice(32);
        if (length > bytes.length) {
          return null;
        }
        const name2 = toUtf8String(bytes.slice(0, length));
        const addr = yield this.resolveName(name2);
        if (addr != address) {
          return null;
        }
        return name2;
      });
    }
    perform(method, params) {
      return logger30.throwError(method + " not implemented", Logger.errors.NOT_IMPLEMENTED, { operation: method });
    }
    _startEvent(event) {
      this.polling = this._events.filter((e3) => e3.pollable()).length > 0;
    }
    _stopEvent(event) {
      this.polling = this._events.filter((e3) => e3.pollable()).length > 0;
    }
    _addEventListener(eventName, listener, once) {
      const event = new Event(getEventTag2(eventName), listener, once);
      this._events.push(event);
      this._startEvent(event);
      return this;
    }
    on(eventName, listener) {
      return this._addEventListener(eventName, listener, false);
    }
    once(eventName, listener) {
      return this._addEventListener(eventName, listener, true);
    }
    emit(eventName, ...args) {
      let result = false;
      let stopped = [];
      let eventTag = getEventTag2(eventName);
      this._events = this._events.filter((event) => {
        if (event.tag !== eventTag) {
          return true;
        }
        setTimeout(() => {
          event.listener.apply(this, args);
        }, 0);
        result = true;
        if (event.once) {
          stopped.push(event);
          return false;
        }
        return true;
      });
      stopped.forEach((event) => {
        this._stopEvent(event);
      });
      return result;
    }
    listenerCount(eventName) {
      if (!eventName) {
        return this._events.length;
      }
      let eventTag = getEventTag2(eventName);
      return this._events.filter((event) => {
        return event.tag === eventTag;
      }).length;
    }
    listeners(eventName) {
      if (eventName == null) {
        return this._events.map((event) => event.listener);
      }
      let eventTag = getEventTag2(eventName);
      return this._events.filter((event) => event.tag === eventTag).map((event) => event.listener);
    }
    off(eventName, listener) {
      if (listener == null) {
        return this.removeAllListeners(eventName);
      }
      const stopped = [];
      let found = false;
      let eventTag = getEventTag2(eventName);
      this._events = this._events.filter((event) => {
        if (event.tag !== eventTag || event.listener != listener) {
          return true;
        }
        if (found) {
          return true;
        }
        found = true;
        stopped.push(event);
        return false;
      });
      stopped.forEach((event) => {
        this._stopEvent(event);
      });
      return this;
    }
    removeAllListeners(eventName) {
      let stopped = [];
      if (eventName == null) {
        stopped = this._events;
        this._events = [];
      } else {
        const eventTag = getEventTag2(eventName);
        this._events = this._events.filter((event) => {
          if (event.tag !== eventTag) {
            return true;
          }
          stopped.push(event);
          return false;
        });
      }
      stopped.forEach((event) => {
        this._stopEvent(event);
      });
      return this;
    }
  };

  // node_modules/@ethersproject/providers/lib.esm/json-rpc-provider.js
  "use strict";
  var __awaiter11 = function(thisArg, _arguments, P3, generator) {
    function adopt(value) {
      return value instanceof P3 ? value : new P3(function(resolve) {
        resolve(value);
      });
    }
    return new (P3 || (P3 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e3) {
          reject(e3);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e3) {
          reject(e3);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var logger31 = new Logger(version23);
  var errorGas = ["call", "estimateGas"];
  function checkError(method, error, params) {
    if (method === "call" && error.code === Logger.errors.SERVER_ERROR) {
      const e3 = error.error;
      if (e3 && e3.message.match("reverted") && isHexString(e3.data)) {
        return e3.data;
      }
      logger31.throwError("missing revert data in call exception", Logger.errors.CALL_EXCEPTION, {
        error,
        data: "0x"
      });
    }
    let message = error.message;
    if (error.code === Logger.errors.SERVER_ERROR && error.error && typeof error.error.message === "string") {
      message = error.error.message;
    } else if (typeof error.body === "string") {
      message = error.body;
    } else if (typeof error.responseText === "string") {
      message = error.responseText;
    }
    message = (message || "").toLowerCase();
    const transaction = params.transaction || params.signedTransaction;
    if (message.match(/insufficient funds|base fee exceeds gas limit/)) {
      logger31.throwError("insufficient funds for intrinsic transaction cost", Logger.errors.INSUFFICIENT_FUNDS, {
        error,
        method,
        transaction
      });
    }
    if (message.match(/nonce too low/)) {
      logger31.throwError("nonce has already been used", Logger.errors.NONCE_EXPIRED, {
        error,
        method,
        transaction
      });
    }
    if (message.match(/replacement transaction underpriced/)) {
      logger31.throwError("replacement fee too low", Logger.errors.REPLACEMENT_UNDERPRICED, {
        error,
        method,
        transaction
      });
    }
    if (message.match(/only replay-protected/)) {
      logger31.throwError("legacy pre-eip-155 transactions not supported", Logger.errors.UNSUPPORTED_OPERATION, {
        error,
        method,
        transaction
      });
    }
    if (errorGas.indexOf(method) >= 0 && message.match(/gas required exceeds allowance|always failing transaction|execution reverted/)) {
      logger31.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
        error,
        method,
        transaction
      });
    }
    throw error;
  }
  function timer(timeout) {
    return new Promise(function(resolve) {
      setTimeout(resolve, timeout);
    });
  }
  function getResult(payload) {
    if (payload.error) {
      const error = new Error(payload.error.message);
      error.code = payload.error.code;
      error.data = payload.error.data;
      throw error;
    }
    return payload.result;
  }
  function getLowerCase(value) {
    if (value) {
      return value.toLowerCase();
    }
    return value;
  }
  var _constructorGuard5 = {};
  var JsonRpcSigner = class extends Signer {
    constructor(constructorGuard, provider, addressOrIndex) {
      logger31.checkNew(new.target, JsonRpcSigner);
      super();
      if (constructorGuard !== _constructorGuard5) {
        throw new Error("do not call the JsonRpcSigner constructor directly; use provider.getSigner");
      }
      defineReadOnly(this, "provider", provider);
      if (addressOrIndex == null) {
        addressOrIndex = 0;
      }
      if (typeof addressOrIndex === "string") {
        defineReadOnly(this, "_address", this.provider.formatter.address(addressOrIndex));
        defineReadOnly(this, "_index", null);
      } else if (typeof addressOrIndex === "number") {
        defineReadOnly(this, "_index", addressOrIndex);
        defineReadOnly(this, "_address", null);
      } else {
        logger31.throwArgumentError("invalid address or index", "addressOrIndex", addressOrIndex);
      }
    }
    connect(provider) {
      return logger31.throwError("cannot alter JSON-RPC Signer connection", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "connect"
      });
    }
    connectUnchecked() {
      return new UncheckedJsonRpcSigner(_constructorGuard5, this.provider, this._address || this._index);
    }
    getAddress() {
      if (this._address) {
        return Promise.resolve(this._address);
      }
      return this.provider.send("eth_accounts", []).then((accounts) => {
        if (accounts.length <= this._index) {
          logger31.throwError("unknown account #" + this._index, Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "getAddress"
          });
        }
        return this.provider.formatter.address(accounts[this._index]);
      });
    }
    sendUncheckedTransaction(transaction) {
      transaction = shallowCopy(transaction);
      const fromAddress = this.getAddress().then((address) => {
        if (address) {
          address = address.toLowerCase();
        }
        return address;
      });
      if (transaction.gasLimit == null) {
        const estimate = shallowCopy(transaction);
        estimate.from = fromAddress;
        transaction.gasLimit = this.provider.estimateGas(estimate);
      }
      if (transaction.to != null) {
        transaction.to = Promise.resolve(transaction.to).then((to) => __awaiter11(this, void 0, void 0, function* () {
          if (to == null) {
            return null;
          }
          const address = yield this.provider.resolveName(to);
          if (address == null) {
            logger31.throwArgumentError("provided ENS name resolves to null", "tx.to", to);
          }
          return address;
        }));
      }
      return resolveProperties({
        tx: resolveProperties(transaction),
        sender: fromAddress
      }).then(({ tx, sender }) => {
        if (tx.from != null) {
          if (tx.from.toLowerCase() !== sender) {
            logger31.throwArgumentError("from address mismatch", "transaction", transaction);
          }
        } else {
          tx.from = sender;
        }
        const hexTx = this.provider.constructor.hexlifyTransaction(tx, { from: true });
        return this.provider.send("eth_sendTransaction", [hexTx]).then((hash3) => {
          return hash3;
        }, (error) => {
          return checkError("sendTransaction", error, hexTx);
        });
      });
    }
    signTransaction(transaction) {
      return logger31.throwError("signing transactions is unsupported", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "signTransaction"
      });
    }
    sendTransaction(transaction) {
      return __awaiter11(this, void 0, void 0, function* () {
        const blockNumber = yield this.provider._getInternalBlockNumber(100 + 2 * this.provider.pollingInterval);
        const hash3 = yield this.sendUncheckedTransaction(transaction);
        try {
          return yield poll(() => __awaiter11(this, void 0, void 0, function* () {
            const tx = yield this.provider.getTransaction(hash3);
            if (tx === null) {
              return void 0;
            }
            return this.provider._wrapTransaction(tx, hash3, blockNumber);
          }), { oncePoll: this.provider });
        } catch (error) {
          error.transactionHash = hash3;
          throw error;
        }
      });
    }
    signMessage(message) {
      return __awaiter11(this, void 0, void 0, function* () {
        const data4 = typeof message === "string" ? toUtf8Bytes(message) : message;
        const address = yield this.getAddress();
        return yield this.provider.send("eth_sign", [address.toLowerCase(), hexlify(data4)]);
      });
    }
    _signTypedData(domain2, types, value) {
      return __awaiter11(this, void 0, void 0, function* () {
        const populated = yield TypedDataEncoder.resolveNames(domain2, types, value, (name2) => {
          return this.provider.resolveName(name2);
        });
        const address = yield this.getAddress();
        return yield this.provider.send("eth_signTypedData_v4", [
          address.toLowerCase(),
          JSON.stringify(TypedDataEncoder.getPayload(populated.domain, types, populated.value))
        ]);
      });
    }
    unlock(password) {
      return __awaiter11(this, void 0, void 0, function* () {
        const provider = this.provider;
        const address = yield this.getAddress();
        return provider.send("personal_unlockAccount", [address.toLowerCase(), password, null]);
      });
    }
  };
  var UncheckedJsonRpcSigner = class extends JsonRpcSigner {
    sendTransaction(transaction) {
      return this.sendUncheckedTransaction(transaction).then((hash3) => {
        return {
          hash: hash3,
          nonce: null,
          gasLimit: null,
          gasPrice: null,
          data: null,
          value: null,
          chainId: null,
          confirmations: 0,
          from: null,
          wait: (confirmations) => {
            return this.provider.waitForTransaction(hash3, confirmations);
          }
        };
      });
    }
  };
  var allowedTransactionKeys4 = {
    chainId: true,
    data: true,
    gasLimit: true,
    gasPrice: true,
    nonce: true,
    to: true,
    value: true,
    type: true,
    accessList: true,
    maxFeePerGas: true,
    maxPriorityFeePerGas: true
  };
  var JsonRpcProvider = class extends BaseProvider {
    constructor(url, network) {
      logger31.checkNew(new.target, JsonRpcProvider);
      let networkOrReady = network;
      if (networkOrReady == null) {
        networkOrReady = new Promise((resolve, reject) => {
          setTimeout(() => {
            this.detectNetwork().then((network2) => {
              resolve(network2);
            }, (error) => {
              reject(error);
            });
          }, 0);
        });
      }
      super(networkOrReady);
      if (!url) {
        url = getStatic(this.constructor, "defaultUrl")();
      }
      if (typeof url === "string") {
        defineReadOnly(this, "connection", Object.freeze({
          url
        }));
      } else {
        defineReadOnly(this, "connection", Object.freeze(shallowCopy(url)));
      }
      this._nextId = 42;
    }
    get _cache() {
      if (this._eventLoopCache == null) {
        this._eventLoopCache = {};
      }
      return this._eventLoopCache;
    }
    static defaultUrl() {
      return "http://localhost:8545";
    }
    detectNetwork() {
      if (!this._cache["detectNetwork"]) {
        this._cache["detectNetwork"] = this._uncachedDetectNetwork();
        setTimeout(() => {
          this._cache["detectNetwork"] = null;
        }, 0);
      }
      return this._cache["detectNetwork"];
    }
    _uncachedDetectNetwork() {
      return __awaiter11(this, void 0, void 0, function* () {
        yield timer(0);
        let chainId = null;
        try {
          chainId = yield this.send("eth_chainId", []);
        } catch (error) {
          try {
            chainId = yield this.send("net_version", []);
          } catch (error2) {
          }
        }
        if (chainId != null) {
          const getNetwork2 = getStatic(this.constructor, "getNetwork");
          try {
            return getNetwork2(BigNumber.from(chainId).toNumber());
          } catch (error) {
            return logger31.throwError("could not detect network", Logger.errors.NETWORK_ERROR, {
              chainId,
              event: "invalidNetwork",
              serverError: error
            });
          }
        }
        return logger31.throwError("could not detect network", Logger.errors.NETWORK_ERROR, {
          event: "noNetwork"
        });
      });
    }
    getSigner(addressOrIndex) {
      return new JsonRpcSigner(_constructorGuard5, this, addressOrIndex);
    }
    getUncheckedSigner(addressOrIndex) {
      return this.getSigner(addressOrIndex).connectUnchecked();
    }
    listAccounts() {
      return this.send("eth_accounts", []).then((accounts) => {
        return accounts.map((a3) => this.formatter.address(a3));
      });
    }
    send(method, params) {
      const request = {
        method,
        params,
        id: this._nextId++,
        jsonrpc: "2.0"
      };
      this.emit("debug", {
        action: "request",
        request: deepCopy(request),
        provider: this
      });
      const cache = ["eth_chainId", "eth_blockNumber"].indexOf(method) >= 0;
      if (cache && this._cache[method]) {
        return this._cache[method];
      }
      const result = fetchJson(this.connection, JSON.stringify(request), getResult).then((result2) => {
        this.emit("debug", {
          action: "response",
          request,
          response: result2,
          provider: this
        });
        return result2;
      }, (error) => {
        this.emit("debug", {
          action: "response",
          error,
          request,
          provider: this
        });
        throw error;
      });
      if (cache) {
        this._cache[method] = result;
        setTimeout(() => {
          this._cache[method] = null;
        }, 0);
      }
      return result;
    }
    prepareRequest(method, params) {
      switch (method) {
        case "getBlockNumber":
          return ["eth_blockNumber", []];
        case "getGasPrice":
          return ["eth_gasPrice", []];
        case "getBalance":
          return ["eth_getBalance", [getLowerCase(params.address), params.blockTag]];
        case "getTransactionCount":
          return ["eth_getTransactionCount", [getLowerCase(params.address), params.blockTag]];
        case "getCode":
          return ["eth_getCode", [getLowerCase(params.address), params.blockTag]];
        case "getStorageAt":
          return ["eth_getStorageAt", [getLowerCase(params.address), params.position, params.blockTag]];
        case "sendTransaction":
          return ["eth_sendRawTransaction", [params.signedTransaction]];
        case "getBlock":
          if (params.blockTag) {
            return ["eth_getBlockByNumber", [params.blockTag, !!params.includeTransactions]];
          } else if (params.blockHash) {
            return ["eth_getBlockByHash", [params.blockHash, !!params.includeTransactions]];
          }
          return null;
        case "getTransaction":
          return ["eth_getTransactionByHash", [params.transactionHash]];
        case "getTransactionReceipt":
          return ["eth_getTransactionReceipt", [params.transactionHash]];
        case "call": {
          const hexlifyTransaction = getStatic(this.constructor, "hexlifyTransaction");
          return ["eth_call", [hexlifyTransaction(params.transaction, { from: true }), params.blockTag]];
        }
        case "estimateGas": {
          const hexlifyTransaction = getStatic(this.constructor, "hexlifyTransaction");
          return ["eth_estimateGas", [hexlifyTransaction(params.transaction, { from: true })]];
        }
        case "getLogs":
          if (params.filter && params.filter.address != null) {
            params.filter.address = getLowerCase(params.filter.address);
          }
          return ["eth_getLogs", [params.filter]];
        default:
          break;
      }
      return null;
    }
    perform(method, params) {
      return __awaiter11(this, void 0, void 0, function* () {
        if (method === "call" || method === "estimateGas") {
          const tx = params.transaction;
          if (tx && tx.type != null && BigNumber.from(tx.type).isZero()) {
            if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {
              const feeData = yield this.getFeeData();
              if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {
                params = shallowCopy(params);
                params.transaction = shallowCopy(tx);
                delete params.transaction.type;
              }
            }
          }
        }
        const args = this.prepareRequest(method, params);
        if (args == null) {
          logger31.throwError(method + " not implemented", Logger.errors.NOT_IMPLEMENTED, { operation: method });
        }
        try {
          return yield this.send(args[0], args[1]);
        } catch (error) {
          return checkError(method, error, params);
        }
      });
    }
    _startEvent(event) {
      if (event.tag === "pending") {
        this._startPending();
      }
      super._startEvent(event);
    }
    _startPending() {
      if (this._pendingFilter != null) {
        return;
      }
      const self2 = this;
      const pendingFilter = this.send("eth_newPendingTransactionFilter", []);
      this._pendingFilter = pendingFilter;
      pendingFilter.then(function(filterId) {
        function poll2() {
          self2.send("eth_getFilterChanges", [filterId]).then(function(hashes) {
            if (self2._pendingFilter != pendingFilter) {
              return null;
            }
            let seq = Promise.resolve();
            hashes.forEach(function(hash3) {
              self2._emitted["t:" + hash3.toLowerCase()] = "pending";
              seq = seq.then(function() {
                return self2.getTransaction(hash3).then(function(tx) {
                  self2.emit("pending", tx);
                  return null;
                });
              });
            });
            return seq.then(function() {
              return timer(1e3);
            });
          }).then(function() {
            if (self2._pendingFilter != pendingFilter) {
              self2.send("eth_uninstallFilter", [filterId]);
              return;
            }
            setTimeout(function() {
              poll2();
            }, 0);
            return null;
          }).catch((error) => {
          });
        }
        poll2();
        return filterId;
      }).catch((error) => {
      });
    }
    _stopEvent(event) {
      if (event.tag === "pending" && this.listenerCount("pending") === 0) {
        this._pendingFilter = null;
      }
      super._stopEvent(event);
    }
    static hexlifyTransaction(transaction, allowExtra) {
      const allowed = shallowCopy(allowedTransactionKeys4);
      if (allowExtra) {
        for (const key2 in allowExtra) {
          if (allowExtra[key2]) {
            allowed[key2] = true;
          }
        }
      }
      checkProperties(transaction, allowed);
      const result = {};
      ["gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach(function(key2) {
        if (transaction[key2] == null) {
          return;
        }
        const value = hexValue(transaction[key2]);
        if (key2 === "gasLimit") {
          key2 = "gas";
        }
        result[key2] = value;
      });
      ["from", "to", "data"].forEach(function(key2) {
        if (transaction[key2] == null) {
          return;
        }
        result[key2] = hexlify(transaction[key2]);
      });
      if (transaction.accessList) {
        result["accessList"] = accessListify(transaction.accessList);
      }
      return result;
    }
  };

  // node_modules/@ethersproject/providers/lib.esm/ws.js
  "use strict";
  var WS = null;
  try {
    WS = WebSocket;
    if (WS == null) {
      throw new Error("inject please");
    }
  } catch (error) {
    const logger45 = new Logger(version23);
    WS = function() {
      logger45.throwError("WebSockets not supported in this environment", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "new WebSocket()"
      });
    };
  }

  // node_modules/@ethersproject/providers/lib.esm/websocket-provider.js
  "use strict";
  var __awaiter12 = function(thisArg, _arguments, P3, generator) {
    function adopt(value) {
      return value instanceof P3 ? value : new P3(function(resolve) {
        resolve(value);
      });
    }
    return new (P3 || (P3 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e3) {
          reject(e3);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e3) {
          reject(e3);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var logger32 = new Logger(version23);
  var NextId = 1;
  var WebSocketProvider = class extends JsonRpcProvider {
    constructor(url, network) {
      if (network === "any") {
        logger32.throwError("WebSocketProvider does not support 'any' network yet", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "network:any"
        });
      }
      super(url, network);
      this._pollingInterval = -1;
      this._wsReady = false;
      defineReadOnly(this, "_websocket", new WS(this.connection.url));
      defineReadOnly(this, "_requests", {});
      defineReadOnly(this, "_subs", {});
      defineReadOnly(this, "_subIds", {});
      defineReadOnly(this, "_detectNetwork", super.detectNetwork());
      this._websocket.onopen = () => {
        this._wsReady = true;
        Object.keys(this._requests).forEach((id2) => {
          this._websocket.send(this._requests[id2].payload);
        });
      };
      this._websocket.onmessage = (messageEvent) => {
        const data4 = messageEvent.data;
        const result = JSON.parse(data4);
        if (result.id != null) {
          const id2 = String(result.id);
          const request = this._requests[id2];
          delete this._requests[id2];
          if (result.result !== void 0) {
            request.callback(null, result.result);
            this.emit("debug", {
              action: "response",
              request: JSON.parse(request.payload),
              response: result.result,
              provider: this
            });
          } else {
            let error = null;
            if (result.error) {
              error = new Error(result.error.message || "unknown error");
              defineReadOnly(error, "code", result.error.code || null);
              defineReadOnly(error, "response", data4);
            } else {
              error = new Error("unknown error");
            }
            request.callback(error, void 0);
            this.emit("debug", {
              action: "response",
              error,
              request: JSON.parse(request.payload),
              provider: this
            });
          }
        } else if (result.method === "eth_subscription") {
          const sub = this._subs[result.params.subscription];
          if (sub) {
            sub.processFunc(result.params.result);
          }
        } else {
          console.warn("this should not happen");
        }
      };
      const fauxPoll = setInterval(() => {
        this.emit("poll");
      }, 1e3);
      if (fauxPoll.unref) {
        fauxPoll.unref();
      }
    }
    detectNetwork() {
      return this._detectNetwork;
    }
    get pollingInterval() {
      return 0;
    }
    resetEventsBlock(blockNumber) {
      logger32.throwError("cannot reset events block on WebSocketProvider", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "resetEventBlock"
      });
    }
    set pollingInterval(value) {
      logger32.throwError("cannot set polling interval on WebSocketProvider", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "setPollingInterval"
      });
    }
    poll() {
      return __awaiter12(this, void 0, void 0, function* () {
        return null;
      });
    }
    set polling(value) {
      if (!value) {
        return;
      }
      logger32.throwError("cannot set polling on WebSocketProvider", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "setPolling"
      });
    }
    send(method, params) {
      const rid = NextId++;
      return new Promise((resolve, reject) => {
        function callback(error, result) {
          if (error) {
            return reject(error);
          }
          return resolve(result);
        }
        const payload = JSON.stringify({
          method,
          params,
          id: rid,
          jsonrpc: "2.0"
        });
        this.emit("debug", {
          action: "request",
          request: JSON.parse(payload),
          provider: this
        });
        this._requests[String(rid)] = { callback, payload };
        if (this._wsReady) {
          this._websocket.send(payload);
        }
      });
    }
    static defaultUrl() {
      return "ws://localhost:8546";
    }
    _subscribe(tag, param, processFunc) {
      return __awaiter12(this, void 0, void 0, function* () {
        let subIdPromise = this._subIds[tag];
        if (subIdPromise == null) {
          subIdPromise = Promise.all(param).then((param2) => {
            return this.send("eth_subscribe", param2);
          });
          this._subIds[tag] = subIdPromise;
        }
        const subId = yield subIdPromise;
        this._subs[subId] = { tag, processFunc };
      });
    }
    _startEvent(event) {
      switch (event.type) {
        case "block":
          this._subscribe("block", ["newHeads"], (result) => {
            const blockNumber = BigNumber.from(result.number).toNumber();
            this._emitted.block = blockNumber;
            this.emit("block", blockNumber);
          });
          break;
        case "pending":
          this._subscribe("pending", ["newPendingTransactions"], (result) => {
            this.emit("pending", result);
          });
          break;
        case "filter":
          this._subscribe(event.tag, ["logs", this._getFilter(event.filter)], (result) => {
            if (result.removed == null) {
              result.removed = false;
            }
            this.emit(event.filter, this.formatter.filterLog(result));
          });
          break;
        case "tx": {
          const emitReceipt = (event2) => {
            const hash3 = event2.hash;
            this.getTransactionReceipt(hash3).then((receipt) => {
              if (!receipt) {
                return;
              }
              this.emit(hash3, receipt);
            });
          };
          emitReceipt(event);
          this._subscribe("tx", ["newHeads"], (result) => {
            this._events.filter((e3) => e3.type === "tx").forEach(emitReceipt);
          });
          break;
        }
        case "debug":
        case "poll":
        case "willPoll":
        case "didPoll":
        case "error":
          break;
        default:
          console.log("unhandled:", event);
          break;
      }
    }
    _stopEvent(event) {
      let tag = event.tag;
      if (event.type === "tx") {
        if (this._events.filter((e3) => e3.type === "tx").length) {
          return;
        }
        tag = "tx";
      } else if (this.listenerCount(event.event)) {
        return;
      }
      const subId = this._subIds[tag];
      if (!subId) {
        return;
      }
      delete this._subIds[tag];
      subId.then((subId2) => {
        if (!this._subs[subId2]) {
          return;
        }
        delete this._subs[subId2];
        this.send("eth_unsubscribe", [subId2]);
      });
    }
    destroy() {
      return __awaiter12(this, void 0, void 0, function* () {
        if (this._websocket.readyState === WS.CONNECTING) {
          yield new Promise((resolve) => {
            this._websocket.onopen = function() {
              resolve(true);
            };
            this._websocket.onerror = function() {
              resolve(false);
            };
          });
        }
        this._websocket.close(1e3);
      });
    }
  };

  // node_modules/@ethersproject/providers/lib.esm/url-json-rpc-provider.js
  "use strict";
  var __awaiter13 = function(thisArg, _arguments, P3, generator) {
    function adopt(value) {
      return value instanceof P3 ? value : new P3(function(resolve) {
        resolve(value);
      });
    }
    return new (P3 || (P3 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e3) {
          reject(e3);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e3) {
          reject(e3);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var logger33 = new Logger(version23);
  var StaticJsonRpcProvider = class extends JsonRpcProvider {
    detectNetwork() {
      const _super = Object.create(null, {
        detectNetwork: { get: () => super.detectNetwork }
      });
      return __awaiter13(this, void 0, void 0, function* () {
        let network = this.network;
        if (network == null) {
          network = yield _super.detectNetwork.call(this);
          if (!network) {
            logger33.throwError("no network detected", Logger.errors.UNKNOWN_ERROR, {});
          }
          if (this._network == null) {
            defineReadOnly(this, "_network", network);
            this.emit("network", network, null);
          }
        }
        return network;
      });
    }
  };
  var UrlJsonRpcProvider = class extends StaticJsonRpcProvider {
    constructor(network, apiKey) {
      logger33.checkAbstract(new.target, UrlJsonRpcProvider);
      network = getStatic(new.target, "getNetwork")(network);
      apiKey = getStatic(new.target, "getApiKey")(apiKey);
      const connection = getStatic(new.target, "getUrl")(network, apiKey);
      super(connection, network);
      if (typeof apiKey === "string") {
        defineReadOnly(this, "apiKey", apiKey);
      } else if (apiKey != null) {
        Object.keys(apiKey).forEach((key2) => {
          defineReadOnly(this, key2, apiKey[key2]);
        });
      }
    }
    _startPending() {
      logger33.warn("WARNING: API provider does not support pending filters");
    }
    isCommunityResource() {
      return false;
    }
    getSigner(address) {
      return logger33.throwError("API provider does not support signing", Logger.errors.UNSUPPORTED_OPERATION, { operation: "getSigner" });
    }
    listAccounts() {
      return Promise.resolve([]);
    }
    static getApiKey(apiKey) {
      return apiKey;
    }
    static getUrl(network, apiKey) {
      return logger33.throwError("not implemented; sub-classes must override getUrl", Logger.errors.NOT_IMPLEMENTED, {
        operation: "getUrl"
      });
    }
  };

  // node_modules/@ethersproject/providers/lib.esm/alchemy-provider.js
  "use strict";
  var __awaiter14 = function(thisArg, _arguments, P3, generator) {
    function adopt(value) {
      return value instanceof P3 ? value : new P3(function(resolve) {
        resolve(value);
      });
    }
    return new (P3 || (P3 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e3) {
          reject(e3);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e3) {
          reject(e3);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var logger34 = new Logger(version23);
  var defaultApiKey = "_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC";
  var AlchemyWebSocketProvider = class extends WebSocketProvider {
    constructor(network, apiKey) {
      const provider = new AlchemyProvider(network, apiKey);
      const url = provider.connection.url.replace(/^http/i, "ws").replace(".alchemyapi.", ".ws.alchemyapi.");
      super(url, provider.network);
      defineReadOnly(this, "apiKey", provider.apiKey);
    }
    isCommunityResource() {
      return this.apiKey === defaultApiKey;
    }
  };
  var AlchemyProvider = class extends UrlJsonRpcProvider {
    static getWebSocketProvider(network, apiKey) {
      return new AlchemyWebSocketProvider(network, apiKey);
    }
    static getApiKey(apiKey) {
      if (apiKey == null) {
        return defaultApiKey;
      }
      if (apiKey && typeof apiKey !== "string") {
        logger34.throwArgumentError("invalid apiKey", "apiKey", apiKey);
      }
      return apiKey;
    }
    static getUrl(network, apiKey) {
      let host = null;
      switch (network.name) {
        case "homestead":
          host = "eth-mainnet.alchemyapi.io/v2/";
          break;
        case "ropsten":
          host = "eth-ropsten.alchemyapi.io/v2/";
          break;
        case "rinkeby":
          host = "eth-rinkeby.alchemyapi.io/v2/";
          break;
        case "goerli":
          host = "eth-goerli.alchemyapi.io/v2/";
          break;
        case "kovan":
          host = "eth-kovan.alchemyapi.io/v2/";
          break;
        case "matic":
          host = "polygon-mainnet.g.alchemy.com/v2/";
          break;
        case "maticmum":
          host = "polygon-mumbai.g.alchemy.com/v2/";
          break;
        default:
          logger34.throwArgumentError("unsupported network", "network", arguments[0]);
      }
      return {
        allowGzip: true,
        url: "https://" + host + apiKey,
        throttleCallback: (attempt, url) => {
          if (apiKey === defaultApiKey) {
            showThrottleMessage();
          }
          return Promise.resolve(true);
        }
      };
    }
    perform(method, params) {
      const _super = Object.create(null, {
        perform: { get: () => super.perform }
      });
      return __awaiter14(this, void 0, void 0, function* () {
        if (method === "estimateGas" && params.transaction.type === 2 || method === "sendTransaction" && params.signedTransaction.substring(0, 4) === "0x02") {
          logger34.throwError("AlchemyProvider does not currently support EIP-1559", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: method,
            transaction: params.transaction
          });
        }
        return _super.perform.call(this, method, params);
      });
    }
    isCommunityResource() {
      return this.apiKey === defaultApiKey;
    }
  };

  // node_modules/@ethersproject/providers/lib.esm/cloudflare-provider.js
  "use strict";
  var __awaiter15 = function(thisArg, _arguments, P3, generator) {
    function adopt(value) {
      return value instanceof P3 ? value : new P3(function(resolve) {
        resolve(value);
      });
    }
    return new (P3 || (P3 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e3) {
          reject(e3);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e3) {
          reject(e3);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var logger35 = new Logger(version23);
  var CloudflareProvider = class extends UrlJsonRpcProvider {
    static getApiKey(apiKey) {
      if (apiKey != null) {
        logger35.throwArgumentError("apiKey not supported for cloudflare", "apiKey", apiKey);
      }
      return null;
    }
    static getUrl(network, apiKey) {
      let host = null;
      switch (network.name) {
        case "homestead":
          host = "https://cloudflare-eth.com/";
          break;
        default:
          logger35.throwArgumentError("unsupported network", "network", arguments[0]);
      }
      return host;
    }
    perform(method, params) {
      const _super = Object.create(null, {
        perform: { get: () => super.perform }
      });
      return __awaiter15(this, void 0, void 0, function* () {
        if (method === "getBlockNumber") {
          const block = yield _super.perform.call(this, "getBlock", { blockTag: "latest" });
          return block.number;
        }
        return _super.perform.call(this, method, params);
      });
    }
  };

  // node_modules/@ethersproject/providers/lib.esm/etherscan-provider.js
  "use strict";
  var __awaiter16 = function(thisArg, _arguments, P3, generator) {
    function adopt(value) {
      return value instanceof P3 ? value : new P3(function(resolve) {
        resolve(value);
      });
    }
    return new (P3 || (P3 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e3) {
          reject(e3);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e3) {
          reject(e3);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var logger36 = new Logger(version23);
  function getTransactionPostData(transaction) {
    const result = {};
    for (let key2 in transaction) {
      if (transaction[key2] == null) {
        continue;
      }
      let value = transaction[key2];
      if (key2 === "type" && value === 0) {
        continue;
      }
      if ({ type: true, gasLimit: true, gasPrice: true, maxFeePerGs: true, maxPriorityFeePerGas: true, nonce: true, value: true }[key2]) {
        value = hexValue(hexlify(value));
      } else if (key2 === "accessList") {
        value = "[" + accessListify(value).map((set) => {
          return `{address:"${set.address}",storageKeys:["${set.storageKeys.join('","')}"]}`;
        }).join(",") + "]";
      } else {
        value = hexlify(value);
      }
      result[key2] = value;
    }
    return result;
  }
  function getResult2(result) {
    if (result.status == 0 && (result.message === "No records found" || result.message === "No transactions found")) {
      return result.result;
    }
    if (result.status != 1 || result.message != "OK") {
      const error = new Error("invalid response");
      error.result = JSON.stringify(result);
      if ((result.result || "").toLowerCase().indexOf("rate limit") >= 0) {
        error.throttleRetry = true;
      }
      throw error;
    }
    return result.result;
  }
  function getJsonResult(result) {
    if (result && result.status == 0 && result.message == "NOTOK" && (result.result || "").toLowerCase().indexOf("rate limit") >= 0) {
      const error = new Error("throttled response");
      error.result = JSON.stringify(result);
      error.throttleRetry = true;
      throw error;
    }
    if (result.jsonrpc != "2.0") {
      const error = new Error("invalid response");
      error.result = JSON.stringify(result);
      throw error;
    }
    if (result.error) {
      const error = new Error(result.error.message || "unknown error");
      if (result.error.code) {
        error.code = result.error.code;
      }
      if (result.error.data) {
        error.data = result.error.data;
      }
      throw error;
    }
    return result.result;
  }
  function checkLogTag(blockTag) {
    if (blockTag === "pending") {
      throw new Error("pending not supported");
    }
    if (blockTag === "latest") {
      return blockTag;
    }
    return parseInt(blockTag.substring(2), 16);
  }
  var defaultApiKey2 = "9D13ZE7XSBTJ94N9BNJ2MA33VMAY2YPIRB";
  function checkError2(method, error, transaction) {
    if (method === "call" && error.code === Logger.errors.SERVER_ERROR) {
      const e3 = error.error;
      if (e3 && (e3.message.match(/reverted/i) || e3.message.match(/VM execution error/i))) {
        let data4 = e3.data;
        if (data4) {
          data4 = "0x" + data4.replace(/^.*0x/i, "");
        }
        if (isHexString(data4)) {
          return data4;
        }
        logger36.throwError("missing revert data in call exception", Logger.errors.CALL_EXCEPTION, {
          error,
          data: "0x"
        });
      }
    }
    let message = error.message;
    if (error.code === Logger.errors.SERVER_ERROR) {
      if (error.error && typeof error.error.message === "string") {
        message = error.error.message;
      } else if (typeof error.body === "string") {
        message = error.body;
      } else if (typeof error.responseText === "string") {
        message = error.responseText;
      }
    }
    message = (message || "").toLowerCase();
    if (message.match(/insufficient funds/)) {
      logger36.throwError("insufficient funds for intrinsic transaction cost", Logger.errors.INSUFFICIENT_FUNDS, {
        error,
        method,
        transaction
      });
    }
    if (message.match(/same hash was already imported|transaction nonce is too low|nonce too low/)) {
      logger36.throwError("nonce has already been used", Logger.errors.NONCE_EXPIRED, {
        error,
        method,
        transaction
      });
    }
    if (message.match(/another transaction with same nonce/)) {
      logger36.throwError("replacement fee too low", Logger.errors.REPLACEMENT_UNDERPRICED, {
        error,
        method,
        transaction
      });
    }
    if (message.match(/execution failed due to an exception|execution reverted/)) {
      logger36.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
        error,
        method,
        transaction
      });
    }
    throw error;
  }
  var EtherscanProvider = class extends BaseProvider {
    constructor(network, apiKey) {
      logger36.checkNew(new.target, EtherscanProvider);
      super(network);
      defineReadOnly(this, "baseUrl", this.getBaseUrl());
      defineReadOnly(this, "apiKey", apiKey || defaultApiKey2);
    }
    getBaseUrl() {
      switch (this.network ? this.network.name : "invalid") {
        case "homestead":
          return "https://api.etherscan.io";
        case "ropsten":
          return "https://api-ropsten.etherscan.io";
        case "rinkeby":
          return "https://api-rinkeby.etherscan.io";
        case "kovan":
          return "https://api-kovan.etherscan.io";
        case "goerli":
          return "https://api-goerli.etherscan.io";
        default:
      }
      return logger36.throwArgumentError("unsupported network", "network", name);
    }
    getUrl(module, params) {
      const query = Object.keys(params).reduce((accum, key2) => {
        const value = params[key2];
        if (value != null) {
          accum += `&${key2}=${value}`;
        }
        return accum;
      }, "");
      const apiKey = this.apiKey ? `&apikey=${this.apiKey}` : "";
      return `${this.baseUrl}/api?module=${module}${query}${apiKey}`;
    }
    getPostUrl() {
      return `${this.baseUrl}/api`;
    }
    getPostData(module, params) {
      params.module = module;
      params.apikey = this.apiKey;
      return params;
    }
    fetch(module, params, post) {
      return __awaiter16(this, void 0, void 0, function* () {
        const url = post ? this.getPostUrl() : this.getUrl(module, params);
        const payload = post ? this.getPostData(module, params) : null;
        const procFunc = module === "proxy" ? getJsonResult : getResult2;
        this.emit("debug", {
          action: "request",
          request: url,
          provider: this
        });
        const connection = {
          url,
          throttleSlotInterval: 1e3,
          throttleCallback: (attempt, url2) => {
            if (this.isCommunityResource()) {
              showThrottleMessage();
            }
            return Promise.resolve(true);
          }
        };
        let payloadStr = null;
        if (payload) {
          connection.headers = { "content-type": "application/x-www-form-urlencoded; charset=UTF-8" };
          payloadStr = Object.keys(payload).map((key2) => {
            return `${key2}=${payload[key2]}`;
          }).join("&");
        }
        const result = yield fetchJson(connection, payloadStr, procFunc || getJsonResult);
        this.emit("debug", {
          action: "response",
          request: url,
          response: deepCopy(result),
          provider: this
        });
        return result;
      });
    }
    detectNetwork() {
      return __awaiter16(this, void 0, void 0, function* () {
        return this.network;
      });
    }
    perform(method, params) {
      const _super = Object.create(null, {
        perform: { get: () => super.perform }
      });
      return __awaiter16(this, void 0, void 0, function* () {
        switch (method) {
          case "getBlockNumber":
            return this.fetch("proxy", { action: "eth_blockNumber" });
          case "getGasPrice":
            return this.fetch("proxy", { action: "eth_gasPrice" });
          case "getBalance":
            return this.fetch("account", {
              action: "balance",
              address: params.address,
              tag: params.blockTag
            });
          case "getTransactionCount":
            return this.fetch("proxy", {
              action: "eth_getTransactionCount",
              address: params.address,
              tag: params.blockTag
            });
          case "getCode":
            return this.fetch("proxy", {
              action: "eth_getCode",
              address: params.address,
              tag: params.blockTag
            });
          case "getStorageAt":
            return this.fetch("proxy", {
              action: "eth_getStorageAt",
              address: params.address,
              position: params.position,
              tag: params.blockTag
            });
          case "sendTransaction":
            return this.fetch("proxy", {
              action: "eth_sendRawTransaction",
              hex: params.signedTransaction
            }, true).catch((error) => {
              return checkError2("sendTransaction", error, params.signedTransaction);
            });
          case "getBlock":
            if (params.blockTag) {
              return this.fetch("proxy", {
                action: "eth_getBlockByNumber",
                tag: params.blockTag,
                boolean: params.includeTransactions ? "true" : "false"
              });
            }
            throw new Error("getBlock by blockHash not implemented");
          case "getTransaction":
            return this.fetch("proxy", {
              action: "eth_getTransactionByHash",
              txhash: params.transactionHash
            });
          case "getTransactionReceipt":
            return this.fetch("proxy", {
              action: "eth_getTransactionReceipt",
              txhash: params.transactionHash
            });
          case "call": {
            if (params.blockTag !== "latest") {
              throw new Error("EtherscanProvider does not support blockTag for call");
            }
            const postData = getTransactionPostData(params.transaction);
            postData.module = "proxy";
            postData.action = "eth_call";
            try {
              return yield this.fetch("proxy", postData, true);
            } catch (error) {
              return checkError2("call", error, params.transaction);
            }
          }
          case "estimateGas": {
            const postData = getTransactionPostData(params.transaction);
            postData.module = "proxy";
            postData.action = "eth_estimateGas";
            try {
              return yield this.fetch("proxy", postData, true);
            } catch (error) {
              return checkError2("estimateGas", error, params.transaction);
            }
          }
          case "getLogs": {
            const args = { action: "getLogs" };
            if (params.filter.fromBlock) {
              args.fromBlock = checkLogTag(params.filter.fromBlock);
            }
            if (params.filter.toBlock) {
              args.toBlock = checkLogTag(params.filter.toBlock);
            }
            if (params.filter.address) {
              args.address = params.filter.address;
            }
            if (params.filter.topics && params.filter.topics.length > 0) {
              if (params.filter.topics.length > 1) {
                logger36.throwError("unsupported topic count", Logger.errors.UNSUPPORTED_OPERATION, { topics: params.filter.topics });
              }
              if (params.filter.topics.length === 1) {
                const topic0 = params.filter.topics[0];
                if (typeof topic0 !== "string" || topic0.length !== 66) {
                  logger36.throwError("unsupported topic format", Logger.errors.UNSUPPORTED_OPERATION, { topic0 });
                }
                args.topic0 = topic0;
              }
            }
            const logs = yield this.fetch("logs", args);
            let blocks = {};
            for (let i3 = 0; i3 < logs.length; i3++) {
              const log = logs[i3];
              if (log.blockHash != null) {
                continue;
              }
              if (blocks[log.blockNumber] == null) {
                const block = yield this.getBlock(log.blockNumber);
                if (block) {
                  blocks[log.blockNumber] = block.hash;
                }
              }
              log.blockHash = blocks[log.blockNumber];
            }
            return logs;
          }
          case "getEtherPrice":
            if (this.network.name !== "homestead") {
              return 0;
            }
            return parseFloat((yield this.fetch("stats", { action: "ethprice" })).ethusd);
          default:
            break;
        }
        return _super.perform.call(this, method, params);
      });
    }
    getHistory(addressOrName, startBlock, endBlock) {
      return __awaiter16(this, void 0, void 0, function* () {
        const params = {
          action: "txlist",
          address: yield this.resolveName(addressOrName),
          startblock: startBlock == null ? 0 : startBlock,
          endblock: endBlock == null ? 99999999 : endBlock,
          sort: "asc"
        };
        const result = yield this.fetch("account", params);
        return result.map((tx) => {
          ["contractAddress", "to"].forEach(function(key2) {
            if (tx[key2] == "") {
              delete tx[key2];
            }
          });
          if (tx.creates == null && tx.contractAddress != null) {
            tx.creates = tx.contractAddress;
          }
          const item = this.formatter.transactionResponse(tx);
          if (tx.timeStamp) {
            item.timestamp = parseInt(tx.timeStamp);
          }
          return item;
        });
      });
    }
    isCommunityResource() {
      return this.apiKey === defaultApiKey2;
    }
  };

  // node_modules/@ethersproject/providers/lib.esm/fallback-provider.js
  "use strict";
  var __awaiter17 = function(thisArg, _arguments, P3, generator) {
    function adopt(value) {
      return value instanceof P3 ? value : new P3(function(resolve) {
        resolve(value);
      });
    }
    return new (P3 || (P3 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e3) {
          reject(e3);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e3) {
          reject(e3);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var logger37 = new Logger(version23);
  function now() {
    return new Date().getTime();
  }
  function checkNetworks(networks2) {
    let result = null;
    for (let i3 = 0; i3 < networks2.length; i3++) {
      const network = networks2[i3];
      if (network == null) {
        return null;
      }
      if (result) {
        if (!(result.name === network.name && result.chainId === network.chainId && (result.ensAddress === network.ensAddress || result.ensAddress == null && network.ensAddress == null))) {
          logger37.throwArgumentError("provider mismatch", "networks", networks2);
        }
      } else {
        result = network;
      }
    }
    return result;
  }
  function median(values, maxDelta) {
    values = values.slice().sort();
    const middle = Math.floor(values.length / 2);
    if (values.length % 2) {
      return values[middle];
    }
    const a3 = values[middle - 1], b2 = values[middle];
    if (maxDelta != null && Math.abs(a3 - b2) > maxDelta) {
      return null;
    }
    return (a3 + b2) / 2;
  }
  function serialize2(value) {
    if (value === null) {
      return "null";
    } else if (typeof value === "number" || typeof value === "boolean") {
      return JSON.stringify(value);
    } else if (typeof value === "string") {
      return value;
    } else if (BigNumber.isBigNumber(value)) {
      return value.toString();
    } else if (Array.isArray(value)) {
      return JSON.stringify(value.map((i3) => serialize2(i3)));
    } else if (typeof value === "object") {
      const keys = Object.keys(value);
      keys.sort();
      return "{" + keys.map((key2) => {
        let v3 = value[key2];
        if (typeof v3 === "function") {
          v3 = "[function]";
        } else {
          v3 = serialize2(v3);
        }
        return JSON.stringify(key2) + ":" + v3;
      }).join(",") + "}";
    }
    throw new Error("unknown value type: " + typeof value);
  }
  var nextRid = 1;
  function stall2(duration) {
    let cancel = null;
    let timer2 = null;
    let promise = new Promise((resolve) => {
      cancel = function() {
        if (timer2) {
          clearTimeout(timer2);
          timer2 = null;
        }
        resolve();
      };
      timer2 = setTimeout(cancel, duration);
    });
    const wait = (func) => {
      promise = promise.then(func);
      return promise;
    };
    function getPromise() {
      return promise;
    }
    return { cancel, getPromise, wait };
  }
  var ForwardErrors = [
    Logger.errors.CALL_EXCEPTION,
    Logger.errors.INSUFFICIENT_FUNDS,
    Logger.errors.NONCE_EXPIRED,
    Logger.errors.REPLACEMENT_UNDERPRICED,
    Logger.errors.UNPREDICTABLE_GAS_LIMIT
  ];
  var ForwardProperties = [
    "address",
    "args",
    "errorArgs",
    "errorSignature",
    "method",
    "transaction"
  ];
  function exposeDebugConfig(config, now2) {
    const result = {
      weight: config.weight
    };
    Object.defineProperty(result, "provider", { get: () => config.provider });
    if (config.start) {
      result.start = config.start;
    }
    if (now2) {
      result.duration = now2 - config.start;
    }
    if (config.done) {
      if (config.error) {
        result.error = config.error;
      } else {
        result.result = config.result || null;
      }
    }
    return result;
  }
  function normalizedTally(normalize, quorum) {
    return function(configs) {
      const tally = {};
      configs.forEach((c3) => {
        const value = normalize(c3.result);
        if (!tally[value]) {
          tally[value] = { count: 0, result: c3.result };
        }
        tally[value].count++;
      });
      const keys = Object.keys(tally);
      for (let i3 = 0; i3 < keys.length; i3++) {
        const check = tally[keys[i3]];
        if (check.count >= quorum) {
          return check.result;
        }
      }
      return void 0;
    };
  }
  function getProcessFunc(provider, method, params) {
    let normalize = serialize2;
    switch (method) {
      case "getBlockNumber":
        return function(configs) {
          const values = configs.map((c3) => c3.result);
          let blockNumber = median(configs.map((c3) => c3.result), 2);
          if (blockNumber == null) {
            return void 0;
          }
          blockNumber = Math.ceil(blockNumber);
          if (values.indexOf(blockNumber + 1) >= 0) {
            blockNumber++;
          }
          if (blockNumber >= provider._highestBlockNumber) {
            provider._highestBlockNumber = blockNumber;
          }
          return provider._highestBlockNumber;
        };
      case "getGasPrice":
        return function(configs) {
          const values = configs.map((c3) => c3.result);
          values.sort();
          return values[Math.floor(values.length / 2)];
        };
      case "getEtherPrice":
        return function(configs) {
          return median(configs.map((c3) => c3.result));
        };
      case "getBalance":
      case "getTransactionCount":
      case "getCode":
      case "getStorageAt":
      case "call":
      case "estimateGas":
      case "getLogs":
        break;
      case "getTransaction":
      case "getTransactionReceipt":
        normalize = function(tx) {
          if (tx == null) {
            return null;
          }
          tx = shallowCopy(tx);
          tx.confirmations = -1;
          return serialize2(tx);
        };
        break;
      case "getBlock":
        if (params.includeTransactions) {
          normalize = function(block) {
            if (block == null) {
              return null;
            }
            block = shallowCopy(block);
            block.transactions = block.transactions.map((tx) => {
              tx = shallowCopy(tx);
              tx.confirmations = -1;
              return tx;
            });
            return serialize2(block);
          };
        } else {
          normalize = function(block) {
            if (block == null) {
              return null;
            }
            return serialize2(block);
          };
        }
        break;
      default:
        throw new Error("unknown method: " + method);
    }
    return normalizedTally(normalize, provider.quorum);
  }
  function waitForSync(config, blockNumber) {
    return __awaiter17(this, void 0, void 0, function* () {
      const provider = config.provider;
      if (provider.blockNumber != null && provider.blockNumber >= blockNumber || blockNumber === -1) {
        return provider;
      }
      return poll(() => {
        return new Promise((resolve, reject) => {
          setTimeout(function() {
            if (provider.blockNumber >= blockNumber) {
              return resolve(provider);
            }
            if (config.cancelled) {
              return resolve(null);
            }
            return resolve(void 0);
          }, 0);
        });
      }, { oncePoll: provider });
    });
  }
  function getRunner(config, currentBlockNumber, method, params) {
    return __awaiter17(this, void 0, void 0, function* () {
      let provider = config.provider;
      switch (method) {
        case "getBlockNumber":
        case "getGasPrice":
          return provider[method]();
        case "getEtherPrice":
          if (provider.getEtherPrice) {
            return provider.getEtherPrice();
          }
          break;
        case "getBalance":
        case "getTransactionCount":
        case "getCode":
          if (params.blockTag && isHexString(params.blockTag)) {
            provider = yield waitForSync(config, currentBlockNumber);
          }
          return provider[method](params.address, params.blockTag || "latest");
        case "getStorageAt":
          if (params.blockTag && isHexString(params.blockTag)) {
            provider = yield waitForSync(config, currentBlockNumber);
          }
          return provider.getStorageAt(params.address, params.position, params.blockTag || "latest");
        case "getBlock":
          if (params.blockTag && isHexString(params.blockTag)) {
            provider = yield waitForSync(config, currentBlockNumber);
          }
          return provider[params.includeTransactions ? "getBlockWithTransactions" : "getBlock"](params.blockTag || params.blockHash);
        case "call":
        case "estimateGas":
          if (params.blockTag && isHexString(params.blockTag)) {
            provider = yield waitForSync(config, currentBlockNumber);
          }
          return provider[method](params.transaction);
        case "getTransaction":
        case "getTransactionReceipt":
          return provider[method](params.transactionHash);
        case "getLogs": {
          let filter = params.filter;
          if (filter.fromBlock && isHexString(filter.fromBlock) || filter.toBlock && isHexString(filter.toBlock)) {
            provider = yield waitForSync(config, currentBlockNumber);
          }
          return provider.getLogs(filter);
        }
      }
      return logger37.throwError("unknown method error", Logger.errors.UNKNOWN_ERROR, {
        method,
        params
      });
    });
  }
  var FallbackProvider = class extends BaseProvider {
    constructor(providers, quorum) {
      logger37.checkNew(new.target, FallbackProvider);
      if (providers.length === 0) {
        logger37.throwArgumentError("missing providers", "providers", providers);
      }
      const providerConfigs = providers.map((configOrProvider, index) => {
        if (Provider.isProvider(configOrProvider)) {
          const stallTimeout = isCommunityResource(configOrProvider) ? 2e3 : 750;
          const priority = 1;
          return Object.freeze({ provider: configOrProvider, weight: 1, stallTimeout, priority });
        }
        const config = shallowCopy(configOrProvider);
        if (config.priority == null) {
          config.priority = 1;
        }
        if (config.stallTimeout == null) {
          config.stallTimeout = isCommunityResource(configOrProvider) ? 2e3 : 750;
        }
        if (config.weight == null) {
          config.weight = 1;
        }
        const weight = config.weight;
        if (weight % 1 || weight > 512 || weight < 1) {
          logger37.throwArgumentError("invalid weight; must be integer in [1, 512]", `providers[${index}].weight`, weight);
        }
        return Object.freeze(config);
      });
      const total = providerConfigs.reduce((accum, c3) => accum + c3.weight, 0);
      if (quorum == null) {
        quorum = total / 2;
      } else if (quorum > total) {
        logger37.throwArgumentError("quorum will always fail; larger than total weight", "quorum", quorum);
      }
      let networkOrReady = checkNetworks(providerConfigs.map((c3) => c3.provider.network));
      if (networkOrReady == null) {
        networkOrReady = new Promise((resolve, reject) => {
          setTimeout(() => {
            this.detectNetwork().then(resolve, reject);
          }, 0);
        });
      }
      super(networkOrReady);
      defineReadOnly(this, "providerConfigs", Object.freeze(providerConfigs));
      defineReadOnly(this, "quorum", quorum);
      this._highestBlockNumber = -1;
    }
    detectNetwork() {
      return __awaiter17(this, void 0, void 0, function* () {
        const networks2 = yield Promise.all(this.providerConfigs.map((c3) => c3.provider.getNetwork()));
        return checkNetworks(networks2);
      });
    }
    perform(method, params) {
      return __awaiter17(this, void 0, void 0, function* () {
        if (method === "sendTransaction") {
          const results = yield Promise.all(this.providerConfigs.map((c3) => {
            return c3.provider.sendTransaction(params.signedTransaction).then((result) => {
              return result.hash;
            }, (error) => {
              return error;
            });
          }));
          for (let i4 = 0; i4 < results.length; i4++) {
            const result = results[i4];
            if (typeof result === "string") {
              return result;
            }
          }
          throw results[0];
        }
        if (this._highestBlockNumber === -1 && method !== "getBlockNumber") {
          yield this.getBlockNumber();
        }
        const processFunc = getProcessFunc(this, method, params);
        const configs = shuffled(this.providerConfigs.map(shallowCopy));
        configs.sort((a3, b2) => a3.priority - b2.priority);
        const currentBlockNumber = this._highestBlockNumber;
        let i3 = 0;
        let first = true;
        while (true) {
          const t0 = now();
          let inflightWeight = configs.filter((c3) => c3.runner && t0 - c3.start < c3.stallTimeout).reduce((accum, c3) => accum + c3.weight, 0);
          while (inflightWeight < this.quorum && i3 < configs.length) {
            const config = configs[i3++];
            const rid = nextRid++;
            config.start = now();
            config.staller = stall2(config.stallTimeout);
            config.staller.wait(() => {
              config.staller = null;
            });
            config.runner = getRunner(config, currentBlockNumber, method, params).then((result) => {
              config.done = true;
              config.result = result;
              if (this.listenerCount("debug")) {
                this.emit("debug", {
                  action: "request",
                  rid,
                  backend: exposeDebugConfig(config, now()),
                  request: { method, params: deepCopy(params) },
                  provider: this
                });
              }
            }, (error) => {
              config.done = true;
              config.error = error;
              if (this.listenerCount("debug")) {
                this.emit("debug", {
                  action: "request",
                  rid,
                  backend: exposeDebugConfig(config, now()),
                  request: { method, params: deepCopy(params) },
                  provider: this
                });
              }
            });
            if (this.listenerCount("debug")) {
              this.emit("debug", {
                action: "request",
                rid,
                backend: exposeDebugConfig(config, null),
                request: { method, params: deepCopy(params) },
                provider: this
              });
            }
            inflightWeight += config.weight;
          }
          const waiting = [];
          configs.forEach((c3) => {
            if (c3.done || !c3.runner) {
              return;
            }
            waiting.push(c3.runner);
            if (c3.staller) {
              waiting.push(c3.staller.getPromise());
            }
          });
          if (waiting.length) {
            yield Promise.race(waiting);
          }
          const results = configs.filter((c3) => c3.done && c3.error == null);
          if (results.length >= this.quorum) {
            const result = processFunc(results);
            if (result !== void 0) {
              configs.forEach((c3) => {
                if (c3.staller) {
                  c3.staller.cancel();
                }
                c3.cancelled = true;
              });
              return result;
            }
            if (!first) {
              yield stall2(100).getPromise();
            }
            first = false;
          }
          const errors = configs.reduce((accum, c3) => {
            if (!c3.done || c3.error == null) {
              return accum;
            }
            const code = c3.error.code;
            if (ForwardErrors.indexOf(code) >= 0) {
              if (!accum[code]) {
                accum[code] = { error: c3.error, weight: 0 };
              }
              accum[code].weight += c3.weight;
            }
            return accum;
          }, {});
          Object.keys(errors).forEach((errorCode) => {
            const tally = errors[errorCode];
            if (tally.weight < this.quorum) {
              return;
            }
            configs.forEach((c3) => {
              if (c3.staller) {
                c3.staller.cancel();
              }
              c3.cancelled = true;
            });
            const e3 = tally.error;
            const props = {};
            ForwardProperties.forEach((name2) => {
              if (e3[name2] == null) {
                return;
              }
              props[name2] = e3[name2];
            });
            logger37.throwError(e3.reason || e3.message, errorCode, props);
          });
          if (configs.filter((c3) => !c3.done).length === 0) {
            break;
          }
        }
        configs.forEach((c3) => {
          if (c3.staller) {
            c3.staller.cancel();
          }
          c3.cancelled = true;
        });
        return logger37.throwError("failed to meet quorum", Logger.errors.SERVER_ERROR, {
          method,
          params,
          results: configs.map((c3) => exposeDebugConfig(c3)),
          provider: this
        });
      });
    }
  };

  // node_modules/@ethersproject/providers/lib.esm/ipc-provider.js
  "use strict";
  var IpcProvider = null;

  // node_modules/@ethersproject/providers/lib.esm/infura-provider.js
  "use strict";
  var logger38 = new Logger(version23);
  var defaultProjectId = "84842078b09946638c03157f83405213";
  var InfuraWebSocketProvider = class extends WebSocketProvider {
    constructor(network, apiKey) {
      const provider = new InfuraProvider(network, apiKey);
      const connection = provider.connection;
      if (connection.password) {
        logger38.throwError("INFURA WebSocket project secrets unsupported", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "InfuraProvider.getWebSocketProvider()"
        });
      }
      const url = connection.url.replace(/^http/i, "ws").replace("/v3/", "/ws/v3/");
      super(url, network);
      defineReadOnly(this, "apiKey", provider.projectId);
      defineReadOnly(this, "projectId", provider.projectId);
      defineReadOnly(this, "projectSecret", provider.projectSecret);
    }
    isCommunityResource() {
      return this.projectId === defaultProjectId;
    }
  };
  var InfuraProvider = class extends UrlJsonRpcProvider {
    static getWebSocketProvider(network, apiKey) {
      return new InfuraWebSocketProvider(network, apiKey);
    }
    static getApiKey(apiKey) {
      const apiKeyObj = {
        apiKey: defaultProjectId,
        projectId: defaultProjectId,
        projectSecret: null
      };
      if (apiKey == null) {
        return apiKeyObj;
      }
      if (typeof apiKey === "string") {
        apiKeyObj.projectId = apiKey;
      } else if (apiKey.projectSecret != null) {
        logger38.assertArgument(typeof apiKey.projectId === "string", "projectSecret requires a projectId", "projectId", apiKey.projectId);
        logger38.assertArgument(typeof apiKey.projectSecret === "string", "invalid projectSecret", "projectSecret", "[REDACTED]");
        apiKeyObj.projectId = apiKey.projectId;
        apiKeyObj.projectSecret = apiKey.projectSecret;
      } else if (apiKey.projectId) {
        apiKeyObj.projectId = apiKey.projectId;
      }
      apiKeyObj.apiKey = apiKeyObj.projectId;
      return apiKeyObj;
    }
    static getUrl(network, apiKey) {
      let host = null;
      switch (network ? network.name : "unknown") {
        case "homestead":
          host = "mainnet.infura.io";
          break;
        case "ropsten":
          host = "ropsten.infura.io";
          break;
        case "rinkeby":
          host = "rinkeby.infura.io";
          break;
        case "kovan":
          host = "kovan.infura.io";
          break;
        case "goerli":
          host = "goerli.infura.io";
          break;
        case "matic":
          host = "polygon-mainnet.infura.io";
          break;
        case "maticmum":
          host = "polygon-mumbai.infura.io";
          break;
        default:
          logger38.throwError("unsupported network", Logger.errors.INVALID_ARGUMENT, {
            argument: "network",
            value: network
          });
      }
      const connection = {
        allowGzip: true,
        url: "https://" + host + "/v3/" + apiKey.projectId,
        throttleCallback: (attempt, url) => {
          if (apiKey.projectId === defaultProjectId) {
            showThrottleMessage();
          }
          return Promise.resolve(true);
        }
      };
      if (apiKey.projectSecret != null) {
        connection.user = "";
        connection.password = apiKey.projectSecret;
      }
      return connection;
    }
    isCommunityResource() {
      return this.projectId === defaultProjectId;
    }
  };

  // node_modules/@ethersproject/providers/lib.esm/json-rpc-batch-provider.js
  var JsonRpcBatchProvider = class extends JsonRpcProvider {
    send(method, params) {
      const request = {
        method,
        params,
        id: this._nextId++,
        jsonrpc: "2.0"
      };
      if (this._pendingBatch == null) {
        this._pendingBatch = [];
      }
      const inflightRequest = { request, resolve: null, reject: null };
      const promise = new Promise((resolve, reject) => {
        inflightRequest.resolve = resolve;
        inflightRequest.reject = reject;
      });
      this._pendingBatch.push(inflightRequest);
      if (!this._pendingBatchAggregator) {
        this._pendingBatchAggregator = setTimeout(() => {
          const batch = this._pendingBatch;
          this._pendingBatch = null;
          this._pendingBatchAggregator = null;
          const request2 = batch.map((inflight) => inflight.request);
          this.emit("debug", {
            action: "requestBatch",
            request: deepCopy(request2),
            provider: this
          });
          return fetchJson(this.connection, JSON.stringify(request2)).then((result) => {
            this.emit("debug", {
              action: "response",
              request: request2,
              response: result,
              provider: this
            });
            batch.forEach((inflightRequest2, index) => {
              const payload = result[index];
              if (payload.error) {
                const error = new Error(payload.error.message);
                error.code = payload.error.code;
                error.data = payload.error.data;
                inflightRequest2.reject(error);
              } else {
                inflightRequest2.resolve(payload.result);
              }
            });
          }, (error) => {
            this.emit("debug", {
              action: "response",
              error,
              request: request2,
              provider: this
            });
            batch.forEach((inflightRequest2) => {
              inflightRequest2.reject(error);
            });
          });
        }, 10);
      }
      return promise;
    }
  };

  // node_modules/@ethersproject/providers/lib.esm/nodesmith-provider.js
  "use strict";
  var logger39 = new Logger(version23);
  var defaultApiKey3 = "ETHERS_JS_SHARED";
  var NodesmithProvider = class extends UrlJsonRpcProvider {
    static getApiKey(apiKey) {
      if (apiKey && typeof apiKey !== "string") {
        logger39.throwArgumentError("invalid apiKey", "apiKey", apiKey);
      }
      return apiKey || defaultApiKey3;
    }
    static getUrl(network, apiKey) {
      logger39.warn("NodeSmith will be discontinued on 2019-12-20; please migrate to another platform.");
      let host = null;
      switch (network.name) {
        case "homestead":
          host = "https://ethereum.api.nodesmith.io/v1/mainnet/jsonrpc";
          break;
        case "ropsten":
          host = "https://ethereum.api.nodesmith.io/v1/ropsten/jsonrpc";
          break;
        case "rinkeby":
          host = "https://ethereum.api.nodesmith.io/v1/rinkeby/jsonrpc";
          break;
        case "goerli":
          host = "https://ethereum.api.nodesmith.io/v1/goerli/jsonrpc";
          break;
        case "kovan":
          host = "https://ethereum.api.nodesmith.io/v1/kovan/jsonrpc";
          break;
        default:
          logger39.throwArgumentError("unsupported network", "network", arguments[0]);
      }
      return host + "?apiKey=" + apiKey;
    }
  };

  // node_modules/@ethersproject/providers/lib.esm/pocket-provider.js
  "use strict";
  var logger40 = new Logger(version23);
  var defaultApplicationIds = {
    homestead: "6004bcd10040261633ade990",
    ropsten: "6004bd4d0040261633ade991",
    rinkeby: "6004bda20040261633ade994",
    goerli: "6004bd860040261633ade992"
  };
  var PocketProvider = class extends UrlJsonRpcProvider {
    constructor(network, apiKey) {
      if (apiKey == null) {
        const n2 = getStatic(new.target, "getNetwork")(network);
        if (n2) {
          const applicationId = defaultApplicationIds[n2.name];
          if (applicationId) {
            apiKey = {
              applicationId,
              loadBalancer: true
            };
          }
        }
        if (apiKey == null) {
          logger40.throwError("unsupported network", Logger.errors.INVALID_ARGUMENT, {
            argument: "network",
            value: network
          });
        }
      }
      super(network, apiKey);
    }
    static getApiKey(apiKey) {
      if (apiKey == null) {
        logger40.throwArgumentError("PocketProvider.getApiKey does not support null apiKey", "apiKey", apiKey);
      }
      const apiKeyObj = {
        applicationId: null,
        loadBalancer: false,
        applicationSecretKey: null
      };
      if (typeof apiKey === "string") {
        apiKeyObj.applicationId = apiKey;
      } else if (apiKey.applicationSecretKey != null) {
        logger40.assertArgument(typeof apiKey.applicationId === "string", "applicationSecretKey requires an applicationId", "applicationId", apiKey.applicationId);
        logger40.assertArgument(typeof apiKey.applicationSecretKey === "string", "invalid applicationSecretKey", "applicationSecretKey", "[REDACTED]");
        apiKeyObj.applicationId = apiKey.applicationId;
        apiKeyObj.applicationSecretKey = apiKey.applicationSecretKey;
        apiKeyObj.loadBalancer = !!apiKey.loadBalancer;
      } else if (apiKey.applicationId) {
        logger40.assertArgument(typeof apiKey.applicationId === "string", "apiKey.applicationId must be a string", "apiKey.applicationId", apiKey.applicationId);
        apiKeyObj.applicationId = apiKey.applicationId;
        apiKeyObj.loadBalancer = !!apiKey.loadBalancer;
      } else {
        logger40.throwArgumentError("unsupported PocketProvider apiKey", "apiKey", apiKey);
      }
      return apiKeyObj;
    }
    static getUrl(network, apiKey) {
      let host = null;
      switch (network ? network.name : "unknown") {
        case "homestead":
          host = "eth-mainnet.gateway.pokt.network";
          break;
        case "ropsten":
          host = "eth-ropsten.gateway.pokt.network";
          break;
        case "rinkeby":
          host = "eth-rinkeby.gateway.pokt.network";
          break;
        case "goerli":
          host = "eth-goerli.gateway.pokt.network";
          break;
        default:
          logger40.throwError("unsupported network", Logger.errors.INVALID_ARGUMENT, {
            argument: "network",
            value: network
          });
      }
      let url = null;
      if (apiKey.loadBalancer) {
        url = `https://${host}/v1/lb/${apiKey.applicationId}`;
      } else {
        url = `https://${host}/v1/${apiKey.applicationId}`;
      }
      const connection = { url };
      connection.headers = {};
      if (apiKey.applicationSecretKey != null) {
        connection.user = "";
        connection.password = apiKey.applicationSecretKey;
      }
      return connection;
    }
    isCommunityResource() {
      return this.applicationId === defaultApplicationIds[this.network.name];
    }
  };

  // node_modules/@ethersproject/providers/lib.esm/web3-provider.js
  "use strict";
  var logger41 = new Logger(version23);
  var _nextId = 1;
  function buildWeb3LegacyFetcher(provider, sendFunc) {
    const fetcher = "Web3LegacyFetcher";
    return function(method, params) {
      if (method == "eth_sign" && (provider.isMetaMask || provider.isStatus)) {
        method = "personal_sign";
        params = [params[1], params[0]];
      }
      const request = {
        method,
        params,
        id: _nextId++,
        jsonrpc: "2.0"
      };
      return new Promise((resolve, reject) => {
        this.emit("debug", {
          action: "request",
          fetcher,
          request: deepCopy(request),
          provider: this
        });
        sendFunc(request, (error, response) => {
          if (error) {
            this.emit("debug", {
              action: "response",
              fetcher,
              error,
              request,
              provider: this
            });
            return reject(error);
          }
          this.emit("debug", {
            action: "response",
            fetcher,
            request,
            response,
            provider: this
          });
          if (response.error) {
            const error2 = new Error(response.error.message);
            error2.code = response.error.code;
            error2.data = response.error.data;
            return reject(error2);
          }
          resolve(response.result);
        });
      });
    };
  }
  function buildEip1193Fetcher(provider) {
    return function(method, params) {
      if (params == null) {
        params = [];
      }
      if (method == "eth_sign" && (provider.isMetaMask || provider.isStatus)) {
        method = "personal_sign";
        params = [params[1], params[0]];
      }
      const request = { method, params };
      this.emit("debug", {
        action: "request",
        fetcher: "Eip1193Fetcher",
        request: deepCopy(request),
        provider: this
      });
      return provider.request(request).then((response) => {
        this.emit("debug", {
          action: "response",
          fetcher: "Eip1193Fetcher",
          request,
          response,
          provider: this
        });
        return response;
      }, (error) => {
        this.emit("debug", {
          action: "response",
          fetcher: "Eip1193Fetcher",
          request,
          error,
          provider: this
        });
        throw error;
      });
    };
  }
  var Web3Provider = class extends JsonRpcProvider {
    constructor(provider, network) {
      logger41.checkNew(new.target, Web3Provider);
      if (provider == null) {
        logger41.throwArgumentError("missing provider", "provider", provider);
      }
      let path = null;
      let jsonRpcFetchFunc = null;
      let subprovider = null;
      if (typeof provider === "function") {
        path = "unknown:";
        jsonRpcFetchFunc = provider;
      } else {
        path = provider.host || provider.path || "";
        if (!path && provider.isMetaMask) {
          path = "metamask";
        }
        subprovider = provider;
        if (provider.request) {
          if (path === "") {
            path = "eip-1193:";
          }
          jsonRpcFetchFunc = buildEip1193Fetcher(provider);
        } else if (provider.sendAsync) {
          jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.sendAsync.bind(provider));
        } else if (provider.send) {
          jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.send.bind(provider));
        } else {
          logger41.throwArgumentError("unsupported provider", "provider", provider);
        }
        if (!path) {
          path = "unknown:";
        }
      }
      super(path, network);
      defineReadOnly(this, "jsonRpcFetchFunc", jsonRpcFetchFunc);
      defineReadOnly(this, "provider", subprovider);
    }
    send(method, params) {
      return this.jsonRpcFetchFunc(method, params);
    }
  };

  // node_modules/@ethersproject/providers/lib.esm/index.js
  "use strict";
  var logger42 = new Logger(version23);
  function getDefaultProvider(network, options) {
    if (network == null) {
      network = "homestead";
    }
    if (typeof network === "string") {
      const match = network.match(/^(ws|http)s?:/i);
      if (match) {
        switch (match[1]) {
          case "http":
            return new JsonRpcProvider(network);
          case "ws":
            return new WebSocketProvider(network);
          default:
            logger42.throwArgumentError("unsupported URL scheme", "network", network);
        }
      }
    }
    const n2 = getNetwork(network);
    if (!n2 || !n2._defaultProvider) {
      logger42.throwError("unsupported getDefaultProvider network", Logger.errors.NETWORK_ERROR, {
        operation: "getDefaultProvider",
        network
      });
    }
    return n2._defaultProvider({
      FallbackProvider,
      AlchemyProvider,
      CloudflareProvider,
      EtherscanProvider,
      InfuraProvider,
      JsonRpcProvider,
      NodesmithProvider,
      PocketProvider,
      Web3Provider,
      IpcProvider
    }, options);
  }

  // node_modules/ethers/lib.esm/utils.js
  var utils_exports = {};
  __export(utils_exports, {
    AbiCoder: () => AbiCoder,
    ConstructorFragment: () => ConstructorFragment,
    ErrorFragment: () => ErrorFragment,
    EventFragment: () => EventFragment,
    FormatTypes: () => FormatTypes,
    Fragment: () => Fragment,
    FunctionFragment: () => FunctionFragment,
    HDNode: () => HDNode,
    Indexed: () => Indexed,
    Interface: () => Interface,
    LogDescription: () => LogDescription,
    Logger: () => Logger,
    ParamType: () => ParamType,
    RLP: () => lib_exports,
    SigningKey: () => SigningKey,
    SupportedAlgorithm: () => SupportedAlgorithm,
    TransactionDescription: () => TransactionDescription,
    TransactionTypes: () => TransactionTypes,
    UnicodeNormalizationForm: () => UnicodeNormalizationForm,
    Utf8ErrorFuncs: () => Utf8ErrorFuncs,
    Utf8ErrorReason: () => Utf8ErrorReason,
    _TypedDataEncoder: () => TypedDataEncoder,
    _fetchData: () => _fetchData,
    _toEscapedUtf8String: () => _toEscapedUtf8String,
    accessListify: () => accessListify,
    arrayify: () => arrayify,
    base58: () => Base58,
    base64: () => lib_exports3,
    checkProperties: () => checkProperties,
    checkResultErrors: () => checkResultErrors,
    commify: () => commify,
    computeAddress: () => computeAddress,
    computeHmac: () => computeHmac,
    computePublicKey: () => computePublicKey,
    concat: () => concat,
    deepCopy: () => deepCopy,
    defaultAbiCoder: () => defaultAbiCoder,
    defaultPath: () => defaultPath,
    defineReadOnly: () => defineReadOnly,
    entropyToMnemonic: () => entropyToMnemonic,
    fetchJson: () => fetchJson,
    formatBytes32String: () => formatBytes32String,
    formatEther: () => formatEther,
    formatUnits: () => formatUnits,
    getAccountPath: () => getAccountPath,
    getAddress: () => getAddress,
    getContractAddress: () => getContractAddress,
    getCreate2Address: () => getCreate2Address,
    getIcapAddress: () => getIcapAddress,
    getJsonWalletAddress: () => getJsonWalletAddress,
    getStatic: () => getStatic,
    hashMessage: () => hashMessage,
    hexConcat: () => hexConcat,
    hexDataLength: () => hexDataLength,
    hexDataSlice: () => hexDataSlice,
    hexStripZeros: () => hexStripZeros,
    hexValue: () => hexValue,
    hexZeroPad: () => hexZeroPad,
    hexlify: () => hexlify,
    id: () => id,
    isAddress: () => isAddress,
    isBytes: () => isBytes,
    isBytesLike: () => isBytesLike,
    isHexString: () => isHexString,
    isValidMnemonic: () => isValidMnemonic,
    isValidName: () => isValidName,
    joinSignature: () => joinSignature,
    keccak256: () => keccak256,
    mnemonicToEntropy: () => mnemonicToEntropy,
    mnemonicToSeed: () => mnemonicToSeed,
    namehash: () => namehash,
    nameprep: () => nameprep,
    parseBytes32String: () => parseBytes32String,
    parseEther: () => parseEther,
    parseTransaction: () => parse,
    parseUnits: () => parseUnits,
    poll: () => poll,
    randomBytes: () => randomBytes,
    recoverAddress: () => recoverAddress,
    recoverPublicKey: () => recoverPublicKey,
    resolveProperties: () => resolveProperties,
    ripemd160: () => ripemd160,
    serializeTransaction: () => serialize,
    sha256: () => sha256,
    sha512: () => sha512,
    shallowCopy: () => shallowCopy,
    shuffled: () => shuffled,
    solidityKeccak256: () => keccak2562,
    solidityPack: () => pack2,
    soliditySha256: () => sha2562,
    splitSignature: () => splitSignature,
    stripZeros: () => stripZeros,
    toUtf8Bytes: () => toUtf8Bytes,
    toUtf8CodePoints: () => toUtf8CodePoints,
    toUtf8String: () => toUtf8String,
    verifyMessage: () => verifyMessage,
    verifyTypedData: () => verifyTypedData,
    zeroPad: () => zeroPad
  });

  // node_modules/@ethersproject/solidity/lib.esm/index.js
  "use strict";
  var regexBytes = new RegExp("^bytes([0-9]+)$");
  var regexNumber = new RegExp("^(u?int)([0-9]*)$");
  var regexArray = new RegExp("^(.*)\\[([0-9]*)\\]$");
  var Zeros2 = "0000000000000000000000000000000000000000000000000000000000000000";
  function _pack(type, value, isArray) {
    switch (type) {
      case "address":
        if (isArray) {
          return zeroPad(value, 32);
        }
        return arrayify(value);
      case "string":
        return toUtf8Bytes(value);
      case "bytes":
        return arrayify(value);
      case "bool":
        value = value ? "0x01" : "0x00";
        if (isArray) {
          return zeroPad(value, 32);
        }
        return arrayify(value);
    }
    let match = type.match(regexNumber);
    if (match) {
      let size = parseInt(match[2] || "256");
      if (match[2] && String(size) !== match[2] || size % 8 !== 0 || size === 0 || size > 256) {
        throw new Error("invalid number type - " + type);
      }
      if (isArray) {
        size = 256;
      }
      value = BigNumber.from(value).toTwos(size);
      return zeroPad(value, size / 8);
    }
    match = type.match(regexBytes);
    if (match) {
      const size = parseInt(match[1]);
      if (String(size) !== match[1] || size === 0 || size > 32) {
        throw new Error("invalid bytes type - " + type);
      }
      if (arrayify(value).byteLength !== size) {
        throw new Error("invalid value for " + type);
      }
      if (isArray) {
        return arrayify((value + Zeros2).substring(0, 66));
      }
      return value;
    }
    match = type.match(regexArray);
    if (match && Array.isArray(value)) {
      const baseType = match[1];
      const count = parseInt(match[2] || String(value.length));
      if (count != value.length) {
        throw new Error("invalid value for " + type);
      }
      const result = [];
      value.forEach(function(value2) {
        result.push(_pack(baseType, value2, true));
      });
      return concat(result);
    }
    throw new Error("invalid type - " + type);
  }
  function pack2(types, values) {
    if (types.length != values.length) {
      throw new Error("type/value count mismatch");
    }
    const tight = [];
    types.forEach(function(type, index) {
      tight.push(_pack(type, values[index]));
    });
    return hexlify(concat(tight));
  }
  function keccak2562(types, values) {
    return keccak256(pack2(types, values));
  }
  function sha2562(types, values) {
    return sha256(pack2(types, values));
  }

  // node_modules/@ethersproject/units/lib.esm/_version.js
  var version24 = "units/5.4.0";

  // node_modules/@ethersproject/units/lib.esm/index.js
  "use strict";
  var logger43 = new Logger(version24);
  var names = [
    "wei",
    "kwei",
    "mwei",
    "gwei",
    "szabo",
    "finney",
    "ether"
  ];
  function commify(value) {
    const comps = String(value).split(".");
    if (comps.length > 2 || !comps[0].match(/^-?[0-9]*$/) || comps[1] && !comps[1].match(/^[0-9]*$/) || value === "." || value === "-.") {
      logger43.throwArgumentError("invalid value", "value", value);
    }
    let whole = comps[0];
    let negative = "";
    if (whole.substring(0, 1) === "-") {
      negative = "-";
      whole = whole.substring(1);
    }
    while (whole.substring(0, 1) === "0") {
      whole = whole.substring(1);
    }
    if (whole === "") {
      whole = "0";
    }
    let suffix = "";
    if (comps.length === 2) {
      suffix = "." + (comps[1] || "0");
    }
    while (suffix.length > 2 && suffix[suffix.length - 1] === "0") {
      suffix = suffix.substring(0, suffix.length - 1);
    }
    const formatted = [];
    while (whole.length) {
      if (whole.length <= 3) {
        formatted.unshift(whole);
        break;
      } else {
        const index = whole.length - 3;
        formatted.unshift(whole.substring(index));
        whole = whole.substring(0, index);
      }
    }
    return negative + formatted.join(",") + suffix;
  }
  function formatUnits(value, unitName) {
    if (typeof unitName === "string") {
      const index = names.indexOf(unitName);
      if (index !== -1) {
        unitName = 3 * index;
      }
    }
    return formatFixed(value, unitName != null ? unitName : 18);
  }
  function parseUnits(value, unitName) {
    if (typeof value !== "string") {
      logger43.throwArgumentError("value must be a string", "value", value);
    }
    if (typeof unitName === "string") {
      const index = names.indexOf(unitName);
      if (index !== -1) {
        unitName = 3 * index;
      }
    }
    return parseFixed(value, unitName != null ? unitName : 18);
  }
  function formatEther(wei) {
    return formatUnits(wei, 18);
  }
  function parseEther(ether) {
    return parseUnits(ether, 18);
  }

  // node_modules/ethers/lib.esm/utils.js
  "use strict";

  // node_modules/ethers/lib.esm/_version.js
  var version25 = "ethers/5.4.4";

  // node_modules/ethers/lib.esm/ethers.js
  "use strict";
  var logger44 = new Logger(version25);

  // node_modules/ethers/lib.esm/index.js
  "use strict";
  try {
    const anyGlobal2 = window;
    if (anyGlobal2._ethers == null) {
      anyGlobal2._ethers = ethers_exports;
    }
  } catch (error) {
  }

  // src/domain/contract/readResponse.ts
  var ReadResponse = class {
    constructor(res) {
      this.convertRecursively = (data4) => {
        if (Array.isArray(data4)) {
          return data4.map((elm) => this.convertRecursively(elm));
        }
        if (BigNumber.isBigNumber(data4) || FixedNumber.isFixedNumber(data4)) {
          return data4.toString();
        }
        if (data4 !== null && typeof data4 === "object") {
          const converted = {};
          Object.keys(data4).forEach((key2) => {
            converted[key2] = this.convertRecursively(data4[key2]);
          });
          return converted;
        }
        return data4;
      };
      this.rawData = res;
      this.data = this.convertRecursively(res);
    }
  };

  // src/domain/contract/contract.ts
  var SIMILAR_IF_ERROR = `bunzz-sdk can't call an overloaded function that has a similar interface with other functions.
Use "strict call" like "contract['methodName(<type in string>)'](args);"`;
  var BaseContract2 = class {
    constructor(config, provider, trackAction2) {
      const { name: name2, abi } = config;
      this.name = name2;
      this.provider = provider;
      this.ethersContract = new Contract(config.address, config.abi, provider).connect(provider.getSigner());
      this.abis = abi;
      this.trackAction = trackAction2;
      if (Array.isArray(abi))
        this.attachFunctions(abi);
    }
    getAbi(name2) {
      return this.abis.filter((abi) => abi.name === name2);
    }
    getAddress() {
      return this.ethersContract.address;
    }
    attachFunctions(abis) {
      abis.forEach((abi) => {
        Object.defineProperty(this, abi.name, {
          value: this.buildDefaultFunction(abi),
          configurable: true
        });
        Object.defineProperty(this, `${abi.name}(${this.getInputTypes(abi)})`, {
          value: this.buildStrictFunction(abi),
          configurable: true
        });
      });
    }
    getFunctionNameOnEthers(abi) {
      const matchedAbi = this.getAbi(abi.name);
      const isExists = matchedAbi.length > 1;
      if (isExists) {
        return `${abi.name}(${this.getInputTypes(abi)})`;
      }
      return abi.name;
    }
    getInputTypes(abi) {
      return abi.inputs.map((input) => input.type).join(",");
    }
    buildDefaultFunction(abi) {
      switch (abi.stateMutability) {
        case "view":
        case "pure":
          return (...args) => {
            const matchedAbi = this.getMatchedAbi(abi.name, args);
            return this.callReadAction(this.getFunctionNameOnEthers(matchedAbi), args);
          };
        default:
          return (...args) => {
            const matchedAbi = this.getMatchedAbi(abi.name, args);
            return this.callUpdateAction(this.getFunctionNameOnEthers(matchedAbi), args);
          };
      }
    }
    buildStrictFunction(abi) {
      switch (abi.stateMutability) {
        case "view":
        case "pure":
          return (...args) => {
            if (abi.inputs.length !== args.length) {
              throw new Error(`Wrong number of arguments: ${abi.name}`);
            }
            return this.callReadAction(this.getFunctionNameOnEthers(abi), args);
          };
        default:
          return (...args) => {
            if (abi.inputs.length !== args.length) {
              throw new Error(`Wrong number of arguments: ${abi.name}`);
            }
            return this.callUpdateAction(this.getFunctionNameOnEthers(abi), args);
          };
      }
    }
    callReadAction(methodName, args) {
      return __async(this, null, function* () {
        var _a;
        const res = yield this.ethersContract[methodName](...args);
        this.trackAction({
          eventName: "callFunction",
          functionName: methodName,
          pathname: (_a = window == null ? void 0 : window.location) == null ? void 0 : _a.pathname,
          functionType: "read",
          functionArgs: JSON.stringify([...args])
        });
        return new ReadResponse(res);
      });
    }
    callUpdateAction(methodName, args) {
      return __async(this, null, function* () {
        var _a;
        const tx = yield this.ethersContract[methodName](...args);
        this.trackAction({
          eventName: "callFunction",
          functionName: methodName,
          pathname: (_a = window == null ? void 0 : window.location) == null ? void 0 : _a.pathname,
          functionType: "update",
          functionArgs: JSON.stringify([...args])
        });
        return new Transaction(tx.hash, tx);
      });
    }
    getMatchedAbi(funcName, args) {
      const nameMatched = this.getAbi(funcName);
      if (nameMatched.length < 1)
        throw new Error(`Invalid function name: ${funcName}`);
      let argsWithoutOption;
      if (this.isUpdatableOption(args.slice(-1)[0])) {
        argsWithoutOption = args.slice(0, -1);
      } else {
        argsWithoutOption = args;
      }
      const lengthMatched = nameMatched.filter((abi) => abi.inputs.length === argsWithoutOption.length);
      if (lengthMatched.length < 1) {
        throw new Error(`Wrong number of arguments: ${funcName}`);
      }
      return this.searchTypeMatchedAbi(lengthMatched, nameMatched, argsWithoutOption);
    }
    searchTypeMatchedAbi(lengthMatched, nameMatched, args) {
      const matchedAbi = lengthMatched.filter((abi) => {
        return abi.inputs.every((abiInput, i3) => {
          return this.verifyArgumentType(abiInput.type, args[i3]);
        });
      });
      if (matchedAbi.length > 1) {
        throw new Error(SIMILAR_IF_ERROR);
      }
      if (matchedAbi.length < 1) {
        const abiMessage = nameMatched.reduce((current, abi, index) => {
          const abiStr = `"${abi.name}(${this.getInputTypes(abi)})"`;
          if (index === 0)
            return abiStr;
          return `${current} or ${abiStr}`;
        }, "");
        const message = `Argument types unmatched.
The valid arguments types are ${abiMessage}.
Your request is "${nameMatched[0].name}(${args})"`;
        throw new Error(message);
      }
      return matchedAbi[0];
    }
    verifyArgumentType(abiType, arg) {
      if (abiType.slice(-2) === "[]" && Array.isArray(arg)) {
        return arg.every((_arg) => this.verifyArgumentType(abiType.slice(0, -2), _arg));
      }
      if (abiType === "address") {
        return utils_exports.isAddress(arg);
      }
      if (abiType === "string") {
        return typeof arg === "string";
      }
      if (abiType.slice(0, 5) === "bytes") {
        return utils_exports.isBytesLike(arg);
      }
      if (abiType.slice(0, 4) === "uint" || abiType.slice(0, 3) === "int") {
        try {
          return BigNumber.from(arg)._isBigNumber;
        } catch (err) {
          console.error(err);
          return false;
        }
      }
      if (abiType.slice(0, 6) === "ufixed" || abiType.slice(0, 5) === "fixed") {
        const _arg = typeof arg === "number" ? arg.toString() : arg;
        try {
          return FixedNumber.from(_arg)._isFixedNumber;
        } catch (err) {
          console.error(err);
          return false;
        }
      }
      if (abiType.slice(0, 4) === "bool")
        return arg === "true";
      return false;
    }
    isUpdatableOption(arg) {
      if (!arg)
        return false;
      return !!(arg.gasPrice | arg.gasLimit | arg.value | arg.nonce);
    }
  };

  // src/domain/handler/handler.ts
  var Handler = class {
    constructor(provider, signer, trackAction2, contractConfigs) {
      this.getProvider = () => {
        return this.provider;
      };
      this.getSignerAddress = () => __async(this, null, function* () {
        return yield this.signer.getAddress();
      });
      this.toBlockNumber = (params) => __async(this, null, function* () {
        return yield findBlock(this.provider, params);
      });
      this.getContract = (contractName) => {
        return this.contracts[contractName];
      };
      this.setContract = (config) => {
        this.contracts[config.name] = new BaseContract2(config, this.provider, this.trackAction);
      };
      this.provider = provider;
      this.signer = signer;
      this.contracts = {};
      this.trackAction = trackAction2;
      contractConfigs.forEach((config) => this.setContract(config));
    }
  };

  // src/domain/connector/walletEvent.ts
  var isValidActionType = (actionType) => {
    if (typeof actionType == "function")
      return true;
    if (actionType === "alert" || actionType == "reload" || actionType == "none")
      return true;
    return false;
  };
  var setupWalletEvent = (eventEmitter, eventActions) => {
    eventEmitter.on("chainChanged", () => setEventAction(eventActions.onChainChanged, "chain"));
    eventEmitter.on("accountsChanged", () => setEventAction(eventActions.onAccountsChanged, "accounts"));
    eventEmitter.on("disconnect", () => setEventAction(eventActions.onDisconnect, "disconnect"));
  };
  var setEventAction = (action, type) => {
    if (action === "none")
      return;
    if (action === "reload")
      window.location.reload();
    if (action === "alert") {
      const alertMessage = createAlertMessage(type);
      alert(alertMessage);
    }
    if (typeof action === "function")
      action();
  };
  var createAlertMessage = (type) => {
    if (type === "chain")
      return "The connected chain on Metamask has been changed. Please reload this page to avoid unexpected behaviors.";
    if (type === "accounts")
      return "The signer account on Metamask has been changed. Please reload this page to avoid unexpected behaviors.";
    if (type === "disconnect")
      return "Metamask has been disconnected. Please reconnect to avoid unexpected behaviors.";
    return "Someting has gone wrong. Please reload this page.";
  };

  // node_modules/@walletconnect/ethereum-provider/dist/esm/index.js
  var import_eventemitter32 = __toModule(require_eventemitter3());

  // node_modules/@walletconnect/jsonrpc-provider/dist/esm/provider.js
  var import_events = __toModule(require_events());

  // node_modules/@walletconnect/jsonrpc-utils/dist/esm/index.js
  var esm_exports = {};
  __export(esm_exports, {
    DEFAULT_ERROR: () => DEFAULT_ERROR,
    IBaseJsonRpcProvider: () => IBaseJsonRpcProvider,
    IEvents: () => IEvents,
    IJsonRpcConnection: () => IJsonRpcConnection,
    IJsonRpcProvider: () => IJsonRpcProvider,
    INTERNAL_ERROR: () => INTERNAL_ERROR,
    INVALID_PARAMS: () => INVALID_PARAMS,
    INVALID_REQUEST: () => INVALID_REQUEST,
    METHOD_NOT_FOUND: () => METHOD_NOT_FOUND,
    PARSE_ERROR: () => PARSE_ERROR,
    RESERVED_ERROR_CODES: () => RESERVED_ERROR_CODES,
    SERVER_ERROR: () => SERVER_ERROR,
    SERVER_ERROR_CODE_RANGE: () => SERVER_ERROR_CODE_RANGE,
    STANDARD_ERROR_MAP: () => STANDARD_ERROR_MAP,
    formatErrorMessage: () => formatErrorMessage,
    formatJsonRpcError: () => formatJsonRpcError,
    formatJsonRpcRequest: () => formatJsonRpcRequest,
    formatJsonRpcResult: () => formatJsonRpcResult,
    getError: () => getError,
    getErrorByCode: () => getErrorByCode,
    isHttpUrl: () => isHttpUrl,
    isJsonRpcError: () => isJsonRpcError,
    isJsonRpcPayload: () => isJsonRpcPayload,
    isJsonRpcRequest: () => isJsonRpcRequest,
    isJsonRpcResponse: () => isJsonRpcResponse,
    isJsonRpcResult: () => isJsonRpcResult,
    isJsonRpcValidationInvalid: () => isJsonRpcValidationInvalid,
    isLocalhostUrl: () => isLocalhostUrl,
    isNodeJs: () => isNodeJs,
    isReservedErrorCode: () => isReservedErrorCode,
    isServerErrorCode: () => isServerErrorCode,
    isValidDefaultRoute: () => isValidDefaultRoute,
    isValidErrorCode: () => isValidErrorCode,
    isValidLeadingWildcardRoute: () => isValidLeadingWildcardRoute,
    isValidRoute: () => isValidRoute,
    isValidTrailingWildcardRoute: () => isValidTrailingWildcardRoute,
    isValidWildcardRoute: () => isValidWildcardRoute,
    isWsUrl: () => isWsUrl,
    parseConnectionError: () => parseConnectionError,
    payloadId: () => payloadId,
    validateJsonRpcError: () => validateJsonRpcError
  });

  // node_modules/@walletconnect/jsonrpc-utils/dist/esm/constants.js
  var PARSE_ERROR = "PARSE_ERROR";
  var INVALID_REQUEST = "INVALID_REQUEST";
  var METHOD_NOT_FOUND = "METHOD_NOT_FOUND";
  var INVALID_PARAMS = "INVALID_PARAMS";
  var INTERNAL_ERROR = "INTERNAL_ERROR";
  var SERVER_ERROR = "SERVER_ERROR";
  var RESERVED_ERROR_CODES = [-32700, -32600, -32601, -32602, -32603];
  var SERVER_ERROR_CODE_RANGE = [-32e3, -32099];
  var STANDARD_ERROR_MAP = {
    [PARSE_ERROR]: { code: -32700, message: "Parse error" },
    [INVALID_REQUEST]: { code: -32600, message: "Invalid Request" },
    [METHOD_NOT_FOUND]: { code: -32601, message: "Method not found" },
    [INVALID_PARAMS]: { code: -32602, message: "Invalid params" },
    [INTERNAL_ERROR]: { code: -32603, message: "Internal error" },
    [SERVER_ERROR]: { code: -32e3, message: "Server error" }
  };
  var DEFAULT_ERROR = SERVER_ERROR;

  // node_modules/@walletconnect/jsonrpc-utils/dist/esm/error.js
  function isServerErrorCode(code) {
    return code <= SERVER_ERROR_CODE_RANGE[0] && code >= SERVER_ERROR_CODE_RANGE[1];
  }
  function isReservedErrorCode(code) {
    return RESERVED_ERROR_CODES.includes(code);
  }
  function isValidErrorCode(code) {
    return typeof code === "number";
  }
  function getError(type) {
    if (!Object.keys(STANDARD_ERROR_MAP).includes(type)) {
      return STANDARD_ERROR_MAP[DEFAULT_ERROR];
    }
    return STANDARD_ERROR_MAP[type];
  }
  function getErrorByCode(code) {
    const match = Object.values(STANDARD_ERROR_MAP).find((e3) => e3.code === code);
    if (!match) {
      return STANDARD_ERROR_MAP[DEFAULT_ERROR];
    }
    return match;
  }
  function validateJsonRpcError(response) {
    if (typeof response.error.code === "undefined") {
      return { valid: false, error: "Missing code for JSON-RPC error" };
    }
    if (typeof response.error.message === "undefined") {
      return { valid: false, error: "Missing message for JSON-RPC error" };
    }
    if (!isValidErrorCode(response.error.code)) {
      return {
        valid: false,
        error: `Invalid error code type for JSON-RPC: ${response.error.code}`
      };
    }
    if (isReservedErrorCode(response.error.code)) {
      const error = getErrorByCode(response.error.code);
      if (error.message !== STANDARD_ERROR_MAP[DEFAULT_ERROR].message && response.error.message === error.message) {
        return {
          valid: false,
          error: `Invalid error code message for JSON-RPC: ${response.error.code}`
        };
      }
    }
    return { valid: true };
  }
  function parseConnectionError(e3, url, type) {
    return e3.message.includes("getaddrinfo ENOTFOUND") || e3.message.includes("connect ECONNREFUSED") ? new Error(`Unavailable ${type} RPC url at ${url}`) : e3;
  }

  // node_modules/@walletconnect/jsonrpc-utils/dist/esm/env.js
  var env_exports = {};
  __export(env_exports, {
    isNodeJs: () => isNodeJs
  });
  var import_environment = __toModule(require_cjs());
  __reExport(env_exports, __toModule(require_cjs()));
  var isNodeJs = import_environment.isNode;

  // node_modules/@walletconnect/jsonrpc-utils/dist/esm/index.js
  __reExport(esm_exports, env_exports);

  // node_modules/@walletconnect/jsonrpc-utils/dist/esm/format.js
  function payloadId() {
    const date = Date.now() * Math.pow(10, 3);
    const extra = Math.floor(Math.random() * Math.pow(10, 3));
    return date + extra;
  }
  function formatJsonRpcRequest(method, params, id2) {
    return {
      id: id2 || payloadId(),
      jsonrpc: "2.0",
      method,
      params
    };
  }
  function formatJsonRpcResult(id2, result) {
    return {
      id: id2,
      jsonrpc: "2.0",
      result
    };
  }
  function formatJsonRpcError(id2, error, data4) {
    return {
      id: id2,
      jsonrpc: "2.0",
      error: formatErrorMessage(error, data4)
    };
  }
  function formatErrorMessage(error, data4) {
    if (typeof error === "undefined") {
      return getError(INTERNAL_ERROR);
    }
    if (typeof error === "string") {
      error = Object.assign(Object.assign({}, getError(SERVER_ERROR)), { message: error });
    }
    if (typeof data4 !== "undefined") {
      error.data = data4;
    }
    if (isReservedErrorCode(error.code)) {
      error = getErrorByCode(error.code);
    }
    return error;
  }

  // node_modules/@walletconnect/jsonrpc-utils/dist/esm/routing.js
  function isValidRoute(route) {
    if (route.includes("*")) {
      return isValidWildcardRoute(route);
    }
    if (/\W/g.test(route)) {
      return false;
    }
    return true;
  }
  function isValidDefaultRoute(route) {
    return route === "*";
  }
  function isValidWildcardRoute(route) {
    if (isValidDefaultRoute(route)) {
      return true;
    }
    if (!route.includes("*")) {
      return false;
    }
    if (route.split("*").length !== 2) {
      return false;
    }
    if (route.split("*").filter((x3) => x3.trim() === "").length !== 1) {
      return false;
    }
    return true;
  }
  function isValidLeadingWildcardRoute(route) {
    return !isValidDefaultRoute(route) && isValidWildcardRoute(route) && !route.split("*")[0].trim();
  }
  function isValidTrailingWildcardRoute(route) {
    return !isValidDefaultRoute(route) && isValidWildcardRoute(route) && !route.split("*")[1].trim();
  }

  // node_modules/@walletconnect/jsonrpc-types/dist/esm/misc.js
  var IEvents = class {
  };

  // node_modules/@walletconnect/jsonrpc-types/dist/esm/provider.js
  var IJsonRpcConnection = class extends IEvents {
    constructor(opts) {
      super();
    }
  };
  var IBaseJsonRpcProvider = class extends IEvents {
    constructor() {
      super();
    }
  };
  var IJsonRpcProvider = class extends IBaseJsonRpcProvider {
    constructor(connection) {
      super();
    }
  };

  // node_modules/@walletconnect/jsonrpc-utils/dist/esm/url.js
  var HTTP_REGEX = "^https?:";
  var WS_REGEX = "^wss?:";
  function getUrlProtocol(url) {
    const matches = url.match(new RegExp(/^\w+:/, "gi"));
    if (!matches || !matches.length)
      return;
    return matches[0];
  }
  function matchRegexProtocol(url, regex) {
    const protocol = getUrlProtocol(url);
    if (typeof protocol === "undefined")
      return false;
    return new RegExp(regex).test(protocol);
  }
  function isHttpUrl(url) {
    return matchRegexProtocol(url, HTTP_REGEX);
  }
  function isWsUrl(url) {
    return matchRegexProtocol(url, WS_REGEX);
  }
  function isLocalhostUrl(url) {
    return new RegExp("wss?://localhost(:d{2,5})?").test(url);
  }

  // node_modules/@walletconnect/jsonrpc-utils/dist/esm/validators.js
  function isJsonRpcPayload(payload) {
    return typeof payload === "object" && "id" in payload && "jsonrpc" in payload && payload.jsonrpc === "2.0";
  }
  function isJsonRpcRequest(payload) {
    return isJsonRpcPayload(payload) && "method" in payload;
  }
  function isJsonRpcResponse(payload) {
    return isJsonRpcPayload(payload) && (isJsonRpcResult(payload) || isJsonRpcError(payload));
  }
  function isJsonRpcResult(payload) {
    return "result" in payload;
  }
  function isJsonRpcError(payload) {
    return "error" in payload;
  }
  function isJsonRpcValidationInvalid(validation) {
    return "error" in validation && validation.valid === false;
  }

  // node_modules/@walletconnect/jsonrpc-provider/dist/esm/provider.js
  var JsonRpcProvider2 = class extends IJsonRpcProvider {
    constructor(connection) {
      super(connection);
      this.events = new import_events.EventEmitter();
      this.hasRegisteredEventListeners = false;
      this.connection = this.setConnection(connection);
      if (this.connection.connected) {
        this.registerEventListeners();
      }
    }
    connect() {
      return __async(this, arguments, function* (connection = this.connection) {
        yield this.open(connection);
      });
    }
    disconnect() {
      return __async(this, null, function* () {
        yield this.close();
      });
    }
    on(event, listener) {
      this.events.on(event, listener);
    }
    once(event, listener) {
      this.events.once(event, listener);
    }
    off(event, listener) {
      this.events.off(event, listener);
    }
    removeListener(event, listener) {
      this.events.removeListener(event, listener);
    }
    request(request, context) {
      return __async(this, null, function* () {
        return this.requestStrict(formatJsonRpcRequest(request.method, request.params || []), context);
      });
    }
    requestStrict(request, context) {
      return __async(this, null, function* () {
        return new Promise((resolve, reject) => __async(this, null, function* () {
          if (!this.connection.connected) {
            try {
              yield this.open();
            } catch (e3) {
              reject(e3);
            }
          }
          this.events.on(`${request.id}`, (response) => {
            if (isJsonRpcError(response)) {
              reject(response.error);
            } else {
              resolve(response.result);
            }
          });
          try {
            yield this.connection.send(request, context);
          } catch (e3) {
            reject(e3);
          }
        }));
      });
    }
    setConnection(connection = this.connection) {
      return connection;
    }
    onPayload(payload) {
      this.events.emit("payload", payload);
      if (isJsonRpcResponse(payload)) {
        this.events.emit(`${payload.id}`, payload);
      } else {
        this.events.emit("message", {
          type: payload.method,
          data: payload.params
        });
      }
    }
    open() {
      return __async(this, arguments, function* (connection = this.connection) {
        if (this.connection === connection && this.connection.connected)
          return;
        if (this.connection.connected)
          this.close();
        if (typeof connection === "string") {
          yield this.connection.open(connection);
          connection = this.connection;
        }
        this.connection = this.setConnection(connection);
        yield this.connection.open();
        this.registerEventListeners();
        this.events.emit("connect");
      });
    }
    close() {
      return __async(this, null, function* () {
        yield this.connection.close();
      });
    }
    registerEventListeners() {
      if (this.hasRegisteredEventListeners)
        return;
      this.connection.on("payload", (payload) => this.onPayload(payload));
      this.connection.on("close", () => this.events.emit("disconnect"));
      this.connection.on("error", (error) => this.events.emit("error", error));
      this.hasRegisteredEventListeners = true;
    }
  };

  // node_modules/@walletconnect/jsonrpc-http-connection/dist/esm/http.js
  var import_events2 = __toModule(require_events());
  var import_cross_fetch = __toModule(require_browser_ponyfill());
  init_esm();
  var DEFAULT_HTTP_HEADERS = {
    Accept: "application/json",
    "Content-Type": "application/json"
  };
  var DEFAULT_HTTP_METHOD = "POST";
  var DEFAULT_FETCH_OPTS = {
    headers: DEFAULT_HTTP_HEADERS,
    method: DEFAULT_HTTP_METHOD
  };
  var HttpConnection = class {
    constructor(url) {
      this.url = url;
      this.events = new import_events2.EventEmitter();
      this.isAvailable = false;
      this.registering = false;
      if (!isHttpUrl(url)) {
        throw new Error(`Provided URL is not compatible with HTTP connection: ${url}`);
      }
      this.url = url;
    }
    get connected() {
      return this.isAvailable;
    }
    get connecting() {
      return this.registering;
    }
    on(event, listener) {
      this.events.on(event, listener);
    }
    once(event, listener) {
      this.events.once(event, listener);
    }
    off(event, listener) {
      this.events.off(event, listener);
    }
    removeListener(event, listener) {
      this.events.removeListener(event, listener);
    }
    open() {
      return __async(this, arguments, function* (url = this.url) {
        yield this.register(url);
      });
    }
    close() {
      return __async(this, null, function* () {
        if (!this.isAvailable) {
          throw new Error("Connection already closed");
        }
        this.onClose();
      });
    }
    send(payload, context) {
      return __async(this, null, function* () {
        if (!this.isAvailable) {
          yield this.register();
        }
        try {
          const body = safeJsonStringify(payload);
          const res = yield (0, import_cross_fetch.default)(this.url, Object.assign(Object.assign({}, DEFAULT_FETCH_OPTS), { body }));
          const data4 = yield res.json();
          this.onPayload({ data: data4 });
        } catch (e3) {
          this.onError(payload.id, e3);
        }
      });
    }
    register() {
      return __async(this, arguments, function* (url = this.url) {
        if (!isHttpUrl(url)) {
          throw new Error(`Provided URL is not compatible with HTTP connection: ${url}`);
        }
        if (this.registering) {
          return new Promise((resolve, reject) => {
            this.events.once("register_error", (error) => {
              reject(error);
            });
            this.events.once("open", () => {
              if (typeof this.isAvailable === "undefined") {
                return reject(new Error("HTTP connection is missing or invalid"));
              }
              resolve();
            });
          });
        }
        this.url = url;
        this.registering = true;
        try {
          const body = safeJsonStringify({ id: 1, jsonrpc: "2.0", method: "test", params: [] });
          yield (0, import_cross_fetch.default)(url, Object.assign(Object.assign({}, DEFAULT_FETCH_OPTS), { body }));
          this.onOpen();
        } catch (e3) {
          const error = this.parseError(e3);
          this.events.emit("register_error", error);
          this.onClose();
          throw error;
        }
      });
    }
    onOpen() {
      this.isAvailable = true;
      this.registering = false;
      this.events.emit("open");
    }
    onClose() {
      this.isAvailable = false;
      this.registering = false;
      this.events.emit("close");
    }
    onPayload(e3) {
      if (typeof e3.data === "undefined")
        return;
      const payload = typeof e3.data === "string" ? safeJsonParse(e3.data) : e3.data;
      this.events.emit("payload", payload);
    }
    onError(id2, e3) {
      const error = this.parseError(e3);
      const message = error.message || error.toString();
      const payload = formatJsonRpcError(id2, message);
      this.events.emit("payload", payload);
    }
    parseError(e3, url = this.url) {
      return parseConnectionError(e3, url, "HTTP");
    }
  };

  // node_modules/@walletconnect/utils/dist/esm/index.js
  init_esm2();

  // node_modules/@walletconnect/utils/dist/esm/constants.js
  var reservedEvents = [
    "session_request",
    "session_update",
    "exchange_key",
    "connect",
    "disconnect",
    "display_uri",
    "modal_closed",
    "transport_open",
    "transport_close",
    "transport_error"
  ];
  var signingMethods = [
    "eth_sendTransaction",
    "eth_signTransaction",
    "eth_sign",
    "eth_signTypedData",
    "eth_signTypedData_v1",
    "eth_signTypedData_v2",
    "eth_signTypedData_v3",
    "eth_signTypedData_v4",
    "personal_sign",
    "wallet_addEthereumChain",
    "wallet_switchEthereumChain",
    "wallet_getPermissions",
    "wallet_requestPermissions",
    "wallet_registerOnboarding",
    "wallet_watchAsset",
    "wallet_scanQRCode"
  ];
  var infuraNetworks = {
    1: "mainnet",
    3: "ropsten",
    4: "rinkeby",
    5: "goerli",
    42: "kovan"
  };

  // node_modules/@walletconnect/utils/dist/esm/encoding.js
  var import_bn3 = __toModule(require_bn2());

  // node_modules/@walletconnect/encoding/dist/esm/index.js
  var import_is_typedarray = __toModule(require_is_typedarray());
  var import_typedarray_to_buffer = __toModule(require_typedarray_to_buffer());
  var ENC_HEX = "hex";
  var ENC_UTF8 = "utf8";
  var STRING_ZERO = "0";
  function bufferToArray(buf) {
    return new Uint8Array(buf);
  }
  function bufferToHex(buf, prefixed = false) {
    const hex2 = buf.toString(ENC_HEX);
    return prefixed ? addHexPrefix(hex2) : hex2;
  }
  function bufferToUtf8(buf) {
    return buf.toString(ENC_UTF8);
  }
  function arrayToBuffer(arr) {
    return (0, import_typedarray_to_buffer.default)(arr);
  }
  function arrayToHex(arr, prefixed = false) {
    return bufferToHex(arrayToBuffer(arr), prefixed);
  }
  function arrayToUtf8(arr) {
    return bufferToUtf8(arrayToBuffer(arr));
  }
  function hexToBuffer(hex2) {
    return Buffer.from(removeHexPrefix(hex2), ENC_HEX);
  }
  function hexToArray(hex2) {
    return bufferToArray(hexToBuffer(hex2));
  }
  function utf8ToBuffer(utf8) {
    return Buffer.from(utf8, ENC_UTF8);
  }
  function utf8ToArray(utf8) {
    return bufferToArray(utf8ToBuffer(utf8));
  }
  function utf8ToHex(utf8, prefixed = false) {
    return bufferToHex(utf8ToBuffer(utf8), prefixed);
  }
  function isHexString2(str, length) {
    if (typeof str !== "string" || !str.match(/^0x[0-9A-Fa-f]*$/)) {
      return false;
    }
    if (length && str.length !== 2 + 2 * length) {
      return false;
    }
    return true;
  }
  function concatArrays(...args) {
    let result = [];
    args.forEach((arg) => result = result.concat(Array.from(arg)));
    return new Uint8Array([...result]);
  }
  function calcByteLength(length, byteSize = 8) {
    const remainder = length % byteSize;
    return remainder ? (length - remainder) / byteSize * byteSize + byteSize : length;
  }
  function sanitizeBytes(str, byteSize = 8, padding2 = STRING_ZERO) {
    return padLeft(str, calcByteLength(str.length, byteSize), padding2);
  }
  function padLeft(str, length, padding2 = STRING_ZERO) {
    return padString(str, length, true, padding2);
  }
  function removeHexPrefix(hex2) {
    return hex2.replace(/^0x/, "");
  }
  function addHexPrefix(hex2) {
    return hex2.startsWith("0x") ? hex2 : `0x${hex2}`;
  }
  function sanitizeHex(hex2) {
    hex2 = removeHexPrefix(hex2);
    hex2 = sanitizeBytes(hex2, 2);
    if (hex2) {
      hex2 = addHexPrefix(hex2);
    }
    return hex2;
  }
  function removeHexLeadingZeros(hex2) {
    const prefixed = hex2.startsWith("0x");
    hex2 = removeHexPrefix(hex2);
    hex2 = hex2.startsWith(STRING_ZERO) ? hex2.substring(1) : hex2;
    return prefixed ? addHexPrefix(hex2) : hex2;
  }
  function padString(str, length, left, padding2 = STRING_ZERO) {
    const diff = length - str.length;
    let result = str;
    if (diff > 0) {
      const pad = padding2.repeat(diff);
      result = left ? pad + str : str + pad;
    }
    return result;
  }

  // node_modules/@walletconnect/utils/dist/esm/encoding.js
  function convertArrayBufferToBuffer(arrBuf) {
    return arrayToBuffer(new Uint8Array(arrBuf));
  }
  function convertArrayBufferToHex(arrBuf, noPrefix) {
    return arrayToHex(new Uint8Array(arrBuf), !noPrefix);
  }
  function convertBufferToArrayBuffer(buf) {
    return bufferToArray(buf).buffer;
  }
  function convertUtf8ToBuffer(utf8) {
    return utf8ToBuffer(utf8);
  }
  function convertUtf8ToHex(utf8, noPrefix) {
    return utf8ToHex(utf8, !noPrefix);
  }
  function convertHexToArrayBuffer(hex2) {
    return hexToArray(hex2).buffer;
  }
  function convertNumberToHex(num, noPrefix) {
    const hex2 = removeHexPrefix(sanitizeHex(new import_bn3.default(num).toString(16)));
    return noPrefix ? hex2 : addHexPrefix(hex2);
  }

  // node_modules/@walletconnect/utils/dist/esm/ethereum.js
  var import_js_sha32 = __toModule(require_sha32());

  // node_modules/@walletconnect/utils/dist/esm/misc.js
  function sanitizeHex2(hex2) {
    return sanitizeHex(hex2);
  }
  function removeHexLeadingZeros2(hex2) {
    return removeHexLeadingZeros(addHexPrefix(hex2));
  }
  var payloadId2 = payloadId;
  function uuid() {
    const result = ((a3, b2) => {
      for (b2 = a3 = ""; a3++ < 36; b2 += a3 * 51 & 52 ? (a3 ^ 15 ? 8 ^ Math.random() * (a3 ^ 20 ? 16 : 4) : 4).toString(16) : "-") {
      }
      return b2;
    })();
    return result;
  }
  function getInfuraRpcUrl(chainId, infuraId) {
    let rpcUrl;
    const network = infuraNetworks[chainId];
    if (network) {
      rpcUrl = `https://${network}.infura.io/v3/${infuraId}`;
    }
    return rpcUrl;
  }
  function getRpcUrl(chainId, rpc) {
    let rpcUrl;
    const infuraUrl = getInfuraRpcUrl(chainId, rpc.infuraId);
    if (rpc.custom && rpc.custom[chainId]) {
      rpcUrl = rpc.custom[chainId];
    } else if (infuraUrl) {
      rpcUrl = infuraUrl;
    }
    return rpcUrl;
  }

  // node_modules/@walletconnect/utils/dist/esm/validators.js
  function isEmptyString(value) {
    return value === "" || typeof value === "string" && value.trim() === "";
  }
  function isEmptyArray(array) {
    return !(array && array.length);
  }
  function isHexString3(value, length) {
    return isHexString2(value, length);
  }
  function isJsonRpcRequest2(object) {
    return typeof object.method !== "undefined";
  }
  function isJsonRpcResponseSuccess(object) {
    return typeof object.result !== "undefined";
  }
  function isJsonRpcResponseError(object) {
    return typeof object.error !== "undefined";
  }
  function isInternalEvent(object) {
    return typeof object.event !== "undefined";
  }
  function isReservedEvent(event) {
    return reservedEvents.includes(event) || event.startsWith("wc_");
  }
  function isSilentPayload(request) {
    if (request.method.startsWith("wc_")) {
      return true;
    }
    if (signingMethods.includes(request.method)) {
      return false;
    }
    return true;
  }

  // node_modules/@walletconnect/utils/dist/esm/ethereum.js
  function toChecksumAddress(address) {
    address = removeHexPrefix(address.toLowerCase());
    const hash3 = removeHexPrefix((0, import_js_sha32.keccak_256)(convertUtf8ToBuffer(address)));
    let checksum = "";
    for (let i3 = 0; i3 < address.length; i3++) {
      if (parseInt(hash3[i3], 16) > 7) {
        checksum += address[i3].toUpperCase();
      } else {
        checksum += address[i3];
      }
    }
    return addHexPrefix(checksum);
  }
  var isValidAddress = (address) => {
    if (!address) {
      return false;
    } else if (address.toLowerCase().substring(0, 2) !== "0x") {
      return false;
    } else if (!/^(0x)?[0-9a-f]{40}$/i.test(address)) {
      return false;
    } else if (/^(0x)?[0-9a-f]{40}$/.test(address) || /^(0x)?[0-9A-F]{40}$/.test(address)) {
      return true;
    } else {
      return address === toChecksumAddress(address);
    }
  };
  function parsePersonalSign(params) {
    if (!isEmptyArray(params) && !isHexString3(params[0])) {
      params[0] = convertUtf8ToHex(params[0]);
    }
    return params;
  }
  function parseTransactionData(txData) {
    if (typeof txData.type !== "undefined" && txData.type !== "0")
      return txData;
    if (typeof txData.from === "undefined" || !isValidAddress(txData.from)) {
      throw new Error(`Transaction object must include a valid 'from' value.`);
    }
    function parseHexValues(value) {
      let result = value;
      if (typeof value === "number" || typeof value === "string" && !isEmptyString(value)) {
        if (!isHexString3(value)) {
          result = convertNumberToHex(value);
        } else if (typeof value === "string") {
          result = sanitizeHex2(value);
        }
      }
      if (typeof result === "string") {
        result = removeHexLeadingZeros2(result);
      }
      return result;
    }
    const txDataRPC = {
      from: sanitizeHex2(txData.from),
      to: typeof txData.to === "undefined" ? void 0 : sanitizeHex2(txData.to),
      gasPrice: typeof txData.gasPrice === "undefined" ? "" : parseHexValues(txData.gasPrice),
      gas: typeof txData.gas === "undefined" ? typeof txData.gasLimit === "undefined" ? "" : parseHexValues(txData.gasLimit) : parseHexValues(txData.gas),
      value: typeof txData.value === "undefined" ? "" : parseHexValues(txData.value),
      nonce: typeof txData.nonce === "undefined" ? "" : parseHexValues(txData.nonce),
      data: typeof txData.data === "undefined" ? "" : sanitizeHex2(txData.data) || "0x"
    };
    const prunable = ["gasPrice", "gas", "value", "nonce"];
    Object.keys(txDataRPC).forEach((key2) => {
      if ((typeof txDataRPC[key2] === "undefined" || typeof txDataRPC[key2] === "string" && !txDataRPC[key2].trim().length) && prunable.includes(key2)) {
        delete txDataRPC[key2];
      }
    });
    return txDataRPC;
  }

  // node_modules/@walletconnect/utils/dist/esm/payload.js
  function formatRpcError(error) {
    const message = error.message || "Failed or Rejected Request";
    let code = -32e3;
    if (error && !error.code) {
      switch (message) {
        case "Parse error":
          code = -32700;
          break;
        case "Invalid request":
          code = -32600;
          break;
        case "Method not found":
          code = -32601;
          break;
        case "Invalid params":
          code = -32602;
          break;
        case "Internal error":
          code = -32603;
          break;
        default:
          code = -32e3;
          break;
      }
    }
    const result = {
      code,
      message
    };
    return result;
  }

  // node_modules/@walletconnect/utils/dist/esm/url.js
  var queryStringUtils = __toModule(require_query_string());
  function getQueryString(url) {
    const pathEnd = url.indexOf("?") !== -1 ? url.indexOf("?") : void 0;
    const queryString = typeof pathEnd !== "undefined" ? url.substr(pathEnd) : "";
    return queryString;
  }
  function appendToQueryString(queryString, newQueryParams) {
    let queryParams = parseQueryString(queryString);
    queryParams = Object.assign(Object.assign({}, queryParams), newQueryParams);
    queryString = formatQueryString(queryParams);
    return queryString;
  }
  function parseQueryString(queryString) {
    return queryStringUtils.parse(queryString);
  }
  function formatQueryString(queryParams) {
    return queryStringUtils.stringify(queryParams);
  }

  // node_modules/@walletconnect/utils/dist/esm/session.js
  function isWalletConnectSession(object) {
    return typeof object.bridge !== "undefined";
  }
  function parseWalletConnectUri(str) {
    const pathStart = str.indexOf(":");
    const pathEnd = str.indexOf("?") !== -1 ? str.indexOf("?") : void 0;
    const protocol = str.substring(0, pathStart);
    const path = str.substring(pathStart + 1, pathEnd);
    function parseRequiredParams(path2) {
      const separator = "@";
      const values = path2.split(separator);
      const requiredParams2 = {
        handshakeTopic: values[0],
        version: parseInt(values[1], 10)
      };
      return requiredParams2;
    }
    const requiredParams = parseRequiredParams(path);
    const queryString = typeof pathEnd !== "undefined" ? str.substr(pathEnd) : "";
    function parseQueryParams(queryString2) {
      const result2 = parseQueryString(queryString2);
      const parameters = {
        key: result2.key || "",
        bridge: result2.bridge || ""
      };
      return parameters;
    }
    const queryParams = parseQueryParams(queryString);
    const result = Object.assign(Object.assign({ protocol }, requiredParams), queryParams);
    return result;
  }

  // node_modules/@walletconnect/signer-connection/dist/esm/index.js
  var import_eventemitter3 = __toModule(require_eventemitter3());

  // node_modules/@walletconnect/socket-transport/dist/esm/network.js
  var NetworkMonitor = class {
    constructor() {
      this._eventEmitters = [];
      if (typeof window !== "undefined" && typeof window.addEventListener !== "undefined") {
        window.addEventListener("online", () => this.trigger("online"));
        window.addEventListener("offline", () => this.trigger("offline"));
      }
    }
    on(event, callback) {
      this._eventEmitters.push({
        event,
        callback
      });
    }
    trigger(event) {
      let eventEmitters = [];
      if (event) {
        eventEmitters = this._eventEmitters.filter((eventEmitter) => eventEmitter.event === event);
      }
      eventEmitters.forEach((eventEmitter) => {
        eventEmitter.callback();
      });
    }
  };
  var network_default = NetworkMonitor;

  // node_modules/@walletconnect/socket-transport/dist/esm/index.js
  var WS2 = typeof global.WebSocket !== "undefined" ? global.WebSocket : require_browser();
  var SocketTransport = class {
    constructor(opts) {
      this.opts = opts;
      this._queue = [];
      this._events = [];
      this._subscriptions = [];
      this._protocol = opts.protocol;
      this._version = opts.version;
      this._url = "";
      this._netMonitor = null;
      this._socket = null;
      this._nextSocket = null;
      this._subscriptions = opts.subscriptions || [];
      this._netMonitor = opts.netMonitor || new network_default();
      if (!opts.url || typeof opts.url !== "string") {
        throw new Error("Missing or invalid WebSocket url");
      }
      this._url = opts.url;
      this._netMonitor.on("online", () => this._socketCreate());
    }
    set readyState(value) {
    }
    get readyState() {
      return this._socket ? this._socket.readyState : -1;
    }
    set connecting(value) {
    }
    get connecting() {
      return this.readyState === 0;
    }
    set connected(value) {
    }
    get connected() {
      return this.readyState === 1;
    }
    set closing(value) {
    }
    get closing() {
      return this.readyState === 2;
    }
    set closed(value) {
    }
    get closed() {
      return this.readyState === 3;
    }
    open() {
      this._socketCreate();
    }
    close() {
      this._socketClose();
    }
    send(message, topic, silent) {
      if (!topic || typeof topic !== "string") {
        throw new Error("Missing or invalid topic field");
      }
      this._socketSend({
        topic,
        type: "pub",
        payload: message,
        silent: !!silent
      });
    }
    subscribe(topic) {
      this._socketSend({
        topic,
        type: "sub",
        payload: "",
        silent: true
      });
    }
    on(event, callback) {
      this._events.push({ event, callback });
    }
    _socketCreate() {
      if (this._nextSocket) {
        return;
      }
      const url = getWebSocketUrl(this._url, this._protocol, this._version);
      this._nextSocket = new WS2(url);
      if (!this._nextSocket) {
        throw new Error("Failed to create socket");
      }
      this._nextSocket.onmessage = (event) => this._socketReceive(event);
      this._nextSocket.onopen = () => this._socketOpen();
      this._nextSocket.onerror = (event) => this._socketError(event);
      this._nextSocket.onclose = () => {
        setTimeout(() => {
          this._nextSocket = null;
          this._socketCreate();
        }, 1e3);
      };
    }
    _socketOpen() {
      this._socketClose();
      this._socket = this._nextSocket;
      this._nextSocket = null;
      this._queueSubscriptions();
      this._pushQueue();
    }
    _socketClose() {
      if (this._socket) {
        this._socket.onclose = () => {
        };
        this._socket.close();
      }
    }
    _socketSend(socketMessage) {
      const message = JSON.stringify(socketMessage);
      if (this._socket && this._socket.readyState === 1) {
        this._socket.send(message);
      } else {
        this._setToQueue(socketMessage);
        this._socketCreate();
      }
    }
    _socketReceive(event) {
      return __async(this, null, function* () {
        let socketMessage;
        try {
          socketMessage = JSON.parse(event.data);
        } catch (error) {
          return;
        }
        this._socketSend({
          topic: socketMessage.topic,
          type: "ack",
          payload: "",
          silent: true
        });
        if (this._socket && this._socket.readyState === 1) {
          const events = this._events.filter((event2) => event2.event === "message");
          if (events && events.length) {
            events.forEach((event2) => event2.callback(socketMessage));
          }
        }
      });
    }
    _socketError(e3) {
      const events = this._events.filter((event) => event.event === "error");
      if (events && events.length) {
        events.forEach((event) => event.callback(e3));
      }
    }
    _queueSubscriptions() {
      const subscriptions = this._subscriptions;
      subscriptions.forEach((topic) => this._queue.push({
        topic,
        type: "sub",
        payload: "",
        silent: true
      }));
      this._subscriptions = this.opts.subscriptions || [];
    }
    _setToQueue(socketMessage) {
      this._queue.push(socketMessage);
    }
    _pushQueue() {
      const queue = this._queue;
      queue.forEach((socketMessage) => this._socketSend(socketMessage));
      this._queue = [];
    }
  };
  function getWebSocketUrl(_url, protocol, version26) {
    var _a, _b;
    const url = _url.startsWith("https") ? _url.replace("https", "wss") : _url.startsWith("http") ? _url.replace("http", "ws") : _url;
    const splitUrl = url.split("?");
    const params = isBrowser() ? {
      protocol,
      version: version26,
      env: "browser",
      host: ((_a = getLocation2()) === null || _a === void 0 ? void 0 : _a.host) || ""
    } : {
      protocol,
      version: version26,
      env: ((_b = detectEnv()) === null || _b === void 0 ? void 0 : _b.name) || ""
    };
    const queryString = appendToQueryString(getQueryString(splitUrl[1] || ""), params);
    return splitUrl[0] + "?" + queryString;
  }
  var esm_default = SocketTransport;

  // node_modules/@walletconnect/core/dist/esm/errors.js
  var ERROR_SESSION_CONNECTED = "Session currently connected";
  var ERROR_SESSION_DISCONNECTED = "Session currently disconnected";
  var ERROR_SESSION_REJECTED = "Session Rejected";
  var ERROR_MISSING_JSON_RPC = "Missing JSON RPC response";
  var ERROR_MISSING_RESULT = `JSON-RPC success response must include "result" field`;
  var ERROR_MISSING_ERROR = `JSON-RPC error response must include "error" field`;
  var ERROR_MISSING_METHOD = `JSON RPC request must have valid "method" value`;
  var ERROR_MISSING_ID = `JSON RPC request must have valid "id" value`;
  var ERROR_MISSING_REQUIRED = "Missing one of the required parameters: bridge / uri / session";
  var ERROR_INVALID_RESPONSE = "JSON RPC response format is invalid";
  var ERROR_INVALID_URI = "URI format is invalid";
  var ERROR_QRCODE_MODAL_NOT_PROVIDED = "QRCode Modal not provided";
  var ERROR_QRCODE_MODAL_USER_CLOSED = "User close QRCode Modal";

  // node_modules/@walletconnect/core/dist/esm/events.js
  var EventManager = class {
    constructor() {
      this._eventEmitters = [];
    }
    subscribe(eventEmitter) {
      this._eventEmitters.push(eventEmitter);
    }
    unsubscribe(event) {
      this._eventEmitters = this._eventEmitters.filter((x3) => x3.event !== event);
    }
    trigger(payload) {
      let eventEmitters = [];
      let event;
      if (isJsonRpcRequest2(payload)) {
        event = payload.method;
      } else if (isJsonRpcResponseSuccess(payload) || isJsonRpcResponseError(payload)) {
        event = `response:${payload.id}`;
      } else if (isInternalEvent(payload)) {
        event = payload.event;
      } else {
        event = "";
      }
      if (event) {
        eventEmitters = this._eventEmitters.filter((eventEmitter) => eventEmitter.event === event);
      }
      if ((!eventEmitters || !eventEmitters.length) && !isReservedEvent(event) && !isInternalEvent(event)) {
        eventEmitters = this._eventEmitters.filter((eventEmitter) => eventEmitter.event === "call_request");
      }
      eventEmitters.forEach((eventEmitter) => {
        if (isJsonRpcResponseError(payload)) {
          const error = new Error(payload.error.message);
          eventEmitter.callback(error, null);
        } else {
          eventEmitter.callback(null, payload);
        }
      });
    }
  };
  var events_default = EventManager;

  // node_modules/@walletconnect/core/dist/esm/storage.js
  var SessionStorage = class {
    constructor(storageId = "walletconnect") {
      this.storageId = storageId;
    }
    getSession() {
      let session = null;
      const json = getLocal(this.storageId);
      if (json && isWalletConnectSession(json)) {
        session = json;
      }
      return session;
    }
    setSession(session) {
      setLocal(this.storageId, session);
      return session;
    }
    removeSession() {
      removeLocal(this.storageId);
    }
  };
  var storage_default = SessionStorage;

  // node_modules/@walletconnect/core/dist/esm/url.js
  var domain = "walletconnect.org";
  var alphanumerical = "abcdefghijklmnopqrstuvwxyz0123456789";
  var bridges = alphanumerical.split("").map((char) => `https://${char}.bridge.walletconnect.org`);
  function extractHostname(url) {
    let hostname = url.indexOf("//") > -1 ? url.split("/")[2] : url.split("/")[0];
    hostname = hostname.split(":")[0];
    hostname = hostname.split("?")[0];
    return hostname;
  }
  function extractRootDomain(url) {
    return extractHostname(url).split(".").slice(-2).join(".");
  }
  function randomBridgeIndex() {
    return Math.floor(Math.random() * bridges.length);
  }
  function selectRandomBridgeUrl() {
    return bridges[randomBridgeIndex()];
  }
  function shouldSelectRandomly(url) {
    return extractRootDomain(url) === domain;
  }
  function getBridgeUrl(url) {
    if (shouldSelectRandomly(url)) {
      return selectRandomBridgeUrl();
    }
    return url;
  }

  // node_modules/@walletconnect/core/dist/esm/index.js
  var Connector = class {
    constructor(opts) {
      this.protocol = "wc";
      this.version = 1;
      this._bridge = "";
      this._key = null;
      this._clientId = "";
      this._clientMeta = null;
      this._peerId = "";
      this._peerMeta = null;
      this._handshakeId = 0;
      this._handshakeTopic = "";
      this._connected = false;
      this._accounts = [];
      this._chainId = 0;
      this._networkId = 0;
      this._rpcUrl = "";
      this._eventManager = new events_default();
      this._clientMeta = getClientMeta() || opts.connectorOpts.clientMeta || null;
      this._cryptoLib = opts.cryptoLib;
      this._sessionStorage = opts.sessionStorage || new storage_default(opts.connectorOpts.storageId);
      this._qrcodeModal = opts.connectorOpts.qrcodeModal;
      this._qrcodeModalOptions = opts.connectorOpts.qrcodeModalOptions;
      this._signingMethods = [...signingMethods, ...opts.connectorOpts.signingMethods || []];
      if (!opts.connectorOpts.bridge && !opts.connectorOpts.uri && !opts.connectorOpts.session) {
        throw new Error(ERROR_MISSING_REQUIRED);
      }
      if (opts.connectorOpts.bridge) {
        this.bridge = getBridgeUrl(opts.connectorOpts.bridge);
      }
      if (opts.connectorOpts.uri) {
        this.uri = opts.connectorOpts.uri;
      }
      const session = opts.connectorOpts.session || this._getStorageSession();
      if (session) {
        this.session = session;
      }
      if (this.handshakeId) {
        this._subscribeToSessionResponse(this.handshakeId, "Session request rejected");
      }
      this._transport = opts.transport || new esm_default({
        protocol: this.protocol,
        version: this.version,
        url: this.bridge,
        subscriptions: [this.clientId]
      });
      this._subscribeToInternalEvents();
      this._initTransport();
      if (opts.connectorOpts.uri) {
        this._subscribeToSessionRequest();
      }
      if (opts.pushServerOpts) {
        this._registerPushServer(opts.pushServerOpts);
      }
    }
    set bridge(value) {
      if (!value) {
        return;
      }
      this._bridge = value;
    }
    get bridge() {
      return this._bridge;
    }
    set key(value) {
      if (!value) {
        return;
      }
      const key2 = convertHexToArrayBuffer(value);
      this._key = key2;
    }
    get key() {
      if (this._key) {
        const key2 = convertArrayBufferToHex(this._key, true);
        return key2;
      }
      return "";
    }
    set clientId(value) {
      if (!value) {
        return;
      }
      this._clientId = value;
    }
    get clientId() {
      let clientId = this._clientId;
      if (!clientId) {
        clientId = this._clientId = uuid();
      }
      return this._clientId;
    }
    set peerId(value) {
      if (!value) {
        return;
      }
      this._peerId = value;
    }
    get peerId() {
      return this._peerId;
    }
    set clientMeta(value) {
    }
    get clientMeta() {
      let clientMeta = this._clientMeta;
      if (!clientMeta) {
        clientMeta = this._clientMeta = getClientMeta();
      }
      return clientMeta;
    }
    set peerMeta(value) {
      this._peerMeta = value;
    }
    get peerMeta() {
      const peerMeta = this._peerMeta;
      return peerMeta;
    }
    set handshakeTopic(value) {
      if (!value) {
        return;
      }
      this._handshakeTopic = value;
    }
    get handshakeTopic() {
      return this._handshakeTopic;
    }
    set handshakeId(value) {
      if (!value) {
        return;
      }
      this._handshakeId = value;
    }
    get handshakeId() {
      return this._handshakeId;
    }
    get uri() {
      const _uri = this._formatUri();
      return _uri;
    }
    set uri(value) {
      if (!value) {
        return;
      }
      const { handshakeTopic, bridge, key: key2 } = this._parseUri(value);
      this.handshakeTopic = handshakeTopic;
      this.bridge = bridge;
      this.key = key2;
    }
    set chainId(value) {
      this._chainId = value;
    }
    get chainId() {
      const chainId = this._chainId;
      return chainId;
    }
    set networkId(value) {
      this._networkId = value;
    }
    get networkId() {
      const networkId = this._networkId;
      return networkId;
    }
    set accounts(value) {
      this._accounts = value;
    }
    get accounts() {
      const accounts = this._accounts;
      return accounts;
    }
    set rpcUrl(value) {
      this._rpcUrl = value;
    }
    get rpcUrl() {
      const rpcUrl = this._rpcUrl;
      return rpcUrl;
    }
    set connected(value) {
    }
    get connected() {
      return this._connected;
    }
    set pending(value) {
    }
    get pending() {
      return !!this._handshakeTopic;
    }
    get session() {
      return {
        connected: this.connected,
        accounts: this.accounts,
        chainId: this.chainId,
        bridge: this.bridge,
        key: this.key,
        clientId: this.clientId,
        clientMeta: this.clientMeta,
        peerId: this.peerId,
        peerMeta: this.peerMeta,
        handshakeId: this.handshakeId,
        handshakeTopic: this.handshakeTopic
      };
    }
    set session(value) {
      if (!value) {
        return;
      }
      this._connected = value.connected;
      this.accounts = value.accounts;
      this.chainId = value.chainId;
      this.bridge = value.bridge;
      this.key = value.key;
      this.clientId = value.clientId;
      this.clientMeta = value.clientMeta;
      this.peerId = value.peerId;
      this.peerMeta = value.peerMeta;
      this.handshakeId = value.handshakeId;
      this.handshakeTopic = value.handshakeTopic;
    }
    on(event, callback) {
      const eventEmitter = {
        event,
        callback
      };
      this._eventManager.subscribe(eventEmitter);
    }
    off(event) {
      this._eventManager.unsubscribe(event);
    }
    createInstantRequest(instantRequest) {
      return __async(this, null, function* () {
        this._key = yield this._generateKey();
        const request = this._formatRequest({
          method: "wc_instantRequest",
          params: [
            {
              peerId: this.clientId,
              peerMeta: this.clientMeta,
              request: this._formatRequest(instantRequest)
            }
          ]
        });
        this.handshakeId = request.id;
        this.handshakeTopic = uuid();
        this._eventManager.trigger({
          event: "display_uri",
          params: [this.uri]
        });
        this.on("modal_closed", () => {
          throw new Error(ERROR_QRCODE_MODAL_USER_CLOSED);
        });
        const endInstantRequest = () => {
          this.killSession();
        };
        try {
          const result = yield this._sendCallRequest(request);
          if (result) {
            endInstantRequest();
          }
          return result;
        } catch (error) {
          endInstantRequest();
          throw error;
        }
      });
    }
    connect(opts) {
      return __async(this, null, function* () {
        if (!this._qrcodeModal) {
          throw new Error(ERROR_QRCODE_MODAL_NOT_PROVIDED);
        }
        if (this.connected) {
          return {
            chainId: this.chainId,
            accounts: this.accounts
          };
        }
        yield this.createSession(opts);
        return new Promise((resolve, reject) => __async(this, null, function* () {
          this.on("modal_closed", () => reject(new Error(ERROR_QRCODE_MODAL_USER_CLOSED)));
          this.on("connect", (error, payload) => {
            if (error) {
              return reject(error);
            }
            resolve(payload.params[0]);
          });
        }));
      });
    }
    createSession(opts) {
      return __async(this, null, function* () {
        if (this._connected) {
          throw new Error(ERROR_SESSION_CONNECTED);
        }
        if (this.pending) {
          return;
        }
        this._key = yield this._generateKey();
        const request = this._formatRequest({
          method: "wc_sessionRequest",
          params: [
            {
              peerId: this.clientId,
              peerMeta: this.clientMeta,
              chainId: opts && opts.chainId ? opts.chainId : null
            }
          ]
        });
        this.handshakeId = request.id;
        this.handshakeTopic = uuid();
        this._sendSessionRequest(request, "Session update rejected", {
          topic: this.handshakeTopic
        });
        this._eventManager.trigger({
          event: "display_uri",
          params: [this.uri]
        });
      });
    }
    approveSession(sessionStatus) {
      if (this._connected) {
        throw new Error(ERROR_SESSION_CONNECTED);
      }
      this.chainId = sessionStatus.chainId;
      this.accounts = sessionStatus.accounts;
      this.networkId = sessionStatus.networkId || 0;
      this.rpcUrl = sessionStatus.rpcUrl || "";
      const sessionParams = {
        approved: true,
        chainId: this.chainId,
        networkId: this.networkId,
        accounts: this.accounts,
        rpcUrl: this.rpcUrl,
        peerId: this.clientId,
        peerMeta: this.clientMeta
      };
      const response = {
        id: this.handshakeId,
        jsonrpc: "2.0",
        result: sessionParams
      };
      this._sendResponse(response);
      this._connected = true;
      this._setStorageSession();
      this._eventManager.trigger({
        event: "connect",
        params: [
          {
            peerId: this.peerId,
            peerMeta: this.peerMeta,
            chainId: this.chainId,
            accounts: this.accounts
          }
        ]
      });
    }
    rejectSession(sessionError) {
      if (this._connected) {
        throw new Error(ERROR_SESSION_CONNECTED);
      }
      const message = sessionError && sessionError.message ? sessionError.message : ERROR_SESSION_REJECTED;
      const response = this._formatResponse({
        id: this.handshakeId,
        error: { message }
      });
      this._sendResponse(response);
      this._connected = false;
      this._eventManager.trigger({
        event: "disconnect",
        params: [{ message }]
      });
      this._removeStorageSession();
    }
    updateSession(sessionStatus) {
      if (!this._connected) {
        throw new Error(ERROR_SESSION_DISCONNECTED);
      }
      this.chainId = sessionStatus.chainId;
      this.accounts = sessionStatus.accounts;
      this.networkId = sessionStatus.networkId || 0;
      this.rpcUrl = sessionStatus.rpcUrl || "";
      const sessionParams = {
        approved: true,
        chainId: this.chainId,
        networkId: this.networkId,
        accounts: this.accounts,
        rpcUrl: this.rpcUrl
      };
      const request = this._formatRequest({
        method: "wc_sessionUpdate",
        params: [sessionParams]
      });
      this._sendSessionRequest(request, "Session update rejected");
      this._eventManager.trigger({
        event: "session_update",
        params: [
          {
            chainId: this.chainId,
            accounts: this.accounts
          }
        ]
      });
      this._manageStorageSession();
    }
    killSession(sessionError) {
      return __async(this, null, function* () {
        const message = sessionError ? sessionError.message : "Session Disconnected";
        const sessionParams = {
          approved: false,
          chainId: null,
          networkId: null,
          accounts: null
        };
        const request = this._formatRequest({
          method: "wc_sessionUpdate",
          params: [sessionParams]
        });
        yield this._sendRequest(request);
        this._handleSessionDisconnect(message);
      });
    }
    sendTransaction(tx) {
      return __async(this, null, function* () {
        if (!this._connected) {
          throw new Error(ERROR_SESSION_DISCONNECTED);
        }
        const parsedTx = parseTransactionData(tx);
        const request = this._formatRequest({
          method: "eth_sendTransaction",
          params: [parsedTx]
        });
        const result = yield this._sendCallRequest(request);
        return result;
      });
    }
    signTransaction(tx) {
      return __async(this, null, function* () {
        if (!this._connected) {
          throw new Error(ERROR_SESSION_DISCONNECTED);
        }
        const parsedTx = parseTransactionData(tx);
        const request = this._formatRequest({
          method: "eth_signTransaction",
          params: [parsedTx]
        });
        const result = yield this._sendCallRequest(request);
        return result;
      });
    }
    signMessage(params) {
      return __async(this, null, function* () {
        if (!this._connected) {
          throw new Error(ERROR_SESSION_DISCONNECTED);
        }
        const request = this._formatRequest({
          method: "eth_sign",
          params
        });
        const result = yield this._sendCallRequest(request);
        return result;
      });
    }
    signPersonalMessage(params) {
      return __async(this, null, function* () {
        if (!this._connected) {
          throw new Error(ERROR_SESSION_DISCONNECTED);
        }
        params = parsePersonalSign(params);
        const request = this._formatRequest({
          method: "personal_sign",
          params
        });
        const result = yield this._sendCallRequest(request);
        return result;
      });
    }
    signTypedData(params) {
      return __async(this, null, function* () {
        if (!this._connected) {
          throw new Error(ERROR_SESSION_DISCONNECTED);
        }
        const request = this._formatRequest({
          method: "eth_signTypedData",
          params
        });
        const result = yield this._sendCallRequest(request);
        return result;
      });
    }
    updateChain(chainParams) {
      return __async(this, null, function* () {
        if (!this._connected) {
          throw new Error("Session currently disconnected");
        }
        const request = this._formatRequest({
          method: "wallet_updateChain",
          params: [chainParams]
        });
        const result = yield this._sendCallRequest(request);
        return result;
      });
    }
    unsafeSend(request, options) {
      this._sendRequest(request, options);
      this._eventManager.trigger({
        event: "call_request_sent",
        params: [{ request, options }]
      });
      return new Promise((resolve, reject) => {
        this._subscribeToResponse(request.id, (error, payload) => {
          if (error) {
            reject(error);
            return;
          }
          if (!payload) {
            throw new Error(ERROR_MISSING_JSON_RPC);
          }
          resolve(payload);
        });
      });
    }
    sendCustomRequest(request, options) {
      return __async(this, null, function* () {
        if (!this._connected) {
          throw new Error(ERROR_SESSION_DISCONNECTED);
        }
        switch (request.method) {
          case "eth_accounts":
            return this.accounts;
          case "eth_chainId":
            return convertNumberToHex(this.chainId);
          case "eth_sendTransaction":
          case "eth_signTransaction":
            if (request.params) {
              request.params[0] = parseTransactionData(request.params[0]);
            }
            break;
          case "personal_sign":
            if (request.params) {
              request.params = parsePersonalSign(request.params);
            }
            break;
          default:
            break;
        }
        const formattedRequest = this._formatRequest(request);
        const result = yield this._sendCallRequest(formattedRequest, options);
        return result;
      });
    }
    approveRequest(response) {
      if (isJsonRpcResponseSuccess(response)) {
        const formattedResponse = this._formatResponse(response);
        this._sendResponse(formattedResponse);
      } else {
        throw new Error(ERROR_MISSING_RESULT);
      }
    }
    rejectRequest(response) {
      if (isJsonRpcResponseError(response)) {
        const formattedResponse = this._formatResponse(response);
        this._sendResponse(formattedResponse);
      } else {
        throw new Error(ERROR_MISSING_ERROR);
      }
    }
    transportClose() {
      this._transport.close();
    }
    _sendRequest(request, options) {
      return __async(this, null, function* () {
        const callRequest = this._formatRequest(request);
        const encryptionPayload = yield this._encrypt(callRequest);
        const topic = typeof (options === null || options === void 0 ? void 0 : options.topic) !== "undefined" ? options.topic : this.peerId;
        const payload = JSON.stringify(encryptionPayload);
        const silent = typeof (options === null || options === void 0 ? void 0 : options.forcePushNotification) !== "undefined" ? !options.forcePushNotification : isSilentPayload(callRequest);
        this._transport.send(payload, topic, silent);
      });
    }
    _sendResponse(response) {
      return __async(this, null, function* () {
        const encryptionPayload = yield this._encrypt(response);
        const topic = this.peerId;
        const payload = JSON.stringify(encryptionPayload);
        const silent = true;
        this._transport.send(payload, topic, silent);
      });
    }
    _sendSessionRequest(request, errorMsg, options) {
      return __async(this, null, function* () {
        this._sendRequest(request, options);
        this._subscribeToSessionResponse(request.id, errorMsg);
      });
    }
    _sendCallRequest(request, options) {
      this._sendRequest(request, options);
      this._eventManager.trigger({
        event: "call_request_sent",
        params: [{ request, options }]
      });
      return this._subscribeToCallResponse(request.id);
    }
    _formatRequest(request) {
      if (typeof request.method === "undefined") {
        throw new Error(ERROR_MISSING_METHOD);
      }
      const formattedRequest = {
        id: typeof request.id === "undefined" ? payloadId2() : request.id,
        jsonrpc: "2.0",
        method: request.method,
        params: typeof request.params === "undefined" ? [] : request.params
      };
      return formattedRequest;
    }
    _formatResponse(response) {
      if (typeof response.id === "undefined") {
        throw new Error(ERROR_MISSING_ID);
      }
      const baseResponse = { id: response.id, jsonrpc: "2.0" };
      if (isJsonRpcResponseError(response)) {
        const error = formatRpcError(response.error);
        const errorResponse = Object.assign(Object.assign(Object.assign({}, baseResponse), response), { error });
        return errorResponse;
      } else if (isJsonRpcResponseSuccess(response)) {
        const successResponse = Object.assign(Object.assign({}, baseResponse), response);
        return successResponse;
      }
      throw new Error(ERROR_INVALID_RESPONSE);
    }
    _handleSessionDisconnect(errorMsg) {
      const message = errorMsg || "Session Disconnected";
      if (!this._connected) {
        if (this._qrcodeModal) {
          this._qrcodeModal.close();
        }
        removeLocal(mobileLinkChoiceKey);
      }
      if (this._connected) {
        this._connected = false;
      }
      if (this._handshakeId) {
        this._handshakeId = 0;
      }
      if (this._handshakeTopic) {
        this._handshakeTopic = "";
      }
      if (this._peerId) {
        this._peerId = "";
      }
      this._eventManager.trigger({
        event: "disconnect",
        params: [{ message }]
      });
      this._removeStorageSession();
      this.transportClose();
    }
    _handleSessionResponse(errorMsg, sessionParams) {
      if (sessionParams) {
        if (sessionParams.approved) {
          if (!this._connected) {
            this._connected = true;
            if (sessionParams.chainId) {
              this.chainId = sessionParams.chainId;
            }
            if (sessionParams.accounts) {
              this.accounts = sessionParams.accounts;
            }
            if (sessionParams.peerId && !this.peerId) {
              this.peerId = sessionParams.peerId;
            }
            if (sessionParams.peerMeta && !this.peerMeta) {
              this.peerMeta = sessionParams.peerMeta;
            }
            this._eventManager.trigger({
              event: "connect",
              params: [
                {
                  peerId: this.peerId,
                  peerMeta: this.peerMeta,
                  chainId: this.chainId,
                  accounts: this.accounts
                }
              ]
            });
          } else {
            if (sessionParams.chainId) {
              this.chainId = sessionParams.chainId;
            }
            if (sessionParams.accounts) {
              this.accounts = sessionParams.accounts;
            }
            this._eventManager.trigger({
              event: "session_update",
              params: [
                {
                  chainId: this.chainId,
                  accounts: this.accounts
                }
              ]
            });
          }
          this._manageStorageSession();
        } else {
          this._handleSessionDisconnect(errorMsg);
        }
      } else {
        this._handleSessionDisconnect(errorMsg);
      }
    }
    _handleIncomingMessages(socketMessage) {
      return __async(this, null, function* () {
        const activeTopics = [this.clientId, this.handshakeTopic];
        if (!activeTopics.includes(socketMessage.topic)) {
          return;
        }
        let encryptionPayload;
        try {
          encryptionPayload = JSON.parse(socketMessage.payload);
        } catch (error) {
          return;
        }
        const payload = yield this._decrypt(encryptionPayload);
        if (payload) {
          this._eventManager.trigger(payload);
        }
      });
    }
    _subscribeToSessionRequest() {
      this._transport.subscribe(this.handshakeTopic);
    }
    _subscribeToResponse(id2, callback) {
      this.on(`response:${id2}`, callback);
    }
    _subscribeToSessionResponse(id2, errorMsg) {
      this._subscribeToResponse(id2, (error, payload) => {
        if (error) {
          this._handleSessionResponse(error.message);
          return;
        }
        if (isJsonRpcResponseSuccess(payload)) {
          this._handleSessionResponse(errorMsg, payload.result);
        } else if (payload.error && payload.error.message) {
          this._handleSessionResponse(payload.error.message);
        } else {
          this._handleSessionResponse(errorMsg);
        }
      });
    }
    _subscribeToCallResponse(id2) {
      return new Promise((resolve, reject) => {
        this._subscribeToResponse(id2, (error, payload) => {
          if (error) {
            reject(error);
            return;
          }
          if (isJsonRpcResponseSuccess(payload)) {
            resolve(payload.result);
          } else if (payload.error && payload.error.message) {
            reject(new Error(payload.error.message));
          } else {
            reject(new Error(ERROR_INVALID_RESPONSE));
          }
        });
      });
    }
    _subscribeToInternalEvents() {
      this.on("display_uri", () => {
        if (this._qrcodeModal) {
          this._qrcodeModal.open(this.uri, () => {
            this._eventManager.trigger({
              event: "modal_closed",
              params: []
            });
          }, this._qrcodeModalOptions);
        }
      });
      this.on("connect", () => {
        if (this._qrcodeModal) {
          this._qrcodeModal.close();
        }
      });
      this.on("call_request_sent", (error, payload) => {
        const { request } = payload.params[0];
        if (isMobile() && this._signingMethods.includes(request.method)) {
          const mobileLinkUrl = getLocal(mobileLinkChoiceKey);
          if (mobileLinkUrl) {
            window.location.href = mobileLinkUrl.href;
          }
        }
      });
      this.on("wc_sessionRequest", (error, payload) => {
        if (error) {
          this._eventManager.trigger({
            event: "error",
            params: [
              {
                code: "SESSION_REQUEST_ERROR",
                message: error.toString()
              }
            ]
          });
        }
        this.handshakeId = payload.id;
        this.peerId = payload.params[0].peerId;
        this.peerMeta = payload.params[0].peerMeta;
        const internalPayload = Object.assign(Object.assign({}, payload), { method: "session_request" });
        this._eventManager.trigger(internalPayload);
      });
      this.on("wc_sessionUpdate", (error, payload) => {
        if (error) {
          this._handleSessionResponse(error.message);
        }
        this._handleSessionResponse("Session disconnected", payload.params[0]);
      });
    }
    _initTransport() {
      this._transport.on("message", (socketMessage) => this._handleIncomingMessages(socketMessage));
      this._transport.on("open", () => this._eventManager.trigger({ event: "transport_open", params: [] }));
      this._transport.on("close", () => this._eventManager.trigger({ event: "transport_close", params: [] }));
      this._transport.on("error", () => this._eventManager.trigger({
        event: "transport_error",
        params: ["Websocket connection failed"]
      }));
      this._transport.open();
    }
    _formatUri() {
      const protocol = this.protocol;
      const handshakeTopic = this.handshakeTopic;
      const version26 = this.version;
      const bridge = encodeURIComponent(this.bridge);
      const key2 = this.key;
      const uri = `${protocol}:${handshakeTopic}@${version26}?bridge=${bridge}&key=${key2}`;
      return uri;
    }
    _parseUri(uri) {
      const result = parseWalletConnectUri(uri);
      if (result.protocol === this.protocol) {
        if (!result.handshakeTopic) {
          throw Error("Invalid or missing handshakeTopic parameter value");
        }
        const handshakeTopic = result.handshakeTopic;
        if (!result.bridge) {
          throw Error("Invalid or missing bridge url parameter value");
        }
        const bridge = decodeURIComponent(result.bridge);
        if (!result.key) {
          throw Error("Invalid or missing key parameter value");
        }
        const key2 = result.key;
        return { handshakeTopic, bridge, key: key2 };
      } else {
        throw new Error(ERROR_INVALID_URI);
      }
    }
    _generateKey() {
      return __async(this, null, function* () {
        if (this._cryptoLib) {
          const result = yield this._cryptoLib.generateKey();
          return result;
        }
        return null;
      });
    }
    _encrypt(data4) {
      return __async(this, null, function* () {
        const key2 = this._key;
        if (this._cryptoLib && key2) {
          const result = yield this._cryptoLib.encrypt(data4, key2);
          return result;
        }
        return null;
      });
    }
    _decrypt(payload) {
      return __async(this, null, function* () {
        const key2 = this._key;
        if (this._cryptoLib && key2) {
          const result = yield this._cryptoLib.decrypt(payload, key2);
          return result;
        }
        return null;
      });
    }
    _getStorageSession() {
      let result = null;
      if (this._sessionStorage) {
        result = this._sessionStorage.getSession();
      }
      return result;
    }
    _setStorageSession() {
      if (this._sessionStorage) {
        this._sessionStorage.setSession(this.session);
      }
    }
    _removeStorageSession() {
      if (this._sessionStorage) {
        this._sessionStorage.removeSession();
      }
    }
    _manageStorageSession() {
      if (this._connected) {
        this._setStorageSession();
      } else {
        this._removeStorageSession();
      }
    }
    _registerPushServer(pushServerOpts) {
      if (!pushServerOpts.url || typeof pushServerOpts.url !== "string") {
        throw Error("Invalid or missing pushServerOpts.url parameter value");
      }
      if (!pushServerOpts.type || typeof pushServerOpts.type !== "string") {
        throw Error("Invalid or missing pushServerOpts.type parameter value");
      }
      if (!pushServerOpts.token || typeof pushServerOpts.token !== "string") {
        throw Error("Invalid or missing pushServerOpts.token parameter value");
      }
      const pushSubscription = {
        bridge: this.bridge,
        topic: this.clientId,
        type: pushServerOpts.type,
        token: pushServerOpts.token,
        peerName: "",
        language: pushServerOpts.language || ""
      };
      this.on("connect", (error, payload) => __async(this, null, function* () {
        if (error) {
          throw error;
        }
        if (pushServerOpts.peerMeta) {
          const peerName = payload.params[0].peerMeta.name;
          pushSubscription.peerName = peerName;
        }
        try {
          const response = yield fetch(`${pushServerOpts.url}/new`, {
            method: "POST",
            headers: {
              Accept: "application/json",
              "Content-Type": "application/json"
            },
            body: JSON.stringify(pushSubscription)
          });
          const json = yield response.json();
          if (!json.success) {
            throw Error("Failed to register in Push Server");
          }
        } catch (error2) {
          throw Error("Failed to register in Push Server");
        }
      }));
    }
  };
  var esm_default2 = Connector;

  // node_modules/@walletconnect/iso-crypto/dist/esm/index.js
  var esm_exports5 = {};
  __export(esm_exports5, {
    decrypt: () => decrypt3,
    encrypt: () => encrypt2,
    generateKey: () => generateKey,
    verifyHmac: () => verifyHmac
  });

  // node_modules/@walletconnect/crypto/dist/esm/browser/index.js
  var browser_exports = {};
  __export(browser_exports, {
    AES_BROWSER_ALGO: () => AES_BROWSER_ALGO,
    AES_LENGTH: () => AES_LENGTH,
    AES_NODE_ALGO: () => AES_NODE_ALGO,
    DECRYPT_OP: () => DECRYPT_OP,
    ENCRYPT_OP: () => ENCRYPT_OP,
    ERROR_BAD_MAC: () => ERROR_BAD_MAC,
    HEX_ENC: () => HEX_ENC,
    HMAC_BROWSER: () => HMAC_BROWSER,
    HMAC_BROWSER_ALGO: () => HMAC_BROWSER_ALGO,
    HMAC_LENGTH: () => HMAC_LENGTH,
    HMAC_NODE_ALGO: () => HMAC_NODE_ALGO,
    IV_LENGTH: () => IV_LENGTH,
    KEY_LENGTH: () => KEY_LENGTH,
    LENGTH_0: () => LENGTH_0,
    LENGTH_1: () => LENGTH_1,
    LENGTH_1024: () => LENGTH_1024,
    LENGTH_128: () => LENGTH_128,
    LENGTH_16: () => LENGTH_16,
    LENGTH_256: () => LENGTH_256,
    LENGTH_32: () => LENGTH_32,
    LENGTH_512: () => LENGTH_512,
    LENGTH_64: () => LENGTH_64,
    MAC_LENGTH: () => MAC_LENGTH,
    PREFIX_LENGTH: () => PREFIX_LENGTH,
    RIPEMD160_NODE_ALGO: () => RIPEMD160_NODE_ALGO,
    SHA256_BROWSER_ALGO: () => SHA256_BROWSER_ALGO,
    SHA256_NODE_ALGO: () => SHA256_NODE_ALGO,
    SHA512_BROWSER_ALGO: () => SHA512_BROWSER_ALGO,
    SHA512_NODE_ALGO: () => SHA512_NODE_ALGO,
    SIGN_OP: () => SIGN_OP,
    UTF8_ENC: () => UTF8_ENC,
    VERIFY_OP: () => VERIFY_OP,
    aesCbcDecrypt: () => aesCbcDecrypt,
    aesCbcEncrypt: () => aesCbcEncrypt,
    assert: () => assert2,
    hmacSha256Sign: () => hmacSha256Sign,
    hmacSha256Verify: () => hmacSha256Verify,
    hmacSha512Sign: () => hmacSha512Sign,
    hmacSha512Verify: () => hmacSha512Verify,
    isConstantTime: () => isConstantTime,
    pkcs7: () => pkcs7,
    randomBytes: () => randomBytes2,
    ripemd160: () => ripemd1602,
    sha256: () => sha2563,
    sha512: () => sha5122
  });

  // node_modules/@walletconnect/randombytes/dist/esm/browser/index.js
  var env = __toModule(require_cjs());
  function randomBytes2(length) {
    const browserCrypto = env.getBrowerCrypto();
    return browserCrypto.getRandomValues(new Uint8Array(length));
  }

  // node_modules/@walletconnect/crypto/dist/esm/lib/browser.js
  var env2 = __toModule(require_cjs());

  // node_modules/@walletconnect/crypto/dist/esm/constants/length.js
  var LENGTH_0 = 0;
  var LENGTH_1 = 1;
  var LENGTH_16 = 16;
  var LENGTH_32 = 32;
  var LENGTH_64 = 64;
  var LENGTH_128 = 128;
  var LENGTH_256 = 256;
  var LENGTH_512 = 512;
  var LENGTH_1024 = 1024;

  // node_modules/@walletconnect/crypto/dist/esm/constants/default.js
  var AES_LENGTH = LENGTH_256;
  var HMAC_LENGTH = LENGTH_256;
  var AES_BROWSER_ALGO = "AES-CBC";
  var HMAC_BROWSER_ALGO = `SHA-${AES_LENGTH}`;
  var HMAC_BROWSER = "HMAC";
  var SHA256_BROWSER_ALGO = "SHA-256";
  var SHA512_BROWSER_ALGO = "SHA-512";
  var AES_NODE_ALGO = `aes-${AES_LENGTH}-cbc`;
  var HMAC_NODE_ALGO = `sha${HMAC_LENGTH}`;
  var SHA256_NODE_ALGO = "sha256";
  var SHA512_NODE_ALGO = "sha512";
  var RIPEMD160_NODE_ALGO = "ripemd160";
  var PREFIX_LENGTH = LENGTH_1;
  var KEY_LENGTH = LENGTH_32;
  var IV_LENGTH = LENGTH_16;
  var MAC_LENGTH = LENGTH_32;

  // node_modules/@walletconnect/crypto/dist/esm/constants/encoding.js
  var HEX_ENC = "hex";
  var UTF8_ENC = "utf8";

  // node_modules/@walletconnect/crypto/dist/esm/constants/error.js
  var ERROR_BAD_MAC = "Bad MAC";

  // node_modules/@walletconnect/crypto/dist/esm/constants/operations.js
  var ENCRYPT_OP = "encrypt";
  var DECRYPT_OP = "decrypt";
  var SIGN_OP = "sign";
  var VERIFY_OP = "verify";

  // node_modules/@walletconnect/crypto/dist/esm/lib/browser.js
  function getAlgo(type) {
    return type === AES_BROWSER_ALGO ? { length: AES_LENGTH, name: AES_BROWSER_ALGO } : {
      hash: { name: HMAC_BROWSER_ALGO },
      name: HMAC_BROWSER
    };
  }
  function getOps(type) {
    return type === AES_BROWSER_ALGO ? [ENCRYPT_OP, DECRYPT_OP] : [SIGN_OP, VERIFY_OP];
  }
  function browserImportKey(_0) {
    return __async(this, arguments, function* (buffer, type = AES_BROWSER_ALGO) {
      return env2.getSubtleCrypto().importKey("raw", buffer, getAlgo(type), true, getOps(type));
    });
  }
  function browserAesEncrypt(iv, key2, data4) {
    return __async(this, null, function* () {
      const subtle = env2.getSubtleCrypto();
      const cryptoKey = yield browserImportKey(key2, AES_BROWSER_ALGO);
      const result = yield subtle.encrypt({
        iv,
        name: AES_BROWSER_ALGO
      }, cryptoKey, data4);
      return new Uint8Array(result);
    });
  }
  function browserAesDecrypt(iv, key2, data4) {
    return __async(this, null, function* () {
      const subtle = env2.getSubtleCrypto();
      const cryptoKey = yield browserImportKey(key2, AES_BROWSER_ALGO);
      const result = yield subtle.decrypt({
        iv,
        name: AES_BROWSER_ALGO
      }, cryptoKey, data4);
      return new Uint8Array(result);
    });
  }
  function browserHmacSha256Sign(key2, data4) {
    return __async(this, null, function* () {
      const subtle = env2.getSubtleCrypto();
      const cryptoKey = yield browserImportKey(key2, HMAC_BROWSER);
      const signature2 = yield subtle.sign({
        length: HMAC_LENGTH,
        name: HMAC_BROWSER
      }, cryptoKey, data4);
      return new Uint8Array(signature2);
    });
  }
  function browserHmacSha512Sign(key2, data4) {
    return __async(this, null, function* () {
      const subtle = env2.getSubtleCrypto();
      const cryptoKey = yield browserImportKey(key2, HMAC_BROWSER);
      const signature2 = yield subtle.sign({
        length: LENGTH_512,
        name: HMAC_BROWSER
      }, cryptoKey, data4);
      return new Uint8Array(signature2);
    });
  }
  function browserSha256(data4) {
    return __async(this, null, function* () {
      const subtle = env2.getSubtleCrypto();
      const result = yield subtle.digest({
        name: SHA256_BROWSER_ALGO
      }, data4);
      return new Uint8Array(result);
    });
  }
  function browserSha512(data4) {
    return __async(this, null, function* () {
      const subtle = env2.getSubtleCrypto();
      const result = yield subtle.digest({
        name: SHA512_BROWSER_ALGO
      }, data4);
      return new Uint8Array(result);
    });
  }

  // node_modules/@walletconnect/crypto/dist/esm/browser/aes.js
  function aesCbcEncrypt(iv, key2, data4) {
    return browserAesEncrypt(iv, key2, data4);
  }
  function aesCbcDecrypt(iv, key2, data4) {
    return browserAesDecrypt(iv, key2, data4);
  }

  // node_modules/@walletconnect/crypto/dist/esm/helpers/index.js
  var helpers_exports = {};
  __export(helpers_exports, {
    assert: () => assert2,
    isConstantTime: () => isConstantTime,
    pkcs7: () => pkcs7
  });

  // node_modules/@walletconnect/crypto/dist/esm/helpers/env.js
  var env_exports2 = {};
  __markAsModule(env_exports2);
  __reExport(env_exports2, __toModule(require_cjs()));

  // node_modules/@walletconnect/crypto/dist/esm/helpers/index.js
  __reExport(helpers_exports, env_exports2);

  // node_modules/@walletconnect/crypto/dist/esm/helpers/pkcs7.js
  var PADDING = [
    [16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16],
    [15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15],
    [14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14],
    [13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13],
    [12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12],
    [11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11],
    [10, 10, 10, 10, 10, 10, 10, 10, 10, 10],
    [9, 9, 9, 9, 9, 9, 9, 9, 9],
    [8, 8, 8, 8, 8, 8, 8, 8],
    [7, 7, 7, 7, 7, 7, 7],
    [6, 6, 6, 6, 6, 6],
    [5, 5, 5, 5, 5],
    [4, 4, 4, 4],
    [3, 3, 3],
    [2, 2],
    [1]
  ];
  var pkcs7 = {
    pad(plaintext) {
      const padding2 = PADDING[plaintext.byteLength % 16 || 0];
      const result = new Uint8Array(plaintext.byteLength + padding2.length);
      result.set(plaintext);
      result.set(padding2, plaintext.byteLength);
      return result;
    },
    unpad(padded) {
      return padded.subarray(0, padded.byteLength - padded[padded.byteLength - 1]);
    }
  };

  // node_modules/@walletconnect/crypto/dist/esm/helpers/validators.js
  function assert2(condition, message) {
    if (!condition) {
      throw new Error(message || "Assertion failed");
    }
  }
  function isConstantTime(arr1, arr2) {
    if (arr1.length !== arr2.length) {
      return false;
    }
    let res = 0;
    for (let i3 = 0; i3 < arr1.length; i3++) {
      res |= arr1[i3] ^ arr2[i3];
    }
    return res === 0;
  }

  // node_modules/@walletconnect/crypto/dist/esm/browser/hmac.js
  function hmacSha256Sign(key2, msg) {
    return __async(this, null, function* () {
      const result = yield browserHmacSha256Sign(key2, msg);
      return result;
    });
  }
  function hmacSha256Verify(key2, msg, sig) {
    return __async(this, null, function* () {
      const expectedSig = yield browserHmacSha256Sign(key2, msg);
      const result = isConstantTime(expectedSig, sig);
      return result;
    });
  }
  function hmacSha512Sign(key2, msg) {
    return __async(this, null, function* () {
      const result = yield browserHmacSha512Sign(key2, msg);
      return result;
    });
  }
  function hmacSha512Verify(key2, msg, sig) {
    return __async(this, null, function* () {
      const expectedSig = yield browserHmacSha512Sign(key2, msg);
      const result = isConstantTime(expectedSig, sig);
      return result;
    });
  }

  // node_modules/@walletconnect/crypto/dist/esm/browser/sha2.js
  function sha2563(msg) {
    return __async(this, null, function* () {
      const result = yield browserSha256(msg);
      return result;
    });
  }
  function sha5122(msg) {
    return __async(this, null, function* () {
      const result = yield browserSha512(msg);
      return result;
    });
  }
  function ripemd1602(msg) {
    return __async(this, null, function* () {
      throw new Error("Not supported for Browser async methods, use sync instead!");
    });
  }

  // node_modules/@walletconnect/crypto/dist/esm/browser/index.js
  __reExport(browser_exports, helpers_exports);

  // node_modules/@walletconnect/iso-crypto/dist/esm/index.js
  function generateKey(length) {
    return __async(this, null, function* () {
      const _length = (length || 256) / 8;
      const bytes = randomBytes2(_length);
      const result = convertBufferToArrayBuffer(arrayToBuffer(bytes));
      return result;
    });
  }
  function verifyHmac(payload, key2) {
    return __async(this, null, function* () {
      const cipherText = hexToArray(payload.data);
      const iv = hexToArray(payload.iv);
      const hmac2 = hexToArray(payload.hmac);
      const hmacHex = arrayToHex(hmac2, false);
      const unsigned = concatArrays(cipherText, iv);
      const chmac = yield hmacSha256Sign(key2, unsigned);
      const chmacHex = arrayToHex(chmac, false);
      if (removeHexPrefix(hmacHex) === removeHexPrefix(chmacHex)) {
        return true;
      }
      return false;
    });
  }
  function encrypt2(data4, key2, providedIv) {
    return __async(this, null, function* () {
      const _key = bufferToArray(convertArrayBufferToBuffer(key2));
      const ivArrayBuffer = providedIv || (yield generateKey(128));
      const iv = bufferToArray(convertArrayBufferToBuffer(ivArrayBuffer));
      const ivHex = arrayToHex(iv, false);
      const contentString = JSON.stringify(data4);
      const content = utf8ToArray(contentString);
      const cipherText = yield aesCbcEncrypt(iv, _key, content);
      const cipherTextHex = arrayToHex(cipherText, false);
      const unsigned = concatArrays(cipherText, iv);
      const hmac2 = yield hmacSha256Sign(_key, unsigned);
      const hmacHex = arrayToHex(hmac2, false);
      return {
        data: cipherTextHex,
        hmac: hmacHex,
        iv: ivHex
      };
    });
  }
  function decrypt3(payload, key2) {
    return __async(this, null, function* () {
      const _key = bufferToArray(convertArrayBufferToBuffer(key2));
      if (!_key) {
        throw new Error("Missing key: required for decryption");
      }
      const verified = yield verifyHmac(payload, _key);
      if (!verified) {
        return null;
      }
      const cipherText = hexToArray(payload.data);
      const iv = hexToArray(payload.iv);
      const buffer = yield aesCbcDecrypt(iv, _key, cipherText);
      const utf8 = arrayToUtf8(buffer);
      let data4;
      try {
        data4 = JSON.parse(utf8);
      } catch (error) {
        return null;
      }
      return data4;
    });
  }

  // node_modules/@walletconnect/client/dist/esm/index.js
  var WalletConnect = class extends esm_default2 {
    constructor(connectorOpts, pushServerOpts) {
      super({
        cryptoLib: esm_exports5,
        connectorOpts,
        pushServerOpts
      });
    }
  };
  var esm_default3 = WalletConnect;

  // node_modules/@walletconnect/signer-connection/dist/esm/index.js
  var import_qrcode_modal = __toModule(require_cjs4());
  var SignerConnection = class extends IJsonRpcConnection {
    constructor(opts) {
      super();
      this.events = new import_eventemitter3.default();
      this.accounts = [];
      this.chainId = 1;
      this.pending = false;
      this.bridge = "https://bridge.walletconnect.org";
      this.qrcode = true;
      this.qrcodeModalOptions = void 0;
      this.opts = opts;
      this.chainId = (opts === null || opts === void 0 ? void 0 : opts.chainId) || this.chainId;
      this.wc = this.register(opts);
    }
    get connected() {
      return typeof this.wc !== "undefined" && this.wc.connected;
    }
    get connecting() {
      return this.pending;
    }
    get connector() {
      this.wc = this.register(this.opts);
      return this.wc;
    }
    on(event, listener) {
      this.events.on(event, listener);
    }
    once(event, listener) {
      this.events.once(event, listener);
    }
    off(event, listener) {
      this.events.off(event, listener);
    }
    removeListener(event, listener) {
      this.events.removeListener(event, listener);
    }
    open(chainId) {
      return __async(this, null, function* () {
        if (this.connected) {
          this.onOpen();
          return;
        }
        return new Promise((resolve, reject) => {
          this.on("error", (err) => {
            reject(err);
          });
          this.on("open", () => {
            resolve();
          });
          this.create(chainId);
        });
      });
    }
    close() {
      return __async(this, null, function* () {
        if (typeof this.wc === "undefined")
          return;
        if (this.wc.connected) {
          this.wc.killSession();
        }
        this.onClose();
      });
    }
    send(payload) {
      return __async(this, null, function* () {
        this.wc = this.register(this.opts);
        if (!this.connected)
          yield this.open();
        this.sendPayload(payload).then((res) => this.events.emit("payload", res)).catch((e3) => this.events.emit("payload", formatJsonRpcError(payload.id, e3.message)));
      });
    }
    register(opts) {
      if (this.wc)
        return this.wc;
      this.opts = opts || this.opts;
      this.bridge = (opts === null || opts === void 0 ? void 0 : opts.connector) ? opts.connector.bridge : (opts === null || opts === void 0 ? void 0 : opts.bridge) || "https://bridge.walletconnect.org";
      this.qrcode = typeof (opts === null || opts === void 0 ? void 0 : opts.qrcode) === "undefined" || opts.qrcode !== false;
      this.chainId = typeof (opts === null || opts === void 0 ? void 0 : opts.chainId) !== "undefined" ? opts.chainId : this.chainId;
      this.qrcodeModalOptions = opts === null || opts === void 0 ? void 0 : opts.qrcodeModalOptions;
      const connectorOpts = {
        bridge: this.bridge,
        qrcodeModal: this.qrcode ? import_qrcode_modal.default : void 0,
        qrcodeModalOptions: this.qrcodeModalOptions,
        storageId: opts === null || opts === void 0 ? void 0 : opts.storageId,
        signingMethods: opts === null || opts === void 0 ? void 0 : opts.signingMethods,
        clientMeta: opts === null || opts === void 0 ? void 0 : opts.clientMeta
      };
      this.wc = typeof (opts === null || opts === void 0 ? void 0 : opts.connector) !== "undefined" ? opts.connector : new esm_default3(connectorOpts);
      if (typeof this.wc === "undefined") {
        throw new Error("Failed to register WalletConnect connector");
      }
      if (this.wc.accounts.length) {
        this.accounts = this.wc.accounts;
      }
      if (this.wc.chainId) {
        this.chainId = this.wc.chainId;
      }
      this.registerConnectorEvents();
      return this.wc;
    }
    onOpen(wc) {
      this.pending = false;
      if (wc) {
        this.wc = wc;
      }
      this.events.emit("open");
    }
    onClose() {
      this.pending = false;
      if (this.wc) {
        this.wc = void 0;
      }
      this.events.emit("close");
    }
    onError(payload, message = "Failed or Rejected Request", code = -32e3) {
      const errorPayload = {
        id: payload.id,
        jsonrpc: payload.jsonrpc,
        error: { code, message }
      };
      this.events.emit("payload", errorPayload);
      return errorPayload;
    }
    create(chainId) {
      this.wc = this.register(this.opts);
      this.chainId = chainId || this.chainId;
      if (this.connected || this.pending)
        return;
      this.pending = true;
      this.registerConnectorEvents();
      this.wc.createSession({ chainId: this.chainId }).then(() => this.events.emit("created")).catch((e3) => this.events.emit("error", e3));
    }
    registerConnectorEvents() {
      this.wc = this.register(this.opts);
      this.wc.on("connect", (err) => {
        var _a, _b;
        if (err) {
          this.events.emit("error", err);
          return;
        }
        this.accounts = ((_a = this.wc) === null || _a === void 0 ? void 0 : _a.accounts) || [];
        this.chainId = ((_b = this.wc) === null || _b === void 0 ? void 0 : _b.chainId) || this.chainId;
        this.onOpen();
      });
      this.wc.on("disconnect", (err) => {
        if (err) {
          this.events.emit("error", err);
          return;
        }
        this.onClose();
      });
      this.wc.on("modal_closed", () => {
        this.events.emit("error", new Error("User closed modal"));
      });
      this.wc.on("session_update", (error, payload) => {
        const { accounts, chainId } = payload.params[0];
        if (!this.accounts || accounts && this.accounts !== accounts) {
          this.accounts = accounts;
          this.events.emit("accountsChanged", accounts);
        }
        if (!this.chainId || chainId && this.chainId !== chainId) {
          this.chainId = chainId;
          this.events.emit("chainChanged", chainId);
        }
      });
    }
    sendPayload(payload) {
      return __async(this, null, function* () {
        this.wc = this.register(this.opts);
        try {
          const response = yield this.wc.unsafeSend(payload);
          return this.sanitizeResponse(response);
        } catch (error) {
          return this.onError(payload, error.message);
        }
      });
    }
    sanitizeResponse(response) {
      return typeof response.error !== "undefined" && typeof response.error.code === "undefined" ? formatJsonRpcError(response.id, response.error.message) : response;
    }
  };

  // node_modules/@walletconnect/ethereum-provider/dist/esm/index.js
  var WalletConnectProvider = class {
    constructor(opts) {
      this.events = new import_eventemitter32.default();
      this.rpc = { infuraId: opts === null || opts === void 0 ? void 0 : opts.infuraId, custom: opts === null || opts === void 0 ? void 0 : opts.rpc };
      this.signer = new JsonRpcProvider2(new SignerConnection(opts));
      const chainId = this.signer.connection.chainId || (opts === null || opts === void 0 ? void 0 : opts.chainId) || 1;
      this.http = this.setHttpProvider(chainId);
      this.registerEventListeners();
    }
    get connected() {
      return this.signer.connection.connected;
    }
    get connector() {
      return this.signer.connection.connector;
    }
    get accounts() {
      return this.signer.connection.accounts;
    }
    get chainId() {
      return this.signer.connection.chainId;
    }
    get rpcUrl() {
      var _a;
      return ((_a = this.http) === null || _a === void 0 ? void 0 : _a.connection).url || "";
    }
    request(args) {
      return __async(this, null, function* () {
        switch (args.method) {
          case "eth_requestAccounts":
            yield this.connect();
            return this.signer.connection.accounts;
          case "eth_accounts":
            return this.signer.connection.accounts;
          case "eth_chainId":
            return this.signer.connection.chainId;
          default:
            break;
        }
        if (signingMethods.includes(args.method)) {
          return this.signer.request(args);
        }
        if (typeof this.http === "undefined") {
          throw new Error(`Cannot request JSON-RPC method (${args.method}) without provided rpc url`);
        }
        return this.http.request(args);
      });
    }
    sendAsync(args, callback) {
      this.request(args).then((response) => callback(null, response)).catch((error) => callback(error, void 0));
    }
    enable() {
      return __async(this, null, function* () {
        const accounts = yield this.request({ method: "eth_requestAccounts" });
        return accounts;
      });
    }
    connect() {
      return __async(this, null, function* () {
        if (!this.signer.connection.connected) {
          yield this.signer.connect();
        }
      });
    }
    disconnect() {
      return __async(this, null, function* () {
        if (this.signer.connection.connected) {
          yield this.signer.disconnect();
        }
      });
    }
    on(event, listener) {
      this.events.on(event, listener);
    }
    once(event, listener) {
      this.events.once(event, listener);
    }
    removeListener(event, listener) {
      this.events.removeListener(event, listener);
    }
    off(event, listener) {
      this.events.off(event, listener);
    }
    get isWalletConnect() {
      return true;
    }
    registerEventListeners() {
      this.signer.connection.on("accountsChanged", (accounts) => {
        this.events.emit("accountsChanged", accounts);
      });
      this.signer.connection.on("chainChanged", (chainId) => {
        this.http = this.setHttpProvider(chainId);
        this.events.emit("chainChanged", chainId);
      });
      this.signer.on("disconnect", () => {
        this.events.emit("disconnect");
      });
    }
    setHttpProvider(chainId) {
      const rpcUrl = getRpcUrl(chainId, this.rpc);
      if (typeof rpcUrl === "undefined")
        return void 0;
      const http = new JsonRpcProvider2(new HttpConnection(rpcUrl));
      return http;
    }
  };
  var esm_default4 = WalletConnectProvider;

  // src/domain/connector/provider.ts
  var isValidWalletType = (walletType) => {
    if (walletType === "metamask" || walletType == "walletconnect")
      return true;
    return false;
  };
  var createProviders = (wallet) => __async(void 0, null, function* () {
    let providers;
    if (wallet === "walletconnect") {
      providers = yield createWalletConnectProviders();
    } else if (window.ethereum) {
      providers = yield createMetemaskProviders();
    } else if (window.web3) {
      providers = createLegacyMetamaskProviders();
    } else {
      providers = createLocalProviders();
    }
    return providers;
  });
  var createWalletConnectProviders = () => __async(void 0, null, function* () {
    const rawProvider = new esm_default4({
      rpc: {
        1: "https://main-light.eth.linkpool.io",
        4: "https://rinkeby-light.eth.linkpool.io",
        5: "https://goerli-light.eth.linkpool.io",
        137: "https://polygon-rpc.com",
        80001: "https://matic-mumbai.chainstacklabs.com",
        1337: "http://localhost:8545"
      }
    });
    yield rawProvider.enable();
    const rpcProvider = new ethers_exports.providers.Web3Provider(rawProvider);
    return { rpcProvider, rawProvider };
  });
  var createMetemaskProviders = () => __async(void 0, null, function* () {
    const rawProvider = window.ethereum;
    const rpcProvider = new ethers_exports.providers.Web3Provider(rawProvider);
    yield window.ethereum.request({ method: "eth_requestAccounts" });
    return { rpcProvider, rawProvider };
  });
  var createLegacyMetamaskProviders = () => {
    const web3 = window.web3;
    console.log("Injected web3 detected");
    const rpcProvider = new ethers_exports.providers.Web3Provider(web3.currentProvider);
    return { rpcProvider, rawProvider: null };
  };
  var createLocalProviders = () => {
    console.log("Neither web3 instance nor ethereum instance injected, using Local provider.");
    return {
      rpcProvider: new ethers_exports.providers.JsonRpcProvider(),
      rawProvider: null
    };
  };

  // src/domain/connector/connector.ts
  var connectWallet = (config) => __async(void 0, null, function* () {
    const { rpcProvider, rawProvider: eventEmitter } = yield createProviders(config.wallet);
    if (eventEmitter)
      setupWalletEvent(eventEmitter, config.eventActions);
    return rpcProvider;
  });

  // src/utils/HttpClient.ts
  var HttpClient = class {
    constructor() {
      this.BASE_URL = "https://sdk-service.bunzz.dev";
    }
    request(endpoint, config) {
      return __async(this, null, function* () {
        const res = yield window.fetch(`${this.BASE_URL}/${endpoint}`, config);
        if (!res.ok)
          throw new Error(`Request to ${config == null ? void 0 : config.method}:${endpoint} were failed with HTTP code: ${res.status}`);
        return yield res.json();
      });
    }
    get(endpoint, customConfig) {
      return __async(this, null, function* () {
        const config = __spreadValues({ method: "GET" }, customConfig);
        return yield this.request(endpoint, config);
      });
    }
    post(endpoint, body, customConfig) {
      return __async(this, null, function* () {
        const config = __spreadValues({
          method: "POST",
          body: JSON.stringify(body)
        }, customConfig);
        return yield this.request(endpoint, config);
      });
    }
  };
  var HttpClient_default = new HttpClient();

  // src/domain/bunzz/fetchConfig.ts
  var fetchConfig = (apiKey, dappId) => __async(void 0, null, function* () {
    const endpoint = `dapps/${dappId}?apiKey=${apiKey}`;
    try {
      const { contractConfig } = yield HttpClient_default.get(endpoint);
      return contractConfig;
    } catch (err) {
      console.log(err);
      throw Error("Invalid API Key or DAapp ID");
    }
  });

  // src/utils/trackAction.ts
  var trackAction = (body) => __async(void 0, null, function* () {
    return yield HttpClient_default.post("track", body);
  });
  var trackActionWrapper = (apiKey, dappId, host, pathname, signerAddr, chainId) => {
    return (params) => __async(void 0, null, function* () {
      try {
        yield trackAction(__spreadValues({
          apiKey,
          dappId,
          host,
          pathname,
          signerAddr,
          chainId
        }, params));
      } catch (e3) {
        console.error(e3);
      }
    });
  };

  // src/domain/bunzz/bunzz.ts
  var bunzz = {
    initializeHandler: (params) => __async(void 0, null, function* () {
      if (!params.dappId && !params.apiKey)
        throw new Error("API KEY and DApp ID are required");
      const connectorConf = createConnectorConf(params);
      const provider = yield connectWallet(connectorConf);
      const track = yield createTrack(provider, params);
      const contractConf = yield fetchConfig(params.apiKey, params.dappId);
      track({ eventName: "initializeHandler" });
      return new Handler(provider, provider.getSigner(), track, contractConf);
    })
  };
  var createTrack = (provider, params) => __async(void 0, null, function* () {
    var _a, _b;
    const signerAddr = yield provider.getSigner().getAddress();
    const network = yield provider.getNetwork();
    const chainId = network.chainId.toString();
    return trackActionWrapper(params.apiKey, params.dappId, (_a = window == null ? void 0 : window.location) == null ? void 0 : _a.host, (_b = window == null ? void 0 : window.location) == null ? void 0 : _b.pathname, signerAddr, chainId);
  });
  var createConnectorConf = (params) => {
    const result = {
      wallet: "metamask",
      eventActions: {
        onChainChanged: "reload",
        onAccountsChanged: "reload",
        onDisconnect: "none"
      }
    };
    if (isValidWalletType(params.wallet))
      result.wallet = params.wallet;
    if (isValidActionType(params.onChainChanged))
      result.eventActions.onChainChanged = params.onChainChanged;
    if (isValidActionType(params.onAccountsChanged))
      result.eventActions.onAccountsChanged = params.onAccountsChanged;
    if (isValidActionType(params.onDisconnect))
      result.eventActions.onDisconnect = params.onDisconnect;
    return result;
  };

  // src/index.ts
  var src_default = bunzz;
  return src_exports;
})();
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
/**
 * [js-sha3]{@link https://github.com/emn178/js-sha3}
 *
 * @version 0.5.7
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2015-2016
 * @license MIT
 */
/**
 * [js-sha3]{@link https://github.com/emn178/js-sha3}
 *
 * @version 0.8.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2015-2018
 * @license MIT
 */
